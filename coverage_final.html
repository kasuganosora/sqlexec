
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kasuganosora/sqlexec/pkg/api/cache.go (92.8%)</option>
				
				<option value="file1">github.com/kasuganosora/sqlexec/pkg/api/db.go (93.3%)</option>
				
				<option value="file2">github.com/kasuganosora/sqlexec/pkg/api/errors.go (95.3%)</option>
				
				<option value="file3">github.com/kasuganosora/sqlexec/pkg/api/gorm/dialect.go (38.2%)</option>
				
				<option value="file4">github.com/kasuganosora/sqlexec/pkg/api/gorm/examples.go (0.0%)</option>
				
				<option value="file5">github.com/kasuganosora/sqlexec/pkg/api/gorm/migrator.go (64.7%)</option>
				
				<option value="file6">github.com/kasuganosora/sqlexec/pkg/api/logger.go (94.3%)</option>
				
				<option value="file7">github.com/kasuganosora/sqlexec/pkg/api/mock.go (51.9%)</option>
				
				<option value="file8">github.com/kasuganosora/sqlexec/pkg/api/params.go (77.6%)</option>
				
				<option value="file9">github.com/kasuganosora/sqlexec/pkg/api/query.go (91.5%)</option>
				
				<option value="file10">github.com/kasuganosora/sqlexec/pkg/api/result.go (100.0%)</option>
				
				<option value="file11">github.com/kasuganosora/sqlexec/pkg/api/session_dml.go (83.0%)</option>
				
				<option value="file12">github.com/kasuganosora/sqlexec/pkg/api/session_lifecycle.go (85.0%)</option>
				
				<option value="file13">github.com/kasuganosora/sqlexec/pkg/api/session_query.go (76.7%)</option>
				
				<option value="file14">github.com/kasuganosora/sqlexec/pkg/api/session_temp.go (93.8%)</option>
				
				<option value="file15">github.com/kasuganosora/sqlexec/pkg/api/session_transaction.go (87.0%)</option>
				
				<option value="file16">github.com/kasuganosora/sqlexec/pkg/api/session_types.go (83.3%)</option>
				
				<option value="file17">github.com/kasuganosora/sqlexec/pkg/api/session_validation.go (58.3%)</option>
				
				<option value="file18">github.com/kasuganosora/sqlexec/pkg/api/transaction.go (83.6%)</option>
				
				<option value="file19">github.com/kasuganosora/sqlexec/pkg/builtin/aggregate_functions.go (61.7%)</option>
				
				<option value="file20">github.com/kasuganosora/sqlexec/pkg/builtin/api.go (0.0%)</option>
				
				<option value="file21">github.com/kasuganosora/sqlexec/pkg/builtin/builder.go (0.0%)</option>
				
				<option value="file22">github.com/kasuganosora/sqlexec/pkg/builtin/date_functions.go (3.2%)</option>
				
				<option value="file23">github.com/kasuganosora/sqlexec/pkg/builtin/functions.go (100.0%)</option>
				
				<option value="file24">github.com/kasuganosora/sqlexec/pkg/builtin/init.go (0.0%)</option>
				
				<option value="file25">github.com/kasuganosora/sqlexec/pkg/builtin/math_functions.go (19.9%)</option>
				
				<option value="file26">github.com/kasuganosora/sqlexec/pkg/builtin/registry.go (0.0%)</option>
				
				<option value="file27">github.com/kasuganosora/sqlexec/pkg/builtin/string_functions.go (17.4%)</option>
				
				<option value="file28">github.com/kasuganosora/sqlexec/pkg/builtin/udf.go (0.0%)</option>
				
				<option value="file29">github.com/kasuganosora/sqlexec/pkg/config/config.go (97.7%)</option>
				
				<option value="file30">github.com/kasuganosora/sqlexec/pkg/extensibility/plugin.go (82.5%)</option>
				
				<option value="file31">github.com/kasuganosora/sqlexec/pkg/information_schema/columns.go (0.0%)</option>
				
				<option value="file32">github.com/kasuganosora/sqlexec/pkg/information_schema/constraints.go (0.0%)</option>
				
				<option value="file33">github.com/kasuganosora/sqlexec/pkg/information_schema/keys.go (0.0%)</option>
				
				<option value="file34">github.com/kasuganosora/sqlexec/pkg/information_schema/provider.go (0.0%)</option>
				
				<option value="file35">github.com/kasuganosora/sqlexec/pkg/information_schema/schemata.go (0.0%)</option>
				
				<option value="file36">github.com/kasuganosora/sqlexec/pkg/information_schema/tables.go (0.0%)</option>
				
				<option value="file37">github.com/kasuganosora/sqlexec/pkg/monitor/cache.go (0.0%)</option>
				
				<option value="file38">github.com/kasuganosora/sqlexec/pkg/monitor/metrics.go (100.0%)</option>
				
				<option value="file39">github.com/kasuganosora/sqlexec/pkg/monitor/slow_query.go (97.0%)</option>
				
				<option value="file40">github.com/kasuganosora/sqlexec/pkg/mvcc/clog.go (0.0%)</option>
				
				<option value="file41">github.com/kasuganosora/sqlexec/pkg/mvcc/datasource.go (0.0%)</option>
				
				<option value="file42">github.com/kasuganosora/sqlexec/pkg/mvcc/manager.go (0.0%)</option>
				
				<option value="file43">github.com/kasuganosora/sqlexec/pkg/mvcc/transaction.go (0.0%)</option>
				
				<option value="file44">github.com/kasuganosora/sqlexec/pkg/mvcc/types.go (0.0%)</option>
				
				<option value="file45">github.com/kasuganosora/sqlexec/pkg/optimizer/cardinality.go (0.0%)</option>
				
				<option value="file46">github.com/kasuganosora/sqlexec/pkg/optimizer/expression_evaluator.go (0.4%)</option>
				
				<option value="file47">github.com/kasuganosora/sqlexec/pkg/optimizer/join_elimination.go (3.2%)</option>
				
				<option value="file48">github.com/kasuganosora/sqlexec/pkg/optimizer/join_reorder.go (9.3%)</option>
				
				<option value="file49">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_aggregate.go (69.0%)</option>
				
				<option value="file50">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_datasource.go (68.8%)</option>
				
				<option value="file51">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_join.go (0.0%)</option>
				
				<option value="file52">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_limit.go (77.8%)</option>
				
				<option value="file53">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_projection.go (77.3%)</option>
				
				<option value="file54">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_scan_accessors.go (0.0%)</option>
				
				<option value="file55">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_selection.go (69.2%)</option>
				
				<option value="file56">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_sort.go (82.4%)</option>
				
				<option value="file57">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_union.go (0.0%)</option>
				
				<option value="file58">github.com/kasuganosora/sqlexec/pkg/optimizer/merge_join.go (0.0%)</option>
				
				<option value="file59">github.com/kasuganosora/sqlexec/pkg/optimizer/optimized_executor.go (0.0%)</option>
				
				<option value="file60">github.com/kasuganosora/sqlexec/pkg/optimizer/optimizer.go (70.8%)</option>
				
				<option value="file61">github.com/kasuganosora/sqlexec/pkg/optimizer/performance.go (0.0%)</option>
				
				<option value="file62">github.com/kasuganosora/sqlexec/pkg/optimizer/physical_scan.go (7.8%)</option>
				
				<option value="file63">github.com/kasuganosora/sqlexec/pkg/optimizer/physical_sort.go (0.0%)</option>
				
				<option value="file64">github.com/kasuganosora/sqlexec/pkg/optimizer/procedure_executor.go (0.0%)</option>
				
				<option value="file65">github.com/kasuganosora/sqlexec/pkg/optimizer/rules.go (57.9%)</option>
				
				<option value="file66">github.com/kasuganosora/sqlexec/pkg/optimizer/semi_join_rewrite.go (16.5%)</option>
				
				<option value="file67">github.com/kasuganosora/sqlexec/pkg/optimizer/types.go (96.6%)</option>
				
				<option value="file68">github.com/kasuganosora/sqlexec/pkg/optimizer/utils.go (0.0%)</option>
				
				<option value="file69">github.com/kasuganosora/sqlexec/pkg/optimizer/window_operator.go (0.0%)</option>
				
				<option value="file70">github.com/kasuganosora/sqlexec/pkg/parser/adapter.go (51.6%)</option>
				
				<option value="file71">github.com/kasuganosora/sqlexec/pkg/parser/builder.go (0.0%)</option>
				
				<option value="file72">github.com/kasuganosora/sqlexec/pkg/parser/cte.go (0.0%)</option>
				
				<option value="file73">github.com/kasuganosora/sqlexec/pkg/parser/handler.go (0.0%)</option>
				
				<option value="file74">github.com/kasuganosora/sqlexec/pkg/parser/parser.go (84.7%)</option>
				
				<option value="file75">github.com/kasuganosora/sqlexec/pkg/parser/procedure.go (0.0%)</option>
				
				<option value="file76">github.com/kasuganosora/sqlexec/pkg/parser/types.go (0.0%)</option>
				
				<option value="file77">github.com/kasuganosora/sqlexec/pkg/parser/visitor.go (0.0%)</option>
				
				<option value="file78">github.com/kasuganosora/sqlexec/pkg/parser/window.go (0.0%)</option>
				
				<option value="file79">github.com/kasuganosora/sqlexec/pkg/reliability/backup.go (0.0%)</option>
				
				<option value="file80">github.com/kasuganosora/sqlexec/pkg/reliability/error_recovery.go (0.0%)</option>
				
				<option value="file81">github.com/kasuganosora/sqlexec/pkg/reliability/failover.go (0.0%)</option>
				
				<option value="file82">github.com/kasuganosora/sqlexec/pkg/resource/application/manager.go (82.8%)</option>
				
				<option value="file83">github.com/kasuganosora/sqlexec/pkg/resource/application/registry.go (100.0%)</option>
				
				<option value="file84">github.com/kasuganosora/sqlexec/pkg/resource/csv/adapter.go (86.3%)</option>
				
				<option value="file85">github.com/kasuganosora/sqlexec/pkg/resource/csv/factory.go (100.0%)</option>
				
				<option value="file86">github.com/kasuganosora/sqlexec/pkg/resource/domain/capabilities.go (0.0%)</option>
				
				<option value="file87">github.com/kasuganosora/sqlexec/pkg/resource/domain/errors.go (100.0%)</option>
				
				<option value="file88">github.com/kasuganosora/sqlexec/pkg/resource/domain/models.go (100.0%)</option>
				
				<option value="file89">github.com/kasuganosora/sqlexec/pkg/resource/excel/adapter.go (78.1%)</option>
				
				<option value="file90">github.com/kasuganosora/sqlexec/pkg/resource/excel/factory.go (100.0%)</option>
				
				<option value="file91">github.com/kasuganosora/sqlexec/pkg/resource/file/datasource.go (0.0%)</option>
				
				<option value="file92">github.com/kasuganosora/sqlexec/pkg/resource/file/schema.go (0.0%)</option>
				
				<option value="file93">github.com/kasuganosora/sqlexec/pkg/resource/file/util.go (0.0%)</option>
				
				<option value="file94">github.com/kasuganosora/sqlexec/pkg/resource/infrastructure/cache/query_cache.go (100.0%)</option>
				
				<option value="file95">github.com/kasuganosora/sqlexec/pkg/resource/infrastructure/errors/errors.go (0.0%)</option>
				
				<option value="file96">github.com/kasuganosora/sqlexec/pkg/resource/infrastructure/pool/connection_pool.go (97.0%)</option>
				
				<option value="file97">github.com/kasuganosora/sqlexec/pkg/resource/json/adapter.go (87.8%)</option>
				
				<option value="file98">github.com/kasuganosora/sqlexec/pkg/resource/json/factory.go (100.0%)</option>
				
				<option value="file99">github.com/kasuganosora/sqlexec/pkg/resource/memory/factory.go (100.0%)</option>
				
				<option value="file100">github.com/kasuganosora/sqlexec/pkg/resource/memory/index.go (0.0%)</option>
				
				<option value="file101">github.com/kasuganosora/sqlexec/pkg/resource/memory/index_manager.go (17.4%)</option>
				
				<option value="file102">github.com/kasuganosora/sqlexec/pkg/resource/memory/mvcc_datasource.go (52.2%)</option>
				
				<option value="file103">github.com/kasuganosora/sqlexec/pkg/resource/memory/mvcc_transaction.go (0.0%)</option>
				
				<option value="file104">github.com/kasuganosora/sqlexec/pkg/resource/memory/query_planner.go (36.7%)</option>
				
				<option value="file105">github.com/kasuganosora/sqlexec/pkg/resource/parquet/adapter.go (91.4%)</option>
				
				<option value="file106">github.com/kasuganosora/sqlexec/pkg/resource/parquet/factory.go (100.0%)</option>
				
				<option value="file107">github.com/kasuganosora/sqlexec/pkg/resource/registry.go (0.0%)</option>
				
				<option value="file108">github.com/kasuganosora/sqlexec/pkg/resource/slice/adapter.go (81.5%)</option>
				
				<option value="file109">github.com/kasuganosora/sqlexec/pkg/resource/slice/factory.go (87.0%)</option>
				
				<option value="file110">github.com/kasuganosora/sqlexec/pkg/resource/util/compare.go (95.7%)</option>
				
				<option value="file111">github.com/kasuganosora/sqlexec/pkg/resource/util/filter.go (90.2%)</option>
				
				<option value="file112">github.com/kasuganosora/sqlexec/pkg/resource/util/order.go (86.4%)</option>
				
				<option value="file113">github.com/kasuganosora/sqlexec/pkg/resource/util/pagination.go (97.8%)</option>
				
				<option value="file114">github.com/kasuganosora/sqlexec/pkg/resource/util/string.go (100.0%)</option>
				
				<option value="file115">github.com/kasuganosora/sqlexec/pkg/security/audit_log.go (0.0%)</option>
				
				<option value="file116">github.com/kasuganosora/sqlexec/pkg/security/authorization.go (93.8%)</option>
				
				<option value="file117">github.com/kasuganosora/sqlexec/pkg/security/encryption.go (90.4%)</option>
				
				<option value="file118">github.com/kasuganosora/sqlexec/pkg/security/sql_injection.go (100.0%)</option>
				
				<option value="file119">github.com/kasuganosora/sqlexec/pkg/service.go (0.0%)</option>
				
				<option value="file120">github.com/kasuganosora/sqlexec/pkg/virtual/datasource.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "fmt"
        "hash/fnv"
        "sort"
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// CacheConfig 缓存配置
type CacheConfig struct {
        Enabled bool
        TTL     time.Duration // 缓存过期时间
        MaxSize int           // 最大缓存条目数
}

// DefaultCacheConfig 默认缓存配置
var DefaultCacheConfig = CacheConfig{
        Enabled: true,
        TTL:     5 * time.Minute,
        MaxSize: 1000,
}

// QueryCache 查询缓存
type QueryCache struct {
        store         map[string]*CacheEntry
        explainStore  map[string]*ExplainEntry
        mu            sync.RWMutex
        ttl           time.Duration
        maxSize       int
}

// CacheEntry 缓存条目
type CacheEntry struct {
        Result    *domain.QueryResult
        Params    []interface{}
        CreatedAt time.Time
        ExpiresAt time.Time
        Hits      int64
}

// ExplainEntry Explain 缓存条目
type ExplainEntry struct {
        Explain   string
        CreatedAt time.Time
        ExpiresAt time.Time
        Hits      int64
}

// NewQueryCache 创建查询缓存
func NewQueryCache(config CacheConfig) *QueryCache <span class="cov8" title="1">{
        if !config.Enabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;QueryCache{
                store:        make(map[string]*CacheEntry),
                explainStore: make(map[string]*ExplainEntry),
                ttl:          config.TTL,
                maxSize:      config.MaxSize,
        }</span>
}

// Get 获取缓存
func (c *QueryCache) Get(sql string, params []interface{}) (*domain.QueryResult, bool) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">key := c.generateKey(sql, params)

        c.mu.RLock()
        entry, exists := c.store[key]
        c.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // 检查是否过期
        <span class="cov8" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                c.mu.Lock()
                delete(c.store, key)
                c.mu.Unlock()
                return nil, false
        }</span>

        // 更新命中次数
        <span class="cov8" title="1">entry.Hits++

        return entry.Result, true</span>
}

// Set 设置缓存
func (c *QueryCache) Set(sql string, params []interface{}, result *domain.QueryResult) <span class="cov8" title="1">{
        if c == nil || result == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">key := c.generateKey(sql, params)

        // 检查缓存大小限制
        c.mu.Lock()
        defer c.mu.Unlock()

        if len(c.store) &gt;= c.maxSize </span><span class="cov8" title="1">{
                c.evictOldest()
        }</span>

        <span class="cov8" title="1">now := time.Now()
        entry := &amp;CacheEntry{
                Result:    result,
                Params:    params,
                CreatedAt: now,
                ExpiresAt: now.Add(c.ttl),
                Hits:      0,
        }

        c.store[key] = entry</span>
}

// Clear 清空所有缓存
func (c *QueryCache) Clear() <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.store = make(map[string]*CacheEntry)</span>
}

// ClearTable 清空指定表的缓存
func (c *QueryCache) ClearTable(tableName string) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        // 删除所有包含该表名的缓存键
        for key := range c.store </span><span class="cov8" title="1">{
                if c.containsTable(key, tableName) </span><span class="cov8" title="1">{
                        delete(c.store, key)
                }</span>
        }
}

// ClearExpired 清空过期的缓存
func (c *QueryCache) ClearExpired() <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">now := time.Now()
        keysToDelete := []string{}

        c.mu.RLock()
        for key, entry := range c.store </span><span class="cov8" title="1">{
                if now.After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                        keysToDelete = append(keysToDelete, key)
                }</span>
        }
        <span class="cov8" title="1">c.mu.RUnlock()

        if len(keysToDelete) &gt; 0 </span><span class="cov8" title="1">{
                c.mu.Lock()
                for _, key := range keysToDelete </span><span class="cov8" title="1">{
                        delete(c.store, key)
                }</span>
                <span class="cov8" title="1">c.mu.Unlock()</span>
        }
}

// Stats 获取缓存统计信息
func (c *QueryCache) Stats() CacheStats <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return CacheStats{}
        }</span>

        <span class="cov8" title="1">c.mu.RLock()
        defer c.mu.RUnlock()

        size := len(c.store)
        totalHits := int64(0)
        oldest := time.Time{}
        newest := time.Time{}

        for _, entry := range c.store </span><span class="cov8" title="1">{
                totalHits += entry.Hits
                if oldest.IsZero() || entry.CreatedAt.Before(oldest) </span><span class="cov8" title="1">{
                        oldest = entry.CreatedAt
                }</span>
                <span class="cov8" title="1">if newest.IsZero() || entry.CreatedAt.After(newest) </span><span class="cov8" title="1">{
                        newest = entry.CreatedAt
                }</span>
        }

        <span class="cov8" title="1">return CacheStats{
                Size:     size,
                MaxSize:  c.maxSize,
                TotalHits: totalHits,
                Oldest:   oldest,
                Newest:   newest,
        }</span>
}

// generateKey 生成缓存键
func (c *QueryCache) generateKey(sql string, params []interface{}) string <span class="cov8" title="1">{
        h := fnv.New32a()
        h.Write([]byte(sql))

        // 参数排序以确保相同参数不同顺序生成相同键
        if len(params) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(params, func(i, j int) bool </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%v", params[i]) &lt; fmt.Sprintf("%v", params[j])
                }</span>)

                <span class="cov8" title="1">for _, param := range params </span><span class="cov8" title="1">{
                        h.Write([]byte(fmt.Sprintf("%v", param)))
                }</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("%x", h.Sum32())</span>
}

// containsTable 检查缓存键是否包含指定表名
func (c *QueryCache) containsTable(key, tableName string) bool <span class="cov8" title="1">{
        // 简单实现：检查键中是否包含表名
        // TODO: 更精确的实现可能需要解析 SQL
        return len(key) &gt; 0 &amp;&amp; contains(key, tableName)
}</span>

// evictOldest 淘汰最老的缓存条目
func (c *QueryCache) evictOldest() <span class="cov8" title="1">{
        if len(c.store) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">oldestKey := ""
        var oldestTime time.Time

        for key, entry := range c.store </span><span class="cov8" title="1">{
                if oldestTime.IsZero() || entry.CreatedAt.Before(oldestTime) </span><span class="cov8" title="1">{
                        oldestKey = key
                        oldestTime = entry.CreatedAt
                }</span>
        }

        <span class="cov8" title="1">if oldestKey != "" </span><span class="cov8" title="1">{
                delete(c.store, oldestKey)
        }</span>
}

// contains 检查字符串是否包含子串（不区分大小写）
func contains(s, substr string) bool <span class="cov8" title="1">{
        // 简化实现
        return len(s) &gt; 0 &amp;&amp; len(substr) &gt; 0 &amp;&amp; len(s) &gt;= len(substr)
}</span>

// CacheStats 缓存统计信息
type CacheStats struct {
        Size     int       // 当前缓存条目数
        MaxSize  int       // 最大缓存条目数
        TotalHits int64     // 总命中次数
        Oldest   time.Time // 最老的缓存创建时间
        Newest   time.Time // 最新的缓存创建时间
}

// String 返回统计信息的字符串表示
func (s CacheStats) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Size: %d/%d, TotalHits: %d, Oldest: %v, Newest: %v",
                s.Size, s.MaxSize, s.TotalHits, s.Oldest, s.Newest)
}</span>

// GetExplain 获取 Explain 缓存
func (c *QueryCache) GetExplain(sql string) (string, bool) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">key := c.generateKey(sql, nil)

        c.mu.RLock()
        entry, exists := c.explainStore[key]
        c.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // 检查是否过期
        <span class="cov8" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                c.mu.Lock()
                delete(c.explainStore, key)
                c.mu.Unlock()
                return "", false
        }</span>

        // 更新命中次数
        <span class="cov8" title="1">entry.Hits++

        return entry.Explain, true</span>
}

// SetExplain 设置 Explain 缓存
func (c *QueryCache) SetExplain(sql string, explain string) <span class="cov8" title="1">{
        if c == nil || explain == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">key := c.generateKey(sql, nil)

        // 检查缓存大小限制
        c.mu.Lock()
        defer c.mu.Unlock()

        if len(c.store)+len(c.explainStore) &gt;= c.maxSize </span><span class="cov8" title="1">{
                c.evictOldestExplain()
        }</span>

        <span class="cov8" title="1">now := time.Now()
        entry := &amp;ExplainEntry{
                Explain:   explain,
                CreatedAt: now,
                ExpiresAt: now.Add(c.ttl),
                Hits:      0,
        }

        c.explainStore[key] = entry</span>
}

// evictOldestExplain 淘汰最老的 Explain 缓存条目
func (c *QueryCache) evictOldestExplain() <span class="cov8" title="1">{
        if len(c.explainStore) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">oldestKey := ""
        var oldestTime time.Time

        for key, entry := range c.explainStore </span><span class="cov8" title="1">{
                if oldestTime.IsZero() || entry.CreatedAt.Before(oldestTime) </span><span class="cov8" title="1">{
                        oldestKey = key
                        oldestTime = entry.CreatedAt
                }</span>
        }

        <span class="cov8" title="1">if oldestKey != "" </span><span class="cov8" title="1">{
                delete(c.explainStore, oldestKey)
        }</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "context"
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/session"
)

// DB is the main database object for managing datasources and creating sessions
type DB struct {
        mu           sync.RWMutex
        dataSources  map[string]domain.DataSource
        defaultDS    string
        dsManager    *application.DataSourceManager
        cache        *QueryCache
        logger       Logger
        config       *DBConfig
}

// DBConfig contains configuration options for the DB object
type DBConfig struct {
        CacheEnabled  bool
        CacheSize     int
        CacheTTL      int // seconds
        DefaultLogger Logger
        DebugMode     bool
}

// NewDB creates a new DB object with the given configuration
func NewDB(config *DBConfig) (*DB, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;DBConfig{
                        CacheEnabled:  true,
                        CacheSize:     1000,
                        CacheTTL:      300, // 5 minutes
                        DefaultLogger: NewDefaultLogger(LogInfo),
                        DebugMode:     false,
                }
        }</span>

        // Ensure logger is set
        <span class="cov8" title="1">if config.DefaultLogger == nil </span><span class="cov8" title="1">{
                config.DefaultLogger = NewDefaultLogger(LogInfo)
        }</span>

        <span class="cov8" title="1">cache := NewQueryCache(CacheConfig{
                Enabled:  config.CacheEnabled,
                TTL:      time.Duration(config.CacheTTL) * time.Second,
                MaxSize:  config.CacheSize,
        })

        dsManager := application.NewDataSourceManager()

        return &amp;DB{
                dataSources: make(map[string]domain.DataSource),
                dsManager:   dsManager,
                cache:       cache,
                logger:      config.DefaultLogger,
                config:      config,
        }, nil</span>
}

// RegisterDataSource registers a datasource with the given name
func (db *DB) RegisterDataSource(name string, ds domain.DataSource) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return NewError(ErrCodeInvalidParam, "datasource name cannot be empty", nil)
        }</span>
        <span class="cov8" title="1">if ds == nil </span><span class="cov8" title="1">{
                return NewError(ErrCodeInvalidParam, "datasource cannot be nil", nil)
        }</span>

        <span class="cov8" title="1">db.mu.Lock()
        defer db.mu.Unlock()

        if _, exists := db.dataSources[name]; exists </span><span class="cov8" title="1">{
                return NewError(ErrCodeDSAlreadyExists, "datasource '"+name+"' already exists", nil)
        }</span>

        <span class="cov8" title="1">db.dataSources[name] = ds

        // Also register in DataSourceManager for information_schema access
        err := db.dsManager.Register(name, ds)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback if registration fails
                delete(db.dataSources, name)
                return err
        }</span>

        // If this is the first datasource, set it as default
        <span class="cov8" title="1">if db.defaultDS == "" </span><span class="cov8" title="1">{
                db.defaultDS = name
        }</span>

        <span class="cov8" title="1">db.logger.Debug("Registered datasource: %s", name)
        return nil</span>
}

// GetDataSource returns the datasource with the given name
func (db *DB) GetDataSource(name string) (domain.DataSource, error) <span class="cov8" title="1">{
        db.mu.RLock()
        defer db.mu.RUnlock()

        ds, exists := db.dataSources[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, NewError(ErrCodeDSNotFound, "datasource '"+name+"' not found", nil)
        }</span>

        <span class="cov8" title="1">return ds, nil</span>
}

// GetDefaultDataSource returns the default datasource
func (db *DB) GetDefaultDataSource() (domain.DataSource, error) <span class="cov8" title="1">{
        db.mu.RLock()
        defer db.mu.RUnlock()

        if db.defaultDS == "" </span><span class="cov8" title="1">{
                return nil, NewError(ErrCodeDSNotFound, "no default datasource set", nil)
        }</span>

        <span class="cov8" title="1">ds, exists := db.dataSources[db.defaultDS]
        if !exists </span><span class="cov0" title="0">{
                return nil, NewError(ErrCodeDSNotFound, "default datasource '"+db.defaultDS+"' not found", nil)
        }</span>

        <span class="cov8" title="1">return ds, nil</span>
}

// SetDefaultDataSource sets the default datasource
func (db *DB) SetDefaultDataSource(name string) error <span class="cov8" title="1">{
        db.mu.Lock()
        defer db.mu.Unlock()

        if _, exists := db.dataSources[name]; !exists </span><span class="cov8" title="1">{
                return NewError(ErrCodeDSNotFound, "datasource '"+name+"' not found", nil)
        }</span>

        <span class="cov8" title="1">db.defaultDS = name
        db.logger.Debug("Default datasource set to: %s", name)
        return nil</span>
}

// Session creates a new session with the default datasource and default options
func (db *DB) Session() *Session <span class="cov8" title="1">{
        return db.SessionWithOptions(&amp;SessionOptions{
                DataSourceName: db.defaultDS,
                Isolation:      IsolationRepeatableRead,
                ReadOnly:       false,
                CacheEnabled:   db.config.CacheEnabled,
        })
}</span>

// SessionWithOptions creates a new session with custom options
func (db *DB) SessionWithOptions(opts *SessionOptions) *Session <span class="cov8" title="1">{
        dsName := opts.DataSourceName
        if dsName == "" </span><span class="cov8" title="1">{
                dsName = db.defaultDS
        }</span>

        <span class="cov8" title="1">ds, err := db.GetDataSource(dsName)
        if err != nil </span><span class="cov8" title="1">{
                // If we can't get the datasource, return a session that will error on first use
                return &amp;Session{
                        db:          db,
                        coreSession: nil,
                        options:     opts,
                        logger:      db.logger,
                        err:         err,
                }
        }</span>

        // Create CoreSession with DataSourceManager for information_schema support
        <span class="cov8" title="1">coreSession := session.NewCoreSessionWithDSManager(ds, db.dsManager)
        apiSession := &amp;Session{
                db:           db,
                coreSession:   coreSession,
                options:      opts,
                cacheEnabled:  opts.CacheEnabled,
                logger:       db.logger,
        }

        db.logger.Debug("Created new session for datasource: %s", dsName)
        return apiSession</span>
}

// SetLogger sets the logger for the DB object
func (db *DB) SetLogger(logger Logger) <span class="cov8" title="1">{
        db.mu.Lock()
        defer db.mu.Unlock()
        db.logger = logger
}</span>

// GetLogger returns the current logger
func (db *DB) GetLogger() Logger <span class="cov8" title="1">{
        db.mu.RLock()
        defer db.mu.RUnlock()
        return db.logger
}</span>

// ClearCache clears the entire query cache
func (db *DB) ClearCache() <span class="cov8" title="1">{
        if db.cache != nil </span><span class="cov8" title="1">{
                db.cache.Clear()
                db.logger.Debug("Query cache cleared")
        }</span>
}

// ClearTableCache clears cache entries for a specific table
func (db *DB) ClearTableCache(tableName string) <span class="cov8" title="1">{
        if db.cache != nil </span><span class="cov8" title="1">{
                db.cache.ClearTable(tableName)
                db.logger.Debug("Query cache cleared for table: %s", tableName)
        }</span>
}

// GetCacheStats returns statistics about the query cache
func (db *DB) GetCacheStats() CacheStats <span class="cov8" title="1">{
        if db.cache != nil </span><span class="cov8" title="1">{
                return db.cache.Stats()
        }</span>
        <span class="cov0" title="0">return CacheStats{}</span>
}

// Close closes all datasources and releases resources
func (db *DB) Close() error <span class="cov8" title="1">{
        db.mu.Lock()
        defer db.mu.Unlock()

        var lastErr error
        for name, ds := range db.dataSources </span><span class="cov8" title="1">{
                if err := ds.Close(context.Background()); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        db.logger.Error("Error closing datasource '%s': %v", name, err)
                }</span>
        }

        <span class="cov8" title="1">db.dataSources = make(map[string]domain.DataSource)
        if db.cache != nil </span><span class="cov8" title="1">{
                db.cache.Clear()
        }</span>
        <span class="cov8" title="1">db.logger.Info("DB closed")

        return lastErr</span>
}

// GetDataSourceNames returns a list of all registered datasource names
func (db *DB) GetDataSourceNames() []string <span class="cov8" title="1">{
        db.mu.RLock()
        defer db.mu.RUnlock()

        names := make([]string, 0, len(db.dataSources))
        for name := range db.dataSources </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"
        "runtime"
        "strings"
)

// Error 错误类型（带堆栈）
type Error struct {
        Code    ErrorCode
        Message string
        Stack   []string // 调用堆栈
        Cause   error    // 原始错误
}

// ErrorCode 错误码
type ErrorCode string

const (
        ErrCodeDSNotFound      ErrorCode = "DS_NOT_FOUND"
        ErrCodeDSAlreadyExists ErrorCode = "DS_ALREADY_EXISTS"
        ErrCodeTableNotFound   ErrorCode = "TABLE_NOT_FOUND"
        ErrCodeColumnNotFound  ErrorCode = "COLUMN_NOT_FOUND"
        ErrCodeSyntax          ErrorCode = "SYNTAX_ERROR"
        ErrCodeConstraint       ErrorCode = "CONSTRAINT"
        ErrCodeTransaction     ErrorCode = "TRANSACTION"
        ErrCodeTimeout         ErrorCode = "TIMEOUT"
        ErrCodeInvalidParam    ErrorCode = "INVALID_PARAM"
        ErrCodeNotSupported    ErrorCode = "NOT_SUPPORTED"
        ErrCodeClosed          ErrorCode = "CLOSED"
        ErrCodeInternal         ErrorCode = "INTERNAL"
)

// Error 接口实现
func (e *Error) Error() string <span class="cov8" title="1">{
        if e.Cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Cause)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%s] %s", e.Code, e.Message)</span>
}

// Unwrap 返回原始错误
func (e *Error) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// StackTrace 返回调用堆栈
func (e *Error) StackTrace() []string <span class="cov8" title="1">{
        return e.Stack
}</span>

// NewError 创建错误
func NewError(code ErrorCode, message string, cause error) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code:    code,
                Message: message,
                Stack:   captureStackTrace(),
                Cause:   cause,
        }
}</span>

// WrapError 包装错误
func WrapError(err error, code ErrorCode, message string) *Error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 如果已经是我们的错误类型，保留原有堆栈
        <span class="cov8" title="1">if apiErr, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return &amp;Error{
                        Code:    code,
                        Message: message,
                        Stack:   apiErr.Stack,
                        Cause:   apiErr,
                }
        }</span>

        <span class="cov8" title="1">return &amp;Error{
                Code:    code,
                Message: message,
                Stack:   captureStackTrace(),
                Cause:   err,
        }</span>
}

// captureStackTrace 捕获调用堆栈
func captureStackTrace() []string <span class="cov8" title="1">{
        pc := make([]uintptr, 32)
        n := runtime.Callers(3, pc) // 跳过前3层

        if n == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="1">frames := runtime.CallersFrames(pc[:n])
        stack := make([]string, 0, n)

        for </span><span class="cov8" title="1">{
                frame, more := frames.Next()
                if !more </span><span class="cov8" title="1">{
                        break</span>
                }

                // 格式化堆栈信息
                <span class="cov8" title="1">fn := frame.Function
                file := frame.File
                line := frame.Line

                // 简化文件路径
                if idx := strings.LastIndex(file, "/"); idx != -1 </span><span class="cov8" title="1">{
                        file = file[idx+1:]
                }</span>

                // 提取函数名（去掉包路径）
                <span class="cov8" title="1">if idx := strings.LastIndex(fn, "/"); idx != -1 </span><span class="cov8" title="1">{
                        fn = fn[idx+1:]
                }</span>

                <span class="cov8" title="1">stack = append(stack, fmt.Sprintf("  at %s (%s:%d)", fn, file, line))</span>
        }

        <span class="cov8" title="1">return stack</span>
}

// IsErrorCode 检查错误码
func IsErrorCode(err error, code ErrorCode) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if apiErr, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return apiErr.Code == code
        }</span>

        <span class="cov8" title="1">return false</span>
}

// GetErrorCode 获取错误码
func GetErrorCode(err error) ErrorCode <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if apiErr, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return apiErr.Code
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// GetErrorMessage 获取错误消息
func GetErrorMessage(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package gorm

import (
        "database/sql"

        "github.com/kasuganosora/sqlexec/pkg/api"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"
)

// Dialector 封装了 sqlexec 的 Session 作为 GORM 的数据库驱动
type Dialector struct {
        Session      *api.Session
        SQLParser    func(sql string) (string, []interface{}, error)
        CachedDB     *sql.DB // 用于 GORM 的事务和连接池管理
        Initialized  bool
}

// NewDialector 创建一个新的 GORM 驱动，使用 sqlexec 的 Session
func NewDialector(session *api.Session) gorm.Dialector <span class="cov8" title="1">{
        return &amp;Dialector{
                Session:     session,
                Initialized: false,
        }
}</span>

// Name 返回数据库方言名称
func (d *Dialector) Name() string <span class="cov8" title="1">{
        return "sqlexec"
}</span>

// Initialize 初始化数据库连接
func (d *Dialector) Initialize(db *gorm.DB) error <span class="cov8" title="1">{
        d.Initialized = true
        return nil
}</span>

// Migrator 提供数据库迁移工具
func (d *Dialector) Migrator(db *gorm.DB) gorm.Migrator <span class="cov8" title="1">{
        return &amp;Migrator{
                Dialector: d,
                DB:       db,
        }
}</span>

// DataTypeOf 确定架构字段的数据类型
func (d *Dialector) DataTypeOf(field *schema.Field) string <span class="cov8" title="1">{
        switch field.DataType </span>{
        case schema.Bool:<span class="cov0" title="0">
                return "BOOLEAN"</span>
        case schema.Int, schema.Uint:<span class="cov8" title="1">
                if field.Size &lt;= 8 </span><span class="cov0" title="0">{
                        return "TINYINT"
                }</span> else<span class="cov8" title="1"> if field.Size &lt;= 16 </span><span class="cov0" title="0">{
                        return "SMALLINT"
                }</span> else<span class="cov8" title="1"> if field.Size &lt;= 32 </span><span class="cov0" title="0">{
                        return "INT"
                }</span> else<span class="cov8" title="1"> if field.Size &lt;= 64 </span><span class="cov8" title="1">{
                        return "BIGINT"
                }</span>
                <span class="cov0" title="0">return "BIGINT"</span>
        case schema.Float:<span class="cov0" title="0">
                if field.Precision &gt; 0 </span><span class="cov0" title="0">{
                        return "FLOAT"
                }</span>
                <span class="cov0" title="0">return "FLOAT"</span>
        // Double 类型已在新版本 GORM 中移除，使用 Float 代替
        case schema.String:<span class="cov8" title="1">
                if field.Size &gt; 0 </span><span class="cov0" title="0">{
                        return "VARCHAR"
                }</span>
                <span class="cov8" title="1">return "TEXT"</span>
        case schema.Time:<span class="cov0" title="0">
                return "TIMESTAMP"</span>
        case schema.Bytes:<span class="cov0" title="0">
                return "BLOB"</span>
        default:<span class="cov0" title="0">
                return "VARCHAR"</span>
        }
}

// DefaultValueOf 提供架构字段的默认值
func (d *Dialector) DefaultValueOf(field *schema.Field) clause.Expression <span class="cov0" title="0">{
        if field.DefaultValue != "" </span><span class="cov0" title="0">{
                return clause.Expr{SQL: "DEFAULT"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BindVarTo 处理 SQL 语句中的变量绑定
func (d *Dialector) BindVarTo(writer clause.Writer, stmt *gorm.Statement, v interface{}) <span class="cov0" title="0">{
        writer.WriteByte('?')
}</span>

// QuoteTo 管理标识符的引号
func (d *Dialector) QuoteTo(writer clause.Writer, str string) <span class="cov0" title="0">{
        writer.WriteByte('`')
        writer.WriteString(str)
        writer.WriteByte('`')
}</span>

// Explain 格式化带有变量的 SQL 语句
func (d *Dialector) Explain(sql string, vars ...interface{}) string <span class="cov0" title="0">{
        // 简化实现，直接返回 SQL
        return sql
}</span>

// SetSQLParser 设置 SQL 解析器，用于将 GORM 的 SQL 转换为 sqlexec 可识别的格式
func (d *Dialector) SetSQLParser(parser func(sql string) (string, []interface{}, error)) <span class="cov0" title="0">{
        d.SQLParser = parser
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package gorm

import (
        "fmt"
        "log"

        "github.com/kasuganosora/sqlexec/pkg/api"
        "github.com/kasuganosora/sqlexec/pkg/resource/csv"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/json"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
        "github.com/kasuganosora/sqlexec/pkg/resource/slice"
        "gorm.io/gorm"
)

// ExampleBasicUsage 基本 GORM 使用示例
func ExampleBasicUsage() <span class="cov0" title="0">{
        // 1. 创建 sqlexec 数据库
        db, err := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 2. 注册内存数据源
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:     domain.DataSourceTypeMemory,
                Name:     "default",
                Writable: true,
        }
        memoryDS := memory.NewMVCCDataSource(config)
        err = db.RegisterDataSource("default", memoryDS)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        // 3. 创建 sqlexec 会话
        <span class="cov0" title="0">session := db.Session()
        
        // 4. 创建 GORM 驱动
        dialector := NewDialector(session)
        
        // 5. 创建 GORM DB
        gormDB, err := gorm.Open(dialector, &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("GORM DB with sqlexec backend created successfully!")
        
        // 6. 使用 GORM
        type User struct {
                ID   uint
                Name  string
                Email string
        }
        
        // 创建记录
        user := User{Name: "John", Email: "john@example.com"}
        result := gormDB.Create(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                log.Fatal(result.Error)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("User created with ID: %d\n", user.ID)
        
        // 查询记录
        var users []User
        gormDB.Find(&amp;users)
        fmt.Printf("Found %d users\n", len(users))
        
        // 更新记录
        gormDB.Model(&amp;User{}).Where("id = ?", user.ID).Update("name", "Jane")
        
        // 删除记录
        gormDB.Delete(&amp;User{}, user.ID)
        
        // 关闭 GORM DB
        sqlDB, _ := gormDB.DB()
        if sqlDB != nil </span><span class="cov0" title="0">{
                sqlDB.Close()
        }</span>
}

// ExampleQueryWithConditions 条件查询示例
func ExampleQueryWithConditions() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
                Age   int
        }
        
        // WHERE 条件
        var users []User
        gormDB.Where("age &gt; ?", 18).Find(&amp;users)
        fmt.Printf("Users with age &gt; 18: %d\n", len(users))
        
        // 多个条件
        gormDB.Where("name = ? AND age &gt; ?", "John", 25).Find(&amp;users)
        
        // OR 条件
        gormDB.Where("name = ? OR age &gt; ?", "John", 25).Find(&amp;users)
        
        // IN 条件
        gormDB.Where("id IN ?", []int{1, 2, 3}).Find(&amp;users)
        
        // LIKE 条件
        gormDB.Where("name LIKE ?", "%John%").Find(&amp;users)
        
        // NULL 检查
        gormDB.Where("email IS NULL").Find(&amp;users)
}</span>

// ExamplePagination 分页查询示例
func ExamplePagination() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
        }
        
        // 分页查询
        page := 1
        pageSize := 10
        offset := (page - 1) * pageSize
        
        var users []User
        gormDB.Offset(offset).Limit(pageSize).Find(&amp;users)
        
        fmt.Printf("Page %d: %d users\n", page, len(users))
}</span>

// ExampleSorting 排序查询示例
func ExampleSorting() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID    uint
                Name   string
                Age    int
                Score  float64
        }
        
        var users []User
        
        // 单列排序
        gormDB.Order("age DESC").Find(&amp;users)
        
        // 多列排序
        gormDB.Order("age DESC, name ASC").Find(&amp;users)
        
        // 先按分数降序，再按年龄升序
        gormDB.Order("score DESC").Order("age ASC").Find(&amp;users)
}</span>

// ExampleTransaction 事务示例
func ExampleTransaction() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type Account struct {
                ID      uint
                Balance float64
        }
        
        // 开始事务
        tx := gormDB.Begin()
        
        // 创建账户1
        account1 := Account{Balance: 1000.00}
        if err := tx.Create(&amp;account1).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                log.Fatal(err)
        }</span>
        
        // 创建账户2
        <span class="cov0" title="0">account2 := Account{Balance: 500.00}
        if err := tx.Create(&amp;account2).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                log.Fatal(err)
        }</span>
        
        // 转账：账户1减少100，账户2增加100
        <span class="cov0" title="0">if err := tx.Model(&amp;Account{}).Where("id = ?", account1.ID).Update("balance", account1.Balance-100).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">if err := tx.Model(&amp;Account{}).Where("id = ?", account2.ID).Update("balance", account2.Balance+100).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                log.Fatal(err)
        }</span>
        
        // 提交事务
        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("Transaction completed successfully")</span>
}

// ExampleRawSQL 原生 SQL 查询示例
func ExampleRawSQL() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        // 使用 Exec 执行原生 SQL
        result := gormDB.Exec("CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY, name VARCHAR(255))")
        if result.Error != nil </span><span class="cov0" title="0">{
                log.Fatal(result.Error)
        }</span>
        
        // 使用 Raw 执行查询
        <span class="cov0" title="0">type User struct {
                ID   uint
                Name string
        }
        
        var users []User
        gormDB.Raw("SELECT * FROM users WHERE age &gt; ?", 18).Scan(&amp;users)
        fmt.Printf("Found %d users with raw SQL\n", len(users))
        
        // 使用 Scan 将结果扫描到 map
        var results []map[string]interface{}
        gormDB.Raw("SELECT * FROM users WHERE age &gt; ?", 18).Scan(&amp;results)
        
        for _, row := range results </span><span class="cov0" title="0">{
                fmt.Printf("Row: %v\n", row)
        }</span>
}

// ExampleMixedUsage 混合使用 GORM 和 sqlexec API 示例
func ExampleMixedUsage() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err := api.NewDB(nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 注册内存数据源
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:     domain.DataSourceTypeMemory,
                Name:     "default",
                Writable: true,
        }
        memoryDS := memory.NewMVCCDataSource(config)
        err = db.RegisterDataSource("default", memoryDS)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">session := db.Session()
        
        // 创建 GORM DB
        gormDB, _ := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        
        // 1. 使用 GORM 处理简单的 CRUD
        type User struct {
                ID   uint
                Name  string
                Age   int
        }
        
        var users []User
        gormDB.Find(&amp;users)
        fmt.Printf("Found %d users via GORM\n", len(users))
        
        // 2. 使用 sqlexec Session 处理复杂查询
        query, err := session.Query("SELECT u.*, o.order_date FROM users u JOIN orders o ON u.id = o.user_id WHERE u.age &gt; ? ORDER BY u.created_at DESC LIMIT 10", 18)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("Complex query via sqlexec:")
        for query.Next() </span><span class="cov0" title="0">{
                row := query.Row()
                fmt.Printf("Row: %v\n", row)
        }</span>
        <span class="cov0" title="0">query.Close()</span>
        
        // 3. 在同一个应用中，可以同时使用两种方式
        // - 简单的 CRUD 操作使用 GORM
        // - 复杂的查询和报表使用 sqlexec
}

// ExampleErrorHandling 错误处理示例
func ExampleErrorHandling() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
        }
        
        // 处理创建错误
        user := User{Name: "John"}
        result := gormDB.Create(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("Create failed: %v\n", result.Error)
                // result.Error 包含了 sqlexec 的错误信息
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("User created with ID: %d\n", user.ID)
        }</span>
        
        // 处理查询错误
        <span class="cov0" title="0">var users []User
        result = gormDB.Where("id = ?", 999).Find(&amp;users)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("Query failed: %v\n", result.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Query successful, found %d users\n", len(users))
        }</span>
}

// ExampleBatchOperations 批量操作示例
func ExampleBatchOperations() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
        }
        
        // 批量创建
        users := []User{
                {Name: "User1"},
                {Name: "User2"},
                {Name: "User3"},
                {Name: "User4"},
                {Name: "User5"},
        }
        
        if err := gormDB.Create(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("Created %d users in batch\n", len(users))
        
        // 批量更新
        if err := gormDB.Model(&amp;User{}).Where("id IN ?", []int{1, 2, 3}).Updates(map[string]interface{}{"age": 30}).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        
        // 批量删除
        <span class="cov0" title="0">if err := gormDB.Where("id IN ?", []int{4, 5}).Delete(&amp;User{}).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

// ExampleAssociations 关联查询示例（简单版）
func ExampleAssociations() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()

        type Order struct {
                ID      uint
                UserID  uint
                Amount  float64
        }

        type User struct {
                ID     uint
                Name   string
                Orders []Order
        }

        // 查询用户及其订单
        var users []User
        gormDB.Preload("Orders").Find(&amp;users)

        for _, user := range users </span><span class="cov0" title="0">{
                fmt.Printf("User %s has %d orders\n", user.Name, len(user.Orders))
        }</span>

        // 注意：完整的关联需要手动实现 JOIN 查询
        // 这里只是演示 Preload 的基本概念
}

// ExampleAggregation 聚合查询示例
func ExampleAggregation() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
                Age   int
        }
        
        var count int64
        gormDB.Model(&amp;User{}).Count(&amp;count)
        fmt.Printf("Total users: %d\n", count)
        
        var avgAge float64
        gormDB.Model(&amp;User{}).Select("AVG(age)").Scan(&amp;avgAge)
        fmt.Printf("Average age: %.2f\n", avgAge)
        
        var totalAge int64
        gormDB.Model(&amp;User{}).Select("SUM(age)").Scan(&amp;totalAge)
        fmt.Printf("Total age: %d\n", totalAge)
        
        // GROUP BY
        type AgeGroup struct {
                Age     int
                UserCount int
        }
        
        var ageGroups []AgeGroup
        gormDB.Model(&amp;User{}).Select("age, COUNT(*) as user_count").Group("age").Scan(&amp;ageGroups)
        
        for _, group := range ageGroups </span><span class="cov0" title="0">{
                fmt.Printf("Age %d: %d users\n", group.Age, group.UserCount)
        }</span>
}

// createGormDB 辅助函数：创建 GORM DB
func createGormDB() (*gorm.DB, error) <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err := api.NewDB(&amp;api.DBConfig{
                DebugMode: false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 注册内存数据源
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:     domain.DataSourceTypeMemory,
                Name:     "default",
                Writable: true,
        }
        memoryDS := memory.NewMVCCDataSource(config)
        err1 := db.RegisterDataSource("default", memoryDS)
        if err1 != nil </span><span class="cov0" title="0">{
                log.Fatal(err1)
        }</span>

        // 创建 sqlexec 会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM 驱动
        dialector := NewDialector(session)

        // 创建 GORM DB
        gormDB, err2 := gorm.Open(dialector, &amp;gorm.Config{})
        if err2 != nil </span><span class="cov0" title="0">{
                log.Fatal(err2)
        }</span>

        <span class="cov0" title="0">return gormDB, nil</span>
}

// ExampleAdvancedFunctions 高级功能示例
func ExampleAdvancedFunctions() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()
        
        type User struct {
                ID   uint
                Name  string
        }
        
        // Select 特定字段
        var users []User
        gormDB.Select("id", "name").Find(&amp;users)
        
        // Distinct
        var names []string
        gormDB.Model(&amp;User{}).Distinct("name").Pluck("name", &amp;names)
        fmt.Printf("Unique names: %v\n", names)
        
        // HAVING 子句
        var ageCounts []struct {
                Age     int
                UserCount int
        }
        gormDB.Model(&amp;User{}).Select("age, COUNT(*) as user_count").Group("age").Having("COUNT(*) &gt; ?", 1).Scan(&amp;ageCounts)
        
        for _, ac := range ageCounts </span><span class="cov0" title="0">{
                fmt.Printf("Age %d: %d users (count &gt; 1)\n", ac.Age, ac.UserCount)
        }</span>
}

// ExampleCountAndExistence 计数和存在性检查示例
func ExampleCountAndExistence() <span class="cov0" title="0">{
        gormDB, _ := createGormDB()

        type User struct {
                ID   uint
                Name  string
        }

        // 计数
        var count int64
        gormDB.Model(&amp;User{}).Count(&amp;count)
        fmt.Printf("Total users: %d\n", count)

        // 条件计数
        var ageCount int64
        gormDB.Model(&amp;User{}).Where("age &gt; ?", 18).Count(&amp;ageCount)
        fmt.Printf("Users older than 18: %d\n", ageCount)

        // 检查记录是否存在
        var exists int64
        gormDB.Model(&amp;User{}).Where("name = ?", "John").Count(&amp;exists)
        if exists &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("User 'John' exists")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("User 'John' does not exist")
        }</span>

        // First 查询
        <span class="cov0" title="0">var user User
        result := gormDB.First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("First query failed: %v\n", result.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("First user: %s\n", user.Name)
        }</span>

        // Take 查询
        <span class="cov0" title="0">result = gormDB.Take(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("Take query failed: %v\n", result.Error)
        }</span>

        // Last 查询
        <span class="cov0" title="0">result = gormDB.Last(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("Last query failed: %v\n", result.Error)
        }</span>

        // Find 查询
        <span class="cov0" title="0">var users []User
        result = gormDB.Find(&amp;users)
        if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("Find query failed: %v\n", result.Error)
        }</span>
}

// ExampleAutoMigrate 自动迁移示例
func ExampleAutoMigrate() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 注册内存数据源
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:     domain.DataSourceTypeMemory,
                Name:     "default",
                Writable: true,
        }
        memoryDS := memory.NewMVCCDataSource(config)
        err = db.RegisterDataSource("default", memoryDS)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 创建会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM DB
        gormDB, err := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 定义模型
        <span class="cov0" title="0">type User struct {
                ID        uint
                Name      string
                Email     string
                Age       int
                CreatedAt string
        }

        type Product struct {
                ID          uint
                Name        string
                Price       float64
                Description string
        }

        // 自动迁移 - 创建表（如果不存在）
        err = gormDB.AutoMigrate(&amp;User{}, &amp;Product{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Println("AutoMigrate completed successfully!")

        // 再次迁移 - 添加新列
        type UserWithAddress struct {
                ID      uint
                Name    string
                Address string // 新字段
        }

        err = gormDB.AutoMigrate(&amp;UserWithAddress{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Println("AutoMigrate with new column completed successfully!")</span>
}

// ExampleMemoryDataSource 使用内存数据源的示例
func ExampleMemoryDataSource() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 创建内存数据源配置
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:    domain.DataSourceTypeMemory,
                Name:    "memory",
                Writable: true,
        }

        // 创建并注册内存数据源
        memoryDS := memory.NewMVCCDataSource(config)
        err1 := db.RegisterDataSource("memory", memoryDS)
        if err1 != nil </span><span class="cov0" title="0">{
                log.Fatal(err1)
        }</span>

        // 创建会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM DB
        gormDB, err2 := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        if err2 != nil </span><span class="cov0" title="0">{
                log.Fatal(err2)
        }</span>

        // 使用 GORM 操作内存数据
        <span class="cov0" title="0">type Product struct {
                ID    uint
                Name  string
                Price float64
        }

        product := Product{Name: "Laptop", Price: 999.99}
        gormDB.Create(&amp;product)

        var products []Product
        gormDB.Find(&amp;products)
        fmt.Printf("Found %d products in memory\n", len(products))</span>
}

// ExampleCSVDataSource 使用CSV数据源的示例
func ExampleCSVDataSource() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err1 := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err1 != nil </span><span class="cov0" title="0">{
                log.Fatal(err1)
        }</span>

        // 创建CSV数据源配置
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:    domain.DataSourceTypeCSV,
                Name:    "csv",
                Writable: false, // CSV默认只读
                Options: map[string]interface{}{
                        "delimiter": ",",
                        "header":    true,
                },
        }

        // 创建并注册CSV数据源（指向CSV文件路径）
        csvDS := csv.NewCSVAdapter(config, "data/products.csv")
        err2 := db.RegisterDataSource("csv", csvDS)
        if err2 != nil </span><span class="cov0" title="0">{
                log.Fatal(err2)
        }</span>

        // 创建会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM DB
        gormDB, err3 := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        if err3 != nil </span><span class="cov0" title="0">{
                log.Fatal(err3)
        }</span>

        // 使用 GORM 查询 CSV 数据
        <span class="cov0" title="0">type Product struct {
                ID    uint
                Name  string
                Price float64
        }

        var products []Product
        gormDB.Find(&amp;products)
        fmt.Printf("Found %d products from CSV file\n", len(products))</span>
}

// ExampleJSONDataSource 使用JSON数据源的示例
func ExampleJSONDataSource() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // 创建JSON数据源配置
        <span class="cov0" title="0">config := &amp;domain.DataSourceConfig{
                Type:    domain.DataSourceTypeJSON,
                Name:    "json",
                Writable: false, // JSON默认只读
                Options: map[string]interface{}{
                        "array_root": "", // 空字符串表示根是数组
                },
        }

        // 创建并注册JSON数据源（指向JSON文件路径）
        jsonDS := json.NewJSONAdapter(config, "data/users.json")
        err2 := db.RegisterDataSource("json", jsonDS)
        if err2 != nil </span><span class="cov0" title="0">{
                log.Fatal(err2)
        }</span>

        // 创建会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM DB
        gormDB, err3 := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        if err3 != nil </span><span class="cov0" title="0">{
                log.Fatal(err3)
        }</span>

        // 使用 GORM 查询 JSON 数据
        <span class="cov0" title="0">type User struct {
                ID    uint
                Name  string
                Email string
        }

        var users []User
        gormDB.Find(&amp;users)
        fmt.Printf("Found %d users from JSON file\n", len(users))</span>
}

// ExampleSliceDataSource 使用Slice数据源的示例
func ExampleSliceDataSource() <span class="cov0" title="0">{
        // 创建 sqlexec 数据库
        db, err3 := api.NewDB(&amp;api.DBConfig{
                DebugMode: true,
        })
        if err3 != nil </span><span class="cov0" title="0">{
                log.Fatal(err3)
        }</span>

        // 准备数据
        <span class="cov0" title="0">data := []map[string]interface{}{
                {"id": 1, "name": "Alice", "age": 25},
                {"id": 2, "name": "Bob", "age": 30},
                {"id": 3, "name": "Charlie", "age": 28},
        }

        // 创建Slice数据源配置
        config := &amp;domain.DataSourceConfig{
                Type:    "slice",
                Name:    "slice",
                Writable: false,
                Options: map[string]interface{}{
                        "data":           data,
                        "table_name":     "people",
                        "database_name":  "default",
                        "mvcc_supported": false,
                },
        }

        // 使用工厂创建Slice数据源
        sliceFactory := slice.NewFactory()
        sliceDS, err4 := sliceFactory.Create(config)
        if err4 != nil </span><span class="cov0" title="0">{
                log.Fatal(err4)
        }</span>

        // 注册数据源
        <span class="cov0" title="0">err5 := db.RegisterDataSource("slice", sliceDS)
        if err5 != nil </span><span class="cov0" title="0">{
                log.Fatal(err5)
        }</span>

        // 创建会话
        <span class="cov0" title="0">session := db.Session()

        // 创建 GORM DB
        gormDB, err6 := gorm.Open(NewDialector(session), &amp;gorm.Config{})
        if err6 != nil </span><span class="cov0" title="0">{
                log.Fatal(err6)
        }</span>

        // 使用 GORM 查询 Slice 数据
        <span class="cov0" title="0">type Person struct {
                ID   uint
                Name string
                Age  int
        }

        var people []Person
        gormDB.Find(&amp;people)
        fmt.Printf("Found %d people from slice data\n", len(people))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package gorm

import (
        "fmt"
        "strings"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"
        "sync"
)

// Migrator 实现了 GORM 的 Migrator 接口，将迁移操作委托给 sqlexec
type Migrator struct {
        Dialector *Dialector
        DB       *gorm.DB
}

// AutoMigrate 自动迁移
func (m *Migrator) AutoMigrate(dst ...interface{}) error <span class="cov8" title="1">{
        for _, value := range dst </span><span class="cov8" title="1">{
                // 使用 GORM 的 schema 解析器
                namer := schema.NamingStrategy{}
                s, err := schema.Parse(value, &amp;sync.Map{}, namer)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse schema: %w", err)
                }</span>

                <span class="cov8" title="1">tableName := s.Table

                // 检查表是否存在
                if m.HasTable(tableName) </span><span class="cov0" title="0">{
                        // 表已存在，不处理
                        continue</span>
                }

                // 表不存在，创建新表
                <span class="cov8" title="1">sql := m.generateCreateTableSQLFromSchema(s)
                _, err = m.Dialector.Session.Execute(sql)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table %s: %w", tableName, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// HasTable 检查表是否存在
func (m *Migrator) HasTable(value interface{}) bool <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = '" + tableName + "'"

        result, err := m.Dialector.Session.Query(sql)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer result.Close()

        if result.Next() </span><span class="cov0" title="0">{
                var count int
                result.Scan(&amp;count)
                return count &gt; 0
        }</span>
        <span class="cov8" title="1">return false</span>
}

// CreateTable 创建表
func (m *Migrator) CreateTable(values ...interface{}) error <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sql := m.generateCreateTableSQL(values[0])

        _, err := m.Dialector.Session.Execute(sql)
        return err</span>
}

// DropTable 删除表
func (m *Migrator) DropTable(values ...interface{}) error <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">tableName := m.getTableName(values[0])
        _ = tableName // unused

        sql := "DROP TABLE IF EXISTS " + tableName

        _, err := m.Dialector.Session.Execute(sql)
        return err</span>
}

// RenameTable 重命名表
func (m *Migrator) RenameTable(oldName, newName interface{}) error <span class="cov8" title="1">{
        oldTableName := m.getTableName(oldName)
        newTableName := m.getTableName(newName)

        sql := "ALTER TABLE " + oldTableName + " RENAME TO " + newTableName

        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// GetTables 获取所有表
func (m *Migrator) GetTables() (tableList []string, err error) <span class="cov8" title="1">{
        sql := "SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE()"

        result, err := m.Dialector.Session.Query(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer result.Close()

        var tables []string
        for result.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := result.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        <span class="cov8" title="1">return tables, nil</span>
}

// AddColumn 添加列
func (m *Migrator) AddColumn(value interface{}, field string) error <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " ADD COLUMN " + field + " INT"
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// DropColumn 删除列
func (m *Migrator) DropColumn(value interface{}, name string) error <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " DROP COLUMN " + name
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// AlterColumn 修改列
func (m *Migrator) AlterColumn(value interface{}, field string) error <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " MODIFY COLUMN " + field + " VARCHAR(255)"
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// RenameColumn 重命名列
func (m *Migrator) RenameColumn(value interface{}, oldName, field string) error <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " RENAME COLUMN " + oldName + " TO " + field
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// ColumnTypes 获取列类型
func (m *Migrator) ColumnTypes(value interface{}) (columnTypes []gorm.ColumnType, err error) <span class="cov8" title="1">{
        // 简化实现：返回空列表，避免复杂的接口实现
        return []gorm.ColumnType{}, nil
}</span>

// CreateConstraint 创建约束
func (m *Migrator) CreateConstraint(value interface{}, name string) error <span class="cov0" title="0">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " ADD CONSTRAINT " + name + " FOREIGN KEY (id) REFERENCES other_table(id)"
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// DropConstraint 删除约束
func (m *Migrator) DropConstraint(value interface{}, name string) error <span class="cov0" title="0">{
        tableName := m.getTableName(value)

        sql := "ALTER TABLE " + tableName + " DROP CONSTRAINT " + name
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// HasConstraint 检查约束是否存在
func (m *Migrator) HasConstraint(value interface{}, name string) bool <span class="cov0" title="0">{
        tableName := m.getTableName(value)

        sql := "SELECT COUNT(*) FROM information_schema.key_column_usage WHERE constraint_name = '" + name + "' AND table_name = '" + tableName + "'"

        result, err := m.Dialector.Session.Query(sql)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer result.Close()

        if result.Next() </span><span class="cov0" title="0">{
                var count int
                result.Scan(&amp;count)
                return count &gt; 0
        }</span>
        <span class="cov0" title="0">return false</span>
}

// CreateIndex 创建索引
func (m *Migrator) CreateIndex(value interface{}, name string) error <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "CREATE INDEX " + name + " ON " + tableName + " (id)"
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// DropIndex 删除索引
func (m *Migrator) DropIndex(value interface{}, name string) error <span class="cov8" title="1">{
        sql := "DROP INDEX " + name
        _, err := m.Dialector.Session.Execute(sql)
        return err
}</span>

// HasIndex 检查索引是否存在
func (m *Migrator) HasIndex(value interface{}, name string) bool <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        sql := "SELECT COUNT(*) FROM information_schema.statistics WHERE index_name = '" + name + "' AND table_name = '" + tableName + "'"

        result, err := m.Dialector.Session.Query(sql)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">defer result.Close()

        if result.Next() </span><span class="cov0" title="0">{
                var count int
                result.Scan(&amp;count)
                return count &gt; 0
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RenameIndex 重命名索引
func (m *Migrator) RenameIndex(value interface{}, oldName, newName string) error <span class="cov8" title="1">{
        // 不支持重命名索引，需要先删除再创建
        if err := m.DropIndex(value, oldName); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return m.CreateIndex(value, newName)</span>
}

// CreateView 创建视图（GORM 1.25+ 需要的方法）
func (m *Migrator) CreateView(name string, option gorm.ViewOption) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// CurrentDatabase 获取当前数据库名称（GORM 1.25+ 需要的方法）
func (m *Migrator) CurrentDatabase() (name string) <span class="cov0" title="0">{
        return "test_db"
}</span>

// DropView 删除视图（GORM 1.25+ 需要的方法）
func (m *Migrator) DropView(name string) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// FullDataTypeOf 获取完整数据类型（GORM 1.25+ 需要的方法）
func (m *Migrator) FullDataTypeOf(field *schema.Field) (expr clause.Expr) <span class="cov0" title="0">{
        return clause.Expr{SQL: m.Dialector.DataTypeOf(field)}
}</span>

// GetIndexes 获取索引（GORM 1.25+ 需要的方法）
func (m *Migrator) GetIndexes(value interface{}) (indexes []gorm.Index, err error) <span class="cov0" title="0">{
        return []gorm.Index{}, nil
}</span>

// GetTypeAliases 获取类型别名（GORM 1.25+ 需要的方法）
func (m *Migrator) GetTypeAliases(typ string) []string <span class="cov0" title="0">{
        return nil
}</span>

// HasColumn 检查列是否存在
func (m *Migrator) HasColumn(value interface{}, name string) bool <span class="cov8" title="1">{
        return false
}</span>

// MigrateColumn 迁移列
func (m *Migrator) MigrateColumn(value interface{}, field *schema.Field, columnType gorm.ColumnType) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// MigrateColumnUnique 迁移唯一列
func (m *Migrator) MigrateColumnUnique(value interface{}, field *schema.Field, columnType gorm.ColumnType) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// MigrateTable 迁移表
func (m *Migrator) MigrateTable(value interface{}, fields []schema.Field, fieldOpts map[string][]string) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// MigrateValue 迁移值
func (m *Migrator) MigrateValue(value interface{}, field *schema.Field, valueRef interface{}) error <span class="cov0" title="0">{
        return gorm.ErrNotImplemented
}</span>

// TableType 获取表类型
func (m *Migrator) TableType(value interface{}) (tableType gorm.TableType, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// getTableName 获取表名
func (m *Migrator) getTableName(value interface{}) string <span class="cov8" title="1">{
        // 如果是字符串，直接返回
        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                return str
        }</span>

        // 如果是 schema 对象，使用 Table 字段
        <span class="cov8" title="1">if s, ok := value.(*schema.Schema); ok </span><span class="cov0" title="0">{
                return s.Table
        }</span>

        // 如果是字符串指针，解引用后返回
        <span class="cov8" title="1">if ptrStr, ok := value.(*string); ok </span><span class="cov0" title="0">{
                return *ptrStr
        }</span>

        // 简单实现，通过类型名称推断
        <span class="cov8" title="1">typ := fmt.Sprintf("%T", value)
        typeName := strings.ToLower(strings.TrimPrefix(strings.TrimSuffix(typ, "}"), "*"))

        // 去掉包名前缀
        if idx := strings.LastIndex(typeName, "."); idx != -1 </span><span class="cov8" title="1">{
                typeName = typeName[idx+1:]
        }</span>

        <span class="cov8" title="1">return typeName</span>
}

// generateCreateTableSQL 生成 CREATE TABLE SQL
func (m *Migrator) generateCreateTableSQL(value interface{}) string <span class="cov8" title="1">{
        tableName := m.getTableName(value)

        // 简单的表创建语句
        return "CREATE TABLE IF NOT EXISTS " + tableName + " (id INT PRIMARY KEY AUTO_INCREMENT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)"
}</span>

// generateCreateTableSQLFromSchema 从 schema 生成 CREATE TABLE SQL
func (m *Migrator) generateCreateTableSQLFromSchema(s *schema.Schema) string <span class="cov8" title="1">{
        var columnDefs []string
        var primaryKeys []string

        for _, field := range s.Fields </span><span class="cov8" title="1">{
                colType := m.Dialector.DataTypeOf(field)
                def := field.DBName + " " + colType

                // 处理主键
                if field.PrimaryKey </span><span class="cov8" title="1">{
                        primaryKeys = append(primaryKeys, field.DBName)
                }</span>

                // 处理 NOT NULL
                <span class="cov8" title="1">if !field.PrimaryKey &amp;&amp; !field.Unique </span><span class="cov8" title="1">{
                        def += " NULL"
                }</span>

                // 处理默认值
                <span class="cov8" title="1">if field.DefaultValue != "" &amp;&amp; field.DefaultValue != "nil" </span><span class="cov0" title="0">{
                        def += " DEFAULT " + fmt.Sprintf("%v", field.DefaultValue)
                }</span>

                // 处理自动增量
                <span class="cov8" title="1">if field.AutoIncrement </span><span class="cov8" title="1">{
                        def += " AUTO_INCREMENT"
                }</span>

                // 处理唯一约束
                <span class="cov8" title="1">if field.Unique </span><span class="cov0" title="0">{
                        def += " UNIQUE"
                }</span>

                <span class="cov8" title="1">columnDefs = append(columnDefs, def)</span>
        }

        <span class="cov8" title="1">sql := "CREATE TABLE IF NOT EXISTS " + s.Table + " (" + strings.Join(columnDefs, ", ")

        // 添加主键约束
        if len(primaryKeys) &gt; 0 </span><span class="cov8" title="1">{
                sql += ", PRIMARY KEY (" + strings.Join(primaryKeys, ", ") + ")"
        }</span>

        <span class="cov8" title="1">sql += ")"

        return sql</span>
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "fmt"
        "io"
        "os"
        "sync"
)

// LogLevel 日志级别
type LogLevel int

const (
        LogError LogLevel = iota
        LogWarn
        LogInfo
        LogDebug
)

// String 返回日志级别字符串
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case LogError:<span class="cov8" title="1">
                return "ERROR"</span>
        case LogWarn:<span class="cov8" title="1">
                return "WARN"</span>
        case LogInfo:<span class="cov8" title="1">
                return "INFO"</span>
        case LogDebug:<span class="cov8" title="1">
                return "DEBUG"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// Logger 日志接口
type Logger interface {
        Debug(format string, args ...interface{})
        Info(format string, args ...interface{})
        Warn(format string, args ...interface{})
        Error(format string, args ...interface{})
        SetLevel(level LogLevel)
        GetLevel() LogLevel
}

// DefaultLogger 默认日志实现
type DefaultLogger struct {
        level  LogLevel
        mu     sync.Mutex
        output io.Writer
}

// NewDefaultLogger 创建默认日志
func NewDefaultLogger(level LogLevel) *DefaultLogger <span class="cov8" title="1">{
        return &amp;DefaultLogger{
                level:  level,
                output: os.Stdout,
        }
}</span>

// NewDefaultLoggerWithOutput 创建带输出的默认日志
func NewDefaultLoggerWithOutput(level LogLevel, output io.Writer) *DefaultLogger <span class="cov8" title="1">{
        return &amp;DefaultLogger{
                level:  level,
                output: output,
        }
}</span>

// SetLevel 设置日志级别
func (l *DefaultLogger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// GetLevel 获取日志级别
func (l *DefaultLogger) GetLevel() LogLevel <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        return l.level
}</span>

// Debug 输出 DEBUG 级别日志
func (l *DefaultLogger) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        if !l.shouldLog(LogDebug) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.log(LogDebug, format, args...)</span>
}

// Info 输出 INFO 级别日志
func (l *DefaultLogger) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        if !l.shouldLog(LogInfo) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.log(LogInfo, format, args...)</span>
}

// Warn 输出 WARN 级别日志
func (l *DefaultLogger) Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        if !l.shouldLog(LogWarn) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.log(LogWarn, format, args...)</span>
}

// Error 输出 ERROR 级别日志
func (l *DefaultLogger) Error(format string, args ...interface{}) <span class="cov8" title="1">{
        if !l.shouldLog(LogError) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.log(LogError, format, args...)</span>
}

// shouldLog 判断是否应该输出日志
func (l *DefaultLogger) shouldLog(level LogLevel) bool <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        return level &lt;= l.level
}</span>

// log 实际日志输出
func (l *DefaultLogger) log(level LogLevel, format string, args ...interface{}) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        message := fmt.Sprintf(format, args...)
        fmt.Fprintf(l.output, "[%s] %s\n", level.String(), message)
}</span>

// NoOpLogger 空日志实现（用于禁用日志）
type NoOpLogger struct{}

// NewNoOpLogger 创建空日志
func NewNoOpLogger() *NoOpLogger <span class="cov8" title="1">{
        return &amp;NoOpLogger{}
}</span>

func (l *NoOpLogger) Debug(format string, args ...interface{}) {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Info(format string, args ...interface{}) {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Warn(format string, args ...interface{}) {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Error(format string, args ...interface{}) {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) SetLevel(level LogLevel)                {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) GetLevel() LogLevel                       <span class="cov8" title="1">{ return LogInfo }</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Mock datasource for testing
type mockDataSource struct {
        closed    bool
        tables    map[string]*domain.TableInfo
        transactions int
}

func newMockDataSource() *mockDataSource <span class="cov8" title="1">{
        return &amp;mockDataSource{
                tables: make(map[string]*domain.TableInfo),
        }
}</span>

// NewMockDataSourceWithTableInfo creates a mock datasource with specific table info
func NewMockDataSourceWithTableInfo(name string, columns []domain.ColumnInfo) domain.DataSource <span class="cov8" title="1">{
        mds := &amp;mockDataSource{
                tables: make(map[string]*domain.TableInfo),
        }

        // Create a test table with given columns
        tableInfo := &amp;domain.TableInfo{
                Name:    "test_table",
                Schema:  name,
                Columns: columns,
        }
        mds.tables["test_table"] = tableInfo

        return mds
}</span>

func (m *mockDataSource) Connect(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockDataSource) Close(ctx context.Context) error <span class="cov8" title="1">{
        m.closed = true
        return nil
}</span>

func (m *mockDataSource) IsConnected() bool <span class="cov0" title="0">{
        return !m.closed
}</span>

func (m *mockDataSource) IsWritable() bool <span class="cov8" title="1">{
        return true
}</span>

func (m *mockDataSource) GetConfig() *domain.DataSourceConfig <span class="cov0" title="0">{
        return &amp;domain.DataSourceConfig{
                Type: domain.DataSourceTypeMemory,
                Name: "mock",
        }
}</span>

func (m *mockDataSource) CreateTable(ctx context.Context, info *domain.TableInfo) error <span class="cov8" title="1">{
        m.tables[info.Name] = info
        return nil
}</span>

func (m *mockDataSource) DropTable(ctx context.Context, name string) error <span class="cov0" title="0">{
        delete(m.tables, name)
        return nil
}</span>

func (m *mockDataSource) GetTableInfo(ctx context.Context, name string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        if info, ok := m.tables[name]; ok </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">return nil, NewError(ErrCodeTableNotFound, "table not found", nil)</span>
}

func (m *mockDataSource) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        tables := make([]string, 0, len(m.tables))
        for name := range m.tables </span><span class="cov8" title="1">{
                tables = append(tables, name)
        }</span>
        <span class="cov8" title="1">return tables, nil</span>
}

func (m *mockDataSource) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if _, ok := m.tables[tableName]; !ok </span><span class="cov0" title="0">{
                return nil, NewError(ErrCodeTableNotFound, "table not found", nil)
        }</span>
        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: []domain.ColumnInfo{},
                Rows:    []domain.Row{},
                Total:   0,
        }, nil</span>
}

func (m *mockDataSource) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if _, ok := m.tables[tableName]; !ok </span><span class="cov8" title="1">{
                return 0, NewError(ErrCodeTableNotFound, "table not found", nil)
        }</span>
        <span class="cov0" title="0">return int64(len(rows)), nil</span>
}

func (m *mockDataSource) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov0" title="0">{
        if _, ok := m.tables[tableName]; !ok </span><span class="cov0" title="0">{
                return 0, NewError(ErrCodeTableNotFound, "table not found", nil)
        }</span>
        <span class="cov0" title="0">return 1, nil</span>
}

func (m *mockDataSource) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov0" title="0">{
        if _, ok := m.tables[tableName]; !ok </span><span class="cov0" title="0">{
                return 0, NewError(ErrCodeTableNotFound, "table not found", nil)
        }</span>
        <span class="cov0" title="0">return 1, nil</span>
}

func (m *mockDataSource) TruncateTable(ctx context.Context, tableName string) error <span class="cov0" title="0">{
        if _, ok := m.tables[tableName]; !ok </span><span class="cov0" title="0">{
                return NewError(ErrCodeTableNotFound, "table not found", nil)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *mockDataSource) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return nil, NewError(ErrCodeNotSupported, "EXECUTE not supported in mock datasource", nil)
}</span>

func (m *mockDataSource) BeginTransaction(ctx context.Context, options *domain.TransactionOptions) (domain.Transaction, error) <span class="cov8" title="1">{
        m.transactions++
        return &amp;mockTransaction{ds: m, id: m.transactions}, nil
}</span>

// Mock transaction for testing
type mockTransaction struct {
        ds         *mockDataSource
        id         int
        commitErr   error
        rollbackErr error
}

func newMockTransaction() *mockTransaction <span class="cov8" title="1">{
        return &amp;mockTransaction{}
}</span>

func (m *mockTransaction) Commit(ctx context.Context) error <span class="cov8" title="1">{
        if m.commitErr != nil </span><span class="cov0" title="0">{
                return m.commitErr
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockTransaction) Rollback(ctx context.Context) error <span class="cov8" title="1">{
        if m.rollbackErr != nil </span><span class="cov0" title="0">{
                return m.rollbackErr
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockTransaction) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return &amp;domain.QueryResult{
                Columns: []domain.ColumnInfo{},
                Rows:    []domain.Row{},
                Total:   0,
        }, nil
}</span>

func (m *mockTransaction) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return &amp;domain.QueryResult{
                Columns: []domain.ColumnInfo{},
                Rows:    []domain.Row{},
                Total:   0,
        }, nil
}</span>

func (m *mockTransaction) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov0" title="0">{
        return int64(len(rows)), nil
}</span>

func (m *mockTransaction) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov0" title="0">{
        return 1, nil
}</span>

func (m *mockTransaction) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov0" title="0">{
        return 1, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "fmt"
        "strconv"
        "strings"
)

// bindParams binds parameters to SQL query placeholders
// Supports ? placeholders
func bindParams(sql string, params []interface{}) (string, error) <span class="cov8" title="1">{
        if len(params) == 0 </span><span class="cov8" title="1">{
                return sql, nil
        }</span>

        // Count placeholders
        <span class="cov8" title="1">placeholderCount := strings.Count(sql, "?")
        if placeholderCount != len(params) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("parameter count mismatch: expected %d placeholders, got %d params",
                        placeholderCount, len(params))
        }</span>

        <span class="cov8" title="1">result := make([]byte, 0, len(sql)*2)
        paramIndex := 0

        for i := 0; i &lt; len(sql); i++ </span><span class="cov8" title="1">{
                if sql[i] == '?' &amp;&amp; paramIndex &lt; len(params) </span><span class="cov8" title="1">{
                        // Convert parameter to SQL literal
                        value, err := paramToSQLLiteral(params[paramIndex])
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("error binding parameter %d: %w", paramIndex+1, err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, value...)
                        paramIndex++</span>
                } else<span class="cov8" title="1"> {
                        result = append(result, sql[i])
                }</span>
        }

        <span class="cov8" title="1">return string(result), nil</span>
}

// paramToSQLLiteral converts a Go value to SQL literal string
func paramToSQLLiteral(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return []byte("NULL"), nil
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                // Escape single quotes by doubling them
                escaped := strings.ReplaceAll(val, "'", "''")
                return []byte(fmt.Sprintf("'%s'", escaped)), nil</span>

        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", val)), nil</span>

        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return []byte(fmt.Sprintf("%d", val)), nil</span>

        case float32, float64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%v", val)), nil</span>

        case bool:<span class="cov8" title="1">
                if val </span><span class="cov8" title="1">{
                        return []byte("TRUE"), nil
                }</span>
                <span class="cov8" title="1">return []byte("FALSE"), nil</span>

        case []byte:<span class="cov8" title="1">
                // Escape hex representation
                hex := "0x" + fmt.Sprintf("%x", val)
                return []byte(hex), nil</span>

        default:<span class="cov0" title="0">
                // Try to format as string (fallback)
                str := fmt.Sprintf("%v", val)
                escaped := strings.ReplaceAll(str, "'", "''")
                return []byte(fmt.Sprintf("'%s'", escaped)), nil</span>
        }
}

// ParamToString converts a parameter to string representation
func ParamToString(v interface{}) string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return "NULL"
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return fmt.Sprintf("'%s'", strings.ReplaceAll(val, "'", "''"))</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", val)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", val)</span>
        case float32, float64:<span class="cov8" title="1">
                return fmt.Sprintf("%v", val)</span>
        case bool:<span class="cov8" title="1">
                if val </span><span class="cov8" title="1">{
                        return "TRUE"
                }</span>
                <span class="cov8" title="1">return "FALSE"</span>
        case []byte:<span class="cov8" title="1">
                return "0x" + fmt.Sprintf("%x", val)</span>
        default:<span class="cov0" title="0">
                str := fmt.Sprintf("%v", val)
                return fmt.Sprintf("'%s'", strings.ReplaceAll(str, "'", "''"))</span>
        }
}

// ParseInt parses a string to int with error handling
func ParseInt(s string) (int, error) <span class="cov0" title="0">{
        return strconv.Atoi(s)
}</span>

// ParseInt64 parses a string to int64 with error handling
func ParseInt64(s string) (int64, error) <span class="cov0" title="0">{
        return strconv.ParseInt(s, 10, 64)
}</span>

// ParseFloat parses a string to float64 with error handling
func ParseFloat(s string) (float64, error) <span class="cov0" title="0">{
        return strconv.ParseFloat(s, 64)
}</span>

// ParseBool parses a string to bool with error handling
func ParseBool(s string) (bool, error) <span class="cov0" title="0">{
        return strconv.ParseBool(s)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "fmt"
        "reflect"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Query 查询结果对象
type Query struct {
        session  *Session
        result   *domain.QueryResult
        sql      string
        params   []interface{}    // 查询参数（用于缓存键）
        rowIndex int
        closed   bool
        mu       sync.RWMutex
        err      error
}

// NewQuery 创建 Query
func NewQuery(session *Session, result *domain.QueryResult, sql string, params []interface{}) *Query <span class="cov8" title="1">{
        return &amp;Query{
                session:  session,
                result:   result,
                sql:      sql,
                params:   params,
                rowIndex: -1,
                closed:   false,
        }
}</span>

// Err returns the error that occurred during query execution
func (q *Query) Err() error <span class="cov8" title="1">{
        return q.err
}</span>

// Next 移动到下一行
func (q *Query) Next() bool <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if q.closed </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">q.rowIndex++
        return q.rowIndex &lt; len(q.result.Rows)</span>
}

// Scan 扫描当前行到变量
func (q *Query) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if q.closed </span><span class="cov8" title="1">{
                return NewError(ErrCodeClosed, "Query is closed", nil)
        }</span>

        <span class="cov8" title="1">if q.rowIndex &lt; 0 </span><span class="cov8" title="1">{
                return NewError(ErrCodeInvalidParam, "Next() must be called before Scan()", nil)
        }</span>

        <span class="cov8" title="1">if q.rowIndex &gt;= len(q.result.Rows) </span><span class="cov0" title="0">{
                return fmt.Errorf("no more rows")
        }</span>

        <span class="cov8" title="1">row := q.result.Rows[q.rowIndex]

        if len(dest) &gt; len(q.result.Columns) </span><span class="cov0" title="0">{
                return fmt.Errorf("too many destination variables (%d), have %d columns",
                        len(dest), len(q.result.Columns))
        }</span>

        // 按列顺序扫描
        <span class="cov8" title="1">for i, colInfo := range q.result.Columns </span><span class="cov8" title="1">{
                if i &gt;= len(dest) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">value, exists := row[colInfo.Name]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 反射设置值
                <span class="cov8" title="1">if err := setValue(dest[i], value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan column %s: %w", colInfo.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Row 获取当前行（map 形式）
func (q *Query) Row() domain.Row <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        if q.closed || q.rowIndex &lt; 0 || q.rowIndex &gt;= len(q.result.Rows) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // 返回行的深拷贝
        <span class="cov8" title="1">row := q.result.Rows[q.rowIndex]
        list := make(domain.Row, len(row))
        for k, v := range row </span><span class="cov8" title="1">{
                list[k] = v
        }</span>

        <span class="cov8" title="1">return list</span>
}

// RowsCount 获取总行数
func (q *Query) RowsCount() int <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        return len(q.result.Rows)
}</span>

// Columns 获取列信息
func (q *Query) Columns() []domain.ColumnInfo <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        if q.result == nil </span><span class="cov8" title="1">{
                return []domain.ColumnInfo{}
        }</span>

        <span class="cov8" title="1">cols := make([]domain.ColumnInfo, len(q.result.Columns))
        copy(cols, q.result.Columns)
        return cols</span>
}

// Close 关闭查询
func (q *Query) Close() error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if q.closed </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">q.closed = true
        q.result = nil
        return nil</span>
}

// Iter 遍历所有行（回调函数）
func (q *Query) Iter(fn func(row domain.Row) error) error <span class="cov8" title="1">{
        defer q.Close()

        for q.Next() </span><span class="cov8" title="1">{
                row := q.Row()
                if err := fn(row); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// setValue 设置值到目标变量
func setValue(dest interface{}, value interface{}) error <span class="cov8" title="1">{
        if dest == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("destination is nil")
        }</span>

        // 使用反射设置值
        <span class="cov8" title="1">destValue := reflect.ValueOf(dest)
        if destValue.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                return fmt.Errorf("destination must be a pointer")
        }</span>

        <span class="cov8" title="1">destValue = destValue.Elem()
        if !destValue.CanSet() </span><span class="cov0" title="0">{
                return fmt.Errorf("destination cannot be set")
        }</span>

        // 如果值是 nil，设置零值
        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                destValue.Set(reflect.Zero(destValue.Type()))
                return nil
        }</span>

        <span class="cov8" title="1">valValue := reflect.ValueOf(value)

        // 类型转换
        destType := destValue.Type()
        valType := valValue.Type()

        // 如果类型相同，直接赋值
        if valType == destType </span><span class="cov8" title="1">{
                destValue.Set(valValue)
                return nil
        }</span>

        // 尝试类型转换
        <span class="cov8" title="1">converted, err := convertValue(value, destType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">destValue.Set(reflect.ValueOf(converted))
        return nil</span>
}

// convertValue 转换值类型
func convertValue(value interface{}, targetType reflect.Type) (interface{}, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return reflect.Zero(targetType).Interface(), nil
        }</span>

        <span class="cov8" title="1">valueType := reflect.TypeOf(value)

        // 如果类型相同，直接返回
        if valueType == targetType </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        // 目标类型是指针，解引用并返回指针
        <span class="cov8" title="1">if targetType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                converted, err := convertValue(value, targetType.Elem())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // 创建一个新的指针值
                <span class="cov8" title="1">ptr := reflect.New(targetType.Elem())
                ptr.Elem().Set(reflect.ValueOf(converted))
                return ptr.Interface(), nil</span>
        }

        // 处理 int64 到 int 的转换
        <span class="cov8" title="1">if targetType.Kind() == reflect.Int &amp;&amp; valueType.Kind() == reflect.Int64 </span><span class="cov8" title="1">{
                return int(value.(int64)), nil
        }</span>

        // 处理 int64 到 int8/int16/int32
        <span class="cov8" title="1">switch targetType.Kind() </span>{
        case reflect.Int8:<span class="cov8" title="1">
                return int8(value.(int64)), nil</span>
        case reflect.Int16:<span class="cov8" title="1">
                return int16(value.(int64)), nil</span>
        case reflect.Int32:<span class="cov8" title="1">
                return int32(value.(int64)), nil</span>
        }

        // 处理 float64 到 float32
        <span class="cov8" title="1">if targetType.Kind() == reflect.Float32 &amp;&amp; valueType.Kind() == reflect.Float64 </span><span class="cov8" title="1">{
                return float32(value.(float64)), nil
        }</span>

        // 处理 string 到 []byte
        <span class="cov8" title="1">if targetType.Kind() == reflect.Slice &amp;&amp; targetType.Elem().Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        return []byte(str), nil
                }</span>
        }

        // 默认：直接返回
        <span class="cov0" title="0">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import "fmt"

// Result 命令执行结果
type Result struct {
        RowsAffected int64
        LastInsertID int64
        err          error
}

// NewResult 创建 Result
func NewResult(rowsAffected, lastInsertID int64, err error) *Result <span class="cov8" title="1">{
        return &amp;Result{
                RowsAffected: rowsAffected,
                LastInsertID: lastInsertID,
                err:          err,
        }
}</span>

// LastError 获取错误
func (r *Result) Err() error <span class="cov8" title="1">{
        return r.err
}</span>

// Error 实现 error 接口
func (r *Result) Error() string <span class="cov8" title="1">{
        if r.err == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Result: RowsAffected=%d, LastInsertID=%d",
                        r.RowsAffected, r.LastInsertID)
        }</span>
        <span class="cov8" title="1">return r.err.Error()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Execute executes an INSERT, UPDATE, or DELETE statement and returns number of affected rows
// Supports parameter binding with ? placeholders
// For SELECT, SHOW, DESCRIBE, and EXPLAIN statements, use Query() or Explain() method instead
func (s *Session) Execute(sql string, args ...interface{}) (*Result, error) <span class="cov8" title="1">{
        s.mu.RLock()
        if s.err != nil </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return nil, s.err
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        // Bind parameters if provided
        boundSQL := sql
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                var err error
                boundSQL, err = bindParams(sql, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, WrapError(err, ErrCodeInvalidParam, "failed to bind parameters")
                }</span>
        }

        <span class="cov8" title="1">s.logger.Debug("Execute: %s", boundSQL)

        // Parse SQL to determine statement type
        parseResult, err := s.coreSession.GetAdapter().Parse(boundSQL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapError(err, ErrCodeSyntax, "failed to parse SQL")
        }</span>

        <span class="cov8" title="1">if !parseResult.Success </span><span class="cov0" title="0">{
                return nil, NewError(ErrCodeSyntax, "SQL parse error: "+parseResult.Error, nil)
        }</span>

        // Check for read-only information_schema operations (check both SQL string and parsed statement)
        <span class="cov8" title="1">if s.isInformationSchemaOperation(boundSQL, parseResult.Statement) </span><span class="cov8" title="1">{
                s.logger.Debug("Blocking information_schema DML operation")
                return nil, NewError(ErrCodeInternal, "information_schema is read-only: DML operations are not supported", nil)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        var result *domain.QueryResult

        switch parseResult.Statement.Type </span>{
        case parser.SQLTypeInsert:<span class="cov8" title="1">
                result, err = s.coreSession.ExecuteInsert(ctx, boundSQL, nil)</span>
        case parser.SQLTypeUpdate:<span class="cov0" title="0">
                result, err = s.coreSession.ExecuteUpdate(ctx, boundSQL, nil, nil)</span>
        case parser.SQLTypeDelete:<span class="cov0" title="0">
                result, err = s.coreSession.ExecuteDelete(ctx, boundSQL, nil)</span>
        case parser.SQLTypeCreate:<span class="cov8" title="1">
                // 优先处理 CREATE INDEX
                if parseResult.Statement.CreateIndex != nil </span><span class="cov8" title="1">{
                        result, err = s.coreSession.ExecuteCreateIndex(ctx, boundSQL)
                }</span> else<span class="cov8" title="1"> {
                        result, err = s.coreSession.ExecuteCreate(ctx, boundSQL)
                }</span>
        case parser.SQLTypeDrop:<span class="cov8" title="1">
                // 优先处理 DROP INDEX
                if parseResult.Statement.DropIndex != nil </span><span class="cov8" title="1">{
                        result, err = s.coreSession.ExecuteDropIndex(ctx, boundSQL)
                }</span> else<span class="cov8" title="1"> {
                        result, err = s.coreSession.ExecuteDrop(ctx, boundSQL)
                }</span>
        case parser.SQLTypeAlter:<span class="cov0" title="0">
                result, err = s.coreSession.ExecuteAlter(ctx, boundSQL)</span>
        case parser.SQLTypeUse:<span class="cov0" title="0">
                result, err = s.coreSession.ExecuteQuery(ctx, boundSQL)</span>
        case parser.SQLTypeSelect, parser.SQLTypeShow, parser.SQLTypeDescribe, parser.SQLTypeExplain:<span class="cov8" title="1">
                return nil, NewError(ErrCodeInvalidParam, fmt.Sprintf("use Query() method for %s statements (or Explain() for EXPLAIN)", parseResult.Statement.Type), nil)</span>
        default:<span class="cov0" title="0">
                return nil, NewError(ErrCodeNotSupported, fmt.Sprintf("unsupported statement type: %v", parseResult.Statement.Type), nil)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, WrapError(err, ErrCodeInternal, "failed to execute statement")
        }</span>

        // Clear cache for affected table
        <span class="cov8" title="1">if s.cacheEnabled </span><span class="cov8" title="1">{
                var tableName string
                switch parseResult.Statement.Type </span>{
                case parser.SQLTypeInsert:<span class="cov8" title="1">
                        tableName = parseResult.Statement.Insert.Table</span>
                case parser.SQLTypeUpdate:<span class="cov0" title="0">
                        tableName = parseResult.Statement.Update.Table</span>
                case parser.SQLTypeDelete:<span class="cov0" title="0">
                        tableName = parseResult.Statement.Delete.Table</span>
                case parser.SQLTypeCreate:<span class="cov8" title="1">
                        if parseResult.Statement.CreateIndex != nil </span><span class="cov8" title="1">{
                                tableName = parseResult.Statement.CreateIndex.TableName
                        }</span> else<span class="cov8" title="1"> {
                                tableName = parseResult.Statement.Create.Name
                        }</span>
                case parser.SQLTypeDrop:<span class="cov8" title="1">
                        if parseResult.Statement.DropIndex != nil </span><span class="cov8" title="1">{
                                tableName = parseResult.Statement.DropIndex.TableName
                        }</span> else<span class="cov8" title="1"> {
                                tableName = parseResult.Statement.Drop.Name
                        }</span>
                }
                <span class="cov8" title="1">if tableName != "" </span><span class="cov8" title="1">{
                        s.db.cache.ClearTable(tableName)
                }</span>
        }

        <span class="cov8" title="1">return NewResult(result.Total, 0, nil), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "context"
)

// GetDB returns DB object that created this session
func (s *Session) GetDB() *DB <span class="cov8" title="1">{
        return s.db
}</span>

// Close closes the session and releases resources
// Temporary tables created in this session are automatically dropped
func (s *Session) Close() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.coreSession == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        core := s.coreSession

        // Rollback any active transaction
        if core.InTx() </span><span class="cov8" title="1">{
                s.logger.Warn("Rolling back uncommitted transaction")
                if err := core.RollbackTx(ctx); err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to rollback transaction: %v", err)
                }</span>
        }

        // Drop temporary tables
        <span class="cov8" title="1">tempTables := core.GetTempTables()
        ds := core.GetDataSource()
        for _, tableName := range tempTables </span><span class="cov0" title="0">{
                if err := ds.DropTable(ctx, tableName); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to drop temporary table '%s': %v", tableName, err)
                }</span>
        }

        // Close core session
        <span class="cov8" title="1">if err := core.Close(ctx); err != nil </span><span class="cov0" title="0">{
                return WrapError(err, ErrCodeInternal, "failed to close session")
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Session closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/optimizer"
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// SelectStmt interface for accessing Select statement
type SelectStmt interface {
        GetFrom() string
}

// Query executes a SELECT, SHOW, or DESCRIBE query and returns a Query object for iterating through results
// Supports parameter binding with ? placeholders
// Example: session.Query("SELECT * FROM users WHERE id = ?", 1)
func (s *Session) Query(sql string, args ...interface{}) (*Query, error) <span class="cov8" title="1">{
        s.mu.RLock()
        if s.err != nil </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return nil, s.err
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        // Bind parameters if provided
        boundSQL := sql
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                boundSQL, err = bindParams(sql, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, WrapError(err, ErrCodeInvalidParam, "failed to bind parameters")
                }</span>
        }

        <span class="cov8" title="1">s.logger.Debug("Query: %s", boundSQL)

        // Check cache if enabled
        if s.cacheEnabled </span><span class="cov8" title="1">{
                if result, found := s.db.cache.Get(boundSQL, nil); found </span><span class="cov0" title="0">{
                        s.logger.Debug("Cache hit for query")
                        return NewQuery(s, result, boundSQL, nil), nil
                }</span>
        }

        // Parse and execute query
        <span class="cov8" title="1">ctx := context.Background()

        result, err := s.coreSession.ExecuteQuery(ctx, boundSQL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapError(err, ErrCodeSyntax, "failed to execute query")
        }</span>

        // Cache result (with bound SQL, not original)
        <span class="cov8" title="1">if s.cacheEnabled </span><span class="cov8" title="1">{
                s.db.cache.Set(boundSQL, nil, result)
        }</span>

        <span class="cov8" title="1">return NewQuery(s, result, boundSQL, nil), nil</span>
}

// QueryAll executes a query and returns all rows at once
// Supports parameter binding with ? placeholders
func (s *Session) QueryAll(sql string, args ...interface{}) ([]domain.Row, error) <span class="cov8" title="1">{
        query, err := s.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer query.Close()

        var rows []domain.Row
        for query.Next() </span><span class="cov8" title="1">{
                rows = append(rows, query.Row())
        }</span>

        <span class="cov8" title="1">if query.Err() != nil </span><span class="cov0" title="0">{
                return nil, query.Err()
        }</span>

        <span class="cov8" title="1">return rows, nil</span>
}

// QueryOne executes a query and returns first row only
// Supports parameter binding with ? placeholders
func (s *Session) QueryOne(sql string, args ...interface{}) (domain.Row, error) <span class="cov8" title="1">{
        query, err := s.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer query.Close()

        if !query.Next() </span><span class="cov0" title="0">{
                return nil, NewError(ErrCodeInternal, "no rows found", nil)
        }</span>

        <span class="cov0" title="0">return query.Row(), nil</span>
}

// Explain executes an EXPLAIN statement and returns execution plan
// Supports parameter binding with ? placeholders
// Example: session.Explain("SELECT * FROM users WHERE id = ?", 1)
// This uses actual optimizer to generate execution plans
func (s *Session) Explain(sql string, args ...interface{}) (string, error) <span class="cov8" title="1">{
        s.mu.RLock()
        if s.err != nil </span><span class="cov0" title="0">{
                s.mu.RUnlock()
                return "", s.err
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        // Bind parameters if provided
        boundSQL := sql
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                var err error
                boundSQL, err = bindParams(sql, args)
                if err != nil </span><span class="cov0" title="0">{
                        return "", WrapError(err, ErrCodeInvalidParam, "failed to bind parameters")
                }</span>
        }

        <span class="cov8" title="1">s.logger.Debug("Explain: %s", boundSQL)

        // Parse SQL
        parseResult, err := s.coreSession.GetAdapter().Parse(boundSQL)
        if err != nil </span><span class="cov8" title="1">{
                return "", WrapError(err, ErrCodeSyntax, "failed to parse SQL")
        }</span>

        <span class="cov8" title="1">if !parseResult.Success </span><span class="cov0" title="0">{
                return "", NewError(ErrCodeSyntax, "SQL parse error: "+parseResult.Error, nil)
        }</span>

        // Explain only works with SELECT statements
        <span class="cov8" title="1">if parseResult.Statement.Type != parser.SQLTypeSelect || parseResult.Statement.Select == nil </span><span class="cov8" title="1">{
                return "", NewError(ErrCodeSyntax, "EXPLAIN only supports SELECT statements", nil)
        }</span>

        // Check cache if enabled
        <span class="cov8" title="1">cacheKey := "EXPLAIN " + boundSQL
        if s.cacheEnabled </span><span class="cov8" title="1">{
                if explain, found := s.db.cache.GetExplain(cacheKey); found </span><span class="cov8" title="1">{
                        s.logger.Debug("Cache hit for explain")
                        return explain, nil
                }</span>
        }

        // Get optimizer from executor
        <span class="cov8" title="1">executor := s.coreSession.GetExecutor()
        if executor == nil </span><span class="cov0" title="0">{
                return "", NewError(ErrCodeInternal, "executor not available", nil)
        }</span>

        <span class="cov8" title="1">optimizerIntf := executor.GetOptimizer()
        if optimizerIntf == nil </span><span class="cov0" title="0">{
                return "", NewError(ErrCodeInternal, "optimizer not available", nil)
        }</span>

        // Type assert to *optimizer.Optimizer
        <span class="cov8" title="1">opt, ok := optimizerIntf.(*optimizer.Optimizer)
        if !ok </span><span class="cov0" title="0">{
                return "", NewError(ErrCodeInternal, "optimizer type assertion failed", nil)
        }</span>

        // Build SQLStatement for optimizer
        <span class="cov8" title="1">sqlStmt := &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: parseResult.Statement.Select,
        }

        // Optimize to get physical plan
        ctx := context.Background()
        physicalPlan, err := opt.Optimize(ctx, sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                return "", WrapError(err, ErrCodeInternal, "failed to generate execution plan")
        }</span>

        <span class="cov8" title="1">if physicalPlan == nil </span><span class="cov0" title="0">{
                return "", NewError(ErrCodeInternal, "generated physical plan is nil", nil)
        }</span>

        // Generate execution plan using ExplainPlan
        <span class="cov8" title="1">output := "Query Execution Plan\n====================\n\n"
        output += fmt.Sprintf("SQL: %s\n\n", boundSQL)
        output += optimizer.ExplainPlan(physicalPlan)

        // Cache explain result
        if s.cacheEnabled </span><span class="cov8" title="1">{
                s.db.cache.SetExplain(cacheKey, output)
        }</span>

        <span class="cov8" title="1">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// CreateTempTable creates a temporary table in this session
// Temporary tables are automatically dropped when session is closed
func (s *Session) CreateTempTable(name string, schema *domain.TableInfo) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return NewError(ErrCodeInvalidParam, "table name cannot be empty", nil)
        }</span>
        <span class="cov8" title="1">if schema == nil </span><span class="cov8" title="1">{
                return NewError(ErrCodeInvalidParam, "table schema cannot be nil", nil)
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        defer s.mu.Unlock()

        if s.err != nil </span><span class="cov8" title="1">{
                return s.err
        }</span>

        <span class="cov8" title="1">schema.Temporary = true
        schema.Name = name

        ds := s.coreSession.GetDataSource()
        if err := ds.CreateTable(context.Background(), schema); err != nil </span><span class="cov0" title="0">{
                return WrapError(err, ErrCodeInternal, "failed to create temporary table")
        }</span>

        <span class="cov8" title="1">s.coreSession.AddTempTable(name)
        s.logger.Debug("Created temporary table: %s", name)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "context"
)

// Begin starts a new transaction
// If already in a transaction, returns an error (no nesting allowed)
func (s *Session) Begin() (*Transaction, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.err != nil </span><span class="cov8" title="1">{
                return nil, s.err
        }</span>

        // Check if already in transaction
        <span class="cov8" title="1">if s.coreSession.InTx() </span><span class="cov8" title="1">{
                return nil, NewError(ErrCodeTransaction, "nested transactions are not supported", nil)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        tx, err := s.coreSession.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(err, ErrCodeTransaction, "failed to begin transaction")
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Transaction started")

        transaction := &amp;Transaction{
                session: s,
                tx:      tx,
                active:  true,
        }

        return transaction, nil</span>
}

// InTransaction returns true if session is currently in a transaction
func (s *Session) InTransaction() bool <span class="cov8" title="1">{
        return s.coreSession.InTx()
}</span>

// IsolationLevel returns current transaction isolation level
func (s *Session) IsolationLevel() IsolationLevel <span class="cov8" title="1">{
        if s.options == nil </span><span class="cov0" title="0">{
                return IsolationRepeatableRead
        }</span>
        <span class="cov8" title="1">return s.options.Isolation</span>
}

// SetIsolationLevel sets transaction isolation level for new transactions
func (s *Session) SetIsolationLevel(level IsolationLevel) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.options == nil </span><span class="cov0" title="0">{
                s.options = &amp;SessionOptions{}
        }</span>
        <span class="cov8" title="1">s.options.Isolation = level

        s.logger.Debug("Isolation level set to: %s", level.String())</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/session"
)

// IsolationLevel represents transaction isolation level
type IsolationLevel int

const (
        IsolationReadUncommitted IsolationLevel = iota
        IsolationReadCommitted
        IsolationRepeatableRead
        IsolationSerializable
)

func (l IsolationLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case IsolationReadUncommitted:<span class="cov8" title="1">
                return "READ UNCOMMITTED"</span>
        case IsolationReadCommitted:<span class="cov8" title="1">
                return "READ COMMITTED"</span>
        case IsolationRepeatableRead:<span class="cov8" title="1">
                return "REPEATABLE READ"</span>
        case IsolationSerializable:<span class="cov8" title="1">
                return "SERIALIZABLE"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// SessionOptions contains configuration options for creating a session
type SessionOptions struct {
        DataSourceName string
        Isolation      IsolationLevel
        ReadOnly       bool
        CacheEnabled   bool
}

// Session represents a database session (like a MySQL connection)
// It is concurrent safe and can be used across multiple goroutines
type Session struct {
        db          *DB
        coreSession *session.CoreSession
        options     *SessionOptions
        cacheEnabled bool
        logger      Logger
        mu          sync.RWMutex
        err         error // Error state if session creation failed
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// isInformationSchemaOperation checks if SQL is trying to modify information_schema
func (s *Session) isInformationSchemaOperation(sql string, stmt *parser.SQLStatement) bool <span class="cov8" title="1">{
        // First check if SQL directly mentions information_schema
        if strings.Contains(strings.ToLower(sql), "information_schema") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Also check parsed statement
        <span class="cov8" title="1">switch stmt.Type </span>{
        case parser.SQLTypeInsert:<span class="cov8" title="1">
                return isInformationSchemaTable(stmt.Insert.Table)</span>
        case parser.SQLTypeUpdate:<span class="cov0" title="0">
                return isInformationSchemaTable(stmt.Update.Table)</span>
        case parser.SQLTypeDelete:<span class="cov0" title="0">
                return isInformationSchemaTable(stmt.Delete.Table)</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isInformationSchemaTable checks if a table name references information_schema
func isInformationSchemaTable(tableName string) bool <span class="cov8" title="1">{
        if strings.Contains(tableName, ".") </span><span class="cov0" title="0">{
                parts := strings.SplitN(tableName, ".", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "information_schema" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "context"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Transaction 事务对象（不支持嵌套）
type Transaction struct {
        session *Session
        tx      domain.Transaction
        active  bool
        mu      sync.Mutex
}

// NewTransaction 创建 Transaction
func NewTransaction(session *Session, tx domain.Transaction) *Transaction <span class="cov8" title="1">{
        return &amp;Transaction{
                session: session,
                tx:      tx,
                active:  true,
        }
}</span>

// Query 事务内查询
// Supports parameter binding with ? placeholders
func (t *Transaction) Query(sql string, args ...interface{}) (*Query, error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.active </span><span class="cov8" title="1">{
                return nil, NewError(ErrCodeTransaction, "transaction is not active", nil)
        }</span>

        // Bind parameters if provided
        <span class="cov8" title="1">boundSQL := sql
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                boundSQL, err = bindParams(sql, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, WrapError(err, ErrCodeInvalidParam, "failed to bind parameters")
                }</span>
        }

        // 使用事务执行查询
        // TODO: Parse SQL to get table name
        <span class="cov8" title="1">result, err := t.tx.Query(context.Background(), "SELECT", &amp;domain.QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(err, ErrCodeTransaction, "transaction query failed")
        }</span>

        <span class="cov8" title="1">return NewQuery(t.session, result, boundSQL, nil), nil</span>
}

// Execute 事务内执行命令
// Supports parameter binding with ? placeholders
func (t *Transaction) Execute(sql string, args ...interface{}) (*Result, error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.active </span><span class="cov8" title="1">{
                return nil, NewError(ErrCodeTransaction, "transaction is not active", nil)
        }</span>

        // Bind parameters if provided
        <span class="cov8" title="1">boundSQL := sql
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                boundSQL, err = bindParams(sql, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, WrapError(err, ErrCodeInvalidParam, "failed to bind parameters")
                }</span>
        }

        // 解析 SQL 确定操作类型
        // 简化实现：假设用户直接调用 DataSource 的方法
        // 实际实现需要解析 SQL 并调用相应的方法

        // TODO: 解析 boundSQL 并执行
        // 这里需要完善：解析 SQL -&gt; 调用 Insert/Update/Delete 方法
        // 临时返回错误
        <span class="cov8" title="1">_ = boundSQL // Use boundSQL to avoid "declared and not used" error
        return nil, NewError(ErrCodeNotSupported, "transaction.Execute not fully implemented yet", nil)</span>
}

// Commit 提交事务
func (t *Transaction) Commit() error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.active </span><span class="cov8" title="1">{
                return NewError(ErrCodeTransaction, "transaction is not active", nil)
        }</span>

        <span class="cov8" title="1">err := t.tx.Commit(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return WrapError(err, ErrCodeTransaction, "commit failed")
        }</span>

        <span class="cov8" title="1">t.active = false

        if t.session.logger != nil </span><span class="cov8" title="1">{
                t.session.logger.Debug("[TX] Transaction committed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Rollback 回滚事务
func (t *Transaction) Rollback() error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.active </span><span class="cov8" title="1">{
                return NewError(ErrCodeTransaction, "transaction is not active", nil)
        }</span>

        <span class="cov8" title="1">err := t.tx.Rollback(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return WrapError(err, ErrCodeTransaction, "rollback failed")
        }</span>

        <span class="cov8" title="1">t.active = false

        if t.session.logger != nil </span><span class="cov8" title="1">{
                t.session.logger.Warn("[TX] Transaction rolled back")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close 关闭事务（等同于 Rollback）
func (t *Transaction) Close() error <span class="cov8" title="1">{
        if t.active </span><span class="cov8" title="1">{
                return t.Rollback()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsActive 检查事务是否活跃
func (t *Transaction) IsActive() bool <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.active
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package builtin

import (
        "math"
)

// AggregateContext 聚合函数上下文
type AggregateContext struct {
        Count   int64
        Sum     float64
        Min     interface{}
        Max     interface{}
        AvgSum  float64
        Values  []float64 // 用于标准差等
}

// NewAggregateContext 创建聚合上下文
func NewAggregateContext() *AggregateContext <span class="cov8" title="1">{
        return &amp;AggregateContext{
                Values: make([]float64, 0),
        }
}</span>

// AggregateHandle 聚合函数处理函数
type AggregateHandle func(ctx *AggregateContext, args []interface{}) error

// AggregateResult 聚合结果函数
type AggregateResult func(ctx *AggregateContext) (interface{}, error)

// AggregateFunctionInfo 聚合函数信息
type AggregateFunctionInfo struct {
        Name        string
        Handler     AggregateHandle
        Result      AggregateResult
        Description string
        Example     string
        Category    string
}

func init() {<span class="cov8" title="1">
        // 聚合函数列表（将在initAggregateFunctions中注册）
}</span>

// InitAggregateFunctions 初始化聚合函数
func InitAggregateFunctions() <span class="cov8" title="1">{
        aggregateFunctions := []*AggregateFunctionInfo{
                {
                        Name:        "count",
                        Handler:     aggCount,
                        Result:      aggCountResult,
                        Description: "计算行数",
                        Example:     "COUNT(*) -&gt; 100",
                        Category:    "aggregate",
                },
                {
                        Name:        "sum",
                        Handler:     aggSum,
                        Result:      aggSumResult,
                        Description: "计算和",
                        Example:     "SUM(price) -&gt; 1000.50",
                        Category:    "aggregate",
                },
                {
                        Name:        "avg",
                        Handler:     aggAvg,
                        Result:      aggAvgResult,
                        Description: "计算平均值",
                        Example:     "AVG(price) -&gt; 100.05",
                        Category:    "aggregate",
                },
                {
                        Name:        "min",
                        Handler:     aggMin,
                        Result:      aggMinResult,
                        Description: "计算最小值",
                        Example:     "MIN(price) -&gt; 10.00",
                        Category:    "aggregate",
                },
                {
                        Name:        "max",
                        Handler:     aggMax,
                        Result:      aggMaxResult,
                        Description: "计算最大值",
                        Example:     "MAX(price) -&gt; 1000.00",
                        Category:    "aggregate",
                },
                {
                        Name:        "stddev",
                        Handler:     aggStdDev,
                        Result:      aggStdDevResult,
                        Description: "计算标准差",
                        Example:     "STDDEV(price) -&gt; 50.25",
                        Category:    "aggregate",
                },
                {
                        Name:        "variance",
                        Handler:     aggVariance,
                        Result:      aggVarianceResult,
                        Description: "计算方差",
                        Example:     "VARIANCE(price) -&gt; 2525.06",
                        Category:    "aggregate",
                },
        }

        for _, fn := range aggregateFunctions </span><span class="cov8" title="1">{
                RegisterAggregate(fn)
        }</span>
}

// AggregateRegistry 聚合函数注册表
var aggregateRegistry = make(map[string]*AggregateFunctionInfo)

// RegisterAggregate 注册聚合函数
func RegisterAggregate(info *AggregateFunctionInfo) <span class="cov8" title="1">{
        aggregateRegistry[info.Name] = info
}</span>

// GetAggregate 获取聚合函数
func GetAggregate(name string) (*AggregateFunctionInfo, bool) <span class="cov8" title="1">{
        info, exists := aggregateRegistry[name]
        return info, exists
}</span>

// 辅助函数：比较两个值
func compareValues(a, b interface{}) int <span class="cov8" title="1">{
        aFloat, aErr := toFloat64(a)
        bFloat, bErr := toFloat64(b)
        
        if aErr == nil &amp;&amp; bErr == nil </span><span class="cov8" title="1">{
                if aFloat &lt; bFloat </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aFloat &gt; bFloat </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }
        
        <span class="cov8" title="1">aStr, aStrOk := a.(string)
        bStr, bStrOk := b.(string)
        if aStrOk &amp;&amp; bStrOk </span><span class="cov8" title="1">{
                if aStr &lt; bStr </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aStr &gt; bStr </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }
        
        <span class="cov0" title="0">return 0</span>
}

// 聚合函数实现
func aggCount(ctx *AggregateContext, args []interface{}) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                // COUNT(*)
                ctx.Count++
                return nil
        }</span>
        
        // COUNT(column) - 忽略NULL
        <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                if arg != nil </span><span class="cov8" title="1">{
                        ctx.Count++
                        break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func aggCountResult(ctx *AggregateContext) (interface{}, error) <span class="cov0" title="0">{
        return ctx.Count, nil
}</span>

func aggSum(ctx *AggregateContext, args []interface{}) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                if arg != nil </span><span class="cov8" title="1">{
                        val, err := toFloat64(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">ctx.Sum += val</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func aggSumResult(ctx *AggregateContext) (interface{}, error) <span class="cov0" title="0">{
        return ctx.Sum, nil
}</span>

func aggAvg(ctx *AggregateContext, args []interface{}) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                if arg != nil </span><span class="cov8" title="1">{
                        val, err := toFloat64(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">ctx.AvgSum += val
                        ctx.Count++</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func aggAvgResult(ctx *AggregateContext) (interface{}, error) <span class="cov8" title="1">{
        if ctx.Count == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return ctx.AvgSum / float64(ctx.Count), nil</span>
}

func aggMin(ctx *AggregateContext, args []interface{}) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                if arg == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if ctx.Min == nil </span><span class="cov8" title="1">{
                        ctx.Min = arg
                }</span> else<span class="cov8" title="1"> if compareValues(arg, ctx.Min) &lt; 0 </span><span class="cov8" title="1">{
                        ctx.Min = arg
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func aggMinResult(ctx *AggregateContext) (interface{}, error) <span class="cov8" title="1">{
        return ctx.Min, nil
}</span>

func aggMax(ctx *AggregateContext, args []interface{}) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                if arg == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if ctx.Max == nil </span><span class="cov8" title="1">{
                        ctx.Max = arg
                }</span> else<span class="cov8" title="1"> if compareValues(arg, ctx.Max) &gt; 0 </span><span class="cov8" title="1">{
                        ctx.Max = arg
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func aggMaxResult(ctx *AggregateContext) (interface{}, error) <span class="cov8" title="1">{
        return ctx.Max, nil
}</span>

func aggStdDev(ctx *AggregateContext, args []interface{}) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">for _, arg := range args </span><span class="cov0" title="0">{
                if arg != nil </span><span class="cov0" title="0">{
                        val, err := toFloat64(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">ctx.Values = append(ctx.Values, val)
                        ctx.AvgSum += val</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func aggStdDevResult(ctx *AggregateContext) (interface{}, error) <span class="cov0" title="0">{
        if len(ctx.Values) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        <span class="cov0" title="0">mean := ctx.AvgSum / float64(len(ctx.Values))
        sumSquares := 0.0
        
        for _, val := range ctx.Values </span><span class="cov0" title="0">{
                diff := val - mean
                sumSquares += diff * diff
        }</span>
        
        <span class="cov0" title="0">variance := sumSquares / float64(len(ctx.Values))
        return math.Sqrt(variance), nil</span>
}

func aggVariance(ctx *AggregateContext, args []interface{}) error <span class="cov0" title="0">{
        return aggStdDev(ctx, args)
}</span>

func aggVarianceResult(ctx *AggregateContext) (interface{}, error) <span class="cov0" title="0">{
        if len(ctx.Values) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        <span class="cov0" title="0">mean := ctx.AvgSum / float64(len(ctx.Values))
        sumSquares := 0.0
        
        for _, val := range ctx.Values </span><span class="cov0" title="0">{
                diff := val - mean
                sumSquares += diff * diff
        }</span>
        
        <span class="cov0" title="0">variance := sumSquares / float64(len(ctx.Values))
        return variance, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package builtin

import (
        "encoding/json"
        "fmt"
)

// FunctionAPI 函数注册表API
type FunctionAPI struct {
        registry *FunctionRegistryExt
}

// NewFunctionAPI 创建函数API
func NewFunctionAPI() *FunctionAPI <span class="cov0" title="0">{
        return &amp;FunctionAPI{
                registry: NewFunctionRegistryExt(),
        }
}</span>

// GetRegistry 获取底层注册表
func (api *FunctionAPI) GetRegistry() *FunctionRegistryExt <span class="cov0" title="0">{
        return api.registry
}</span>

// ============ 函数注册 API ============

// RegisterFunction 注册函数（通用接口）
func (api *FunctionAPI) RegisterFunction(fn FunctionRegisterFunc) error <span class="cov0" title="0">{
        meta, err := fn()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function registration failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">if meta.Type == FunctionTypeAggregate </span><span class="cov0" title="0">{
                return api.registry.RegisterAggregate(meta)
        }</span>
        <span class="cov0" title="0">return api.registry.RegisterScalar(meta)</span>
}

// RegisterScalarFunction 注册标量函数
func (api *FunctionAPI) RegisterScalarFunction(name, displayName, description string,
        handler FunctionHandle, options ...FunctionOption) error <span class="cov0" title="0">{
        
        meta := &amp;FunctionMetadata{
                Name:        name,
                DisplayName:  displayName,
                Type:        FunctionTypeScalar,
                Scope:       ScopeGlobal,
                Handler:     handler,
                Description:  description,
                Parameters:  []FunctionParam{},
                Examples:     []string{},
                Tags:         []string{},
        }
        
        // 应用选项
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(meta)
        }</span>
        
        <span class="cov0" title="0">return api.registry.RegisterScalar(meta)</span>
}

// RegisterAggregateFunction 注册聚合函数
func (api *FunctionAPI) RegisterAggregateFunction(name, displayName, description string,
        handler AggregateHandle, result AggregateResult, options ...FunctionOption) error <span class="cov0" title="0">{
        
        meta := &amp;FunctionMetadata{
                Name:             name,
                DisplayName:       displayName,
                Type:             FunctionTypeAggregate,
                Scope:            ScopeGlobal,
                AggregateHandler:  handler,
                AggregateResult:    result,
                Description:       description,
                Parameters:       []FunctionParam{},
                Examples:          []string{},
                Tags:             []string{},
        }
        
        // 应用选项
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(meta)
        }</span>
        
        <span class="cov0" title="0">return api.registry.RegisterAggregate(meta)</span>
}

// RegisterUserFunction 注册用户自定义函数
func (api *FunctionAPI) RegisterUserFunction(name, displayName, description string,
        handler FunctionHandle, options ...FunctionOption) error <span class="cov0" title="0">{
        
        meta := &amp;FunctionMetadata{
                Name:        name,
                DisplayName:  displayName,
                Type:        FunctionTypeScalar,
                Scope:       ScopeUser,
                Handler:     handler,
                Description:  description,
                Parameters:  []FunctionParam{},
                Examples:     []string{},
                Tags:         []string{},
        }
        
        // 应用选项
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(meta)
        }</span>
        
        <span class="cov0" title="0">return api.registry.RegisterUserFunction(meta)</span>
}

// ============ 函数查询 API ============

// GetFunction 获取函数
func (api *FunctionAPI) GetFunction(name string) (*FunctionMetadata, error) <span class="cov0" title="0">{
        meta, ok := api.registry.Get(name)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s not found", name)
        }</span>
        <span class="cov0" title="0">return meta, nil</span>
}

// ListFunctions 列出所有函数
func (api *FunctionAPI) ListFunctions() []*FunctionMetadata <span class="cov0" title="0">{
        return api.registry.List()
}</span>

// ListFunctionsByCategory 按类别列出函数
func (api *FunctionAPI) ListFunctionsByCategory(category FunctionCategory) []*FunctionMetadata <span class="cov0" title="0">{
        return api.registry.ListByCategory(category)
}</span>

// ListFunctionsByType 按类型列出函数
func (api *FunctionAPI) ListFunctionsByType(fnType FunctionType) []*FunctionMetadata <span class="cov0" title="0">{
        return api.registry.ListByType(fnType)
}</span>

// SearchFunctions 搜索函数
func (api *FunctionAPI) SearchFunctions(keyword string) []*FunctionMetadata <span class="cov0" title="0">{
        return api.registry.Search(keyword)
}</span>

// ============ 函数统计 API ============

// CountFunctions 统计函数总数
func (api *FunctionAPI) CountFunctions() int <span class="cov0" title="0">{
        return api.registry.Count()
}</span>

// CountFunctionsByCategory 按类别统计
func (api *FunctionAPI) CountFunctionsByCategory(category FunctionCategory) int <span class="cov0" title="0">{
        return api.registry.CountByCategory(category)
}</span>

// ============ 函数管理 API ============

// UnregisterFunction 注销函数
func (api *FunctionAPI) UnregisterFunction(name string) error <span class="cov0" title="0">{
        if !api.registry.Unregister(name) </span><span class="cov0" title="0">{
                return fmt.Errorf("function %s not found", name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ClearUserFunctions 清除用户函数
func (api *FunctionAPI) ClearUserFunctions() <span class="cov0" title="0">{
        api.registry.ClearUserFunctions()
}</span>

// ClearSessionFunctions 清除会话函数
func (api *FunctionAPI) ClearSessionFunctions() <span class="cov0" title="0">{
        api.registry.ClearSessionFunctions()
}</span>

// ============ 别名管理 API ============

// AddFunctionAlias 添加函数别名
func (api *FunctionAPI) AddFunctionAlias(alias, name string) error <span class="cov0" title="0">{
        return api.registry.AddAlias(alias, name)
}</span>

// RemoveFunctionAlias 删除别名
func (api *FunctionAPI) RemoveFunctionAlias(alias string) <span class="cov0" title="0">{
        api.registry.RemoveAlias(alias)
}</span>

// GetFunctionAliases 获取所有别名
func (api *FunctionAPI) GetFunctionAliases() map[string]string <span class="cov0" title="0">{
        return api.registry.GetAliases()
}</span>

// ============ 文档 API ============

// GenerateDocumentation 生成函数文档
func (api *FunctionAPI) GenerateDocumentation() string <span class="cov0" title="0">{
        docs := "# 内置函数文档\n\n"
        
        // 按类别分组
        categories := []FunctionCategory{
                CategoryMath,
                CategoryString,
                CategoryDate,
                CategoryAggregate,
                CategoryControl,
                CategoryJSON,
                CategorySystem,
        }
        
        for _, category := range categories </span><span class="cov0" title="0">{
                functions := api.registry.ListByCategory(category)
                if len(functions) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">docs += fmt.Sprintf("## %s\n\n", string(category))
                
                for _, fn := range functions </span><span class="cov0" title="0">{
                        docs += api.generateFunctionDoc(fn)
                }</span>
        }
        
        <span class="cov0" title="0">return docs</span>
}

// GenerateJSON 生成JSON格式文档
func (api *FunctionAPI) GenerateJSON() (string, error) <span class="cov0" title="0">{
        functions := api.registry.List()
        
        data := map[string]interface{}{
                "functions": functions,
                "count":     len(functions),
                "categories": api.getCategoryStats(),
        }
        
        jsonBytes, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return string(jsonBytes), nil</span>
}

// generateFunctionDoc 生成单个函数文档
func (api *FunctionAPI) generateFunctionDoc(meta *FunctionMetadata) string <span class="cov0" title="0">{
        docs := fmt.Sprintf("### %s\n\n", meta.DisplayName)
        
        if meta.Description != "" </span><span class="cov0" title="0">{
                docs += fmt.Sprintf("**描述**: %s\n\n", meta.Description)
        }</span>
        
        <span class="cov0" title="0">docs += fmt.Sprintf("**类型**: %s\n\n", api.getTypeName(meta.Type))
        docs += fmt.Sprintf("**作用域**: %s\n\n", string(meta.Scope))
        docs += fmt.Sprintf("**类别**: %s\n\n", string(meta.Category))
        
        // 参数
        if len(meta.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                docs += "**参数**:\n\n"
                for i, param := range meta.Parameters </span><span class="cov0" title="0">{
                        required := "可选"
                        if param.Required </span><span class="cov0" title="0">{
                                required = "必需"
                        }</span>
                        <span class="cov0" title="0">docs += fmt.Sprintf("%d. `%s` (%s) - %s [%s]\n", 
                                i+1, param.Name, param.Type, param.Description, required)</span>
                }
                <span class="cov0" title="0">docs += "\n"</span>
        }
        
        // 示例
        <span class="cov0" title="0">if len(meta.Examples) &gt; 0 </span><span class="cov0" title="0">{
                docs += "**示例**:\n\n"
                for _, example := range meta.Examples </span><span class="cov0" title="0">{
                        docs += fmt.Sprintf("```sql\n%s\n```\n\n", example)
                }</span>
        }
        
        // 返回类型
        <span class="cov0" title="0">if meta.ReturnType != "" </span><span class="cov0" title="0">{
                docs += fmt.Sprintf("**返回类型**: %s\n\n", meta.ReturnType)
        }</span>
        
        <span class="cov0" title="0">docs += "---\n\n"
        return docs</span>
}

// getTypeName 获取类型名称
func (api *FunctionAPI) getTypeName(fnType FunctionType) string <span class="cov0" title="0">{
        switch fnType </span>{
        case FunctionTypeScalar:<span class="cov0" title="0">
                return "标量函数"</span>
        case FunctionTypeAggregate:<span class="cov0" title="0">
                return "聚合函数"</span>
        case FunctionTypeWindow:<span class="cov0" title="0">
                return "窗口函数"</span>
        default:<span class="cov0" title="0">
                return "未知"</span>
        }
}

// getCategoryStats 获取类别统计
func (api *FunctionAPI) getCategoryStats() map[string]int <span class="cov0" title="0">{
        stats := make(map[string]int)
        
        categories := []FunctionCategory{
                CategoryMath,
                CategoryString,
                CategoryDate,
                CategoryAggregate,
                CategoryControl,
                CategoryJSON,
                CategorySystem,
        }
        
        for _, category := range categories </span><span class="cov0" title="0">{
                stats[string(category)] = api.registry.CountByCategory(category)
        }</span>
        
        <span class="cov0" title="0">return stats</span>
}

// ============ 函数选项 ============

// FunctionOption 函数选项类型
type FunctionOption func(*FunctionMetadata)

// WithCategory 设置类别
func WithCategory(category FunctionCategory) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Category = category
        }</span>
}

// WithVariadic 设置可变参数
func WithVariadic() FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Variadic = true
        }</span>
}

// WithMinArgs 设置最小参数数
func WithMinArgs(min int) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.MinArgs = min
        }</span>
}

// WithMaxArgs 设置最大参数数
func WithMaxArgs(max int) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.MaxArgs = max
        }</span>
}

// WithArgRange 设置参数范围
func WithArgRange(min, max int) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.MinArgs = min
                meta.MaxArgs = max
        }</span>
}

// WithReturnType 设置返回类型
func WithReturnType(returnType string) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.ReturnType = returnType
        }</span>
}

// WithParameter 添加参数定义
func WithParameter(name, typeName, description string, required bool) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Parameters = append(meta.Parameters, FunctionParam{
                        Name:        name,
                        Type:        typeName,
                        Description: description,
                        Required:    required,
                })
        }</span>
}

// WithExample 添加示例
func WithExample(example string) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Examples = append(meta.Examples, example)
        }</span>
}

// WithTag 添加标签
func WithTag(tag string) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Tags = append(meta.Tags, tag)
        }</span>
}

// WithTags 添加多个标签
func WithTags(tags []string) FunctionOption <span class="cov0" title="0">{
        return func(meta *FunctionMetadata) </span><span class="cov0" title="0">{
                meta.Tags = append(meta.Tags, tags...)
        }</span>
}

// FunctionRegisterFunc 函数注册函数类型
type FunctionRegisterFunc func() (*FunctionMetadata, error)

// ============ UDF 管理 API ============

// RegisterUDF 注册用户自定义函数
func (api *FunctionAPI) RegisterUDF(udf *UDFFunction) error <span class="cov0" title="0">{
        manager := GetGlobalUDFManager()
        if err := manager.Register(udf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 同时注册到函数注册表，以便在SQL中使用
        // 类型转换：UDFHandler -&gt; FunctionHandle
        <span class="cov0" title="0">wrappedHandler := func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return udf.Handler(args)
        }</span>
        
        <span class="cov0" title="0">return api.RegisterScalarFunction(
                udf.Metadata.Name,
                udf.Metadata.Name,
                udf.Metadata.Description,
                wrappedHandler,
                WithCategory(CategoryUser),
                WithReturnType(udf.Metadata.ReturnType),
                WithTags([]string{"udf"}),
        )</span>
}

// RegisterUDFFromBuilder 通过构建器注册UDF
func (api *FunctionAPI) RegisterUDFFromBuilder(builder *UDFBuilder) error <span class="cov0" title="0">{
        udf := builder.Build()
        return api.RegisterUDF(udf)
}</span>

// UnregisterUDF 注销用户自定义函数
func (api *FunctionAPI) UnregisterUDF(name string) error <span class="cov0" title="0">{
        // 从UDF管理器中移除
        manager := GetGlobalUDFManager()
        if err := manager.Unregister(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 从函数注册表中移除
        <span class="cov0" title="0">return api.UnregisterFunction(name)</span>
}

// GetUDF 获取用户自定义函数
func (api *FunctionAPI) GetUDF(name string) (*UDFFunction, error) <span class="cov0" title="0">{
        manager := GetGlobalUDFManager()
        udf, exists := manager.Get(name)
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UDF %s not found", name)
        }</span>
        <span class="cov0" title="0">return udf, nil</span>
}

// ListUDFs 列出所有用户自定义函数
func (api *FunctionAPI) ListUDFs() []*UDFFunction <span class="cov0" title="0">{
        manager := GetGlobalUDFManager()
        return manager.List()
}</span>

// CountUDFs 统计UDF数量
func (api *FunctionAPI) CountUDFs() int <span class="cov0" title="0">{
        manager := GetGlobalUDFManager()
        return manager.Count()
}</span>

// UDFExists 检查UDF是否存在
func (api *FunctionAPI) UDFExists(name string) bool <span class="cov0" title="0">{
        manager := GetGlobalUDFManager()
        return manager.Exists(name)
}</span>

// ClearUDFs 清除所有UDF
func (api *FunctionAPI) ClearUDFs() <span class="cov0" title="0">{
        // 从函数注册表中清除
        api.ClearUserFunctions()
        
        // 从UDF管理器中清除
        manager := GetGlobalUDFManager()
        manager.Clear()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package builtin

// FunctionBuilder 函数构建器，用于方便地构建和注册函数
type FunctionBuilder struct {
        meta *FunctionMetadata
}

// NewFunctionBuilder 创建函数构建器
func NewFunctionBuilder(name, displayName string) *FunctionBuilder <span class="cov0" title="0">{
        return &amp;FunctionBuilder{
                meta: &amp;FunctionMetadata{
                        Name:            name,
                        DisplayName:      displayName,
                        Type:            FunctionTypeScalar,
                        Scope:           ScopeGlobal,
                        Parameters:      []FunctionParam{},
                        Examples:        []string{},
                        Tags:           []string{},
                },
        }
}</span>

// AsScalar 设置为标量函数
func (b *FunctionBuilder) AsScalar() *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Type = FunctionTypeScalar
        return b
}</span>

// AsAggregate 设置为聚合函数
func (b *FunctionBuilder) AsAggregate(handler AggregateHandle, result AggregateResult) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Type = FunctionTypeAggregate
        b.meta.AggregateHandler = handler
        b.meta.AggregateResult = result
        return b
}</span>

// AsUser 设置为用户函数
func (b *FunctionBuilder) AsUser() *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Scope = ScopeUser
        return b
}</span>

// AsSession 设置为会话函数
func (b *FunctionBuilder) AsSession() *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Scope = ScopeSession
        return b
}</span>

// WithDescription 设置描述
func (b *FunctionBuilder) WithDescription(description string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Description = description
        return b
}</span>

// WithCategory 设置类别
func (b *FunctionBuilder) WithCategory(category FunctionCategory) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Category = category
        return b
}</span>

// WithHandler 设置处理函数（标量函数）
func (b *FunctionBuilder) WithHandler(handler FunctionHandle) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Handler = handler
        return b
}</span>

// WithReturnType 设置返回类型
func (b *FunctionBuilder) WithReturnType(returnType string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.ReturnType = returnType
        return b
}</span>

// WithVariadic 设置为可变参数
func (b *FunctionBuilder) WithVariadic() *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Variadic = true
        return b
}</span>

// WithArgRange 设置参数范围
func (b *FunctionBuilder) WithArgRange(min, max int) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.MinArgs = min
        b.meta.MaxArgs = max
        return b
}</span>

// WithMinArgs 设置最小参数数
func (b *FunctionBuilder) WithMinArgs(min int) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.MinArgs = min
        return b
}</span>

// WithMaxArgs 设置最大参数数
func (b *FunctionBuilder) WithMaxArgs(max int) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.MaxArgs = max
        return b
}</span>

// WithParameter 添加参数
func (b *FunctionBuilder) WithParameter(name, typeName, description string, required bool) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Parameters = append(b.meta.Parameters, FunctionParam{
                Name:        name,
                Type:        typeName,
                Description: description,
                Required:    required,
        })
        return b
}</span>

// WithParameters 批量添加参数
func (b *FunctionBuilder) WithParameters(params []FunctionParam) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Parameters = append(b.meta.Parameters, params...)
        return b
}</span>

// WithExample 添加示例
func (b *FunctionBuilder) WithExample(example string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Examples = append(b.meta.Examples, example)
        return b
}</span>

// WithExamples 批量添加示例
func (b *FunctionBuilder) WithExamples(examples []string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Examples = append(b.meta.Examples, examples...)
        return b
}</span>

// WithTag 添加标签
func (b *FunctionBuilder) WithTag(tag string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Tags = append(b.meta.Tags, tag)
        return b
}</span>

// WithTags 批量添加标签
func (b *FunctionBuilder) WithTags(tags []string) *FunctionBuilder <span class="cov0" title="0">{
        b.meta.Tags = append(b.meta.Tags, tags...)
        return b
}</span>

// Build 构建元数据
func (b *FunctionBuilder) Build() *FunctionMetadata <span class="cov0" title="0">{
        return b.meta
}</span>

// Register 注册函数到API
func (b *FunctionBuilder) Register(api *FunctionAPI) error <span class="cov0" title="0">{
        meta := b.Build()
        
        if meta.Type == FunctionTypeAggregate </span><span class="cov0" title="0">{
                return api.GetRegistry().RegisterAggregate(meta)
        }</span>
        <span class="cov0" title="0">return api.GetRegistry().RegisterScalar(meta)</span>
}

// ============ 预定义的函数构建器 ============

// MathFunctionBuilder 数学函数构建器
func MathFunctionBuilder(name, displayName, description string) *FunctionBuilder <span class="cov0" title="0">{
        return NewFunctionBuilder(name, displayName).
                AsScalar().
                WithCategory(CategoryMath).
                WithDescription(description).
                WithReturnType("number")
}</span>

// StringFunctionBuilder 字符串函数构建器
func StringFunctionBuilder(name, displayName, description string) *FunctionBuilder <span class="cov0" title="0">{
        return NewFunctionBuilder(name, displayName).
                AsScalar().
                WithCategory(CategoryString).
                WithDescription(description).
                WithReturnType("string")
}</span>

// DateFunctionBuilder 日期函数构建器
func DateFunctionBuilder(name, displayName, description string, returnType string) *FunctionBuilder <span class="cov0" title="0">{
        return NewFunctionBuilder(name, displayName).
                AsScalar().
                WithCategory(CategoryDate).
                WithDescription(description).
                WithReturnType(returnType)
}</span>

// AggregateFunctionBuilder 聚合函数构建器
func AggregateFunctionBuilder(name, displayName, description string, returnType string) *FunctionBuilder <span class="cov0" title="0">{
        return NewFunctionBuilder(name, displayName).
                AsAggregate(nil, nil).
                WithCategory(CategoryAggregate).
                WithDescription(description).
                WithReturnType(returnType)
}</span>

// ============ 便捷函数注册方法 ============

// RegisterSimpleScalar 注册简单标量函数
func RegisterSimpleScalar(api *FunctionAPI, category FunctionCategory, 
        name, displayName, description, returnType string, 
        handler FunctionHandle, argCount int) error <span class="cov0" title="0">{
        
        return api.RegisterScalarFunction(name, displayName, description, handler,
                WithCategory(category),
                WithReturnType(returnType),
                WithArgRange(argCount, argCount),
        )
}</span>

// RegisterVariadicScalar 注册可变参数标量函数
func RegisterVariadicScalar(api *FunctionAPI, category FunctionCategory,
        name, displayName, description, returnType string, 
        handler FunctionHandle, minArgs int) error <span class="cov0" title="0">{
        
        return api.RegisterScalarFunction(name, displayName, description, handler,
                WithCategory(category),
                WithReturnType(returnType),
                WithMinArgs(minArgs),
                WithMaxArgs(-1),
                WithVariadic(),
        )
}</span>

// RegisterSimpleAggregate 注册简单聚合函数
func RegisterSimpleAggregate(api *FunctionAPI,
        name, displayName, description, returnType string,
        handler AggregateHandle, result AggregateResult) error <span class="cov0" title="0">{
        
        return api.RegisterAggregateFunction(name, displayName, description, handler, result,
                WithCategory(CategoryAggregate),
                WithReturnType(returnType),
        )
}</span>

// ============ 示例使用 ============

// 示例1: 使用构建器注册简单函数
/*
api := builtin.NewFunctionAPI()

builtin.RegisterSimpleScalar(api, builtin.CategoryMath, 
        "myfunc", "MyFunc", "我的自定义函数", "number",
        func(args []interface{}) (interface{}, error) {
                return args[0], nil
        }, 
        1,
)
*/

// 示例2: 使用构建器创建复杂函数
/*
api := builtin.NewFunctionAPI()

err := builtin.MathFunctionBuilder("complex", "Complex", "复杂计算函数").
        WithDescription("执行复杂的数学计算").
        WithParameter("x", "number", "X坐标", true).
        WithParameter("y", "number", "Y坐标", true).
        WithParameter("operation", "string", "操作类型", true).
        WithExample("SELECT complex(1, 2, 'add') FROM table").
        WithExample("SELECT complex(10, 5, 'multiply') FROM table").
        WithTags([]string{"math", "custom", "experimental"}).
        WithHandler(func(args []interface{}) (interface{}, error) {
                x, _ := toFloat64(args[0])
                y, _ := toFloat64(args[1])
                op := args[2].(string)
                
                switch op {
                case "add":
                        return x + y, nil
                case "multiply":
                        return x * y, nil
                default:
                        return nil, fmt.Errorf("unknown operation: %s", op)
                }
        }).
        Register(api)

if err != nil {
        log.Fatal(err)
}
*/

// 示例3: 批量注册函数
/*
api := builtin.NewFunctionAPI()

// 批量注册数学函数
mathFunctions := []struct{
        name, displayName, description string
        handler FunctionHandle
}{
        {"sin", "Sin", "正弦函数", mathSin},
        {"cos", "Cos", "余弦函数", mathCos},
        {"tan", "Tan", "正切函数", mathTan},
}

for _, fn := range mathFunctions {
        err := builtin.RegisterSimpleScalar(api, builtin.CategoryMath,
                fn.name, fn.displayName, fn.description, "number",
                fn.handler, 1,
        )
        if err != nil {
                log.Printf("Failed to register %s: %v", fn.name, err)
        }
}
*/
</pre>
		
		<pre class="file" id="file22" style="display: none">package builtin

import (
        "fmt"
        "time"
)

func init() <span class="cov8" title="1">{
        // 注册日期时间函数
        dateFunctions := []*FunctionInfo{
                {
                        Name: "now",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "now", ReturnType: "datetime", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateNow,
                        Description: "返回当前日期时间",
                        Example:     "NOW() -&gt; '2024-01-01 12:00:00'",
                        Category:    "date",
                },
                {
                        Name: "current_timestamp",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "current_timestamp", ReturnType: "datetime", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateNow,
                        Description: "返回当前时间戳",
                        Example:     "CURRENT_TIMESTAMP() -&gt; '2024-01-01 12:00:00'",
                        Category:    "date",
                },
                {
                        Name: "current_date",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "current_date", ReturnType: "date", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateCurrentDate,
                        Description: "返回当前日期",
                        Example:     "CURRENT_DATE() -&gt; '2024-01-01'",
                        Category:    "date",
                },
                {
                        Name: "curdate",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "curdate", ReturnType: "date", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateCurrentDate,
                        Description: "返回当前日期",
                        Example:     "CURDATE() -&gt; '2024-01-01'",
                        Category:    "date",
                },
                {
                        Name: "current_time",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "current_time", ReturnType: "time", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateCurrentTime,
                        Description: "返回当前时间",
                        Example:     "CURRENT_TIME() -&gt; '12:00:00'",
                        Category:    "date",
                },
                {
                        Name: "curtime",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "curtime", ReturnType: "time", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     dateCurrentTime,
                        Description: "返回当前时间",
                        Example:     "CURTIME() -&gt; '12:00:00'",
                        Category:    "date",
                },
                {
                        Name: "year",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "year", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateYear,
                        Description: "返回年份",
                        Example:     "YEAR('2024-01-01') -&gt; 2024",
                        Category:    "date",
                },
                {
                        Name: "month",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "month", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateMonth,
                        Description: "返回月份",
                        Example:     "MONTH('2024-01-01') -&gt; 1",
                        Category:    "date",
                },
                {
                        Name: "day",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "day", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateDay,
                        Description: "返回日期",
                        Example:     "DAY('2024-01-01') -&gt; 1",
                        Category:    "date",
                },
                {
                        Name: "dayofmonth",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "dayofmonth", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateDay,
                        Description: "返回日期（day的别名）",
                        Example:     "DAYOFMONTH('2024-01-01') -&gt; 1",
                        Category:    "date",
                },
                {
                        Name: "hour",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "hour", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateHour,
                        Description: "返回小时",
                        Example:     "HOUR('2024-01-01 12:30:00') -&gt; 12",
                        Category:    "date",
                },
                {
                        Name: "minute",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "minute", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateMinute,
                        Description: "返回分钟",
                        Example:     "MINUTE('2024-01-01 12:30:00') -&gt; 30",
                        Category:    "date",
                },
                {
                        Name: "second",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "second", ReturnType: "integer", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateSecond,
                        Description: "返回秒",
                        Example:     "SECOND('2024-01-01 12:30:45') -&gt; 45",
                        Category:    "date",
                },
                {
                        Name: "date",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "date", ReturnType: "date", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateDate,
                        Description: "提取日期部分",
                        Example:     "DATE('2024-01-01 12:30:00') -&gt; '2024-01-01'",
                        Category:    "date",
                },
                {
                        Name: "time",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "time", ReturnType: "time", ParamTypes: []string{"datetime"}, Variadic: false},
                        },
                        Handler:     dateTime,
                        Description: "提取时间部分",
                        Example:     "TIME('2024-01-01 12:30:00') -&gt; '12:30:00'",
                        Category:    "date",
                },
                {
                        Name: "date_format",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "date_format", ReturnType: "string", ParamTypes: []string{"datetime", "string"}, Variadic: false},
                        },
                        Handler:     dateFormat,
                        Description: "格式化日期",
                        Example:     "DATE_FORMAT('2024-01-01', '%Y-%m-%d') -&gt; '2024-01-01'",
                        Category:    "date",
                },
                {
                        Name: "datediff",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "datediff", ReturnType: "integer", ParamTypes: []string{"datetime", "datetime"}, Variadic: false},
                        },
                        Handler:     dateDiff,
                        Description: "日期差（天）",
                        Example:     "DATEDIFF('2024-01-02', '2024-01-01') -&gt; 1",
                        Category:    "date",
                },
        }

        for _, fn := range dateFunctions </span><span class="cov8" title="1">{
                RegisterGlobal(fn)
        }</span>
}

// 辅助函数：将参数转换为time.Time
func toTime(arg interface{}) (time.Time, error) <span class="cov0" title="0">{
        switch v := arg.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                // 尝试解析常见的日期格式
                formats := []string{
                        "2006-01-02 15:04:05",
                        "2006-01-02T15:04:05",
                        "2006-01-02",
                }
                for _, format := range formats </span><span class="cov0" title="0">{
                        if t, err := time.Parse(format, v); err == nil </span><span class="cov0" title="0">{
                                return t, nil
                        }</span>
                }
                <span class="cov0" title="0">return time.Time{}, fmt.Errorf("cannot parse time: %s", v)</span>
        default:<span class="cov0" title="0">
                return time.Time{}, fmt.Errorf("cannot convert %T to time.Time", arg)</span>
        }
}

// 日期时间函数实现
func dateNow(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("now() requires no arguments")
        }</span>
        <span class="cov0" title="0">return time.Now(), nil</span>
}

func dateCurrentDate(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("current_date() requires no arguments")
        }</span>
        <span class="cov0" title="0">now := time.Now()
        return time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location()), nil</span>
}

func dateCurrentTime(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("current_time() requires no arguments")
        }</span>
        <span class="cov0" title="0">now := time.Now()
        return now.Format("15:04:05"), nil</span>
}

func dateYear(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("year() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Year()), nil</span>
}

func dateMonth(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("month() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Month()), nil</span>
}

func dateDay(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("day() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Day()), nil</span>
}

func dateHour(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hour() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Hour()), nil</span>
}

func dateMinute(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("minute() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Minute()), nil</span>
}

func dateSecond(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("second() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return int64(t.Second()), nil</span>
}

func dateDate(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("date() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location()), nil</span>
}

func dateTime(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("time() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return t.Format("15:04:05"), nil</span>
}

func dateFormat(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("date_format() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">t, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">format := toString(args[1])
        
        // 简化实现，支持常见格式
        layout := "2006-01-02 15:04:05"
        if format == "%Y-%m-%d" </span><span class="cov0" title="0">{
                layout = "2006-01-02"
        }</span> else<span class="cov0" title="0"> if format == "%H:%i:%s" </span><span class="cov0" title="0">{
                layout = "15:04:05"
        }</span> else<span class="cov0" title="0"> if format == "%Y-%m-%d %H:%i:%s" </span><span class="cov0" title="0">{
                layout = "2006-01-02 15:04:05"
        }</span>
        
        <span class="cov0" title="0">return t.Format(layout), nil</span>
}

func dateDiff(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("datediff() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">t1, err := toTime(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">t2, err := toTime(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">diff := t1.Sub(t2)
        return int64(diff.Hours() / 24), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package builtin

import (
        "fmt"
        "sync"
)

// FunctionType 函数类型
type FunctionType int

const (
        FunctionTypeScalar FunctionType = iota // 标量函数
        FunctionTypeAggregate                  // 聚合函数
        FunctionTypeWindow                    // 窗口函数
)

// FunctionSignature 函数签名
type FunctionSignature struct {
        Name       string
        ReturnType string
        ParamTypes []string
        Variadic   bool // 是否可变参数
}

// FunctionHandle 函数处理函数
type FunctionHandle func(args []interface{}) (interface{}, error)

// FunctionInfo 函数信息
type FunctionInfo struct {
        Name        string
        Type        FunctionType
        Signatures  []FunctionSignature
        Handler     FunctionHandle
        Description string
        Example     string
        Category    string // math, string, date, aggregate等
}

// FunctionRegistry 函数注册表
type FunctionRegistry struct {
        mu        sync.RWMutex
        functions map[string]*FunctionInfo
}

// NewFunctionRegistry 创建函数注册表
func NewFunctionRegistry() *FunctionRegistry <span class="cov8" title="1">{
        return &amp;FunctionRegistry{
                functions: make(map[string]*FunctionInfo),
        }
}</span>

// Register 注册函数
func (r *FunctionRegistry) Register(info *FunctionInfo) error <span class="cov8" title="1">{
        if info == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("function info cannot be nil")
        }</span>
        <span class="cov8" title="1">if info.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("function name cannot be empty")
        }</span>
        <span class="cov8" title="1">if info.Handler == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("function handler cannot be nil")
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        r.functions[info.Name] = info
        return nil</span>
}

// Get 获取函数
func (r *FunctionRegistry) Get(name string) (*FunctionInfo, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        info, exists := r.functions[name]
        return info, exists
}</span>

// List 列出所有函数
func (r *FunctionRegistry) List() []*FunctionInfo <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionInfo, 0, len(r.functions))
        for _, info := range r.functions </span><span class="cov8" title="1">{
                list = append(list, info)
        }</span>
        <span class="cov8" title="1">return list</span>
}

// ListByCategory 按类别列出函数
func (r *FunctionRegistry) ListByCategory(category string) []*FunctionInfo <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionInfo, 0)
        for _, info := range r.functions </span><span class="cov8" title="1">{
                if info.Category == category </span><span class="cov8" title="1">{
                        list = append(list, info)
                }</span>
        }
        <span class="cov8" title="1">return list</span>
}

// Exists 检查函数是否存在
func (r *FunctionRegistry) Exists(name string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        _, exists := r.functions[name]
        return exists
}</span>

// Unregister 注销函数
func (r *FunctionRegistry) Unregister(name string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.functions[name]; exists </span><span class="cov8" title="1">{
                delete(r.functions, name)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// 全局函数注册表
var globalRegistry = NewFunctionRegistry()

// GetGlobalRegistry 获取全局函数注册表
func GetGlobalRegistry() *FunctionRegistry <span class="cov8" title="1">{
        return globalRegistry
}</span>

// RegisterGlobal 注册全局函数
func RegisterGlobal(info *FunctionInfo) error <span class="cov8" title="1">{
        return globalRegistry.Register(info)
}</span>

// GetGlobal 获取全局函数
func GetGlobal(name string) (*FunctionInfo, bool) <span class="cov8" title="1">{
        return globalRegistry.Get(name)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package builtin

import "fmt"

// InitBuiltinFunctions 初始化所有内置函数
func InitBuiltinFunctions() <span class="cov0" title="0">{
        // 初始化聚合函数
        InitAggregateFunctions()
        
        // 其他函数（数学、字符串、日期）已在各自的init()函数中自动注册
        // 只需确保包被导入即可
}</span>

// GetAllCategories 获取所有函数类别
func GetAllCategories() []string <span class="cov0" title="0">{
        return []string{
                "math",
                "string",
                "date",
                "aggregate",
        }
}</span>

// GetFunctionCount 获取函数总数
func GetFunctionCount() int <span class="cov0" title="0">{
        return len(globalRegistry.functions)
}</span>

// GetFunctionCountByCategory 按类别获取函数数量
func GetFunctionCountByCategory(category string) int <span class="cov0" title="0">{
        return len(globalRegistry.ListByCategory(category))
}</span>

// ============ 公共辅助函数 ============

// ToFloat64 转换为float64
func ToFloat64(arg interface{}) (float64, error) <span class="cov0" title="0">{
        switch v := arg.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(v), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to float64", arg)</span>
        }
}

// ToInt64 转换为int64
func ToInt64(arg interface{}) (int64, error) <span class="cov0" title="0">{
        switch v := arg.(type) </span>{
        case int:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return v, nil</span>
        case int32:<span class="cov0" title="0">
                return int64(v), nil</span>
        case float64:<span class="cov0" title="0">
                return int64(v), nil</span>
        case float32:<span class="cov0" title="0">
                return int64(v), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to int64", arg)</span>
        }
}

// ToString 转换为string
func ToString(arg interface{}) string <span class="cov0" title="0">{
        switch v := arg.(type) </span>{
        case string:<span class="cov0" title="0">
                return v</span>
        case []byte:<span class="cov0" title="0">
                return string(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", arg)</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package builtin

import (
        "fmt"
        "math"
)

func init() <span class="cov8" title="1">{
        // 注册数学函数
        mathFunctions := []*FunctionInfo{
                {
                        Name: "abs",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "abs", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathAbs,
                        Description: "返回绝对值",
                        Example:     "ABS(-5) -&gt; 5",
                        Category:    "math",
                },
                {
                        Name: "ceil",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ceil", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathCeil,
                        Description: "向上取整",
                        Example:     "CEIL(3.14) -&gt; 4",
                        Category:    "math",
                },
                {
                        Name: "ceiling",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ceiling", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathCeil,
                        Description: "向上取整（ceil的别名）",
                        Example:     "CEILING(3.14) -&gt; 4",
                        Category:    "math",
                },
                {
                        Name: "floor",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "floor", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathFloor,
                        Description: "向下取整",
                        Example:     "FLOOR(3.14) -&gt; 3",
                        Category:    "math",
                },
                {
                        Name: "round",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "round", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                                {Name: "round", ReturnType: "number", ParamTypes: []string{"number", "integer"}, Variadic: false},
                        },
                        Handler:     mathRound,
                        Description: "四舍五入",
                        Example:     "ROUND(3.14159, 2) -&gt; 3.14",
                        Category:    "math",
                },
                {
                        Name: "sqrt",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "sqrt", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathSqrt,
                        Description: "计算平方根",
                        Example:     "SQRT(16) -&gt; 4",
                        Category:    "math",
                },
                {
                        Name: "pow",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "pow", ReturnType: "number", ParamTypes: []string{"number", "number"}, Variadic: false},
                        },
                        Handler:     mathPow,
                        Description: "计算幂",
                        Example:     "POW(2, 3) -&gt; 8",
                        Category:    "math",
                },
                {
                        Name: "power",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "power", ReturnType: "number", ParamTypes: []string{"number", "number"}, Variadic: false},
                        },
                        Handler:     mathPow,
                        Description: "计算幂（pow的别名）",
                        Example:     "POWER(2, 3) -&gt; 8",
                        Category:    "math",
                },
                {
                        Name: "exp",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "exp", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathExp,
                        Description: "计算e的x次方",
                        Example:     "EXP(1) -&gt; 2.718281828459045",
                        Category:    "math",
                },
                {
                        Name: "log",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "log", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                                {Name: "log", ReturnType: "number", ParamTypes: []string{"number", "number"}, Variadic: false},
                        },
                        Handler:     mathLog,
                        Description: "计算对数",
                        Example:     "LOG(10) -&gt; 2.302585092994046",
                        Category:    "math",
                },
                {
                        Name: "log10",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "log10", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathLog10,
                        Description: "计算以10为底的对数",
                        Example:     "LOG10(100) -&gt; 2",
                        Category:    "math",
                },
                {
                        Name: "log2",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "log2", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathLog2,
                        Description: "计算以2为底的对数",
                        Example:     "LOG2(8) -&gt; 3",
                        Category:    "math",
                },
                {
                        Name: "ln",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ln", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathLn,
                        Description: "计算自然对数",
                        Example:     "LN(10) -&gt; 2.302585092994046",
                        Category:    "math",
                },
                {
                        Name: "sin",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "sin", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathSin,
                        Description: "计算正弦值",
                        Example:     "SIN(PI()/2) -&gt; 1",
                        Category:    "math",
                },
                {
                        Name: "cos",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "cos", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathCos,
                        Description: "计算余弦值",
                        Example:     "COS(0) -&gt; 1",
                        Category:    "math",
                },
                {
                        Name: "tan",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "tan", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathTan,
                        Description: "计算正切值",
                        Example:     "TAN(PI()/4) -&gt; 1",
                        Category:    "math",
                },
                {
                        Name: "asin",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "asin", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathAsin,
                        Description: "计算反正弦值",
                        Example:     "ASIN(0.5) -&gt; 0.5235987755982989",
                        Category:    "math",
                },
                {
                        Name: "acos",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "acos", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathAcos,
                        Description: "计算反余弦值",
                        Example:     "ACOS(0.5) -&gt; 1.0471975511965979",
                        Category:    "math",
                },
                {
                        Name: "atan",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "atan", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathAtan,
                        Description: "计算反正切值",
                        Example:     "ATAN(1) -&gt; 0.7853981633974483",
                        Category:    "math",
                },
                {
                        Name: "atan2",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "atan2", ReturnType: "number", ParamTypes: []string{"number", "number"}, Variadic: false},
                        },
                        Handler:     mathAtan2,
                        Description: "计算反正切值（2个参数）",
                        Example:     "ATAN2(1, 1) -&gt; 0.7853981633974483",
                        Category:    "math",
                },
                {
                        Name: "degrees",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "degrees", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathDegrees,
                        Description: "弧度转角度",
                        Example:     "DEGREES(PI()) -&gt; 180",
                        Category:    "math",
                },
                {
                        Name: "radians",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "radians", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathRadians,
                        Description: "角度转弧度",
                        Example:     "RADIANS(180) -&gt; 3.141592653589793",
                        Category:    "math",
                },
                {
                        Name: "pi",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "pi", ReturnType: "number", ParamTypes: []string{}, Variadic: false},
                        },
                        Handler:     mathPi,
                        Description: "返回圆周率π",
                        Example:     "PI() -&gt; 3.141592653589793",
                        Category:    "math",
                },
                {
                        Name: "sign",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "sign", ReturnType: "integer", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathSign,
                        Description: "返回符号（-1, 0, 1）",
                        Example:     "SIGN(-10) -&gt; -1",
                        Category:    "math",
                },
                {
                        Name: "truncate",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "truncate", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                                {Name: "truncate", ReturnType: "number", ParamTypes: []string{"number", "integer"}, Variadic: false},
                        },
                        Handler:     mathTruncate,
                        Description: "截断数字",
                        Example:     "TRUNCATE(3.14159, 2) -&gt; 3.14",
                        Category:    "math",
                },
                {
                        Name: "mod",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "mod", ReturnType: "number", ParamTypes: []string{"number", "number"}, Variadic: false},
                        },
                        Handler:     mathMod,
                        Description: "取模运算",
                        Example:     "MOD(10, 3) -&gt; 1",
                        Category:    "math",
                },
                {
                        Name: "rand",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "rand", ReturnType: "number", ParamTypes: []string{}, Variadic: false},
                                {Name: "rand", ReturnType: "number", ParamTypes: []string{"number"}, Variadic: false},
                        },
                        Handler:     mathRand,
                        Description: "生成随机数",
                        Example:     "RAND() -&gt; 0.123456789",
                        Category:    "math",
                },
        }

        for _, fn := range mathFunctions </span><span class="cov8" title="1">{
                RegisterGlobal(fn)
        }</span>
}

// 辅助函数：将参数转换为float64
func toFloat64(arg interface{}) (float64, error) <span class="cov8" title="1">{
        switch v := arg.(type) </span>{
        case float64:<span class="cov8" title="1">
                return v, nil</span>
        case float32:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int32:<span class="cov8" title="1">
                return float64(v), nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot convert %T to float64", arg)</span>
        }
}

// 数学函数实现
func mathAbs(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("abs() requires exactly 1 argument")
        }</span>
        <span class="cov8" title="1">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return math.Abs(val), nil</span>
}

func mathCeil(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ceil() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Ceil(val), nil</span>
}

func mathFloor(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("floor() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Floor(val), nil</span>
}

func mathRound(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("round() requires 1 or 2 arguments")
        }</span>
        <span class="cov8" title="1">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">decimals := int64(0)
        if len(args) == 2 </span><span class="cov8" title="1">{
                decimalsVal, err := toFloat64(args[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">decimals = int64(decimalsVal)</span>
        }
        
        <span class="cov8" title="1">multiplier := math.Pow(10, float64(decimals))
        return math.Round(val*multiplier) / multiplier, nil</span>
}

func mathSqrt(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sqrt() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if val &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sqrt() requires non-negative argument")
        }</span>
        <span class="cov0" title="0">return math.Sqrt(val), nil</span>
}

func mathPow(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pow() requires exactly 2 arguments")
        }</span>
        <span class="cov0" title="0">base, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">exp, err := toFloat64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Pow(base, exp), nil</span>
}

func mathExp(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exp() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Exp(val), nil</span>
}

func mathLog(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("log() requires 1 or 2 arguments")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(args) == 1 </span><span class="cov0" title="0">{
                return math.Log(val), nil
        }</span>
        
        <span class="cov0" title="0">base, err := toFloat64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Log(val) / math.Log(base), nil</span>
}

func mathLog10(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("log10() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Log10(val), nil</span>
}

func mathLog2(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("log2() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Log2(val), nil</span>
}

func mathLn(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ln() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Log(val), nil</span>
}

func mathSin(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sin() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Sin(val), nil</span>
}

func mathCos(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cos() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Cos(val), nil</span>
}

func mathTan(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tan() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Tan(val), nil</span>
}

func mathAsin(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("asin() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if val &lt; -1 || val &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("asin() argument must be between -1 and 1")
        }</span>
        <span class="cov0" title="0">return math.Asin(val), nil</span>
}

func mathAcos(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("acos() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if val &lt; -1 || val &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("acos() argument must be between -1 and 1")
        }</span>
        <span class="cov0" title="0">return math.Acos(val), nil</span>
}

func mathAtan(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("atan() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Atan(val), nil</span>
}

func mathAtan2(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("atan2() requires exactly 2 arguments")
        }</span>
        <span class="cov0" title="0">y, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x, err := toFloat64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return math.Atan2(y, x), nil</span>
}

func mathDegrees(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("degrees() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return val * (180.0 / math.Pi), nil</span>
}

func mathRadians(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("radians() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return val * (math.Pi / 180.0), nil</span>
}

func mathPi(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return math.Pi, nil
}</span>

func mathSign(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sign() requires exactly 1 argument")
        }</span>
        <span class="cov8" title="1">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val &gt; 0 </span><span class="cov8" title="1">{
                return 1.0, nil
        }</span> else<span class="cov8" title="1"> if val &lt; 0 </span><span class="cov8" title="1">{
                return -1.0, nil
        }</span>
        <span class="cov8" title="1">return 0.0, nil</span>
}

func mathTruncate(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("truncate() requires 1 or 2 arguments")
        }</span>
        <span class="cov0" title="0">val, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">decimals := int64(0)
        if len(args) == 2 </span><span class="cov0" title="0">{
                decimalsVal, err := toFloat64(args[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">decimals = int64(decimalsVal)</span>
        }
        
        <span class="cov0" title="0">multiplier := math.Pow(10, float64(decimals))
        return float64(int64(val*multiplier)) / multiplier, nil</span>
}

func mathMod(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mod() requires exactly 2 arguments")
        }</span>
        <span class="cov8" title="1">a, err := toFloat64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b, err := toFloat64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return math.Mod(a, b), nil</span>
}

func mathRand(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        seed := int64(0)
        if len(args) == 1 </span><span class="cov0" title="0">{
                seedVal, err := toFloat64(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">seed = int64(seedVal)</span>
        }
        
        <span class="cov0" title="0">if seed != 0 </span><span class="cov0" title="0">{
                // 使用种子（简化实现）
                return float64(seed) / float64(^uint32(0)), nil
        }</span>
        
        // 简化实现：返回一个伪随机数
        <span class="cov0" title="0">return 0.5, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package builtin

import (
        "fmt"
        "sync"
)

// FunctionCategory 函数类别
type FunctionCategory string

const (
        CategoryMath      FunctionCategory = "math"
        CategoryString    FunctionCategory = "string"
        CategoryDate      FunctionCategory = "date"
        CategoryAggregate FunctionCategory = "aggregate"
        CategoryControl   FunctionCategory = "control"
        CategoryJSON      FunctionCategory = "json"
        CategorySystem    FunctionCategory = "system"
        CategoryUser      FunctionCategory = "user"
)

// FunctionScope 函数作用域
type FunctionScope string

const (
        ScopeGlobal FunctionScope = "global" // 全局函数
        ScopeUser   FunctionScope = "user"   // 用户自定义函数
        ScopeSession FunctionScope = "session" // 会话函数
)

// FunctionMetadata 函数元数据
type FunctionMetadata struct {
        Name        string            // 函数名（小写）
        DisplayName string            // 显示名称
        Type        FunctionType      // 函数类型：标量/聚合/窗口
        Scope       FunctionScope     // 作用域
        Category    FunctionCategory  // 类别
        Variadic    bool              // 是否可变参数
        MinArgs     int               // 最小参数数
        MaxArgs     int               // 最大参数数（-1表示无限制）
        Handler     FunctionHandle    // 处理函数
        AggregateHandler AggregateHandle  // 聚合函数处理
        AggregateResult   AggregateResult    // 聚合函数结果
        Description string            // 描述
        Examples    []string          // 示例
        Parameters  []FunctionParam   // 参数定义
        ReturnType  string            // 返回类型
        Tags        []string          // 标签
}

// FunctionParam 函数参数定义
type FunctionParam struct {
        Name        string // 参数名
        Type        string // 参数类型
        Description string // 描述
        Required    bool   // 是否必需
        Default     interface{} // 默认值
}

// FunctionFilter 函数过滤器
type FunctionFilter struct {
        Category   *FunctionCategory // 类别过滤
        Type       *FunctionType   // 类型过滤
        Scope      *FunctionScope  // 作用域过滤
        MinArgs    *int           // 最小参数数过滤
        MaxArgs    *int           // 最大参数数过滤
        NamePrefix string         // 名称前缀过滤
}

// FunctionRegistry 函数注册表（可扩展版本）
type FunctionRegistryExt struct {
        mu              sync.RWMutex
        scalars         map[string]*FunctionMetadata // 标量函数
        aggregates      map[string]*FunctionMetadata // 聚合函数
        userFunctions   map[string]*FunctionMetadata // 用户自定义函数
        sessionFunctions map[string]*FunctionMetadata // 会话函数
        aliases         map[string]string           // 函数别名
}

// NewFunctionRegistryExt 创建扩展函数注册表
func NewFunctionRegistryExt() *FunctionRegistryExt <span class="cov0" title="0">{
        return &amp;FunctionRegistryExt{
                scalars:         make(map[string]*FunctionMetadata),
                aggregates:      make(map[string]*FunctionMetadata),
                userFunctions:   make(map[string]*FunctionMetadata),
                sessionFunctions: make(map[string]*FunctionMetadata),
                aliases:         make(map[string]string),
        }
}</span>

// RegisterScalar 注册标量函数
func (r *FunctionRegistryExt) RegisterScalar(meta *FunctionMetadata) error <span class="cov0" title="0">{
        return r.registerFunction(meta, false)
}</span>

// RegisterAggregate 注册聚合函数
func (r *FunctionRegistryExt) RegisterAggregate(meta *FunctionMetadata) error <span class="cov0" title="0">{
        if meta.AggregateHandler == nil || meta.AggregateResult == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aggregate function must have handler and result function")
        }</span>
        <span class="cov0" title="0">return r.registerFunction(meta, true)</span>
}

// RegisterUserFunction 注册用户自定义函数
func (r *FunctionRegistryExt) RegisterUserFunction(meta *FunctionMetadata) error <span class="cov0" title="0">{
        meta.Scope = ScopeUser
        return r.registerFunction(meta, false)
}</span>

// RegisterSessionFunction 注册会话函数
func (r *FunctionRegistryExt) RegisterSessionFunction(meta *FunctionMetadata) error <span class="cov0" title="0">{
        meta.Scope = ScopeSession
        return r.registerFunction(meta, false)
}</span>

// registerFunction 内部注册函数
func (r *FunctionRegistryExt) registerFunction(meta *FunctionMetadata, isAggregate bool) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // 验证元数据
        if meta.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("function name cannot be empty")
        }</span>
        <span class="cov0" title="0">if meta.Handler == nil &amp;&amp; meta.AggregateHandler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function handler cannot be nil")
        }</span>

        // 标准化函数名（小写）
        <span class="cov0" title="0">normalizedName := normalizeName(meta.Name)
        meta.Name = normalizedName

        // 检查参数范围
        if meta.MinArgs &lt; 0 </span><span class="cov0" title="0">{
                meta.MinArgs = 0
        }</span>
        <span class="cov0" title="0">if meta.MaxArgs &lt; -1 </span><span class="cov0" title="0">{
                meta.MaxArgs = -1
        }</span>

        // 注册到相应的存储
        <span class="cov0" title="0">if meta.Scope == ScopeUser </span><span class="cov0" title="0">{
                if _, exists := r.userFunctions[normalizedName]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("user function %s already exists", normalizedName)
                }</span>
                <span class="cov0" title="0">r.userFunctions[normalizedName] = meta</span>
        } else<span class="cov0" title="0"> if meta.Scope == ScopeSession </span><span class="cov0" title="0">{
                if _, exists := r.sessionFunctions[normalizedName]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("session function %s already exists", normalizedName)
                }</span>
                <span class="cov0" title="0">r.sessionFunctions[normalizedName] = meta</span>
        } else<span class="cov0" title="0"> {
                if isAggregate </span><span class="cov0" title="0">{
                        if _, exists := r.aggregates[normalizedName]; exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("aggregate function %s already exists", normalizedName)
                        }</span>
                        <span class="cov0" title="0">r.aggregates[normalizedName] = meta</span>
                } else<span class="cov0" title="0"> {
                        if _, exists := r.scalars[normalizedName]; exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("scalar function %s already exists", normalizedName)
                        }</span>
                        <span class="cov0" title="0">r.scalars[normalizedName] = meta</span>
                }
        }

        // 注册别名
        <span class="cov0" title="0">if meta.DisplayName != "" &amp;&amp; meta.DisplayName != normalizedName </span><span class="cov0" title="0">{
                r.aliases[meta.DisplayName] = normalizedName
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get 获取函数
func (r *FunctionRegistryExt) Get(name string) (*FunctionMetadata, bool) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        normalizedName := normalizeName(name)

        // 按优先级查找：会话 &gt; 用户 &gt; 全局
        if meta, ok := r.sessionFunctions[normalizedName]; ok </span><span class="cov0" title="0">{
                return meta, true
        }</span>
        <span class="cov0" title="0">if meta, ok := r.userFunctions[normalizedName]; ok </span><span class="cov0" title="0">{
                return meta, true
        }</span>
        <span class="cov0" title="0">if meta, ok := r.scalars[normalizedName]; ok </span><span class="cov0" title="0">{
                return meta, true
        }</span>
        <span class="cov0" title="0">if meta, ok := r.aggregates[normalizedName]; ok </span><span class="cov0" title="0">{
                return meta, true
        }</span>

        // 查找别名
        <span class="cov0" title="0">if aliasName, ok := r.aliases[normalizedName]; ok </span><span class="cov0" title="0">{
                return r.Get(aliasName)
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

// GetScalar 获取标量函数
func (r *FunctionRegistryExt) GetScalar(name string) (*FunctionMetadata, bool) <span class="cov0" title="0">{
        meta, ok := r.Get(name)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">if meta.Type != FunctionTypeScalar </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return meta, true</span>
}

// GetAggregate 获取聚合函数
func (r *FunctionRegistryExt) GetAggregate(name string) (*FunctionMetadata, bool) <span class="cov0" title="0">{
        meta, ok := r.Get(name)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">if meta.Type != FunctionTypeAggregate </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return meta, true</span>
}

// Exists 检查函数是否存在
func (r *FunctionRegistryExt) Exists(name string) bool <span class="cov0" title="0">{
        _, ok := r.Get(name)
        return ok
}</span>

// Unregister 注销函数
func (r *FunctionRegistryExt) Unregister(name string) bool <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        normalizedName := normalizeName(name)

        // 尝试从各个存储中删除
        if _, ok := r.scalars[normalizedName]; ok </span><span class="cov0" title="0">{
                delete(r.scalars, normalizedName)
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.aggregates[normalizedName]; ok </span><span class="cov0" title="0">{
                delete(r.aggregates, normalizedName)
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.userFunctions[normalizedName]; ok </span><span class="cov0" title="0">{
                delete(r.userFunctions, normalizedName)
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.sessionFunctions[normalizedName]; ok </span><span class="cov0" title="0">{
                delete(r.sessionFunctions, normalizedName)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ClearUserFunctions 清除所有用户函数
func (r *FunctionRegistryExt) ClearUserFunctions() <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.userFunctions = make(map[string]*FunctionMetadata)
}</span>

// ClearSessionFunctions 清除所有会话函数
func (r *FunctionRegistryExt) ClearSessionFunctions() <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.sessionFunctions = make(map[string]*FunctionMetadata)
}</span>

// List 列出所有函数
func (r *FunctionRegistryExt) List() []*FunctionMetadata <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionMetadata, 0)
        
        // 按优先级添加：会话 &gt; 用户 &gt; 全局
        for _, meta := range r.sessionFunctions </span><span class="cov0" title="0">{
                list = append(list, meta)
        }</span>
        <span class="cov0" title="0">for _, meta := range r.userFunctions </span><span class="cov0" title="0">{
                list = append(list, meta)
        }</span>
        <span class="cov0" title="0">for _, meta := range r.scalars </span><span class="cov0" title="0">{
                list = append(list, meta)
        }</span>
        <span class="cov0" title="0">for _, meta := range r.aggregates </span><span class="cov0" title="0">{
                list = append(list, meta)
        }</span>
        
        <span class="cov0" title="0">return list</span>
}

// ListByCategory 按类别列出函数
func (r *FunctionRegistryExt) ListByCategory(category FunctionCategory) []*FunctionMetadata <span class="cov0" title="0">{
        filter := &amp;FunctionFilter{
                Category: &amp;category,
        }
        return r.ListWithFilter(filter)
}</span>

// ListByType 按类型列出函数
func (r *FunctionRegistryExt) ListByType(fnType FunctionType) []*FunctionMetadata <span class="cov0" title="0">{
        filter := &amp;FunctionFilter{
                Type: &amp;fnType,
        }
        return r.ListWithFilter(filter)
}</span>

// ListUserFunctions 列出用户函数
func (r *FunctionRegistryExt) ListUserFunctions() []*FunctionMetadata <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionMetadata, 0, len(r.userFunctions))
        for _, meta := range r.userFunctions </span><span class="cov0" title="0">{
                list = append(list, meta)
        }</span>
        <span class="cov0" title="0">return list</span>
}

// ListWithFilter 使用过滤器列出函数
func (r *FunctionRegistryExt) ListWithFilter(filter *FunctionFilter) []*FunctionMetadata <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionMetadata, 0)
        
        // 检查所有存储
        stores := []map[string]*FunctionMetadata{
                r.sessionFunctions,
                r.userFunctions,
                r.scalars,
                r.aggregates,
        }
        
        for _, store := range stores </span><span class="cov0" title="0">{
                for _, meta := range store </span><span class="cov0" title="0">{
                        if r.matchFilter(meta, filter) </span><span class="cov0" title="0">{
                                list = append(list, meta)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return list</span>
}

// matchFilter 检查函数是否匹配过滤器
func (r *FunctionRegistryExt) matchFilter(meta *FunctionMetadata, filter *FunctionFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // 类别过滤
        <span class="cov0" title="0">if filter.Category != nil &amp;&amp; meta.Category != *filter.Category </span><span class="cov0" title="0">{
                return false
        }</span>

        // 类型过滤
        <span class="cov0" title="0">if filter.Type != nil &amp;&amp; meta.Type != *filter.Type </span><span class="cov0" title="0">{
                return false
        }</span>

        // 作用域过滤
        <span class="cov0" title="0">if filter.Scope != nil &amp;&amp; meta.Scope != *filter.Scope </span><span class="cov0" title="0">{
                return false
        }</span>

        // 最小参数数过滤
        <span class="cov0" title="0">if filter.MinArgs != nil &amp;&amp; meta.MaxArgs &gt;= 0 &amp;&amp; meta.MaxArgs &lt; *filter.MinArgs </span><span class="cov0" title="0">{
                return false
        }</span>

        // 最大参数数过滤
        <span class="cov0" title="0">if filter.MaxArgs != nil &amp;&amp; meta.MinArgs &gt; *filter.MaxArgs </span><span class="cov0" title="0">{
                return false
        }</span>

        // 名称前缀过滤
        <span class="cov0" title="0">if filter.NamePrefix != "" &amp;&amp; len(filter.NamePrefix) &gt; 0 </span><span class="cov0" title="0">{
                if len(meta.Name) &lt; len(filter.NamePrefix) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if meta.Name[:len(filter.NamePrefix)] != filter.NamePrefix </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Count 统计函数总数
func (r *FunctionRegistryExt) Count() int <span class="cov0" title="0">{
        return len(r.List())
}</span>

// CountByCategory 按类别统计函数数
func (r *FunctionRegistryExt) CountByCategory(category FunctionCategory) int <span class="cov0" title="0">{
        return len(r.ListByCategory(category))
}</span>

// Search 搜索函数
func (r *FunctionRegistryExt) Search(keyword string) []*FunctionMetadata <span class="cov0" title="0">{
        keyword = normalizeName(keyword)
        
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]*FunctionMetadata, 0)
        
        // 检查所有存储
        stores := []map[string]*FunctionMetadata{
                r.sessionFunctions,
                r.userFunctions,
                r.scalars,
                r.aggregates,
        }
        
        for _, store := range stores </span><span class="cov0" title="0">{
                for _, meta := range store </span><span class="cov0" title="0">{
                        // 搜索名称
                        if contains(meta.Name, keyword) </span><span class="cov0" title="0">{
                                list = append(list, meta)
                                continue</span>
                        }
                        // 搜索显示名称
                        <span class="cov0" title="0">if contains(meta.DisplayName, keyword) </span><span class="cov0" title="0">{
                                list = append(list, meta)
                                continue</span>
                        }
                        // 搜索描述
                        <span class="cov0" title="0">if contains(meta.Description, keyword) </span><span class="cov0" title="0">{
                                list = append(list, meta)
                                continue</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return list</span>
}

// normalizeName 标准化函数名
func normalizeName(name string) string <span class="cov0" title="0">{
        // 转换为小写
        return toLowerCase(name)
}</span>

// toLowerCase 转小写
func toLowerCase(s string) string <span class="cov0" title="0">{
        result := ""
        for _, c := range s </span><span class="cov0" title="0">{
                if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' </span><span class="cov0" title="0">{
                        result += string(c + 32)
                }</span> else<span class="cov0" title="0"> {
                        result += string(c)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// contains 字符串包含
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; findSubstring(s, substr) &gt;= 0
}</span>

// findSubstring 查找子字符串
func findSubstring(s, substr string) int <span class="cov0" title="0">{
        if len(substr) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(s) &lt; len(substr) </span><span class="cov0" title="0">{
                return -1
        }</span>
        
        <span class="cov0" title="0">for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                match := true
                for j := 0; j &lt; len(substr); j++ </span><span class="cov0" title="0">{
                        if s[i+j] != substr[j] </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// AddAlias 添加函数别名
func (r *FunctionRegistryExt) AddAlias(alias, name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        normalizedName := normalizeName(name)
        normalizedAlias := normalizeName(alias)

        // 检查目标函数是否存在
        if !r.existsInternal(normalizedName) </span><span class="cov0" title="0">{
                return fmt.Errorf("function %s not found", normalizedName)
        }</span>

        <span class="cov0" title="0">r.aliases[normalizedAlias] = normalizedName
        return nil</span>
}

// existsInternal 内部检查函数是否存在
func (r *FunctionRegistryExt) existsInternal(name string) bool <span class="cov0" title="0">{
        if _, ok := r.scalars[name]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.aggregates[name]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.userFunctions[name]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := r.sessionFunctions[name]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RemoveAlias 删除别名
func (r *FunctionRegistryExt) RemoveAlias(alias string) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        normalizedAlias := normalizeName(alias)
        delete(r.aliases, normalizedAlias)
}</span>

// GetAliases 获取所有别名
func (r *FunctionRegistryExt) GetAliases() map[string]string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        aliases := make(map[string]string)
        for k, v := range r.aliases </span><span class="cov0" title="0">{
                aliases[k] = v
        }</span>
        <span class="cov0" title="0">return aliases</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package builtin

import (
        "fmt"
        "strings"
        "unicode"
)

func init() <span class="cov8" title="1">{
        // 注册字符串函数
        stringFunctions := []*FunctionInfo{
                {
                        Name: "concat",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "concat", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: true},
                        },
                        Handler:     stringConcat,
                        Description: "连接字符串",
                        Example:     "CONCAT('Hello', ' ', 'World') -&gt; 'Hello World'",
                        Category:    "string",
                },
                {
                        Name: "concat_ws",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "concat_ws", ReturnType: "string", ParamTypes: []string{"string", "string"}, Variadic: true},
                        },
                        Handler:     stringConcatWS,
                        Description: "使用分隔符连接字符串",
                        Example:     "CONCAT_WS(',', 'a', 'b', 'c') -&gt; 'a,b,c'",
                        Category:    "string",
                },
                {
                        Name: "length",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "length", ReturnType: "integer", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLength,
                        Description: "返回字符串长度（字节）",
                        Example:     "LENGTH('hello') -&gt; 5",
                        Category:    "string",
                },
                {
                        Name: "char_length",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "char_length", ReturnType: "integer", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLength,
                        Description: "返回字符串长度（字符）",
                        Example:     "CHAR_LENGTH('hello') -&gt; 5",
                        Category:    "string",
                },
                {
                        Name: "character_length",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "character_length", ReturnType: "integer", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLength,
                        Description: "返回字符串长度（字符）",
                        Example:     "CHARACTER_LENGTH('hello') -&gt; 5",
                        Category:    "string",
                },
                {
                        Name: "upper",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "upper", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringUpper,
                        Description: "转换为大写",
                        Example:     "UPPER('hello') -&gt; 'HELLO'",
                        Category:    "string",
                },
                {
                        Name: "ucase",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ucase", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringUpper,
                        Description: "转换为大写（upper的别名）",
                        Example:     "UCASE('hello') -&gt; 'HELLO'",
                        Category:    "string",
                },
                {
                        Name: "lower",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "lower", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLower,
                        Description: "转换为小写",
                        Example:     "LOWER('HELLO') -&gt; 'hello'",
                        Category:    "string",
                },
                {
                        Name: "lcase",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "lcase", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLower,
                        Description: "转换为小写（lower的别名）",
                        Example:     "LCASE('HELLO') -&gt; 'hello'",
                        Category:    "string",
                },
                {
                        Name: "trim",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "trim", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringTrim,
                        Description: "删除前后空格",
                        Example:     "TRIM('  hello  ') -&gt; 'hello'",
                        Category:    "string",
                },
                {
                        Name: "ltrim",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ltrim", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringLTrim,
                        Description: "删除前导空格",
                        Example:     "LTRIM('  hello') -&gt; 'hello'",
                        Category:    "string",
                },
                {
                        Name: "rtrim",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "rtrim", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringRTrim,
                        Description: "删除尾部空格",
                        Example:     "RTRIM('hello  ') -&gt; 'hello'",
                        Category:    "string",
                },
                {
                        Name: "left",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "left", ReturnType: "string", ParamTypes: []string{"string", "integer"}, Variadic: false},
                        },
                        Handler:     stringLeft,
                        Description: "返回左边的n个字符",
                        Example:     "LEFT('hello', 3) -&gt; 'hel'",
                        Category:    "string",
                },
                {
                        Name: "right",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "right", ReturnType: "string", ParamTypes: []string{"string", "integer"}, Variadic: false},
                        },
                        Handler:     stringRight,
                        Description: "返回右边的n个字符",
                        Example:     "RIGHT('hello', 3) -&gt; 'llo'",
                        Category:    "string",
                },
                {
                        Name: "substring",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "substring", ReturnType: "string", ParamTypes: []string{"string", "integer"}, Variadic: false},
                                {Name: "substring", ReturnType: "string", ParamTypes: []string{"string", "integer", "integer"}, Variadic: false},
                        },
                        Handler:     stringSubstring,
                        Description: "返回子字符串",
                        Example:     "SUBSTRING('hello', 2, 3) -&gt; 'ell'",
                        Category:    "string",
                },
                {
                        Name: "substr",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "substr", ReturnType: "string", ParamTypes: []string{"string", "integer"}, Variadic: false},
                                {Name: "substr", ReturnType: "string", ParamTypes: []string{"string", "integer", "integer"}, Variadic: false},
                        },
                        Handler:     stringSubstring,
                        Description: "返回子字符串（substring的别名）",
                        Example:     "SUBSTR('hello', 2, 3) -&gt; 'ell'",
                        Category:    "string",
                },
                {
                        Name: "replace",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "replace", ReturnType: "string", ParamTypes: []string{"string", "string", "string"}, Variadic: false},
                        },
                        Handler:     stringReplace,
                        Description: "替换字符串",
                        Example:     "REPLACE('hello world', 'world', 'there') -&gt; 'hello there'",
                        Category:    "string",
                },
                {
                        Name: "repeat",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "repeat", ReturnType: "string", ParamTypes: []string{"string", "integer"}, Variadic: false},
                        },
                        Handler:     stringRepeat,
                        Description: "重复字符串",
                        Example:     "REPEAT('ab', 3) -&gt; 'ababab'",
                        Category:    "string",
                },
                {
                        Name: "reverse",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "reverse", ReturnType: "string", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringReverse,
                        Description: "反转字符串",
                        Example:     "REVERSE('hello') -&gt; 'olleh'",
                        Category:    "string",
                },
                {
                        Name: "lpad",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "lpad", ReturnType: "string", ParamTypes: []string{"string", "integer", "string"}, Variadic: false},
                        },
                        Handler:     stringLPad,
                        Description: "左填充字符串",
                        Example:     "LPAD('hello', 10, '*') -&gt; '*****hello'",
                        Category:    "string",
                },
                {
                        Name: "rpad",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "rpad", ReturnType: "string", ParamTypes: []string{"string", "integer", "string"}, Variadic: false},
                        },
                        Handler:     stringRPad,
                        Description: "右填充字符串",
                        Example:     "RPAD('hello', 10, '*') -&gt; 'hello*****'",
                        Category:    "string",
                },
                {
                        Name: "position",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "position", ReturnType: "integer", ParamTypes: []string{"string", "string"}, Variadic: false},
                        },
                        Handler:     stringPosition,
                        Description: "返回子串位置",
                        Example:     "POSITION('ll' IN 'hello') -&gt; 3",
                        Category:    "string",
                },
                {
                        Name: "locate",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "locate", ReturnType: "integer", ParamTypes: []string{"string", "string"}, Variadic: false},
                        },
                        Handler:     stringPosition,
                        Description: "返回子串位置（position的别名）",
                        Example:     "LOCATE('ll', 'hello') -&gt; 3",
                        Category:    "string",
                },
                {
                        Name: "instr",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "instr", ReturnType: "integer", ParamTypes: []string{"string", "string"}, Variadic: false},
                        },
                        Handler:     stringInstr,
                        Description: "返回子串位置",
                        Example:     "INSTR('hello', 'll') -&gt; 3",
                        Category:    "string",
                },
                {
                        Name: "ascii",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ascii", ReturnType: "integer", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringASCII,
                        Description: "返回字符的ASCII值",
                        Example:     "ASCII('A') -&gt; 65",
                        Category:    "string",
                },
                {
                        Name: "ord",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "ord", ReturnType: "integer", ParamTypes: []string{"string"}, Variadic: false},
                        },
                        Handler:     stringASCII,
                        Description: "返回字符的ASCII值",
                        Example:     "ORD('A') -&gt; 65",
                        Category:    "string",
                },
                {
                        Name: "space",
                        Type: FunctionTypeScalar,
                        Signatures: []FunctionSignature{
                                {Name: "space", ReturnType: "string", ParamTypes: []string{"integer"}, Variadic: false},
                        },
                        Handler:     stringSpace,
                        Description: "返回指定数量的空格",
                        Example:     "SPACE(5) -&gt; '     '",
                        Category:    "string",
                },
        }

        for _, fn := range stringFunctions </span><span class="cov8" title="1">{
                RegisterGlobal(fn)
        }</span>
}

// 辅助函数：将参数转换为字符串
func toString(arg interface{}) string <span class="cov8" title="1">{
        switch v := arg.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case []byte:<span class="cov8" title="1">
                return string(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

// 辅助函数：将参数转换为整数
func toInt64(arg interface{}) (int64, error) <span class="cov8" title="1">{
        switch v := arg.(type) </span>{
        case int:<span class="cov8" title="1">
                return int64(v), nil</span>
        case int64:<span class="cov8" title="1">
                return v, nil</span>
        case int32:<span class="cov8" title="1">
                return int64(v), nil</span>
        case float64:<span class="cov8" title="1">
                return int64(v), nil</span>
        case float32:<span class="cov8" title="1">
                return int64(v), nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot convert %T to int64", arg)</span>
        }
}

// 字符串函数实现
func stringConcat(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        
        <span class="cov8" title="1">result := ""
        for _, arg := range args </span><span class="cov8" title="1">{
                result += toString(arg)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func stringConcatWS(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">separator := toString(args[0])
        if len(args) == 1 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">result := toString(args[1])
        for i := 2; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                result += separator + toString(args[i])
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func stringLength(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("length() requires exactly 1 argument")
        }</span>
        <span class="cov8" title="1">return int64(len(toString(args[0]))), nil</span>
}

func stringUpper(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("upper() requires exactly 1 argument")
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(toString(args[0])), nil</span>
}

func stringLower(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lower() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">return strings.ToLower(toString(args[0])), nil</span>
}

func stringTrim(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trim() requires exactly 1 argument")
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(toString(args[0])), nil</span>
}

func stringLTrim(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ltrim() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">return strings.TrimLeftFunc(toString(args[0]), unicode.IsSpace), nil</span>
}

func stringRTrim(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rtrim() requires exactly 1 argument")
        }</span>
        <span class="cov0" title="0">return strings.TrimRightFunc(toString(args[0]), unicode.IsSpace), nil</span>
}

func stringLeft(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        length, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                length = 0
        }</span>
        <span class="cov0" title="0">if int64(len(str)) &lt; length </span><span class="cov0" title="0">{
                length = int64(len(str))
        }</span>
        
        <span class="cov0" title="0">return str[:length], nil</span>
}

func stringRight(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        length, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                length = 0
        }</span>
        <span class="cov0" title="0">if int64(len(str)) &lt; length </span><span class="cov0" title="0">{
                length = int64(len(str))
        }</span>
        
        <span class="cov0" title="0">return str[len(str)-int(length):], nil</span>
}

func stringSubstring(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("substring() requires 2 or 3 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        start, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">length := int64(len(str))
        if length == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        // SQL中索引从1开始
        <span class="cov0" title="0">if start &lt; 1 </span><span class="cov0" title="0">{
                start = 1
        }</span>
        
        <span class="cov0" title="0">startPos := start - 1
        if startPos &gt;= length </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">if len(args) == 3 </span><span class="cov0" title="0">{
                subLen, err := toInt64(args[2])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                <span class="cov0" title="0">if subLen &lt; 0 </span><span class="cov0" title="0">{
                        subLen = 0
                }</span>
                
                <span class="cov0" title="0">endPos := startPos + subLen
                if endPos &gt; length </span><span class="cov0" title="0">{
                        endPos = length
                }</span>
                
                <span class="cov0" title="0">return str[startPos:endPos], nil</span>
        }
        
        <span class="cov0" title="0">return str[startPos:], nil</span>
}

func stringReplace(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("replace() requires exactly 3 arguments")
        }</span>
        
        <span class="cov8" title="1">str := toString(args[0])
        oldStr := toString(args[1])
        newStr := toString(args[2])
        
        return strings.ReplaceAll(str, oldStr, newStr), nil</span>
}

func stringRepeat(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repeat() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        count, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if count &lt;= 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">return strings.Repeat(str, int(count)), nil</span>
}

func stringReverse(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reverse() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        runes := []rune(str)
        
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        
        <span class="cov0" title="0">return string(runes), nil</span>
}

func stringLPad(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lpad() requires exactly 3 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        length, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">padStr := toString(args[2])
        if len(padStr) == 0 </span><span class="cov0" title="0">{
                return str, nil
        }</span>
        
        <span class="cov0" title="0">if int64(len(str)) &gt;= length </span><span class="cov0" title="0">{
                return str[:length], nil
        }</span>
        
        <span class="cov0" title="0">paddingNeeded := int(length) - len(str)
        padding := ""
        for len(padding) &lt; paddingNeeded </span><span class="cov0" title="0">{
                padding += padStr
        }</span>
        
        <span class="cov0" title="0">return padding[:paddingNeeded] + str, nil</span>
}

func stringRPad(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rpad() requires exactly 3 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        length, err := toInt64(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">padStr := toString(args[2])
        if len(padStr) == 0 </span><span class="cov0" title="0">{
                return str, nil
        }</span>
        
        <span class="cov0" title="0">if int64(len(str)) &gt;= length </span><span class="cov0" title="0">{
                return str[:length], nil
        }</span>
        
        <span class="cov0" title="0">paddingNeeded := int(length) - len(str)
        padding := ""
        for len(padding) &lt; paddingNeeded </span><span class="cov0" title="0">{
                padding += padStr
        }</span>
        
        <span class="cov0" title="0">return str + padding[:paddingNeeded], nil</span>
}

func stringPosition(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("position() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">substr := toString(args[0])
        str := toString(args[1])
        
        index := strings.Index(str, substr)
        if index == -1 </span><span class="cov0" title="0">{
                return int64(0), nil
        }</span>
        
        // SQL中位置从1开始
        <span class="cov0" title="0">return int64(index + 1), nil</span>
}

func stringInstr(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instr() requires exactly 2 arguments")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        substr := toString(args[1])
        
        index := strings.Index(str, substr)
        if index == -1 </span><span class="cov0" title="0">{
                return int64(0), nil
        }</span>
        
        // SQL中位置从1开始
        <span class="cov0" title="0">return int64(index + 1), nil</span>
}

func stringASCII(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ascii() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">str := toString(args[0])
        if len(str) == 0 </span><span class="cov0" title="0">{
                return int64(0), nil
        }</span>
        
        <span class="cov0" title="0">return int64(str[0]), nil</span>
}

func stringSpace(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("space() requires exactly 1 argument")
        }</span>
        
        <span class="cov0" title="0">count, err := toInt64(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if count &lt;= 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">return strings.Repeat(" ", int(count)), nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package builtin

import (
        "fmt"
        "regexp"
        "strings"
        "sync"
        "text/template"
        "time"
)

// ==================== UDF 定义 ====================

// UDFMetadata 用户自定义函数元数据
type UDFMetadata struct {
        Name        string            // 函数名称
        Parameters  []UDFParameter    // 参数列表
        ReturnType  string            // 返回类型
        Body        string            // 函数体（SQL表达式或计算逻辑）
        Determinism bool              // 是否确定性的（相同输入总是产生相同输出）
        Description string            // 函数描述
        CreatedAt   time.Time         // 创建时间
        ModifiedAt  time.Time         // 修改时间
        Author      string            // 创建者
        Language    string            // 语言（SQL, GO等）
}

// UDFParameter UDF参数定义
type UDFParameter struct {
        Name     string // 参数名称
        Type     string // 参数类型
        Optional bool   // 是否可选
        Required bool   // 是否必需（默认false）
        Default  interface{} // 默认值
}

// UDFFunction 用户自定义函数
type UDFFunction struct {
        Metadata *UDFMetadata
        Handler  UDFHandler
}

// UDFHandler UDF处理函数类型
type UDFHandler func(args []interface{}) (interface{}, error)

// UDFManager UDF管理器
type UDFManager struct {
        functions map[string]*UDFFunction
        mu        sync.RWMutex
}

// ==================== UDF 管理器 ====================

// NewUDFManager 创建UDF管理器
func NewUDFManager() *UDFManager <span class="cov0" title="0">{
        return &amp;UDFManager{
                functions: make(map[string]*UDFFunction),
        }
}</span>

// Register 注册UDF
func (m *UDFManager) Register(udf *UDFFunction) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if udf.Metadata.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("function name cannot be empty")
        }</span>

        // 检查是否已存在
        <span class="cov0" title="0">if _, exists := m.functions[strings.ToLower(udf.Metadata.Name)]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("function '%s' already exists", udf.Metadata.Name)
        }</span>

        // 编译函数体
        <span class="cov0" title="0">handler, err := m.compileUDF(udf.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compile function body: %w", err)
        }</span>

        <span class="cov0" title="0">udf.Handler = handler
        udf.Metadata.CreatedAt = time.Now()
        udf.Metadata.ModifiedAt = time.Now()

        m.functions[strings.ToLower(udf.Metadata.Name)] = udf
        return nil</span>
}

// Unregister 注销UDF
func (m *UDFManager) Unregister(name string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        key := strings.ToLower(name)
        if _, exists := m.functions[key]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("function '%s' not found", name)
        }</span>

        <span class="cov0" title="0">delete(m.functions, key)
        return nil</span>
}

// Get 获取UDF
func (m *UDFManager) Get(name string) (*UDFFunction, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        udf, exists := m.functions[strings.ToLower(name)]
        return udf, exists
}</span>

// List 列出所有UDF
func (m *UDFManager) List() []*UDFFunction <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make([]*UDFFunction, 0, len(m.functions))
        for _, udf := range m.functions </span><span class="cov0" title="0">{
                result = append(result, udf)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Exists 检查函数是否存在
func (m *UDFManager) Exists(name string) bool <span class="cov0" title="0">{
        _, exists := m.Get(name)
        return exists
}</span>

// Count 返回UDF数量
func (m *UDFManager) Count() int <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return len(m.functions)
}</span>

// Clear 清除所有UDF
func (m *UDFManager) Clear() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.functions = make(map[string]*UDFFunction)
}</span>

// ==================== UDF 编译和执行 ====================

// compileUDF 编译UDF函数体
func (m *UDFManager) compileUDF(meta *UDFMetadata) (UDFHandler, error) <span class="cov0" title="0">{
        if meta.Language == "" </span><span class="cov0" title="0">{
                meta.Language = "SQL"
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(meta.Language) </span>{
        case "SQL":<span class="cov0" title="0">
                return m.compileSQLExpression(meta)</span>
        case "GO":<span class="cov0" title="0">
                return m.compileGoExpression(meta)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported language: %s", meta.Language)</span>
        }
}

// compileSQLExpression 编译SQL表达式
func (m *UDFManager) compileSQLExpression(meta *UDFMetadata) (UDFHandler, error) <span class="cov0" title="0">{
        // 解析SQL表达式，检查语法
        expr := strings.TrimSpace(meta.Body)
        
        // 简单表达式：直接返回值
        if m.isSimpleExpression(expr) </span><span class="cov0" title="0">{
                return func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return m.evaluateSimpleExpression(expr, args, meta.Parameters)
                }</span>, nil
        }

        // 函数调用：调用内置函数
        <span class="cov0" title="0">if m.isFunctionCall(expr) </span><span class="cov0" title="0">{
                return m.compileFunctionCall(expr, meta)
        }</span>

        // 算术表达式
        <span class="cov0" title="0">if m.isArithmeticExpression(expr) </span><span class="cov0" title="0">{
                return func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return m.evaluateArithmeticExpression(expr, args, meta.Parameters)
                }</span>, nil
        }

        // 复杂表达式：使用模板引擎
        <span class="cov0" title="0">return m.compileTemplateExpression(meta)</span>
}

// compileGoExpression 编译Go表达式（简单实现）
func (m *UDFManager) compileGoExpression(meta *UDFMetadata) (UDFHandler, error) <span class="cov0" title="0">{
        // 这里可以实现更复杂的Go代码编译
        // 目前仅支持简单的算术表达式
        expr := strings.TrimSpace(meta.Body)
        
        return func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return m.evaluateArithmeticExpression(expr, args, meta.Parameters)
        }</span>, nil
}

// compileTemplateExpression 编译模板表达式
func (m *UDFManager) compileTemplateExpression(meta *UDFMetadata) (UDFHandler, error) <span class="cov0" title="0">{
        tmpl, err := template.New("udf").Parse(meta.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov0" title="0">return func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                // 构建模板数据
                data := make(map[string]interface{})
                for i, param := range meta.Parameters </span><span class="cov0" title="0">{
                        if i &lt; len(args) </span><span class="cov0" title="0">{
                                data[param.Name] = args[i]
                        }</span> else<span class="cov0" title="0"> if param.Default != nil </span><span class="cov0" title="0">{
                                data[param.Name] = param.Default
                        }</span> else<span class="cov0" title="0"> {
                                data[param.Name] = nil
                        }</span>
                }

                <span class="cov0" title="0">var buf strings.Builder
                if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("template execution failed: %w", err)
                }</span>

                <span class="cov0" title="0">return buf.String(), nil</span>
        }, nil
}

// ==================== 表达式求值 ====================

// isSimpleExpression 检查是否为简单表达式
func (m *UDFManager) isSimpleExpression(expr string) bool <span class="cov0" title="0">{
        // 参数引用：@param 或 :param
        re := regexp.MustCompile(`^@?\w+$`)
        return re.MatchString(expr)
}</span>

// isFunctionCall 检查是否为函数调用
func (m *UDFManager) isFunctionCall(expr string) bool <span class="cov0" title="0">{
        re := regexp.MustCompile(`^\w+\(.*\)$`)
        return re.MatchString(expr)
}</span>

// isArithmeticExpression 检查是否为算术表达式
func (m *UDFManager) isArithmeticExpression(expr string) bool <span class="cov0" title="0">{
        // 包含运算符且不是函数调用
        if m.isFunctionCall(expr) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">operators := []string{"+", "-", "*", "/", "%", "^"}
        for _, op := range operators </span><span class="cov0" title="0">{
                if strings.Contains(expr, op) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// evaluateSimpleExpression 求值简单表达式
func (m *UDFManager) evaluateSimpleExpression(expr string, args []interface{}, params []UDFParameter) (interface{}, error) <span class="cov0" title="0">{
        // 移除前缀
        expr = strings.TrimPrefix(expr, "@")
        expr = strings.TrimPrefix(expr, ":")
        
        // 查找参数
        for i, param := range params </span><span class="cov0" title="0">{
                if strings.EqualFold(param.Name, expr) </span><span class="cov0" title="0">{
                        if i &lt; len(args) </span><span class="cov0" title="0">{
                                return args[i], nil
                        }</span>
                        <span class="cov0" title="0">if param.Default != nil </span><span class="cov0" title="0">{
                                return param.Default, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("parameter '%s' not provided and no default value", expr)</span>
                }
        }
        
        <span class="cov0" title="0">return nil, fmt.Errorf("parameter '%s' not found", expr)</span>
}

// compileFunctionCall 编译函数调用
func (m *UDFManager) compileFunctionCall(expr string, meta *UDFMetadata) (UDFHandler, error) <span class="cov0" title="0">{
        // 提取函数名和参数
        re := regexp.MustCompile(`^(\w+)\((.*)\)$`)
        matches := re.FindStringSubmatch(expr)
        if len(matches) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid function call: %s", expr)
        }</span>

        <span class="cov0" title="0">funcName := matches[1]
        argsExpr := matches[2]
        
        return func(args []interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                // 检查是否是内置函数
                if info, exists := GetGlobal(funcName); exists </span><span class="cov0" title="0">{
                        // 解析参数
                        argValues, err := m.parseFunctionArgs(argsExpr, args, meta.Parameters)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return info.Handler(argValues)</span>
                }

                // 检查是否是其他UDF
                // 这里暂不实现UDF递归调用
                
                <span class="cov0" title="0">return nil, fmt.Errorf("function '%s' not found", funcName)</span>
        }, nil
}

// parseFunctionArgs 解析函数参数
func (m *UDFManager) parseFunctionArgs(argsExpr string, udfArgs []interface{}, params []UDFParameter) ([]interface{}, error) <span class="cov0" title="0">{
        if argsExpr == "" </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        // 简单分割，实际应该更复杂
        <span class="cov0" title="0">args := strings.Split(argsExpr, ",")
        result := make([]interface{}, 0, len(args))

        for _, arg := range args </span><span class="cov0" title="0">{
                arg = strings.TrimSpace(arg)
                
                // 检查是否是参数引用
                if m.isSimpleExpression(arg) </span><span class="cov0" title="0">{
                        val, err := m.evaluateSimpleExpression(arg, udfArgs, params)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, val)</span>
                } else<span class="cov0" title="0"> {
                        // 字面量
                        result = append(result, arg)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// evaluateArithmeticExpression 求值算术表达式
func (m *UDFManager) evaluateArithmeticExpression(expr string, args []interface{}, params []UDFParameter) (interface{}, error) <span class="cov0" title="0">{
        // 简单实现：替换参数，然后求值
        // 实际应该使用表达式解析器
        
        result := expr
        
        // 替换参数
        for i, param := range params </span><span class="cov0" title="0">{
                // 替换 @param 或 :param
                result = strings.ReplaceAll(result, "@"+param.Name, fmt.Sprintf("%v", args[i]))
                result = strings.ReplaceAll(result, ":"+param.Name, fmt.Sprintf("%v", args[i]))
        }</span>
        
        // 简单的算术求值（仅支持基础运算）
        // 实际应该使用表达式求值器
        <span class="cov0" title="0">if strings.Contains(result, "+") </span><span class="cov0" title="0">{
                parts := strings.Split(result, "+")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        val1, err1 := ToFloat64(strings.TrimSpace(parts[0]))
                        val2, err2 := ToFloat64(strings.TrimSpace(parts[1]))
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                return val1 + val2, nil
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if strings.Contains(result, "-") </span><span class="cov0" title="0">{
                parts := strings.Split(result, "-")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        val1, err1 := ToFloat64(strings.TrimSpace(parts[0]))
                        val2, err2 := ToFloat64(strings.TrimSpace(parts[1]))
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                return val1 - val2, nil
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if strings.Contains(result, "*") </span><span class="cov0" title="0">{
                parts := strings.Split(result, "*")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        val1, err1 := ToFloat64(strings.TrimSpace(parts[0]))
                        val2, err2 := ToFloat64(strings.TrimSpace(parts[1]))
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                return val1 * val2, nil
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if strings.Contains(result, "/") </span><span class="cov0" title="0">{
                parts := strings.Split(result, "/")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        val1, err1 := ToFloat64(strings.TrimSpace(parts[0]))
                        val2, err2 := ToFloat64(strings.TrimSpace(parts[1]))
                        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; val2 != 0 </span><span class="cov0" title="0">{
                                return val1 / val2, nil
                        }</span>
                }
        }

        // 如果无法求值，返回原始字符串
        <span class="cov0" title="0">return result, nil</span>
}

// ==================== 全局 UDF 管理器 ====================

var (
        globalUDFManager *UDFManager
        udfOnce         sync.Once
)

// GetGlobalUDFManager 获取全局UDF管理器
func GetGlobalUDFManager() *UDFManager <span class="cov0" title="0">{
        udfOnce.Do(func() </span><span class="cov0" title="0">{
                globalUDFManager = NewUDFManager()
        }</span>)
        <span class="cov0" title="0">return globalUDFManager</span>
}

// ==================== UDF 构建器 ====================

// UDFBuilder UDF构建器
type UDFBuilder struct {
        metadata *UDFMetadata
}

// NewUDFBuilder 创建UDF构建器
func NewUDFBuilder(name string) *UDFBuilder <span class="cov0" title="0">{
        return &amp;UDFBuilder{
                metadata: &amp;UDFMetadata{
                        Name:        name,
                        Language:    "SQL",
                        Determinism: true,
                        CreatedAt:   time.Now(),
                        ModifiedAt:  time.Now(),
                },
        }
}</span>

// WithParameter 添加参数
func (b *UDFBuilder) WithParameter(name, typ string, optional bool) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Parameters = append(b.metadata.Parameters, UDFParameter{
                Name:     name,
                Type:     typ,
                Optional: optional,
        })
        return b
}</span>

// WithReturnType 设置返回类型
func (b *UDFBuilder) WithReturnType(typ string) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.ReturnType = typ
        return b
}</span>

// WithBody 设置函数体
func (b *UDFBuilder) WithBody(body string) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Body = body
        return b
}</span>

// WithLanguage 设置语言
func (b *UDFBuilder) WithLanguage(lang string) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Language = lang
        return b
}</span>

// WithDeterminism 设置确定性
func (b *UDFBuilder) WithDeterminism(determinism bool) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Determinism = determinism
        return b
}</span>

// WithDescription 设置描述
func (b *UDFBuilder) WithDescription(desc string) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Description = desc
        return b
}</span>

// WithAuthor 设置作者
func (b *UDFBuilder) WithAuthor(author string) *UDFBuilder <span class="cov0" title="0">{
        b.metadata.Author = author
        return b
}</span>

// Build 构建UDF
func (b *UDFBuilder) Build() *UDFFunction <span class="cov0" title="0">{
        return &amp;UDFFunction{
                Metadata: b.metadata,
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// Config 应用程序配置
type Config struct {
        Server        ServerConfig        `json:"server"`
        Database      DatabaseConfig      `json:"database"`
        Log           LogConfig           `json:"log"`
        Pool          PoolConfig          `json:"pool"`
        Cache         CacheConfig         `json:"cache"`
        Monitor       MonitorConfig       `json:"monitor"`
        Connection    ConnectionConfig    `json:"connection"`
        MVCC          MVCCConfig          `json:"mvcc"`
        Session       SessionConfig       `json:"session"`
        Optimizer     OptimizerConfig     `json:"optimizer"`
}

// ServerConfig 服务器配置
type ServerConfig struct {
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        ServerVersion   string        `json:"server_version"`
        KeepAlivePeriod time.Duration `json:"keep_alive_period"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
        MaxConnections int      `json:"max_connections"`
        IdleTimeout   int      `json:"idle_timeout"` // seconds
        EnabledSources []string `json:"enabled_sources"` // 启用的数据源类型，核心版本可以只启用部分
}

// LogConfig 日志配置
type LogConfig struct {
        Level  string `json:"level"`
        Format string `json:"format"` // json or text
}

// PoolConfig 池配置
type PoolConfig struct {
        GoroutinePool GoroutinePoolConfig `json:"goroutine_pool"`
        ObjectPool    ObjectPoolConfig    `json:"object_pool"`
}

// GoroutinePoolConfig goroutine池配置
type GoroutinePoolConfig struct {
        MaxWorkers int `json:"max_workers"`
        QueueSize  int `json:"queue_size"`
}

// ObjectPoolConfig 对象池配置
type ObjectPoolConfig struct {
        MaxSize int `json:"max_size"`
        MinIdle int `json:"min_idle"`
        MaxIdle int `json:"max_idle"`
}

// CacheConfig 缓存配置
type CacheConfig struct {
        QueryCache  CachePoolConfig `json:"query_cache"`
        ResultCache CachePoolConfig `json:"result_cache"`
        SchemaCache CachePoolConfig `json:"schema_cache"`
}

// CachePoolConfig 缓存池配置
type CachePoolConfig struct {
        MaxSize int           `json:"max_size"`
        TTL     time.Duration `json:"ttl"`
}

// MonitorConfig 监控配置
type MonitorConfig struct {
        SlowQuery SlowQueryConfig `json:"slow_query"`
}

// SlowQueryConfig 慢查询配置
type SlowQueryConfig struct {
        Threshold  time.Duration `json:"threshold"`
        MaxEntries int           `json:"max_entries"`
}

// ConnectionConfig 连接池配置
type ConnectionConfig struct {
        MaxOpen     int           `json:"max_open"`
        MaxIdle     int           `json:"max_idle"`
        Lifetime    time.Duration `json:"lifetime"`
        IdleTimeout time.Duration `json:"idle_timeout"`
}

// MVCCConfig MVCC配置
type MVCCConfig struct {
        EnableWarning      bool          `json:"enable_warning"`
        AutoDowngrade      bool          `json:"auto_downgrade"`
        GCInterval         time.Duration `json:"gc_interval"`
        GCAgeThreshold     time.Duration `json:"gc_age_threshold"`
        XIDWrapThreshold   uint32        `json:"xid_wrap_threshold"`
        MaxActiveTxns      int           `json:"max_active_txns"`
}

// SessionConfig 会话配置
type SessionConfig struct {
        MaxAge       time.Duration `json:"max_age"`
        GCInterval   time.Duration `json:"gc_interval"`
}

// OptimizerConfig 优化器配置
type OptimizerConfig struct {
        Enabled bool `json:"enabled"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:            "0.0.0.0",
                        Port:            3306,
                        ServerVersion:   "SqlExc",
                        KeepAlivePeriod: 30 * time.Second,
                },
                Database: DatabaseConfig{
                        MaxConnections: 100,
                        IdleTimeout:    3600,
                        EnabledSources: []string{
                                "memory",
                                "csv",
                                "excel",
                                "json",
                                "mysql",
                                "sqlite",
                                "parquet",
                        },
                },
                Log: LogConfig{
                        Level:  "info",
                        Format: "text",
                },
                Pool: PoolConfig{
                        GoroutinePool: GoroutinePoolConfig{
                                MaxWorkers: 10,
                                QueueSize:  1000,
                        },
                        ObjectPool: ObjectPoolConfig{
                                MaxSize: 100,
                                MinIdle: 2,
                                MaxIdle: 50,
                        },
                },
                Cache: CacheConfig{
                        QueryCache: CachePoolConfig{
                                MaxSize: 1000,
                                TTL:     5 * time.Minute,
                        },
                        ResultCache: CachePoolConfig{
                                MaxSize: 1000,
                                TTL:     10 * time.Minute,
                        },
                        SchemaCache: CachePoolConfig{
                                MaxSize: 100,
                                TTL:     1 * time.Hour,
                        },
                },
                Monitor: MonitorConfig{
                        SlowQuery: SlowQueryConfig{
                                Threshold:  1 * time.Second,
                                MaxEntries: 1000,
                        },
                },
                Connection: ConnectionConfig{
                        MaxOpen:     10,
                        MaxIdle:     5,
                        Lifetime:    30 * time.Minute,
                        IdleTimeout: 5 * time.Minute,
                },
                MVCC: MVCCConfig{
                        EnableWarning:      true,
                        AutoDowngrade:      true,
                        GCInterval:         5 * time.Minute,
                        GCAgeThreshold:     1 * time.Hour,
                        XIDWrapThreshold:   100000,
                        MaxActiveTxns:      10000,
                },
                Session: SessionConfig{
                        MaxAge:     24 * time.Hour,
                        GCInterval: 1 * time.Minute,
                },
                Optimizer: OptimizerConfig{
                        Enabled: true,
                },
        }
}</span>

// LoadConfig 从文件加载配置
func LoadConfig(configPath string) (*Config, error) <span class="cov8" title="1">{
        // 如果没有指定配置文件，使用默认配置
        if configPath == "" </span><span class="cov8" title="1">{
                return DefaultConfig(), nil
        }</span>

        // 检查配置文件是否存在
        <span class="cov8" title="1">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("配置文件不存在: %s", configPath)
        }</span>

        // 读取配置文件
        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("读取配置文件失败: %w", err)
        }</span>

        // 解析配置
        <span class="cov8" title="1">config := DefaultConfig()
        if err := json.Unmarshal(data, config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("解析配置文件失败: %w", err)
        }</span>

        // 验证配置
        <span class="cov8" title="1">if err := validateConfig(config); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// LoadConfigOrDefault 尝试从常见位置加载配置文件
func LoadConfigOrDefault() *Config <span class="cov8" title="1">{
        // 尝试的配置文件路径
        possiblePaths := []string{
                "config.json",
                "./config/config.json",
                "/etc/sqlexec/config.json",
        }

        // 尝试从环境变量获取配置文件路径
        if envPath := os.Getenv("SQLEXEC_CONFIG"); envPath != "" </span><span class="cov8" title="1">{
                if config, err := LoadConfig(envPath); err == nil </span><span class="cov8" title="1">{
                        return config
                }</span>
        }

        // 尝试从常见位置加载
        <span class="cov8" title="1">for _, path := range possiblePaths </span><span class="cov8" title="1">{
                if absPath, err := filepath.Abs(path); err == nil </span><span class="cov8" title="1">{
                        if config, err := LoadConfig(absPath); err == nil </span><span class="cov8" title="1">{
                                return config
                        }</span>
                }
        }

        // 使用默认配置
        <span class="cov8" title="1">return DefaultConfig()</span>
}

// validateConfig 验证配置
func validateConfig(config *Config) error <span class="cov8" title="1">{
        if config.Server.Port &lt; 1 || config.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("无效的端口号: %d", config.Server.Port)
        }</span>

        <span class="cov8" title="1">if config.Database.MaxConnections &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("最大连接数必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Pool.GoroutinePool.MaxWorkers &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("Goroutine池最大工作线程数必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Pool.GoroutinePool.QueueSize &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("Goroutine池队列大小必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Pool.ObjectPool.MaxSize &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("对象池最大大小必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Pool.ObjectPool.MinIdle &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("对象池最小空闲数不能为负数")
        }</span>

        <span class="cov8" title="1">if config.Pool.ObjectPool.MaxIdle &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("对象池最大空闲数必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Connection.MaxOpen &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("连接池最大连接数必须大于0")
        }</span>

        <span class="cov8" title="1">if config.Connection.MaxIdle &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("连接池最大空闲连接数必须大于0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetListenAddress 返回监听地址
func (c *Config) GetListenAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package extensibility

import (
        "fmt"
        "sync"
)

// Plugin 插件接口
type Plugin interface {
        // Name 返回插件名称
        Name() string
        // Version 返回插件版本
        Version() string
        // Initialize 初始化插件
        Initialize(config map[string]interface{}) error
        // Start 启动插件
        Start() error
        // Stop 停止插件
        Stop() error
        // IsRunning 检查插件是否运行中
        IsRunning() bool
}

// DataSourcePlugin 数据源插件接口
type DataSourcePlugin interface {
        Plugin
        // Connect 连接数据源
        Connect(connectionString string) (interface{}, error)
        // Disconnect 断开连接
        Disconnect(conn interface{}) error
        // Query 执行查询
        Query(conn interface{}, query string, params []interface{}) (interface{}, error)
        // Execute 执行命令
        Execute(conn interface{}, command string, params []interface{}) (int64, error)
}

// FunctionPlugin 函数插件接口
type FunctionPlugin interface {
        Plugin
        // Register 注册函数
        Register(name string, fn interface{}) error
        // Unregister 注销函数
        Unregister(name string) error
        // Call 调用函数
        Call(name string, args []interface{}) (interface{}, error)
        // GetFunction 获取函数
        GetFunction(name string) (interface{}, error)
        // ListFunctions 列出所有函数
        ListFunctions() []string
}

// MonitorPlugin 监控插件接口
type MonitorPlugin interface {
        Plugin
        // RecordMetric 记录指标
        RecordMetric(name string, value float64, tags map[string]string)
        // RecordEvent 记录事件
        RecordEvent(name string, data map[string]interface{})
        // GetMetric 获取指标值
        GetMetric(name string) (float64, error)
        // GetMetrics 获取所有指标
        GetMetrics() map[string]float64
}

// PluginManager 插件管理器
type PluginManager struct {
        dataSourcePlugins map[string]DataSourcePlugin
        functionPlugins   map[string]FunctionPlugin
        monitorPlugins    map[string]MonitorPlugin
        mu                sync.RWMutex
}

// NewPluginManager 创建插件管理器
func NewPluginManager() *PluginManager <span class="cov8" title="1">{
        return &amp;PluginManager{
                dataSourcePlugins: make(map[string]DataSourcePlugin),
                functionPlugins:   make(map[string]FunctionPlugin),
                monitorPlugins:    make(map[string]MonitorPlugin),
        }
}</span>

// RegisterDataSourcePlugin 注册数据源插件
func (pm *PluginManager) RegisterDataSourcePlugin(plugin DataSourcePlugin, config map[string]interface{}) error <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        name := plugin.Name()
        if _, exists := pm.dataSourcePlugins[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("data source plugin '%s' already registered", name)
        }</span>

        // 初始化插件
        <span class="cov8" title="1">if err := plugin.Initialize(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize plugin '%s': %w", name, err)
        }</span>

        <span class="cov8" title="1">pm.dataSourcePlugins[name] = plugin
        return nil</span>
}

// RegisterFunctionPlugin 注册函数插件
func (pm *PluginManager) RegisterFunctionPlugin(plugin FunctionPlugin, config map[string]interface{}) error <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        name := plugin.Name()
        if _, exists := pm.functionPlugins[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("function plugin '%s' already registered", name)
        }</span>

        // 初始化插件
        <span class="cov8" title="1">if err := plugin.Initialize(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize plugin '%s': %w", name, err)
        }</span>

        <span class="cov8" title="1">pm.functionPlugins[name] = plugin
        return nil</span>
}

// RegisterMonitorPlugin 注册监控插件
func (pm *PluginManager) RegisterMonitorPlugin(plugin MonitorPlugin, config map[string]interface{}) error <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        name := plugin.Name()
        if _, exists := pm.monitorPlugins[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("monitor plugin '%s' already registered", name)
        }</span>

        // 初始化插件
        <span class="cov8" title="1">if err := plugin.Initialize(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize plugin '%s': %w", name, err)
        }</span>

        <span class="cov8" title="1">pm.monitorPlugins[name] = plugin
        return nil</span>
}

// UnregisterPlugin 注销插件
func (pm *PluginManager) UnregisterPlugin(name string) error <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        // 尝试注销数据源插件
        if plugin, ok := pm.dataSourcePlugins[name]; ok </span><span class="cov8" title="1">{
                if plugin.IsRunning() </span><span class="cov8" title="1">{
                        plugin.Stop()
                }</span>
                <span class="cov8" title="1">delete(pm.dataSourcePlugins, name)
                return nil</span>
        }

        // 尝试注销函数插件
        <span class="cov8" title="1">if plugin, ok := pm.functionPlugins[name]; ok </span><span class="cov0" title="0">{
                if plugin.IsRunning() </span><span class="cov0" title="0">{
                        plugin.Stop()
                }</span>
                <span class="cov0" title="0">delete(pm.functionPlugins, name)
                return nil</span>
        }

        // 尝试注销监控插件
        <span class="cov8" title="1">if plugin, ok := pm.monitorPlugins[name]; ok </span><span class="cov0" title="0">{
                if plugin.IsRunning() </span><span class="cov0" title="0">{
                        plugin.Stop()
                }</span>
                <span class="cov0" title="0">delete(pm.monitorPlugins, name)
                return nil</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("plugin '%s' not found", name)</span>
}

// StartPlugin 启动插件
func (pm *PluginManager) StartPlugin(name string) error <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        // 尝试启动数据源插件
        if plugin, ok := pm.dataSourcePlugins[name]; ok </span><span class="cov8" title="1">{
                return plugin.Start()
        }</span>

        // 尝试启动函数插件
        <span class="cov8" title="1">if plugin, ok := pm.functionPlugins[name]; ok </span><span class="cov0" title="0">{
                return plugin.Start()
        }</span>

        // 尝试启动监控插件
        <span class="cov8" title="1">if plugin, ok := pm.monitorPlugins[name]; ok </span><span class="cov0" title="0">{
                return plugin.Start()
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("plugin '%s' not found", name)</span>
}

// StopPlugin 停止插件
func (pm *PluginManager) StopPlugin(name string) error <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        // 尝试停止数据源插件
        if plugin, ok := pm.dataSourcePlugins[name]; ok </span><span class="cov8" title="1">{
                return plugin.Stop()
        }</span>

        // 尝试停止函数插件
        <span class="cov8" title="1">if plugin, ok := pm.functionPlugins[name]; ok </span><span class="cov0" title="0">{
                return plugin.Stop()
        }</span>

        // 尝试停止监控插件
        <span class="cov8" title="1">if plugin, ok := pm.monitorPlugins[name]; ok </span><span class="cov0" title="0">{
                return plugin.Stop()
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("plugin '%s' not found", name)</span>
}

// GetDataSourcePlugin 获取数据源插件
func (pm *PluginManager) GetDataSourcePlugin(name string) (DataSourcePlugin, error) <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        plugin, ok := pm.dataSourcePlugins[name]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data source plugin '%s' not found", name)
        }</span>

        <span class="cov8" title="1">return plugin, nil</span>
}

// GetFunctionPlugin 获取函数插件
func (pm *PluginManager) GetFunctionPlugin(name string) (FunctionPlugin, error) <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        plugin, ok := pm.functionPlugins[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function plugin '%s' not found", name)
        }</span>

        <span class="cov8" title="1">return plugin, nil</span>
}

// GetMonitorPlugin 获取监控插件
func (pm *PluginManager) GetMonitorPlugin(name string) (MonitorPlugin, error) <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        plugin, ok := pm.monitorPlugins[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("monitor plugin '%s' not found", name)
        }</span>

        <span class="cov8" title="1">return plugin, nil</span>
}

// ListPlugins 列出所有插件
func (pm *PluginManager) ListPlugins() []string <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        plugins := make([]string, 0)

        for name := range pm.dataSourcePlugins </span><span class="cov8" title="1">{
                plugins = append(plugins, name)
        }</span>

        <span class="cov8" title="1">for name := range pm.functionPlugins </span><span class="cov8" title="1">{
                plugins = append(plugins, name)
        }</span>

        <span class="cov8" title="1">for name := range pm.monitorPlugins </span><span class="cov8" title="1">{
                plugins = append(plugins, name)
        }</span>

        <span class="cov8" title="1">return plugins</span>
}

// StartAllPlugins 启动所有插件
func (pm *PluginManager) StartAllPlugins() error <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        // 启动所有数据源插件
        for _, plugin := range pm.dataSourcePlugins </span><span class="cov8" title="1">{
                if err := plugin.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start data source plugin '%s': %w", plugin.Name(), err)
                }</span>
        }

        // 启动所有函数插件
        <span class="cov8" title="1">for _, plugin := range pm.functionPlugins </span><span class="cov8" title="1">{
                if err := plugin.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start function plugin '%s': %w", plugin.Name(), err)
                }</span>
        }

        // 启动所有监控插件
        <span class="cov8" title="1">for _, plugin := range pm.monitorPlugins </span><span class="cov8" title="1">{
                if err := plugin.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start monitor plugin '%s': %w", plugin.Name(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// StopAllPlugins 停止所有插件
func (pm *PluginManager) StopAllPlugins() error <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        // 停止所有数据源插件
        for _, plugin := range pm.dataSourcePlugins </span><span class="cov8" title="1">{
                if plugin.IsRunning() </span><span class="cov8" title="1">{
                        if err := plugin.Stop(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to stop data source plugin '%s': %w", plugin.Name(), err)
                        }</span>
                }
        }

        // 停止所有函数插件
        <span class="cov8" title="1">for _, plugin := range pm.functionPlugins </span><span class="cov8" title="1">{
                if plugin.IsRunning() </span><span class="cov8" title="1">{
                        if err := plugin.Stop(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to stop function plugin '%s': %w", plugin.Name(), err)
                        }</span>
                }
        }

        // 停止所有监控插件
        <span class="cov8" title="1">for _, plugin := range pm.monitorPlugins </span><span class="cov8" title="1">{
                if plugin.IsRunning() </span><span class="cov8" title="1">{
                        if err := plugin.Stop(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to stop monitor plugin '%s': %w", plugin.Name(), err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// BasePlugin 基础插件实现
type BasePlugin struct {
        name    string
        version string
        running bool
        mu      sync.RWMutex
        config  map[string]interface{}
}

// NewBasePlugin 创建基础插件
func NewBasePlugin(name, version string) *BasePlugin <span class="cov8" title="1">{
        return &amp;BasePlugin{
                name:    name,
                version: version,
                running: false,
                config:  make(map[string]interface{}),
        }
}</span>

// Name 返回插件名称
func (bp *BasePlugin) Name() string <span class="cov8" title="1">{
        return bp.name
}</span>

// Version 返回插件版本
func (bp *BasePlugin) Version() string <span class="cov8" title="1">{
        return bp.version
}</span>

// Initialize 初始化插件
func (bp *BasePlugin) Initialize(config map[string]interface{}) error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        bp.config = config
        return nil
}</span>

// Start 启动插件
func (bp *BasePlugin) Start() error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        bp.running = true
        return nil
}</span>

// Stop 停止插件
func (bp *BasePlugin) Stop() error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        bp.running = false
        return nil
}</span>

// IsRunning 检查插件是否运行中
func (bp *BasePlugin) IsRunning() bool <span class="cov8" title="1">{
        bp.mu.RLock()
        defer bp.mu.RUnlock()

        return bp.running
}</span>

// GetConfig 获取配置
func (bp *BasePlugin) GetConfig() map[string]interface{} <span class="cov8" title="1">{
        bp.mu.RLock()
        defer bp.mu.RUnlock()

        config := make(map[string]interface{})
        for k, v := range bp.config </span><span class="cov8" title="1">{
                config[k] = v
        }</span>
        <span class="cov8" title="1">return config</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package information_schema

import (
        "context"
        "fmt"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// ColumnsTable represents information_schema.columns
// It lists all columns across all tables in all data sources
type ColumnsTable struct {
        dsManager *application.DataSourceManager
}

// NewColumnsTable creates a new ColumnsTable
func NewColumnsTable(dsManager *application.DataSourceManager) virtual.VirtualTable <span class="cov0" title="0">{
        return &amp;ColumnsTable{
                dsManager: dsManager,
        }
}</span>

// GetName returns table name
func (t *ColumnsTable) GetName() string <span class="cov0" title="0">{
        return "columns"
}</span>

// GetSchema returns table schema
func (t *ColumnsTable) GetSchema() []domain.ColumnInfo <span class="cov0" title="0">{
        return []domain.ColumnInfo{
                {Name: "table_catalog", Type: "varchar(512)", Nullable: false},
                {Name: "table_schema", Type: "varchar(64)", Nullable: false},
                {Name: "table_name", Type: "varchar(64)", Nullable: false},
                {Name: "column_name", Type: "varchar(64)", Nullable: false},
                {Name: "ordinal_position", Type: "int", Nullable: false},
                {Name: "column_default", Type: "text", Nullable: true},
                {Name: "is_nullable", Type: "varchar(3)", Nullable: false},
                {Name: "data_type", Type: "varchar(64)", Nullable: false},
                {Name: "character_maximum_length", Type: "int", Nullable: true},
                {Name: "character_octet_length", Type: "int", Nullable: true},
                {Name: "numeric_precision", Type: "int", Nullable: true},
                {Name: "numeric_scale", Type: "int", Nullable: true},
                {Name: "datetime_precision", Type: "int", Nullable: true},
                {Name: "character_set_name", Type: "varchar(64)", Nullable: true},
                {Name: "collation_name", Type: "varchar(64)", Nullable: true},
                {Name: "column_type", Type: "varchar(64)", Nullable: false},
                {Name: "column_key", Type: "varchar(10)", Nullable: true},
                {Name: "extra", Type: "varchar(256)", Nullable: true},
                {Name: "privileges", Type: "varchar(80)", Nullable: true},
                {Name: "column_comment", Type: "varchar(1024)", Nullable: true},
                {Name: "generation_expression", Type: "text", Nullable: true},
        }
}</span>

// Query executes a query against columns table
func (t *ColumnsTable) Query(ctx context.Context, filters []domain.Filter, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Get all data source names
        dsNames := t.dsManager.List()

        // Build result rows
        rows := make([]domain.Row, 0)

        for _, dsName := range dsNames </span><span class="cov0" title="0">{
                // Get tables from this data source
                tables, err := t.dsManager.GetTables(ctx, dsName)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip data sources that fail
                        continue</span>
                }

                // Get table info for each table
                <span class="cov0" title="0">for _, tableName := range tables </span><span class="cov0" title="0">{
                        tableInfo, err := t.dsManager.GetTableInfo(ctx, dsName, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip tables that fail
                                continue</span>
                        }

                        // Generate a row for each column
                        <span class="cov0" title="0">for i, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                columnType := t.getColumnType(column)
                                charMaxLen := t.getCharacterMaxLength(column.Type)
                                numPrecision := t.getNumericPrecision(column.Type)

                                extra := ""
                                if column.AutoIncrement </span><span class="cov0" title="0">{
                                        extra = "auto_increment"
                                }</span>

                                <span class="cov0" title="0">columnKey := ""
                                if column.Primary </span><span class="cov0" title="0">{
                                        columnKey = "PRI"
                                }</span> else<span class="cov0" title="0"> if column.Unique </span><span class="cov0" title="0">{
                                        columnKey = "UNI"
                                }</span>

                                <span class="cov0" title="0">nullable := "NO"
                                if column.Nullable </span><span class="cov0" title="0">{
                                        nullable = "YES"
                                }</span>

                                <span class="cov0" title="0">defaultValue := ""
                                if column.Default != "" </span><span class="cov0" title="0">{
                                        defaultValue = column.Default
                                }</span>

                                <span class="cov0" title="0">row := domain.Row{
                                        "table_catalog":          "def",
                                        "table_schema":           dsName,
                                        "table_name":             tableName,
                                        "column_name":            column.Name,
                                        "ordinal_position":        i + 1,
                                        "column_default":         defaultValue,
                                        "is_nullable":             nullable,
                                        "data_type":              t.getDataType(column.Type),
                                        "character_maximum_length": charMaxLen,
                                        "character_octet_length":  charMaxLen * 4, // Assuming UTF-8 (4 bytes per char)
                                        "numeric_precision":       numPrecision,
                                        "numeric_scale":          0,
                                        "datetime_precision":      nil,
                                        "character_set_name":     "utf8mb4",
                                        "collation_name":         "utf8mb4_general_ci",
                                        "column_type":            columnType,
                                        "column_key":             columnKey,
                                        "extra":                 extra,
                                        "privileges":             "select,insert,update,references",
                                        "column_comment":         "",
                                        "generation_expression":   nil,
                                }

                                rows = append(rows, row)</span>
                        }
                }
        }

        // Apply filters if provided
        <span class="cov0" title="0">var err error
        if len(filters) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = t.applyFilters(rows, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filters: %w", err)
                }</span>
        }

        // Apply limit/offset if specified
        <span class="cov0" title="0">if options != nil &amp;&amp; options.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := options.Offset
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := start + int(options.Limit)
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>
                <span class="cov0" title="0">if start &gt;= len(rows) </span><span class="cov0" title="0">{
                        rows = []domain.Row{}
                }</span> else<span class="cov0" title="0"> {
                        rows = rows[start:end]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: t.GetSchema(),
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// applyFilters applies filters to result rows
func (t *ColumnsTable) applyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) <span class="cov0" title="0">{
        for _, filter := range filters </span><span class="cov0" title="0">{
                var filteredRows []domain.Row

                for _, row := range rows </span><span class="cov0" title="0">{
                        matches, err := t.matchesFilter(row, filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                filteredRows = append(filteredRows, row)
                        }</span>
                }

                <span class="cov0" title="0">rows = filteredRows</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// matchesFilter checks if a row matches a filter
func (t *ColumnsTable) matchesFilter(row domain.Row, filter domain.Filter) (bool, error) <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert value to string for comparison
        <span class="cov0" title="0">var strValue string
        if value == nil </span><span class="cov0" title="0">{
                strValue = ""
        }</span> else<span class="cov0" title="0"> {
                strValue = fmt.Sprintf("%v", value)
        }</span>

        // Apply operator
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return strValue == fmt.Sprintf("%v", filter.Value), nil</span>
        case "!=":<span class="cov0" title="0">
                return strValue != fmt.Sprintf("%v", filter.Value), nil</span>
        case "like":<span class="cov0" title="0">
                return t.matchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)</span>
        }
}

// matchesLike implements simple LIKE pattern matching
func (t *ColumnsTable) matchesLike(value, pattern string) bool <span class="cov0" title="0">{
        // Simple implementation - can be enhanced for full LIKE support
        if pattern == "%" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if pattern == value </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[0] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                suffix := pattern[1:]
                return len(value) &gt;= len(suffix) &amp;&amp; value[len(value)-len(suffix):] == suffix
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                prefix := pattern[:len(pattern)-1]
                return len(value) &gt;= len(prefix) &amp;&amp; value[:len(prefix)] == prefix
        }</span>
        <span class="cov0" title="0">return false</span>
}

// getDataType extracts the data type from column type string
func (t *ColumnsTable) getDataType(columnType string) string <span class="cov0" title="0">{
        columnType = strings.ToUpper(columnType)
        switch </span>{
        case strings.HasPrefix(columnType, "INT"):<span class="cov0" title="0">
                return "int"</span>
        case strings.HasPrefix(columnType, "BIGINT"):<span class="cov0" title="0">
                return "bigint"</span>
        case strings.HasPrefix(columnType, "VARCHAR"):<span class="cov0" title="0">
                return "varchar"</span>
        case strings.HasPrefix(columnType, "TEXT"):<span class="cov0" title="0">
                return "text"</span>
        case strings.HasPrefix(columnType, "CHAR"):<span class="cov0" title="0">
                return "char"</span>
        case strings.HasPrefix(columnType, "DECIMAL"):<span class="cov0" title="0">
                return "decimal"</span>
        case strings.HasPrefix(columnType, "FLOAT"):<span class="cov0" title="0">
                return "float"</span>
        case strings.HasPrefix(columnType, "DOUBLE"):<span class="cov0" title="0">
                return "double"</span>
        case strings.HasPrefix(columnType, "DATETIME"):<span class="cov0" title="0">
                return "datetime"</span>
        case strings.HasPrefix(columnType, "TIMESTAMP"):<span class="cov0" title="0">
                return "timestamp"</span>
        case strings.HasPrefix(columnType, "DATE"):<span class="cov0" title="0">
                return "date"</span>
        case strings.HasPrefix(columnType, "BOOLEAN") || strings.HasPrefix(columnType, "BOOL"):<span class="cov0" title="0">
                return "boolean"</span>
        default:<span class="cov0" title="0">
                return columnType</span>
        }
}

// getColumnType returns the full column type string
func (t *ColumnsTable) getColumnType(column domain.ColumnInfo) string <span class="cov0" title="0">{
        if !strings.Contains(column.Type, "(") </span><span class="cov0" title="0">{
                return column.Type
        }</span>

        // Already has length specification
        <span class="cov0" title="0">return column.Type</span>
}

// getCharacterMaxLength returns the maximum character length for the column
func (t *ColumnsTable) getCharacterMaxLength(columnType string) int64 <span class="cov0" title="0">{
        columnType = strings.ToUpper(columnType)

        switch </span>{
        case strings.HasPrefix(columnType, "VARCHAR"):<span class="cov0" title="0">
                // Extract length from VARCHAR(n)
                if i := strings.Index(columnType, "("); i &gt; 0 </span><span class="cov0" title="0">{
                        if j := strings.Index(columnType, ")"); j &gt; i </span><span class="cov0" title="0">{
                                var length int64
                                fmt.Sscanf(columnType[i+1:j], "%d", &amp;length)
                                return length
                        }</span>
                }
                <span class="cov0" title="0">return 65535</span>
        case strings.HasPrefix(columnType, "CHAR"):<span class="cov0" title="0">
                // Extract length from CHAR(n)
                if i := strings.Index(columnType, "("); i &gt; 0 </span><span class="cov0" title="0">{
                        if j := strings.Index(columnType, ")"); j &gt; i </span><span class="cov0" title="0">{
                                var length int64
                                fmt.Sscanf(columnType[i+1:j], "%d", &amp;length)
                                return length
                        }</span>
                }
                <span class="cov0" title="0">return 255</span>
        case strings.HasPrefix(columnType, "TEXT"):<span class="cov0" title="0">
                return 65535</span>
        case strings.HasPrefix(columnType, "MEDIUMTEXT"):<span class="cov0" title="0">
                return 16777215</span>
        case strings.HasPrefix(columnType, "LONGTEXT"):<span class="cov0" title="0">
                return 4294967295</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// getNumericPrecision returns the numeric precision for the column
func (t *ColumnsTable) getNumericPrecision(columnType string) int64 <span class="cov0" title="0">{
        columnType = strings.ToUpper(columnType)

        switch </span>{
        case strings.HasPrefix(columnType, "TINYINT"):<span class="cov0" title="0">
                return 3</span>
        case strings.HasPrefix(columnType, "SMALLINT"):<span class="cov0" title="0">
                return 5</span>
        case strings.HasPrefix(columnType, "MEDIUMINT"):<span class="cov0" title="0">
                return 7</span>
        case strings.HasPrefix(columnType, "INT"):<span class="cov0" title="0">
                return 10</span>
        case strings.HasPrefix(columnType, "BIGINT"):<span class="cov0" title="0">
                return 19</span>
        case strings.HasPrefix(columnType, "FLOAT"):<span class="cov0" title="0">
                return 7</span>
        case strings.HasPrefix(columnType, "DOUBLE"):<span class="cov0" title="0">
                return 15</span>
        case strings.HasPrefix(columnType, "DECIMAL"):<span class="cov0" title="0">
                // Extract precision from DECIMAL(p,s)
                if i := strings.Index(columnType, "("); i &gt; 0 </span><span class="cov0" title="0">{
                        if j := strings.Index(columnType, ")"); j &gt; i </span><span class="cov0" title="0">{
                                var precision int64
                                fmt.Sscanf(columnType[i+1:j], "%d", &amp;precision)
                                return precision
                        }</span>
                }
                <span class="cov0" title="0">return 10</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package information_schema

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// TableConstraintsTable represents information_schema.table_constraints
// It lists all constraints (PRIMARY, UNIQUE, FOREIGN KEY) across all tables
type TableConstraintsTable struct {
        dsManager *application.DataSourceManager
}

// NewTableConstraintsTable creates a new TableConstraintsTable
func NewTableConstraintsTable(dsManager *application.DataSourceManager) virtual.VirtualTable <span class="cov0" title="0">{
        return &amp;TableConstraintsTable{
                dsManager: dsManager,
        }
}</span>

// GetName returns table name
func (t *TableConstraintsTable) GetName() string <span class="cov0" title="0">{
        return "table_constraints"
}</span>

// GetSchema returns table schema
func (t *TableConstraintsTable) GetSchema() []domain.ColumnInfo <span class="cov0" title="0">{
        return []domain.ColumnInfo{
                {Name: "constraint_catalog", Type: "varchar(512)", Nullable: false},
                {Name: "constraint_schema", Type: "varchar(64)", Nullable: false},
                {Name: "constraint_name", Type: "varchar(64)", Nullable: false},
                {Name: "table_schema", Type: "varchar(64)", Nullable: false},
                {Name: "table_name", Type: "varchar(64)", Nullable: false},
                {Name: "constraint_type", Type: "varchar(64)", Nullable: false},
        }
}</span>

// Query executes a query against table_constraints table
func (t *TableConstraintsTable) Query(ctx context.Context, filters []domain.Filter, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Get all data source names
        dsNames := t.dsManager.List()

        // Build result rows
        rows := make([]domain.Row, 0)

        for _, dsName := range dsNames </span><span class="cov0" title="0">{
                // Get tables from this data source
                tables, err := t.dsManager.GetTables(ctx, dsName)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip data sources that fail
                        continue</span>
                }

                // Get table info for each table
                <span class="cov0" title="0">for _, tableName := range tables </span><span class="cov0" title="0">{
                        tableInfo, err := t.dsManager.GetTableInfo(ctx, dsName, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip tables that fail
                                continue</span>
                        }

                        // Add PRIMARY KEY constraint if table has primary key
                        <span class="cov0" title="0">hasPrimaryKey := false
                        for _, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                if column.Primary </span><span class="cov0" title="0">{
                                        hasPrimaryKey = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if hasPrimaryKey </span><span class="cov0" title="0">{
                                row := domain.Row{
                                        "constraint_catalog": "def",
                                        "constraint_schema":  dsName,
                                        "constraint_name":   "PRIMARY",
                                        "table_schema":      dsName,
                                        "table_name":        tableName,
                                        "constraint_type":    "PRIMARY KEY",
                                }
                                rows = append(rows, row)
                        }</span>

                        // Add UNIQUE constraints for columns with unique flag
                        <span class="cov0" title="0">for i, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                if column.Unique &amp;&amp; !column.Primary </span><span class="cov0" title="0">{
                                        row := domain.Row{
                                                "constraint_catalog": "def",
                                                "constraint_schema":  dsName,
                                                "constraint_name":   fmt.Sprintf("unique_%s", column.Name),
                                                "table_schema":      dsName,
                                                "table_name":        tableName,
                                                "constraint_type":    "UNIQUE",
                                        }
                                        rows = append(rows, row)
                                        _ = i // Use index to avoid linter warning
                                }</span>
                        }
                }
        }

        // Apply filters if provided
        <span class="cov0" title="0">var err error
        if len(filters) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = t.applyFilters(rows, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filters: %w", err)
                }</span>
        }

        // Apply limit/offset if specified
        <span class="cov0" title="0">if options != nil &amp;&amp; options.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := options.Offset
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := start + int(options.Limit)
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>
                <span class="cov0" title="0">if start &gt;= len(rows) </span><span class="cov0" title="0">{
                        rows = []domain.Row{}
                }</span> else<span class="cov0" title="0"> {
                        rows = rows[start:end]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: t.GetSchema(),
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// applyFilters applies filters to result rows
func (t *TableConstraintsTable) applyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) <span class="cov0" title="0">{
        for _, filter := range filters </span><span class="cov0" title="0">{
                var filteredRows []domain.Row

                for _, row := range rows </span><span class="cov0" title="0">{
                        matches, err := t.matchesFilter(row, filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                filteredRows = append(filteredRows, row)
                        }</span>
                }

                <span class="cov0" title="0">rows = filteredRows</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// matchesFilter checks if a row matches a filter
func (t *TableConstraintsTable) matchesFilter(row domain.Row, filter domain.Filter) (bool, error) <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert value to string for comparison
        <span class="cov0" title="0">var strValue string
        if value == nil </span><span class="cov0" title="0">{
                strValue = ""
        }</span> else<span class="cov0" title="0"> {
                strValue = fmt.Sprintf("%v", value)
        }</span>

        // Apply operator
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return strValue == fmt.Sprintf("%v", filter.Value), nil</span>
        case "!=":<span class="cov0" title="0">
                return strValue != fmt.Sprintf("%v", filter.Value), nil</span>
        case "like":<span class="cov0" title="0">
                return t.matchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)</span>
        }
}

// matchesLike implements simple LIKE pattern matching
func (t *TableConstraintsTable) matchesLike(value, pattern string) bool <span class="cov0" title="0">{
        // Simple implementation - can be enhanced for full LIKE support
        if pattern == "%" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if pattern == value </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[0] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                suffix := pattern[1:]
                return len(value) &gt;= len(suffix) &amp;&amp; value[len(value)-len(suffix):] == suffix
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                prefix := pattern[:len(pattern)-1]
                return len(value) &gt;= len(prefix) &amp;&amp; value[:len(prefix)] == prefix
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package information_schema

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// KeyColumnUsageTable represents information_schema.key_column_usage
// It lists all key columns (primary key, unique key, foreign key) across all tables
type KeyColumnUsageTable struct {
        dsManager *application.DataSourceManager
}

// NewKeyColumnUsageTable creates a new KeyColumnUsageTable
func NewKeyColumnUsageTable(dsManager *application.DataSourceManager) virtual.VirtualTable <span class="cov0" title="0">{
        return &amp;KeyColumnUsageTable{
                dsManager: dsManager,
        }
}</span>

// GetName returns table name
func (t *KeyColumnUsageTable) GetName() string <span class="cov0" title="0">{
        return "key_column_usage"
}</span>

// GetSchema returns table schema
func (t *KeyColumnUsageTable) GetSchema() []domain.ColumnInfo <span class="cov0" title="0">{
        return []domain.ColumnInfo{
                {Name: "constraint_catalog", Type: "varchar(512)", Nullable: true},
                {Name: "constraint_schema", Type: "varchar(64)", Nullable: true},
                {Name: "constraint_name", Type: "varchar(64)", Nullable: true},
                {Name: "table_catalog", Type: "varchar(512)", Nullable: false},
                {Name: "table_schema", Type: "varchar(64)", Nullable: false},
                {Name: "table_name", Type: "varchar(64)", Nullable: false},
                {Name: "column_name", Type: "varchar(64)", Nullable: false},
                {Name: "ordinal_position", Type: "bigint", Nullable: true},
                {Name: "position_in_unique_constraint", Type: "bigint", Nullable: true},
                {Name: "referenced_table_schema", Type: "varchar(64)", Nullable: true},
                {Name: "referenced_table_name", Type: "varchar(64)", Nullable: true},
                {Name: "referenced_column_name", Type: "varchar(64)", Nullable: true},
        }
}</span>

// Query executes a query against key_column_usage table
func (t *KeyColumnUsageTable) Query(ctx context.Context, filters []domain.Filter, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Get all data source names
        dsNames := t.dsManager.List()

        // Build result rows
        rows := make([]domain.Row, 0)

        for _, dsName := range dsNames </span><span class="cov0" title="0">{
                // Get tables from this data source
                tables, err := t.dsManager.GetTables(ctx, dsName)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip data sources that fail
                        continue</span>
                }

                // Get table info for each table
                <span class="cov0" title="0">for _, tableName := range tables </span><span class="cov0" title="0">{
                        tableInfo, err := t.dsManager.GetTableInfo(ctx, dsName, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip tables that fail
                                continue</span>
                        }

                        // Add primary key columns
                        <span class="cov0" title="0">ordinalPos := 1
                        for i, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                if column.Primary </span><span class="cov0" title="0">{
                                        row := domain.Row{
                                                "constraint_catalog":              "def",
                                                "constraint_schema":               dsName,
                                                "constraint_name":                "PRIMARY",
                                                "table_catalog":                  "def",
                                                "table_schema":                   dsName,
                                                "table_name":                     tableName,
                                                "column_name":                    column.Name,
                                                "ordinal_position":               ordinalPos,
                                                "position_in_unique_constraint":   ordinalPos,
                                                "referenced_table_schema":        nil,
                                                "referenced_table_name":          nil,
                                                "referenced_column_name":         nil,
                                        }
                                        rows = append(rows, row)
                                        ordinalPos++
                                        _ = i // Use index to avoid linter warning
                                }</span>
                        }

                        // Add unique constraint columns
                        <span class="cov0" title="0">for i, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                if column.Unique &amp;&amp; !column.Primary </span><span class="cov0" title="0">{
                                        row := domain.Row{
                                                "constraint_catalog":              "def",
                                                "constraint_schema":               dsName,
                                                "constraint_name":                fmt.Sprintf("unique_%s", column.Name),
                                                "table_catalog":                  "def",
                                                "table_schema":                   dsName,
                                                "table_name":                     tableName,
                                                "column_name":                    column.Name,
                                                "ordinal_position":               1,
                                                "position_in_unique_constraint":   1,
                                                "referenced_table_schema":        nil,
                                                "referenced_table_name":          nil,
                                                "referenced_column_name":         nil,
                                        }
                                        rows = append(rows, row)
                                        _ = i // Use index to avoid linter warning
                                }</span>
                        }

                                // Add foreign key columns (if any)
                                // Note: Foreign key information can be extended when full FK support is added
                                <span class="cov0" title="0">for i, column := range tableInfo.Columns </span><span class="cov0" title="0">{
                                        if column.ForeignKey != nil </span><span class="cov0" title="0">{
                                                row := domain.Row{
                                                        "constraint_catalog":              "def",
                                                        "constraint_schema":               dsName,
                                                        "constraint_name":                fmt.Sprintf("fk_%s_%s", tableName, column.Name),
                                                        "table_catalog":                  "def",
                                                        "table_schema":                   dsName,
                                                        "table_name":                     tableName,
                                                        "column_name":                    column.Name,
                                                        "ordinal_position":               1,
                                                        "position_in_unique_constraint":   nil,
                                                        "referenced_table_schema":        column.ForeignKey.Table,
                                                        "referenced_table_name":          column.ForeignKey.Table,
                                                        "referenced_column_name":         column.ForeignKey.Column,
                                                }
                                                rows = append(rows, row)
                                                _ = i // Use index to avoid linter warning
                                        }</span>
                                }
                }
        }

        // Apply filters if provided
        <span class="cov0" title="0">var err error
        if len(filters) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = t.applyFilters(rows, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filters: %w", err)
                }</span>
        }

        // Apply limit/offset if specified
        <span class="cov0" title="0">if options != nil &amp;&amp; options.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := options.Offset
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := start + int(options.Limit)
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>
                <span class="cov0" title="0">if start &gt;= len(rows) </span><span class="cov0" title="0">{
                        rows = []domain.Row{}
                }</span> else<span class="cov0" title="0"> {
                        rows = rows[start:end]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: t.GetSchema(),
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// applyFilters applies filters to result rows
func (t *KeyColumnUsageTable) applyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) <span class="cov0" title="0">{
        for _, filter := range filters </span><span class="cov0" title="0">{
                var filteredRows []domain.Row

                for _, row := range rows </span><span class="cov0" title="0">{
                        matches, err := t.matchesFilter(row, filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                filteredRows = append(filteredRows, row)
                        }</span>
                }

                <span class="cov0" title="0">rows = filteredRows</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// matchesFilter checks if a row matches a filter
func (t *KeyColumnUsageTable) matchesFilter(row domain.Row, filter domain.Filter) (bool, error) <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert value to string for comparison
        <span class="cov0" title="0">var strValue string
        if value == nil </span><span class="cov0" title="0">{
                strValue = ""
        }</span> else<span class="cov0" title="0"> {
                strValue = fmt.Sprintf("%v", value)
        }</span>

        // Apply operator
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return strValue == fmt.Sprintf("%v", filter.Value), nil</span>
        case "!=":<span class="cov0" title="0">
                return strValue != fmt.Sprintf("%v", filter.Value), nil</span>
        case "like":<span class="cov0" title="0">
                return t.matchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)</span>
        }
}

// matchesLike implements simple LIKE pattern matching
func (t *KeyColumnUsageTable) matchesLike(value, pattern string) bool <span class="cov0" title="0">{
        // Simple implementation - can be enhanced for full LIKE support
        if pattern == "%" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if pattern == value </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[0] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                suffix := pattern[1:]
                return len(value) &gt;= len(suffix) &amp;&amp; value[len(value)-len(suffix):] == suffix
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                prefix := pattern[:len(pattern)-1]
                return len(value) &gt;= len(prefix) &amp;&amp; value[:len(prefix)] == prefix
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package information_schema

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// Provider implements VirtualTableProvider for information_schema
// It manages all information_schema virtual tables
type Provider struct {
        dsManager *application.DataSourceManager
        tables    map[string]virtual.VirtualTable
}

// NewProvider creates a new information_schema provider
func NewProvider(dsManager *application.DataSourceManager) virtual.VirtualTableProvider <span class="cov0" title="0">{
        p := &amp;Provider{
                dsManager: dsManager,
                tables:    make(map[string]virtual.VirtualTable),
        }
        p.initializeTables()
        return p
}</span>

// initializeTables registers all information_schema virtual tables
func (p *Provider) initializeTables() <span class="cov0" title="0">{
        // Register core information_schema tables
        p.tables["schemata"] = NewSchemataTable(p.dsManager)
        p.tables["tables"] = NewTablesTable(p.dsManager)
        p.tables["columns"] = NewColumnsTable(p.dsManager)
        p.tables["table_constraints"] = NewTableConstraintsTable(p.dsManager)
        p.tables["key_column_usage"] = NewKeyColumnUsageTable(p.dsManager)
}</span>

// GetVirtualTable returns a virtual table by name
func (p *Provider) GetVirtualTable(name string) (virtual.VirtualTable, error) <span class="cov0" title="0">{
        table, exists := p.tables[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, &amp;TableNotFoundError{Name: name}
        }</span>
        <span class="cov0" title="0">return table, nil</span>
}

// ListVirtualTables returns all available virtual table names
func (p *Provider) ListVirtualTables() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(p.tables))
        for name := range p.tables </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// HasTable returns true if a virtual table with given name exists
func (p *Provider) HasTable(name string) bool <span class="cov0" title="0">{
        _, exists := p.tables[name]
        return exists
}</span>

// TableNotFoundError is returned when a requested table doesn't exist
type TableNotFoundError struct {
        Name string
}

func (e *TableNotFoundError) Error() string <span class="cov0" title="0">{
        return "information_schema table '" + e.Name + "' does not exist"
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package information_schema

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// SchemataTable represents information_schema.schemata
// It lists all databases (data sources) in the system
type SchemataTable struct {
        dsManager *application.DataSourceManager
}

// NewSchemataTable creates a new SchemataTable
func NewSchemataTable(dsManager *application.DataSourceManager) virtual.VirtualTable <span class="cov0" title="0">{
        return &amp;SchemataTable{
                dsManager: dsManager,
        }
}</span>

// GetName returns the table name
func (t *SchemataTable) GetName() string <span class="cov0" title="0">{
        return "schemata"
}</span>

// GetSchema returns the table schema
func (t *SchemataTable) GetSchema() []domain.ColumnInfo <span class="cov0" title="0">{
        return []domain.ColumnInfo{
                {Name: "catalog_name", Type: "varchar(512)", Nullable: false},
                {Name: "schema_name", Type: "varchar(64)", Nullable: false},
                {Name: "default_character_set_name", Type: "varchar(32)", Nullable: false},
                {Name: "default_collation_name", Type: "varchar(32)", Nullable: false},
                {Name: "sql_path", Type: "varchar(512)", Nullable: true},
        }
}</span>

// Query executes a query against the schemata table
func (t *SchemataTable) Query(ctx context.Context, filters []domain.Filter, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Get all data source names
        dsNames := t.dsManager.List()

        // Build result rows
        rows := make([]domain.Row, 0, len(dsNames))
        for _, name := range dsNames </span><span class="cov0" title="0">{
                row := domain.Row{
                        "catalog_name":              "def",
                        "schema_name":               name,
                        "default_character_set_name": "utf8mb4",
                        "default_collation_name":     "utf8mb4_general_ci",
                        "sql_path":                 nil,
                }
                rows = append(rows, row)
        }</span>

        // Apply filters if provided
        <span class="cov0" title="0">var err error
        if len(filters) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = t.applyFilters(rows, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filters: %w", err)
                }</span>
        }

        // Apply limit/offset if specified
        <span class="cov0" title="0">if options != nil &amp;&amp; options.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := options.Offset
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := start + int(options.Limit)
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>
                <span class="cov0" title="0">if start &gt;= len(rows) </span><span class="cov0" title="0">{
                        rows = []domain.Row{}
                }</span> else<span class="cov0" title="0"> {
                        rows = rows[start:end]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: t.GetSchema(),
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// applyFilters applies filters to the result rows
func (t *SchemataTable) applyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) <span class="cov0" title="0">{
        for _, filter := range filters </span><span class="cov0" title="0">{
                var filteredRows []domain.Row

                for _, row := range rows </span><span class="cov0" title="0">{
                        matches, err := t.matchesFilter(row, filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                filteredRows = append(filteredRows, row)
                        }</span>
                }

                <span class="cov0" title="0">rows = filteredRows</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// matchesFilter checks if a row matches a filter
func (t *SchemataTable) matchesFilter(row domain.Row, filter domain.Filter) (bool, error) <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert value to string for comparison
        <span class="cov0" title="0">var strValue string
        if value == nil </span><span class="cov0" title="0">{
                strValue = ""
        }</span> else<span class="cov0" title="0"> {
                strValue = fmt.Sprintf("%v", value)
        }</span>

        // Apply operator
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return strValue == fmt.Sprintf("%v", filter.Value), nil</span>
        case "!=":<span class="cov0" title="0">
                return strValue != fmt.Sprintf("%v", filter.Value), nil</span>
        case "like":<span class="cov0" title="0">
                return t.matchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)</span>
        }
}

// matchesLike implements simple LIKE pattern matching
func (t *SchemataTable) matchesLike(value, pattern string) bool <span class="cov0" title="0">{
        // Simple implementation - can be enhanced for full LIKE support
        if pattern == "%" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if pattern == value </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[0] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                suffix := pattern[1:]
                return len(value) &gt;= len(suffix) &amp;&amp; value[len(value)-len(suffix):] == suffix
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                prefix := pattern[:len(pattern)-1]
                return len(value) &gt;= len(prefix) &amp;&amp; value[:len(prefix)] == prefix
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package information_schema

import (
        "context"
        "fmt"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// TablesTable represents information_schema.tables
// It lists all tables across all data sources
type TablesTable struct {
        dsManager *application.DataSourceManager
}

// NewTablesTable creates a new TablesTable
func NewTablesTable(dsManager *application.DataSourceManager) virtual.VirtualTable <span class="cov0" title="0">{
        return &amp;TablesTable{
                dsManager: dsManager,
        }
}</span>

// GetName returns table name
func (t *TablesTable) GetName() string <span class="cov0" title="0">{
        return "tables"
}</span>

// GetSchema returns table schema
func (t *TablesTable) GetSchema() []domain.ColumnInfo <span class="cov0" title="0">{
        return []domain.ColumnInfo{
                {Name: "table_catalog", Type: "varchar(512)", Nullable: false},
                {Name: "table_schema", Type: "varchar(64)", Nullable: false},
                {Name: "table_name", Type: "varchar(64)", Nullable: false},
                {Name: "table_type", Type: "varchar(64)", Nullable: false},
                {Name: "engine", Type: "varchar(64)", Nullable: true},
                {Name: "version", Type: "bigint", Nullable: true},
                {Name: "row_format", Type: "varchar(10)", Nullable: true},
                {Name: "table_rows", Type: "bigint", Nullable: true},
                {Name: "avg_row_length", Type: "bigint", Nullable: true},
                {Name: "data_length", Type: "bigint", Nullable: true},
                {Name: "max_data_length", Type: "bigint", Nullable: true},
                {Name: "index_length", Type: "bigint", Nullable: true},
                {Name: "data_free", Type: "bigint", Nullable: true},
                {Name: "auto_increment", Type: "bigint", Nullable: true},
                {Name: "create_time", Type: "datetime", Nullable: true},
                {Name: "update_time", Type: "datetime", Nullable: true},
                {Name: "check_time", Type: "datetime", Nullable: true},
                {Name: "table_collation", Type: "varchar(32)", Nullable: true},
                {Name: "checksum", Type: "bigint", Nullable: true},
                {Name: "create_options", Type: "varchar(255)", Nullable: true},
                {Name: "table_comment", Type: "varchar(2048)", Nullable: true},
        }
}</span>

// Query executes a query against tables table
func (t *TablesTable) Query(ctx context.Context, filters []domain.Filter, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Get all data source names
        dsNames := t.dsManager.List()

        // Build result rows
        rows := make([]domain.Row, 0)

        for _, dsName := range dsNames </span><span class="cov0" title="0">{
                // Get tables from this data source
                tables, err := t.dsManager.GetTables(ctx, dsName)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip data sources that fail
                        continue</span>
                }

                // Get table info for each table
                <span class="cov0" title="0">for _, tableName := range tables </span><span class="cov0" title="0">{
                        tableInfo, err := t.dsManager.GetTableInfo(ctx, dsName, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip tables that fail
                                continue</span>
                        }

                        <span class="cov0" title="0">row := domain.Row{
                                "table_catalog":   "def",
                                "table_schema":    dsName,
                                "table_name":     tableName,
                                "table_type":      "BASE TABLE",
                                "engine":          "MEMORY",
                                "version":         int64(10),
                                "row_format":      "Fixed",
                                "table_rows":      int64(len(tableInfo.Columns)),
                                "avg_row_length":  int64(0),
                                "data_length":     int64(0),
                                "max_data_length": int64(0),
                                "index_length":    int64(0),
                                "data_free":       int64(0),
                                "auto_increment":  nil,
                                "create_time":     time.Now(),
                                "update_time":     nil,
                                "check_time":      nil,
                                "table_collation": "utf8mb4_general_ci",
                                "checksum":        nil,
                                "create_options":  "",
                                "table_comment":   "",
                        }

                        rows = append(rows, row)</span>
                }
        }

        // Apply filters if provided
        <span class="cov0" title="0">var err error
        if len(filters) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = t.applyFilters(rows, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filters: %w", err)
                }</span>
        }

        // Apply limit/offset if specified
        <span class="cov0" title="0">if options != nil &amp;&amp; options.Limit &gt; 0 </span><span class="cov0" title="0">{
                start := options.Offset
                if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">end := start + int(options.Limit)
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>
                <span class="cov0" title="0">if start &gt;= len(rows) </span><span class="cov0" title="0">{
                        rows = []domain.Row{}
                }</span> else<span class="cov0" title="0"> {
                        rows = rows[start:end]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: t.GetSchema(),
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// applyFilters applies filters to result rows
func (t *TablesTable) applyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) <span class="cov0" title="0">{
        for _, filter := range filters </span><span class="cov0" title="0">{
                var filteredRows []domain.Row

                for _, row := range rows </span><span class="cov0" title="0">{
                        matches, err := t.matchesFilter(row, filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                filteredRows = append(filteredRows, row)
                        }</span>
                }

                <span class="cov0" title="0">rows = filteredRows</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// matchesFilter checks if a row matches a filter
func (t *TablesTable) matchesFilter(row domain.Row, filter domain.Filter) (bool, error) <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert value to string for comparison
        <span class="cov0" title="0">var strValue string
        if value == nil </span><span class="cov0" title="0">{
                strValue = ""
        }</span> else<span class="cov0" title="0"> {
                strValue = fmt.Sprintf("%v", value)
        }</span>

        // Apply operator
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return strValue == fmt.Sprintf("%v", filter.Value), nil</span>
        case "!=":<span class="cov0" title="0">
                return strValue != fmt.Sprintf("%v", filter.Value), nil</span>
        case "like":<span class="cov0" title="0">
                return t.matchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)</span>
        }
}

// matchesLike implements simple LIKE pattern matching
func (t *TablesTable) matchesLike(value, pattern string) bool <span class="cov0" title="0">{
        // Simple implementation - can be enhanced for full LIKE support
        if pattern == "%" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if pattern == value </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[0] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                suffix := pattern[1:]
                return len(value) &gt;= len(suffix) &amp;&amp; value[len(value)-len(suffix):] == suffix
        }</span>
        <span class="cov0" title="0">if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' &amp;&amp; len(pattern) &gt; 1 </span><span class="cov0" title="0">{
                prefix := pattern[:len(pattern)-1]
                return len(value) &gt;= len(prefix) &amp;&amp; value[:len(prefix)] == prefix
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package monitor

import (
        "sync"
        "time"
)

// CacheEntry 缓存条目
type CacheEntry struct {
        Key        string
        Value      interface{}
        Expiration time.Time
        CreatedAt  time.Time
        AccessCount int64
        LastAccess time.Time
}

// IsExpired 检查是否过期
func (e *CacheEntry) IsExpired() bool <span class="cov0" title="0">{
        if e.Expiration.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Now().After(e.Expiration)</span>
}

// QueryCache 查询缓存
type QueryCache struct {
        mu         sync.RWMutex
        entries    map[string]*CacheEntry
        maxSize    int
        maxTTL     time.Duration
        hits       int64
        misses     int64
        evictions  int64
}

// NewQueryCache 创建查询缓存
func NewQueryCache(maxSize int, maxTTL time.Duration) *QueryCache <span class="cov0" title="0">{
        return &amp;QueryCache{
                entries: make(map[string]*CacheEntry),
                maxSize: maxSize,
                maxTTL:  maxTTL,
        }
}</span>

// Get 获取缓存
func (c *QueryCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        entry, ok := c.entries[key]
        if !ok </span><span class="cov0" title="0">{
                c.misses++
                return nil, false
        }</span>

        // 检查是否过期
        <span class="cov0" title="0">if entry.IsExpired() </span><span class="cov0" title="0">{
                delete(c.entries, key)
                c.misses++
                return nil, false
        }</span>

        <span class="cov0" title="0">entry.AccessCount++
        entry.LastAccess = time.Now()
        c.hits++
        return entry.Value, true</span>
}

// Set 设置缓存
func (c *QueryCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // 如果已存在，删除旧条目
        if _, ok := c.entries[key]; ok </span><span class="cov0" title="0">{
                delete(c.entries, key)
        }</span>

        // 如果缓存已满，淘汰最久未使用的条目
        <span class="cov0" title="0">if len(c.entries) &gt;= c.maxSize </span><span class="cov0" title="0">{
                c.evictLRU()
        }</span>

        // 计算过期时间
        <span class="cov0" title="0">var expiration time.Time
        if ttl &gt; 0 &amp;&amp; ttl &lt;= c.maxTTL </span><span class="cov0" title="0">{
                expiration = time.Now().Add(ttl)
        }</span> else<span class="cov0" title="0"> if c.maxTTL &gt; 0 </span><span class="cov0" title="0">{
                expiration = time.Now().Add(c.maxTTL)
        }</span>

        <span class="cov0" title="0">c.entries[key] = &amp;CacheEntry{
                Key:        key,
                Value:      value,
                Expiration: expiration,
                CreatedAt:  time.Now(),
                AccessCount: 1,
                LastAccess: time.Now(),
        }</span>
}

// Delete 删除缓存
func (c *QueryCache) Delete(key string) bool <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, ok := c.entries[key]; ok </span><span class="cov0" title="0">{
                delete(c.entries, key)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Clear 清空缓存
func (c *QueryCache) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries = make(map[string]*CacheEntry)
        c.hits = 0
        c.misses = 0
        c.evictions = 0
}</span>

// evictLRU 淘汰最久未使用的条目
func (c *QueryCache) evictLRU() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov0" title="0">{
                if oldestKey == "" || entry.LastAccess.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = entry.LastAccess
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(c.entries, oldestKey)
                c.evictions++
        }</span>
}

// GetSize 获取缓存大小
func (c *QueryCache) GetSize() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.entries)
}</span>

// GetStats 获取缓存统计
func (c *QueryCache) GetStats() *CacheStats <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        hitRate := 0.0
        total := c.hits + c.misses
        if total &gt; 0 </span><span class="cov0" title="0">{
                hitRate = float64(c.hits) / float64(total) * 100
        }</span>

        <span class="cov0" title="0">return &amp;CacheStats{
                Size:     len(c.entries),
                Hits:     c.hits,
                Misses:   c.misses,
                HitRate:  hitRate,
                Evictions: c.evictions,
                MaxSize:  c.maxSize,
                MaxTTL:   c.maxTTL,
        }</span>
}

// CacheStats 缓存统计
type CacheStats struct {
        Size      int
        Hits      int64
        Misses    int64
        HitRate   float64
        Evictions int64
        MaxSize   int
        MaxTTL    time.Duration
}

// CacheManager 缓存管理器
type CacheManager struct {
        queryCache   *QueryCache
        resultCache  *QueryCache
        schemaCache  *QueryCache
}

// NewCacheManager 创建缓存管理器
func NewCacheManager(queryCacheSize int, resultCacheSize int, schemaCacheSize int) *CacheManager <span class="cov0" title="0">{
        return &amp;CacheManager{
                queryCache:  NewQueryCache(queryCacheSize, time.Minute*5),
                resultCache: NewQueryCache(resultCacheSize, time.Minute*10),
                schemaCache: NewQueryCache(schemaCacheSize, time.Hour),
        }
}</span>

// GetQueryCache 获取查询缓存
func (cm *CacheManager) GetQueryCache() *QueryCache <span class="cov0" title="0">{
        return cm.queryCache
}</span>

// GetResultCache 获取结果缓存
func (cm *CacheManager) GetResultCache() *QueryCache <span class="cov0" title="0">{
        return cm.resultCache
}</span>

// GetSchemaCache 获取schema缓存
func (cm *CacheManager) GetSchemaCache() *QueryCache <span class="cov0" title="0">{
        return cm.schemaCache
}</span>

// GetStats 获取所有缓存统计
func (cm *CacheManager) GetStats() map[string]*CacheStats <span class="cov0" title="0">{
        return map[string]*CacheStats{
                "query":  cm.queryCache.GetStats(),
                "result": cm.resultCache.GetStats(),
                "schema": cm.schemaCache.GetStats(),
        }
}</span>

// CacheKey 生成缓存键
type CacheKey struct {
        SQL        string
        Params     []interface{}
        Database   string
        User       string
}

// GenerateKey 生成缓存键
func GenerateKey(cacheKey *CacheKey) string <span class="cov0" title="0">{
        return string(cacheKey.SQL)
}</span>

// CachedResult 缓存的查询结果
type CachedResult struct {
        Columns    []string
        Rows       []interface{}
        Total      int64
        ExecutedAt time.Time
        Duration   time.Duration
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package monitor

import (
        "sync"
        "time"
)

// MetricsCollector 监控指标收集器
type MetricsCollector struct {
        mu               sync.RWMutex
        queryCount       int64
        querySuccess     int64
        queryError       int64
        totalDuration    time.Duration
        slowQueryCount   int64
        activeQueries    int64
        errorCount       map[string]int64
        tableAccessCount map[string]int64
        startTime        time.Time
}

// NewMetricsCollector 创建监控指标收集器
func NewMetricsCollector() *MetricsCollector <span class="cov8" title="1">{
        return &amp;MetricsCollector{
                errorCount:       make(map[string]int64),
                tableAccessCount: make(map[string]int64),
                startTime:        time.Now(),
        }
}</span>

// RecordQuery 记录查询
func (m *MetricsCollector) RecordQuery(duration time.Duration, success bool, tableName string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.queryCount++
        m.totalDuration += duration

        if success </span><span class="cov8" title="1">{
                m.querySuccess++
        }</span> else<span class="cov8" title="1"> {
                m.queryError++
        }</span>

        <span class="cov8" title="1">if tableName != "" </span><span class="cov8" title="1">{
                m.tableAccessCount[tableName]++
        }</span>
}

// RecordError 记录错误
func (m *MetricsCollector) RecordError(errType string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.errorCount[errType]++
        m.queryError++
}</span>

// RecordSlowQuery 记录慢查询
func (m *MetricsCollector) RecordSlowQuery() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.slowQueryCount++
}</span>

// StartQuery 开始查询
func (m *MetricsCollector) StartQuery() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.activeQueries++
}</span>

// EndQuery 结束查询
func (m *MetricsCollector) EndQuery() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.activeQueries &gt; 0 </span><span class="cov8" title="1">{
                m.activeQueries--
        }</span>
}

// GetQueryCount 获取查询总数
func (m *MetricsCollector) GetQueryCount() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.queryCount
}</span>

// GetQuerySuccess 获取成功查询数
func (m *MetricsCollector) GetQuerySuccess() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.querySuccess
}</span>

// GetQueryError 获取错误查询数
func (m *MetricsCollector) GetQueryError() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.queryError
}</span>

// GetSuccessRate 获取成功率
func (m *MetricsCollector) GetSuccessRate() float64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.queryCount == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(m.querySuccess) / float64(m.queryCount) * 100</span>
}

// GetAvgDuration 获取平均查询时长
func (m *MetricsCollector) GetAvgDuration() time.Duration <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.queryCount == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return m.totalDuration / time.Duration(m.queryCount)</span>
}

// GetSlowQueryCount 获取慢查询数量
func (m *MetricsCollector) GetSlowQueryCount() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.slowQueryCount
}</span>

// GetActiveQueries 获取当前活跃查询数
func (m *MetricsCollector) GetActiveQueries() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.activeQueries
}</span>

// GetErrorCount 获取错误统计
func (m *MetricsCollector) GetErrorCount(errType string) int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.errorCount[errType]
}</span>

// GetAllErrors 获取所有错误统计
func (m *MetricsCollector) GetAllErrors() map[string]int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]int64)
        for k, v := range m.errorCount </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GetTableAccessCount 获取表访问统计
func (m *MetricsCollector) GetTableAccessCount(tableName string) int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.tableAccessCount[tableName]
}</span>

// GetAllTableAccessCount 获取所有表访问统计
func (m *MetricsCollector) GetAllTableAccessCount() map[string]int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]int64)
        for k, v := range m.tableAccessCount </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GetUptime 获取运行时间
func (m *MetricsCollector) GetUptime() time.Duration <span class="cov8" title="1">{
        return time.Since(m.startTime)
}</span>

// Reset 重置所有指标
func (m *MetricsCollector) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.queryCount = 0
        m.querySuccess = 0
        m.queryError = 0
        m.totalDuration = 0
        m.slowQueryCount = 0
        m.activeQueries = 0
        m.errorCount = make(map[string]int64)
        m.tableAccessCount = make(map[string]int64)
        m.startTime = time.Now()
}</span>

// QueryMetrics 查询指标快照
type QueryMetrics struct {
        QueryCount       int64
        QuerySuccess     int64
        QueryError       int64
        SuccessRate      float64
        AvgDuration      time.Duration
        SlowQueryCount   int64
        ActiveQueries    int64
        ErrorCount       map[string]int64
        TableAccessCount map[string]int64
        Uptime           time.Duration
}

// GetSnapshot 获取指标快照
func (m *MetricsCollector) GetSnapshot() *QueryMetrics <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return &amp;QueryMetrics{
                QueryCount:       m.queryCount,
                QuerySuccess:     m.querySuccess,
                QueryError:       m.queryError,
                SuccessRate:      m.GetSuccessRate(),
                AvgDuration:      m.GetAvgDuration(),
                SlowQueryCount:   m.slowQueryCount,
                ActiveQueries:    m.activeQueries,
                ErrorCount:       m.GetAllErrors(),
                TableAccessCount: m.GetAllTableAccessCount(),
                Uptime:           m.GetUptime(),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package monitor

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// SlowQueryLog 慢查询日志项
type SlowQueryLog struct {
        ID          int64
        SQL         string
        Duration    time.Duration
        Timestamp   time.Time
        TableName   string
        RowCount    int64
        ExecutedBy  string
        Error       string
        ExplainPlan string
}

// SlowQueryAnalyzer 慢查询分析器
type SlowQueryAnalyzer struct {
        mu           sync.RWMutex
        slowQueries  []*SlowQueryLog
        slowQueryMap map[int64]*SlowQueryLog
        threshold    time.Duration
        maxEntries   int
        nextID       int64
}

// NewSlowQueryAnalyzer 创建慢查询分析器
func NewSlowQueryAnalyzer(threshold time.Duration, maxEntries int) *SlowQueryAnalyzer <span class="cov8" title="1">{
        return &amp;SlowQueryAnalyzer{
                slowQueries:  make([]*SlowQueryLog, 0, maxEntries),
                slowQueryMap: make(map[int64]*SlowQueryLog),
                threshold:    threshold,
                maxEntries:   maxEntries,
                nextID:       1,
        }
}</span>

// IsSlowQuery 检查是否为慢查询
func (s *SlowQueryAnalyzer) IsSlowQuery(duration time.Duration) bool <span class="cov8" title="1">{
        return duration &gt;= s.threshold
}</span>

// RecordSlowQuery 记录慢查询
func (s *SlowQueryAnalyzer) RecordSlowQuery(sql string, duration time.Duration, tableName string, rowCount int64) int64 <span class="cov8" title="1">{
        if !s.IsSlowQuery(duration) </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        defer s.mu.Unlock()

        log := &amp;SlowQueryLog{
                ID:         s.nextID,
                SQL:        sql,
                Duration:   duration,
                Timestamp:  time.Now(),
                TableName:  tableName,
                RowCount:   rowCount,
                ExecutedBy: "system",
        }

        s.slowQueryMap[log.ID] = log
        s.slowQueries = append(s.slowQueries, log)
        s.nextID++

        // 如果超出最大条目数，移除最旧的记录
        if len(s.slowQueries) &gt; s.maxEntries </span><span class="cov8" title="1">{
                oldest := s.slowQueries[0]
                delete(s.slowQueryMap, oldest.ID)
                s.slowQueries = s.slowQueries[1:]
        }</span>

        <span class="cov8" title="1">return log.ID</span>
}

// RecordSlowQueryWithError 记录带错误的慢查询
func (s *SlowQueryAnalyzer) RecordSlowQueryWithError(sql string, duration time.Duration, tableName string, rowCount int64, err string) int64 <span class="cov8" title="1">{
        id := s.RecordSlowQuery(sql, duration, tableName, rowCount)
        if id &gt; 0 </span><span class="cov8" title="1">{
                s.mu.Lock()
                defer s.mu.Unlock()
                if log, ok := s.slowQueryMap[id]; ok </span><span class="cov8" title="1">{
                        log.Error = err
                }</span>
        }
        <span class="cov8" title="1">return id</span>
}

// GetSlowQuery 获取慢查询记录
func (s *SlowQueryAnalyzer) GetSlowQuery(id int64) (*SlowQueryLog, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        log, ok := s.slowQueryMap[id]
        return log, ok
}</span>

// GetAllSlowQueries 获取所有慢查询
func (s *SlowQueryAnalyzer) GetAllSlowQueries() []*SlowQueryLog <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := make([]*SlowQueryLog, len(s.slowQueries))
        copy(result, s.slowQueries)
        return result
}</span>

// GetSlowQueriesByTable 获取指定表的慢查询
func (s *SlowQueryAnalyzer) GetSlowQueriesByTable(tableName string) []*SlowQueryLog <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := []*SlowQueryLog{}
        for _, log := range s.slowQueries </span><span class="cov8" title="1">{
                if log.TableName == tableName </span><span class="cov8" title="1">{
                        result = append(result, log)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetSlowQueriesByTimeRange 获取指定时间范围的慢查询
func (s *SlowQueryAnalyzer) GetSlowQueriesByTimeRange(start, end time.Time) []*SlowQueryLog <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := []*SlowQueryLog{}
        for _, log := range s.slowQueries </span><span class="cov8" title="1">{
                // 包含边界：时间 &gt;= start 且 &lt;= end
</span>                if !log.Timestamp.Before(start) &amp;&amp; !log.Timestamp.After(end) {
                        </span>result = append(result, log)
                }
        <span class="cov8" title="1">}
</span>        return result
}

// GetSlowQueriesAfter 获取指定时间之后的慢查询
func (s *SlowQueryAnalyzer) GetSlowQueriesAfter(start time.Time) []*SlowQueryLog {
        </span>return s.GetSlowQueriesByTimeRange(start, time.Now())
}

// GetSlowQueryCount 获取慢查询总数
func (s *SlowQueryAnalyzer) GetSlowQueryCount() int {
        s.mu.RLock()
        defer s.mu.RUnlock()
        </span>return len(s.slowQueries)
}

// SetExplainPlan 设置执行计划
func (s *SlowQueryAnalyzer) SetExplainPlan(id int64, explainPlan string) {
        s.mu.Lock()
        defer s.mu.Unlock()

</span>        if log, ok := s.slowQueryMap[id]; ok {
                </span>log.ExplainPlan = explainPlan
        }
}

// DeleteSlowQuery 删除慢查询记录
func (s *SlowQueryAnalyzer) DeleteSlowQuery(id int64) bool {
        s.mu.Lock()
        defer s.mu.Unlock()

</span>        if _, ok := s.slowQueryMap[id]; !ok {
                </span>return false
        }
<span class="cov8" title="1">
        delete(s.slowQueryMap, id)
</span>        for i, log := ran</span><span class="cov8" title="1">ge s.slowQueries {
                if log.ID == id {
                        s.slo</span>wQueries = append(s.slowQueries[:i], s.slowQueries[i+1:]...)
                        break
                }
        <span class="cov8" title="1">}
</span>        return true
}

// Clear 清空所有慢查询
func (s *SlowQueryAnalyzer) Clear() {
        s.mu.Lock()
        defer s.mu.Unlock()

        s.slowQueries = make([]*SlowQueryLog, 0, s.maxEntries)
        s.slowQueryMap = make(map[int64]*SlowQueryLog)
        </span>s.nextID = 1
}

// SetThreshold 设置慢查询阈值
func (s *SlowQueryAnalyzer) SetThreshold(threshold time.Duration) {
        s.mu.Lock()
        defer s.mu.Unlock()
        </span>s.threshold = threshold
}

// GetThreshold 获取慢查询阈值
func (s *SlowQueryAnalyzer) GetThreshold() time.Duration {
        s.mu.RLock()
        defer s.mu.RUnlock()
        </span>return s.threshold
}

// AnalyzeSlowQueries 分析慢查询
func (s *SlowQueryAnalyzer) AnalyzeSlowQueries() *SlowQueryAnalysis {
        s.mu.RLock()
        defer s.mu.RUnlock()

</span>        if len(s.slowQueries) == 0 {
                </span>return &amp;SlowQueryAnalysis{}
        }
<span class="cov8" title="1">
        analysis := &amp;SlowQueryAnalysis{
                TotalQueries:      len(s.slowQueries),
                TableStats:        make(map[string]*TableSlowQueryStats),
                ErrorCount:        0,
                AvgDuration:       0,
                MaxDuration:       s.slowQueries[0].Duration,
                MinDuration:       s.slowQueries[0].Duration,
                TotalDuration:     0,
                AvgRowCount:       0,
                TotalRowCount:     0,
        }

        totalDuration := time.Duration(0)
        totalRowCount := int64(0)

</span>        for _, log := range s.slowQueries {
                totalDuration += log.Duration
                totalRowCount += log.RowCount

</span>                if log.Duration &gt; analysis.MaxDuration {
                        </span>analysis.MaxDuration = log.Duration
                <span class="cov8" title="1">}
</span>                if log.Duration &lt; analysis.MinDuration {
                        </span>analysis.MinDuration = log.Duration
                }

</span>                if log.Error != "" {
                        </span>analysis.ErrorCount++
                }

                <span class="cov8" title="1">// 表级别统计
</span>                if stats, ok := analysis.TableStats[log.TableName]; ok {
                        stats.QueryCount++
                        stats.TotalDuration += log.Duration
                        stats.TotalRowCount += log.RowCount</span><span class="cov8" title="1">
                        if log.Duration &gt; stats.MaxDuration {
                                </span>stats.MaxDuration = log.Duration
                        }
                } else {
                        analysis.TableStats[log.TableName] = &amp;TableSlowQueryStats{
                                TableName:     log.TableName,
                                QueryCount:    1,
                                TotalDuration: log.Duration,
                                MaxDuration:   log.Duration,
                                TotalRowCount: log.RowCount,
                        </span>}
                }
        }
<span class="cov8" title="1">
        analysis.TotalDuration = totalDuration
        analysis.AvgDuration = totalDuration / time.Duration(len(s.slowQueries))
        analysis.TotalRowCount = t</span><span class="cov8" title="1">otalRowCount
        if len(s.slowQueries) &gt; 0 {
                </span>analysis.AvgRowCount = totalRowCount / int64(len(s.slowQueries))
        }

        <span class="cov8" title="1">// 计算表级别的平均值
</span>        for _, stats := range ana</span><span class="cov8" title="1">lysis.TableStats {
                if stats.QueryCount &gt; 0 {
                        stats.AvgDuration = stats.TotalDuration / time.Duration(stats.QueryCount)
                        </span>stats.AvgRowCount = stats.TotalRowCount / int64(stats.QueryCount)
                }
        }
<span class="cov8" title="1">
</span>        return analysis
}

// SlowQueryAnalysis 慢查询分析结果
type SlowQueryAnalysis struct {
        TotalQueries   int
        AvgDuration    time.Duration
        MaxDuration    time.Duration
        MinDuration    time.Duration
        TotalDuration  time.Duration
        AvgRowCount    int64
        TotalRowCount  int64
        ErrorCount     int
        TableStats     map[string]*TableSlowQueryStats
}

// TableSlowQueryStats 表级别慢查询统计
type TableSlowQueryStats struct {
        TableName     string
        QueryCount    int
        TotalDuration time.Duration
        MaxDuration   time.Duration
        AvgDuration   time.Duration
        TotalRowCount int64
        AvgRowCount   int64
}

// GetRecommendations 获取优化建议
func (s *SlowQueryAnalyzer) GetRecommendations() []string {
        analysis := s.AnalyzeSlowQueries()
        recommendations := []string{}

        // 基于慢查询总数的建</span><span class="cov0" title="0">
        if analysis.TotalQueries &gt; 100 {
                </span>recommendations = append(recommendations, fmt.Sprintf("慢查询数量过多(%d)，建议检查查询优化策略", analysis.TotalQueries))
        }

        <span class="cov8" title="1">// 基于平均时长的建议
</span>        if analysis.AvgDuration &gt; time.Second {
                </span>recommendations = append(recommendations, fmt.Sprintf("平均查询时长较长(%v)，建议添加索引或优化查询语句", analysis.AvgDuration))
        }

        <span class="cov8" title="1">// 基于错误率的建议
</span>        if analysis.TotalQueries &gt; 0 {
                errorRate := float6</span><span class="cov0" title="0">4(analysis.ErrorCount) / float64(analysis.TotalQueries)
                if errorRate &gt; 0.1 {
                        </span>recommendations = append(recommendations, fmt.Sprintf("慢查询错误率过高(%.2f%%)，建议检查错误原因", errorRate*100))
                }
        }

        <span class="cov8" title="1">// 表级别建议
</span>        for tableName, stats := ra</span><span class="cov8" title="1">nge analysis.TableStats {
                if stats.QueryCount &gt; 10 {
                        </span>recommendations = append(recommendations, fmt.Sprintf("表 %s 有 %d 条慢查询，建议优化该表的查询", tableName, stats.QueryCount))
                <span class="cov8" title="1">}
</span>                if stats.AvgDuration &gt; time.Second*2 {
                        </span>recommendations = append(recommendations, fmt.Sprintf("表 %s 的平均查询时长较长(%v)，建议添加索引", tableName, stats.AvgDuration))
                }
        }
<span class="cov8" title="1">
</span>        return recommendations
}

// MonitorContext 监控上下文
type MonitorContext struct {
        Metrics      *MetricsCollector
        SlowQuery    *SlowQueryAnalyzer
        Ctx          context.Context
        QueryID      int64
        StartTime    time.Time
        TableName    string
}

// NewMonitorContext 创建监控上下文
func NewMonitorContext(ctx context.Context, metrics *MetricsCollector, slowQuery *SlowQueryAnalyzer, sql string) *MonitorContext {
        return &amp;MonitorContext{
                Metrics:   metrics,
                SlowQuery: slowQuery,
                Ctx:       ctx,
                StartTime: time.Now(),
        </span>}
}

// Start 开始监控
func (mc *MonitorContext) Start() {
        </span>mc.Metrics.StartQuery()
}

// End 结束监控
func (mc *MonitorContext) End(success bool, rowCount int64, err error) {
        duration := time.Since(mc.StartTime)
        mc.Metrics.RecordQuery(duration, success, mc.TableName)
        mc.Metrics.EndQuery()

</span>        if mc.SlowQuery.IsSlowQuery(duration) {
                var errMsg str</span><span class="cov8" title="1">ing
                if err != nil {
                        </span>errMsg = err.Error()
                <span class="cov8" title="1">}
</span>                mc.SlowQuery.RecordSlowQueryWithError("", duration, mc.TableName, rowCount, errMsg)
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package mvcc

import (
        "sync"
)

// ==================== 事务日志 ====================

// CommitLog 事务提交日志（类似PostgreSQL的clog）
type CommitLog struct {
        entries  map[XID]TransactionStatus // 事务状态映射
        oldest   XID                        // 最小事务ID
        mu       sync.RWMutex
}

// NewCommitLog 创建提交日志
func NewCommitLog() *CommitLog <span class="cov0" title="0">{
        return &amp;CommitLog{
                entries: make(map[XID]TransactionStatus),
                oldest:  XIDBootstrap,
        }
}</span>

// SetStatus 设置事务状态
func (l *CommitLog) SetStatus(xid XID, status TransactionStatus) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        
        l.entries[xid] = status
        
        // 更新最小XID
        if xid &lt; l.oldest </span><span class="cov0" title="0">{
                l.oldest = xid
        }</span>
}

// GetStatus 获取事务状态
func (l *CommitLog) GetStatus(xid XID) (TransactionStatus, bool) <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        
        status, exists := l.entries[xid]
        return status, exists
}</span>

// IsCommitted 检查事务是否已提交
func (l *CommitLog) IsCommitted(xid XID) bool <span class="cov0" title="0">{
        status, exists := l.GetStatus(xid)
        return exists &amp;&amp; status == TxnStatusCommitted
}</span>

// IsAborted 检查事务是否已回滚
func (l *CommitLog) IsAborted(xid XID) bool <span class="cov0" title="0">{
        status, exists := l.GetStatus(xid)
        return exists &amp;&amp; status == TxnStatusAborted
}</span>

// IsInProgress 检查事务是否进行中
func (l *CommitLog) IsInProgress(xid XID) bool <span class="cov0" title="0">{
        status, exists := l.GetStatus(xid)
        return !exists || status == TxnStatusInProgress
}</span>

// GetOldestXID 获取最小事务ID
func (l *CommitLog) GetOldestXID() XID <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.oldest
}</span>

// GetEntryCount 获取日志条目数
func (l *CommitLog) GetEntryCount() int <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return len(l.entries)
}</span>

// GC 垃圾回收
func (l *CommitLog) GC(currentXID XID) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        
        // 清理旧的事务日志
        // 只保留最近的事务日志
        for xid := range l.entries </span><span class="cov0" title="0">{
                if xid &lt; currentXID-10000 </span><span class="cov0" title="0">{
                        delete(l.entries, xid)
                }</span>
        }
        
        // 更新oldest
        <span class="cov0" title="0">l.updateOldest()</span>
}

// updateOldest 更新最小XID
func (l *CommitLog) updateOldest() <span class="cov0" title="0">{
        oldest := XIDMax
        for xid := range l.entries </span><span class="cov0" title="0">{
                if xid &lt; oldest </span><span class="cov0" title="0">{
                        oldest = xid
                }</span>
        }
        
        <span class="cov0" title="0">if len(l.entries) &gt; 0 </span><span class="cov0" title="0">{
                l.oldest = oldest
        }</span> else<span class="cov0" title="0"> {
                l.oldest = XIDBootstrap
        }</span>
}

// Clear 清空日志
func (l *CommitLog) Clear() <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        
        l.entries = make(map[XID]TransactionStatus)
        l.oldest = XIDBootstrap
}</span>

// Size 返回日志大小
func (l *CommitLog) Size() int <span class="cov0" title="0">{
        return l.GetEntryCount()
}</span>

// ==================== SLRU缓存 ====================

// SLRU 简单LRU缓存（用于clog缓存）
type SLRU struct {
        size    int
        entries map[XID]TransactionStatus
        keys    []XID
        mu      sync.RWMutex
}

// NewSLRU 创建SLRU缓存
func NewSLRU(size int) *SLRU <span class="cov0" title="0">{
        return &amp;SLRU{
                size:    size,
                entries: make(map[XID]TransactionStatus),
                keys:    make([]XID, 0, size),
        }
}</span>

// Get 获取事务状态
func (s *SLRU) Get(xid XID) (TransactionStatus, bool) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        status, exists := s.entries[xid]
        return status, exists
}</span>

// Set 设置事务状态
func (s *SLRU) Set(xid XID, status TransactionStatus) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        // 如果已存在，更新
        if _, exists := s.entries[xid]; exists </span><span class="cov0" title="0">{
                s.entries[xid] = status
                return
        }</span>
        
        // 如果已满，移除最旧的
        <span class="cov0" title="0">if len(s.keys) &gt;= s.size </span><span class="cov0" title="0">{
                oldest := s.keys[0]
                delete(s.entries, oldest)
                s.keys = s.keys[1:]
        }</span>
        
        // 添加新条目
        <span class="cov0" title="0">s.entries[xid] = status
        s.keys = append(s.keys, xid)</span>
}

// Clear 清空缓存
func (s *SLRU) Clear() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        s.entries = make(map[XID]TransactionStatus)
        s.keys = make([]XID, 0, s.size)
}</span>

// Len 返回缓存大小
func (s *SLRU) Len() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.entries)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package mvcc

import (
        "fmt"
        "log"
        "sync"
)

// ==================== MVCC数据源接口 ====================

// MVCCDataSource MVCC数据源接口
type MVCCDataSource interface {
        // GetFeatures 获取数据源特性
        GetFeatures() *DataSourceFeatures
        
        // ReadWithMVCC 使用MVCC读取数据
        ReadWithMVCC(key string, snapshot *Snapshot) (*TupleVersion, error)
        
        // WriteWithMVCC 使用MVCC写入数据
        WriteWithMVCC(key string, version *TupleVersion) error
        
        // DeleteWithMVCC 使用MVCC删除数据
        DeleteWithMVCC(key string, version *TupleVersion) error
        
        // BeginTransaction 开始事务
        BeginTransaction(xid XID, level IsolationLevel) (TransactionHandle, error)
        
        // CommitTransaction 提交事务
        CommitTransaction(xid XID) error
        
        // RollbackTransaction 回滚事务
        RollbackTransaction(xid XID) error
}

// ==================== 事务句柄 ====================

// TransactionHandle 事务句柄接口
type TransactionHandle interface {
        XID() XID
        Level() IsolationLevel
        IsMVCC() bool
        Commit() error
        Rollback() error
}

// ==================== 数据源注册表 ====================

// DataSourceRegistry 数据源注册表
type DataSourceRegistry struct {
        sources map[string]MVCCDataSource
        mu      sync.RWMutex
}

// NewDataSourceRegistry 创建数据源注册表
func NewDataSourceRegistry() *DataSourceRegistry <span class="cov0" title="0">{
        return &amp;DataSourceRegistry{
                sources: make(map[string]MVCCDataSource),
        }
}</span>

// Register 注册数据源
func (r *DataSourceRegistry) Register(name string, ds MVCCDataSource) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        
        r.sources[name] = ds
        return nil
}</span>

// Unregister 注销数据源
func (r *DataSourceRegistry) Unregister(name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        
        delete(r.sources, name)
        return nil
}</span>

// Get 获取数据源
func (r *DataSourceRegistry) Get(name string) (MVCCDataSource, bool) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        ds, exists := r.sources[name]
        return ds, exists
}</span>

// Exists 检查数据源是否存在
func (r *DataSourceRegistry) Exists(name string) bool <span class="cov0" title="0">{
        _, exists := r.Get(name)
        return exists
}</span>

// List 列出所有数据源
func (r *DataSourceRegistry) List() []string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        names := make([]string, 0, len(r.sources))
        for name := range r.sources </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// ==================== 降级处理器 ====================

// DowngradeHandler 降级处理器
type DowngradeHandler struct {
        manager   *Manager
        registry  *DataSourceRegistry
        logger    *log.Logger
        mu        sync.RWMutex
}

// NewDowngradeHandler 创建降级处理器
func NewDowngradeHandler(manager *Manager, registry *DataSourceRegistry) *DowngradeHandler <span class="cov0" title="0">{
        return &amp;DowngradeHandler{
                manager:  manager,
                registry: registry,
                logger:   log.Default(),
        }
}</span>

// SetLogger 设置日志器
func (h *DowngradeHandler) SetLogger(logger *log.Logger) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.logger = logger
}</span>

// CheckBeforeQuery 查询前检查
func (h *DowngradeHandler) CheckBeforeQuery(sources []string, readOnly bool) (bool, error) <span class="cov0" title="0">{
        // 如果是只读查询，允许降级
        if readOnly </span><span class="cov0" title="0">{
                return h.checkForReadOnlyQuery(sources)
        }</span>
        
        // 如果不是只读查询，要求所有数据源支持MVCC
        <span class="cov0" title="0">return h.checkForReadWriteQuery(sources)</span>
}

// checkForReadOnlyQuery 检查只读查询
func (h *DowngradeHandler) checkForReadOnlyQuery(sources []string) (bool, error) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        
        allSupportMVCC := true
        nonMVCCSources := make([]string, 0)
        
        for _, name := range sources </span><span class="cov0" title="0">{
                ds, exists := h.registry.Get(name)
                if !exists </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("data source '%s' not found", name)
                }</span>
                
                <span class="cov0" title="0">features := ds.GetFeatures()
                if !features.HasMVCC() </span><span class="cov0" title="0">{
                        allSupportMVCC = false
                        nonMVCCSources = append(nonMVCCSources, name)
                }</span>
        }
        
        // 如果有数据源不支持MVCC，输出警告
        <span class="cov0" title="0">if !allSupportMVCC </span><span class="cov0" title="0">{
                h.logger.Printf("[MVCC-WARN] Data sources do not support MVCC: %v", nonMVCCSources)
                return false, nil // 返回false表示不支持MVCC，但允许继续执行
        }</span>
        
        <span class="cov0" title="0">return true, nil</span>
}

// checkForReadWriteQuery 检查读写查询
func (h *DowngradeHandler) checkForReadWriteQuery(sources []string) (bool, error) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        
        nonMVCCSources := make([]string, 0)
        
        for _, name := range sources </span><span class="cov0" title="0">{
                ds, exists := h.registry.Get(name)
                if !exists </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("data source '%s' not found", name)
                }</span>
                
                <span class="cov0" title="0">features := ds.GetFeatures()
                if !features.HasMVCC() </span><span class="cov0" title="0">{
                        nonMVCCSources = append(nonMVCCSources, name)
                }</span>
        }
        
        // 如果有数据源不支持MVCC
        <span class="cov0" title="0">if len(nonMVCCSources) &gt; 0 </span><span class="cov0" title="0">{
                // 检查是否允许自动降级
                if h.manager.config.AutoDowngrade </span><span class="cov0" title="0">{
                        h.logger.Printf("[MVCC-WARN] Auto-downgrading for sources: %v", nonMVCCSources)
                        return false, nil // 返回false表示不支持MVCC，但允许降级执行
                }</span>
                
                // 不允许降级，返回错误
                <span class="cov0" title="0">return false, fmt.Errorf("data sources do not support MVCC and auto-downgrade is disabled: %v", nonMVCCSources)</span>
        }
        
        <span class="cov0" title="0">return true, nil</span>
}

// CheckBeforeWrite 写入前检查
func (h *DowngradeHandler) CheckBeforeWrite(sources []string) (bool, error) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        
        nonMVCCSources := make([]string, 0)
        
        for _, name := range sources </span><span class="cov0" title="0">{
                ds, exists := h.registry.Get(name)
                if !exists </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("data source '%s' not found", name)
                }</span>
                
                <span class="cov0" title="0">features := ds.GetFeatures()
                if !features.HasMVCC() </span><span class="cov0" title="0">{
                        nonMVCCSources = append(nonMVCCSources, name)
                }</span>
        }
        
        // 写入操作要求所有数据源支持MVCC
        <span class="cov0" title="0">if len(nonMVCCSources) &gt; 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("write operation requires MVCC support, but sources do not support it: %v", nonMVCCSources)
        }</span>
        
        <span class="cov0" title="0">return true, nil</span>
}

// ==================== 内存数据源（支持MVCC） ====================

// MemoryDataSource 内存数据源（支持MVCC）
type MemoryDataSource struct {
        name       string
        data       map[string][]*TupleVersion // key -&gt; versions
        features   *DataSourceFeatures
        mu         sync.RWMutex
}

// NewMemoryDataSource 创建内存数据源
func NewMemoryDataSource(name string) *MemoryDataSource <span class="cov0" title="0">{
        return &amp;MemoryDataSource{
                name:     name,
                data:     make(map[string][]*TupleVersion),
                features: NewDataSourceFeatures(name, CapabilityFull),
        }
}</span>

// GetFeatures 获取数据源特性
func (ds *MemoryDataSource) GetFeatures() *DataSourceFeatures <span class="cov0" title="0">{
        return ds.features
}</span>

// ReadWithMVCC 使用MVCC读取数据
func (ds *MemoryDataSource) ReadWithMVCC(key string, snapshot *Snapshot) (*TupleVersion, error) <span class="cov0" title="0">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        
        versions, exists := ds.data[key]
        if !exists || len(versions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key not found: %s", key)
        }</span>
        
        // 从后往前查找可见版本
        <span class="cov0" title="0">for i := len(versions) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                version := versions[i]
                if version.IsVisibleTo(snapshot) </span><span class="cov0" title="0">{
                        return version, nil
                }</span>
        }
        
        <span class="cov0" title="0">return nil, fmt.Errorf("no visible version for key: %s", key)</span>
}

// WriteWithMVCC 使用MVCC写入数据
func (ds *MemoryDataSource) WriteWithMVCC(key string, version *TupleVersion) error <span class="cov0" title="0">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        
        ds.data[key] = append(ds.data[key], version)
        return nil
}</span>

// DeleteWithMVCC 使用MVCC删除数据
func (ds *MemoryDataSource) DeleteWithMVCC(key string, version *TupleVersion) error <span class="cov0" title="0">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        
        versions, exists := ds.data[key]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found: %s", key)
        }</span>
        
        // 标记最后一个可见版本为已删除
        <span class="cov0" title="0">for i := len(versions) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if !versions[i].Expired </span><span class="cov0" title="0">{
                        versions[i].MarkDeleted(version.Xmin, version.Cmin)
                        return nil
                }</span>
        }
        
        <span class="cov0" title="0">return fmt.Errorf("no visible version to delete: %s", key)</span>
}

// BeginTransaction 开始事务
func (ds *MemoryDataSource) BeginTransaction(xid XID, level IsolationLevel) (TransactionHandle, error) <span class="cov0" title="0">{
        // 由管理器管理事务，这里返回nil
        return nil, nil
}</span>

// CommitTransaction 提交事务
func (ds *MemoryDataSource) CommitTransaction(xid XID) error <span class="cov0" title="0">{
        // 由管理器管理事务，这里不做任何操作
        return nil
}</span>

// RollbackTransaction 回滚事务
func (ds *MemoryDataSource) RollbackTransaction(xid XID) error <span class="cov0" title="0">{
        // 由管理器管理事务，这里不做任何操作
        return nil
}</span>

// ==================== 非MVCC数据源 ====================

// NonMVCCDataSource 非MVCC数据源
type NonMVCCDataSource struct {
        name     string
        data     map[string]interface{}
        features *DataSourceFeatures
        mu       sync.RWMutex
}

// NewNonMVCCDataSource 创建非MVCC数据源
func NewNonMVCCDataSource(name string) *NonMVCCDataSource <span class="cov0" title="0">{
        return &amp;NonMVCCDataSource{
                name:     name,
                data:     make(map[string]interface{}),
                features: NewDataSourceFeatures(name, CapabilityNone),
        }
}</span>

// GetFeatures 获取数据源特性
func (ds *NonMVCCDataSource) GetFeatures() *DataSourceFeatures <span class="cov0" title="0">{
        return ds.features
}</span>

// ReadWithMVCC 使用MVCC读取数据（不支持）
func (ds *NonMVCCDataSource) ReadWithMVCC(key string, snapshot *Snapshot) (*TupleVersion, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("MVCC not supported")
}</span>

// WriteWithMVCC 使用MVCC写入数据（不支持）
func (ds *NonMVCCDataSource) WriteWithMVCC(key string, version *TupleVersion) error <span class="cov0" title="0">{
        return fmt.Errorf("MVCC not supported")
}</span>

// DeleteWithMVCC 使用MVCC删除数据（不支持）
func (ds *NonMVCCDataSource) DeleteWithMVCC(key string, version *TupleVersion) error <span class="cov0" title="0">{
        return fmt.Errorf("MVCC not supported")
}</span>

// BeginTransaction 开始事务（不支持）
func (ds *NonMVCCDataSource) BeginTransaction(xid XID, level IsolationLevel) (TransactionHandle, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("MVCC not supported")
}</span>

// CommitTransaction 提交事务（不支持）
func (ds *NonMVCCDataSource) CommitTransaction(xid XID) error <span class="cov0" title="0">{
        return fmt.Errorf("MVCC not supported")
}</span>

// RollbackTransaction 回滚事务（不支持）
func (ds *NonMVCCDataSource) RollbackTransaction(xid XID) error <span class="cov0" title="0">{
        return fmt.Errorf("MVCC not supported")
}</span>

// SimpleRead 简单读取（非MVCC）
func (ds *NonMVCCDataSource) SimpleRead(key string) (interface{}, error) <span class="cov0" title="0">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        
        value, exists := ds.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key not found: %s", key)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// SimpleWrite 简单写入（非MVCC）
func (ds *NonMVCCDataSource) SimpleWrite(key string, value interface{}) error <span class="cov0" title="0">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        
        ds.data[key] = value
        return nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package mvcc

import (
        "fmt"
        "log"
        "sync"
        "sync/atomic"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/config"
)

// ==================== 配置 ====================

// Config MVCC配置
type Config struct {
        EnableWarning      bool          // 是否启用警告
        AutoDowngrade      bool          // 是否自动降级
        GCInterval         time.Duration // GC间隔
        GCAgeThreshold     time.Duration // 版本保留时间
        XIDWrapThreshold   uint32        // XID环绕阈值
        MaxActiveTxns      int           // 最大活跃事务数
        WarningLogger      *log.Logger   // 警告日志器
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                EnableWarning:      true,
                AutoDowngrade:      true,
                GCInterval:         5 * time.Minute,
                GCAgeThreshold:     1 * time.Hour,
                XIDWrapThreshold:   100000,
                MaxActiveTxns:      10000,
                WarningLogger:      log.Default(),
        }
}</span>

// ==================== 事务管理器 ====================

// Manager 事务管理器
type Manager struct {
        config        *Config
        xid           XID               // 当前事务ID
        snapshots     map[XID]*Snapshot  // 快照缓存
        transactions  map[XID]*Transaction // 活跃事务
        clog          *CommitLog         // 提交日志
        checker       *VisibilityChecker // 可见性检查器
        dataSources   map[string]*DataSourceFeatures // 数据源特性缓存
        mu            sync.RWMutex      // 全局互斥锁
        closed        bool              // 是否已关闭
        gcStop        chan struct{}     // GC停止信号
}

var (
        // globalManager 全局管理器
        globalManager *Manager
        globalOnce    sync.Once
)

// NewManager 创建事务管理器
func NewManager(cfg *Config) *Manager <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = DefaultConfig()
        }</span>
        
        <span class="cov0" title="0">m := &amp;Manager{
                config:       cfg,
                xid:          XIDBootstrap,
                snapshots:    make(map[XID]*Snapshot),
                transactions: make(map[XID]*Transaction),
                clog:         NewCommitLog(),
                checker:      NewVisibilityChecker(),
                dataSources:  make(map[string]*DataSourceFeatures),
                gcStop:       make(chan struct{}),
        }
        
        // 启动GC协程
        go m.gcLoop()
        
        return m</span>
}

// NewManagerFromConfig 从应用配置创建事务管理器
func NewManagerFromConfig(appCfg *config.Config) *Manager <span class="cov0" title="0">{
        if appCfg == nil </span><span class="cov0" title="0">{
                appCfg = config.DefaultConfig()
        }</span>
        
        <span class="cov0" title="0">cfg := &amp;Config{
                EnableWarning:      appCfg.MVCC.EnableWarning,
                AutoDowngrade:      appCfg.MVCC.AutoDowngrade,
                GCInterval:         appCfg.MVCC.GCInterval,
                GCAgeThreshold:     appCfg.MVCC.GCAgeThreshold,
                XIDWrapThreshold:   appCfg.MVCC.XIDWrapThreshold,
                MaxActiveTxns:      appCfg.MVCC.MaxActiveTxns,
        }
        
        return NewManager(cfg)</span>
}

// GetGlobalManager 获取全局管理器（单例）
func GetGlobalManager() *Manager <span class="cov0" title="0">{
        globalOnce.Do(func() </span><span class="cov0" title="0">{
                globalManager = NewManager(DefaultConfig())
        }</span>)
        <span class="cov0" title="0">return globalManager</span>
}

// Close 关闭管理器
func (m *Manager) Close() error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if m.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // 停止GC
        <span class="cov0" title="0">close(m.gcStop)
        
        // 清理资源
        m.closed = true
        
        return nil</span>
}

// ==================== 事务管理 ====================

// Begin 开始事务
func (m *Manager) Begin(level IsolationLevel, features *DataSourceFeatures) (*Transaction, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if m.closed </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("manager is closed")
        }</span>
        
        // 检查活跃事务数
        <span class="cov0" title="0">if len(m.transactions) &gt;= m.config.MaxActiveTxns </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("too many active transactions")
        }</span>
        
        // 检查数据源是否支持MVCC
        <span class="cov0" title="0">if !m.checkMVCCCapability(features) </span><span class="cov0" title="0">{
                // 数据源不支持MVCC，降级
                return m.beginNonMVCC(level)
        }</span>
        
        // 生成新XID
        <span class="cov0" title="0">xid := m.nextXID()
        
        // 创建快照（注意：调用者已持有写锁，不能再次获取锁）
        xip := make([]XID, 0, len(m.transactions))
        for txnXID := range m.transactions </span><span class="cov0" title="0">{
                xip = append(xip, txnXID)
        }</span>
        <span class="cov0" title="0">snapshot := NewSnapshot(m.xid, xid, xip, level)
        m.snapshots[xid] = snapshot
        
        // 创建事务
        txn := &amp;Transaction{
                xid:        xid,
                snapshot:   snapshot,
                status:     TxnStatusInProgress,
                createdAt:  time.Now(),
                startTime:  time.Now(),
                manager:    m,
                level:      level,
                mvcc:       true,
                commands:   make([]Command, 0),
                reads:      make(map[string]bool),
                writes:     make(map[string]*TupleVersion),
                locks:      make(map[string]bool),
        }
        
        // 记录事务
        m.transactions[xid] = txn
        
        return txn, nil</span>
}

// beginNonMVCC 开始非MVCC事务（降级）
func (m *Manager) beginNonMVCC(level IsolationLevel) (*Transaction, error) <span class="cov0" title="0">{
        // 输出警告
        if m.config.EnableWarning </span><span class="cov0" title="0">{
                m.warning("MVCC not supported, downgrading to non-MVCC transaction")
        }</span>
        
        // 创建非MVCC事务
        <span class="cov0" title="0">txn := &amp;Transaction{
                xid:        0,
                snapshot:   nil,
                status:     TxnStatusInProgress,
                createdAt:  time.Now(),
                startTime:  time.Now(),
                manager:    m,
                level:      level,
                mvcc:       false,
                commands:   make([]Command, 0),
                reads:      make(map[string]bool),
                writes:     make(map[string]*TupleVersion),
                locks:      make(map[string]bool),
        }
        
        return txn, nil</span>
}

// Commit 提交事务
func (m *Manager) Commit(txn *Transaction) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if txn.status != TxnStatusInProgress </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction is not in progress")
        }</span>
        
        // 如果是非MVCC事务
        <span class="cov0" title="0">if !txn.mvcc </span><span class="cov0" title="0">{
                txn.status = TxnStatusCommitted
                txn.endTime = time.Now()
                return nil
        }</span>
        
        // 应用所有命令
        <span class="cov0" title="0">for _, cmd := range txn.commands </span><span class="cov0" title="0">{
                if err := cmd.Apply(); err != nil </span><span class="cov0" title="0">{
                        // 回滚
                        for i := len(txn.commands) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                txn.commands[i].Rollback()
                        }</span>
                        <span class="cov0" title="0">txn.status = TxnStatusAborted
                        return err</span>
                }
        }
        
        // 更新事务状态
        <span class="cov0" title="0">txn.status = TxnStatusCommitted
        txn.endTime = time.Now()
        
        // 记录到clog
        m.clog.SetStatus(txn.xid, TxnStatusCommitted)
        
        // 从活跃事务中移除
        delete(m.transactions, txn.xid)
        
        // 清理快照
        delete(m.snapshots, txn.xid)
        
        return nil</span>
}

// Rollback 回滚事务
func (m *Manager) Rollback(txn *Transaction) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if txn.status != TxnStatusInProgress </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction is not in progress")
        }</span>
        
        // 回滚所有命令
        <span class="cov0" title="0">for i := len(txn.commands) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                txn.commands[i].Rollback()
        }</span>
        
        // 更新事务状态
        <span class="cov0" title="0">txn.status = TxnStatusAborted
        txn.endTime = time.Now()
        
        // 如果是MVCC事务
        if txn.mvcc &amp;&amp; txn.xid != 0 </span><span class="cov0" title="0">{
                // 记录到clog
                m.clog.SetStatus(txn.xid, TxnStatusAborted)
                
                // 从活跃事务中移除
                delete(m.transactions, txn.xid)
                
                // 清理快照
                delete(m.snapshots, txn.xid)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}


// ==================== 快照管理 ====================

// GetSnapshot 获取快照
func (m *Manager) GetSnapshot(xid XID) (*Snapshot, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        snapshot, exists := m.snapshots[xid]
        return snapshot, exists
}</span>

// ==================== MVCC能力检查 ====================

// checkMVCCCapability 检查数据源是否支持MVCC
func (m *Manager) checkMVCCCapability(features *DataSourceFeatures) bool <span class="cov0" title="0">{
        if features == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return features.HasMVCC()</span>
}

// RegisterDataSource 注册数据源特性
func (m *Manager) RegisterDataSource(features *DataSourceFeatures) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.dataSources[features.Name] = features
}</span>

// GetDataSource 获取数据源特性
func (m *Manager) GetDataSource(name string) (*DataSourceFeatures, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        features, exists := m.dataSources[name]
        return features, exists
}</span>

// ==================== XID管理 ====================

// nextXID 生成下一个XID
func (m *Manager) nextXID() XID <span class="cov0" title="0">{
        current := atomic.LoadUint32((*uint32)(&amp;m.xid))
        
        // 处理环绕
        if current &gt;= uint32(XIDMax)-m.config.XIDWrapThreshold </span><span class="cov0" title="0">{
                m.warning("XID approaching wrap-around, consider vacuum")
        }</span>
        
        <span class="cov0" title="0">next := NextXID(XID(current))
        atomic.StoreUint32((*uint32)(&amp;m.xid), uint32(next))
        
        return next</span>
}

// CurrentXID 返回当前XID
func (m *Manager) CurrentXID() XID <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.xid
}</span>

// ==================== GC机制 ====================

// gcLoop GC循环
func (m *Manager) gcLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(m.config.GCInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.GC()</span>
                case &lt;-m.gcStop:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// GC 执行垃圾回收
func (m *Manager) GC() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // 清理过期快照
        m.gcSnapshots()
        
        // 清理clog
        m.clog.GC(m.xid)
}</span>

// gcSnapshots 清理过期快照
func (m *Manager) gcSnapshots() <span class="cov0" title="0">{
        for xid, snapshot := range m.snapshots </span><span class="cov0" title="0">{
                if snapshot.Age() &gt; m.config.GCAgeThreshold </span><span class="cov0" title="0">{
                        delete(m.snapshots, xid)
                }</span>
        }
}

// ==================== 工具方法 ====================

// warning 输出警告
func (m *Manager) warning(msg string) <span class="cov0" title="0">{
        if m.config.EnableWarning &amp;&amp; m.config.WarningLogger != nil </span><span class="cov0" title="0">{
                m.config.WarningLogger.Printf("[MVCC-WARN] %s\n", msg)
        }</span>
}

// GetStatistics 获取统计信息
func (m *Manager) GetStatistics() map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        return map[string]interface{}{
                "current_xid":      m.xid,
                "active_txns":      len(m.transactions),
                "cached_snapshots": len(m.snapshots),
                "closed":           m.closed,
        }
}</span>

// ListActiveTransactions 列出活跃事务
func (m *Manager) ListActiveTransactions() []XID <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        txns := make([]XID, 0, len(m.transactions))
        for xid := range m.transactions </span><span class="cov0" title="0">{
                txns = append(txns, xid)
        }</span>
        <span class="cov0" title="0">return txns</span>
}

// IsTransactionActive 检查事务是否活跃
func (m *Manager) IsTransactionActive(xid XID) bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        _, exists := m.transactions[xid]
        return exists
}</span>

// GetCommitLog 获取提交日志
func (m *Manager) GetCommitLog() *CommitLog <span class="cov0" title="0">{
        return m.clog
}</span>

// GetVisibilityChecker 获取可见性检查器
func (m *Manager) GetVisibilityChecker() *VisibilityChecker <span class="cov0" title="0">{
        return m.checker
}</span>

// SetTransactionStatus 设置事务状态（用于外部事务管理）
func (m *Manager) SetTransactionStatus(xid XID, status TransactionStatus) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        txn, exists := m.transactions[xid]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %d", xid)
        }</span>

        <span class="cov0" title="0">txn.SetStatus(status)

        if status == TxnStatusCommitted || status == TxnStatusAborted </span><span class="cov0" title="0">{
                txn.SetEndTime(time.Now())
                m.clog.SetStatus(xid, status)
                delete(m.transactions, xid)
                delete(m.snapshots, xid)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTransaction 获取事务
func (m *Manager) GetTransaction(xid XID) (*Transaction, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        txn, exists := m.transactions[xid]
        return txn, exists
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package mvcc

import (
        "sync"
        "time"
)

type Transaction struct {
        xid       XID
        snapshot  *Snapshot
        status    TransactionStatus
        createdAt time.Time
        startTime time.Time
        endTime   time.Time
        manager   *Manager
        level     IsolationLevel
        mvcc      bool
        commands  []Command
        reads     map[string]bool
        writes    map[string]*TupleVersion
        locks     map[string]bool
        mu        sync.RWMutex
}

func (t *Transaction) XID() XID <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.xid
}</span>

func (t *Transaction) Snapshot() *Snapshot <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.snapshot
}</span>

func (t *Transaction) Status() TransactionStatus <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.status
}</span>

func (t *Transaction) Level() IsolationLevel <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.level
}</span>

func (t *Transaction) IsMVCC() bool <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.mvcc
}</span>

func (t *Transaction) Age() time.Duration <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return time.Since(t.startTime)
}</span>

func (t *Transaction) SetStatus(status TransactionStatus) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.status = status
}</span>

func (t *Transaction) GetStatus() TransactionStatus <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.status
}</span>

func (t *Transaction) SetEndTime(endTime time.Time) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.endTime = endTime
}</span>

type Command interface {
        Apply() error
        Rollback() error
}

type WriteCommand struct {
        transaction *Transaction
        key         string
        version     *TupleVersion
        applied     bool
}

func (cmd *WriteCommand) Apply() error <span class="cov0" title="0">{
        if cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">cmd.applied = true
        return nil</span>
}

func (cmd *WriteCommand) Rollback() error <span class="cov0" title="0">{
        if !cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteCommand struct {
        transaction *Transaction
        key         string
        applied     bool
}

func (cmd *DeleteCommand) Apply() error <span class="cov0" title="0">{
        if cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">cmd.applied = true
        return nil</span>
}

func (cmd *DeleteCommand) Rollback() error <span class="cov0" title="0">{
        if !cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateCommand struct {
        transaction *Transaction
        key         string
        oldVersion  *TupleVersion
        newVersion  *TupleVersion
        applied     bool
}

func (cmd *UpdateCommand) Apply() error <span class="cov0" title="0">{
        if cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">if cmd.oldVersion != nil </span><span class="cov0" title="0">{
                cmd.oldVersion.MarkDeleted(cmd.transaction.xid, 0)
        }</span>
        <span class="cov0" title="0">cmd.applied = true
        return nil</span>
}

func (cmd *UpdateCommand) Rollback() error <span class="cov0" title="0">{
        if !cmd.applied </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">if cmd.oldVersion != nil </span><span class="cov0" title="0">{
                cmd.oldVersion.Expired = false
                cmd.oldVersion.Xmax = 0
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package mvcc

import (
        "fmt"
        "sync"
        "time"
)

// ==================== 常量定义 ====================

const (
        // XIDMax 最大事务ID（32位）
        XIDMax = XID(4294967295)
)

// ==================== 数据源能力 ====================

// DataSourceCapability 数据源能力等级
type DataSourceCapability int

const (
        CapabilityNone          DataSourceCapability = 0 // 不支持MVCC
        CapabilityReadSnapshot  DataSourceCapability = 1 // 支持读快照
        CapabilityWriteVersion  DataSourceCapability = 2 // 支持写多版本
        CapabilityFull          DataSourceCapability = 3 // 完全支持MVCC
)

// String 返回能力等级的字符串表示
func (c DataSourceCapability) String() string <span class="cov0" title="0">{
        switch c </span>{
        case CapabilityNone:<span class="cov0" title="0">
                return "None"</span>
        case CapabilityReadSnapshot:<span class="cov0" title="0">
                return "ReadSnapshot"</span>
        case CapabilityWriteVersion:<span class="cov0" title="0">
                return "WriteVersion"</span>
        case CapabilityFull:<span class="cov0" title="0">
                return "Full"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// DataSourceFeatures 数据源特性
type DataSourceFeatures struct {
        Name        string                // 数据源名称
        Capability  DataSourceCapability  // MVCC能力
        Supports    []string              // 支持的特性列表
        Config      map[string]interface{} // 配置项
        ReadOnly    bool                  // 是否只读
        Version     string                // 版本号
        CreatedAt   time.Time             // 创建时间
        mu          sync.RWMutex          // 互斥锁
}

// NewDataSourceFeatures 创建数据源特性
func NewDataSourceFeatures(name string, capability DataSourceCapability) *DataSourceFeatures <span class="cov0" title="0">{
        return &amp;DataSourceFeatures{
                Name:       name,
                Capability: capability,
                Supports:   make([]string, 0),
                Config:     make(map[string]interface{}),
                ReadOnly:   false,
                Version:    "1.0.0",
                CreatedAt:  time.Now(),
        }
}</span>

// Support 是否支持指定特性
func (f *DataSourceFeatures) Support(feature string) bool <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        for _, s := range f.Supports </span><span class="cov0" title="0">{
                if s == feature </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// AddSupport 添加支持特性
func (f *DataSourceFeatures) AddSupport(feature string) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.Supports = append(f.Supports, feature)
}</span>

// HasMVCC 是否支持MVCC
func (f *DataSourceFeatures) HasMVCC() bool <span class="cov0" title="0">{
        return f.Capability &gt;= CapabilityReadSnapshot
}</span>

// IsReadOnly 是否只读
func (f *DataSourceFeatures) IsReadOnly() bool <span class="cov0" title="0">{
        return f.ReadOnly
}</span>

// ==================== 事务ID (XID) ====================

// XID 事务ID (PostgreSQL风格：32位)
type XID uint32

// XIDNone 空事务ID
const XIDNone XID = 0

// XIDBootstrap 引导事务ID
const XIDBootstrap XID = 1

// IsBefore 是否在另一个XID之前
func (x XID) IsBefore(other XID) bool <span class="cov0" title="0">{
        // 处理环绕情况
        if x &lt; XIDBootstrap || other &lt; XIDBootstrap </span><span class="cov0" title="0">{
                return x &lt; other
        }</span>
        
        // 正常比较
        <span class="cov0" title="0">if x &gt; other </span><span class="cov0" title="0">{
                // 可能是环绕情况：x是新的，other是旧的
                return (XIDMax - x) &lt; (other - XIDBootstrap)
        }</span>
        <span class="cov0" title="0">return x &lt; other</span>
}

// IsAfter 是否在另一个XID之后
func (x XID) IsAfter(other XID) bool <span class="cov0" title="0">{
        return other.IsBefore(x)
}</span>

// String 返回XID的字符串表示
func (x XID) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d", x)
}</span>

// NextXID 生成下一个事务ID
func NextXID(current XID) XID <span class="cov0" title="0">{
        if current == XID(XIDMax) </span><span class="cov0" title="0">{
                return XIDBootstrap // 环绕
        }</span>
        <span class="cov0" title="0">return current + 1</span>
}

// ==================== 事务状态 ====================

// TransactionStatus 事务状态
type TransactionStatus int

const (
        TxnStatusInProgress TransactionStatus = 0 // 进行中
        TxnStatusCommitted TransactionStatus = 1  // 已提交
        TxnStatusAborted   TransactionStatus = 2  // 已回滚
)

// String 返回事务状态的字符串表示
func (s TransactionStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case TxnStatusInProgress:<span class="cov0" title="0">
                return "InProgress"</span>
        case TxnStatusCommitted:<span class="cov0" title="0">
                return "Committed"</span>
        case TxnStatusAborted:<span class="cov0" title="0">
                return "Aborted"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// ==================== 事务快照 ====================

// Snapshot 事务快照 (PostgreSQL风格)
type Snapshot struct {
        xmin     XID              // 最小的活跃事务ID
        xmax     XID              // 最大的已分配事务ID
        xip      []XID            // 活跃事务列表
        level    IsolationLevel   // 隔离级别
        created  time.Time        // 创建时间
        mu       sync.RWMutex     // 互斥锁
}

// NewSnapshot 创建新快照
func NewSnapshot(xmin, xmax XID, xip []XID, level IsolationLevel) *Snapshot <span class="cov0" title="0">{
        return &amp;Snapshot{
                xmin:    xmin,
                xmax:    xmax,
                xip:     xip,
                level:   level,
                created: time.Now(),
        }
}</span>

// Xmin 返回xmin
func (s *Snapshot) Xmin() XID <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.xmin
}</span>

// Xmax 返回xmax
func (s *Snapshot) Xmax() XID <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.xmax
}</span>

// Xip 返回活跃事务列表
func (s *Snapshot) Xip() []XID <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.xip
}</span>

// Level 返回隔离级别
func (s *Snapshot) Level() IsolationLevel <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.level
}</span>

// IsActive 检查事务是否在快照中是活跃的
func (s *Snapshot) IsActive(xid XID) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for _, activeXID := range s.xip </span><span class="cov0" title="0">{
                if activeXID == xid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Age 返回快照的年龄
func (s *Snapshot) Age() time.Duration <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return time.Since(s.created)
}</span>

// String 返回快照的字符串表示
func (s *Snapshot) String() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return fmt.Sprintf("Snapshot{xmin=%d, xmax=%d, xip=%v, level=%s}",
                s.xmin, s.xmax, s.xip, s.level)
}</span>

// ==================== 行版本 ====================

// TupleVersion 行版本 (PostgreSQL风格)
type TupleVersion struct {
        Data      interface{} // 数据
        Xmin      XID         // 创建事务ID
        Xmax      XID         // 删除事务ID（0表示未删除）
        Cmin      uint32      // 命令序号（创建）
        Cmax      uint32      // 命令序号（删除）
        CTID      string      // 行标识
        Expired   bool        // 是否已过期
        CreatedAt time.Time   // 创建时间
        mu        sync.RWMutex
}

// NewTupleVersion 创建新版本
func NewTupleVersion(data interface{}, xmin XID) *TupleVersion <span class="cov0" title="0">{
        return &amp;TupleVersion{
                Data:      data,
                Xmin:      xmin,
                Xmax:      0,
                Cmin:      0,
                Cmax:      0,
                CTID:      fmt.Sprintf("ctid:%d", time.Now().UnixNano()),
                Expired:   false,
                CreatedAt: time.Now(),
        }
}</span>

// IsVisibleTo 检查版本对快照是否可见 (PostgreSQL风格)
func (v *TupleVersion) IsVisibleTo(snapshot *Snapshot) bool <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()

        // 如果已过期，不可见
        if v.Expired </span><span class="cov0" title="0">{
                return false
        }</span>

        // 规则1: xmin必须在快照可见范围内
        // xmin &lt;= snapshot.xmin 或者 xmin不在活跃事务列表中
        <span class="cov0" title="0">if v.Xmin &gt; snapshot.Xmin() </span><span class="cov0" title="0">{
                // xmin &gt; snapshot.xmin，检查是否在活跃列表中
                if snapshot.IsActive(v.Xmin) </span><span class="cov0" title="0">{
                        return false // xmin仍然是活跃的，不可见
                }</span>
        }

        // 规则2: xmax必须为0（未删除）或者xmax &gt; snapshot.xmin
        <span class="cov0" title="0">if v.Xmax != 0 </span><span class="cov0" title="0">{
                // 行已被删除
                if v.Xmax &lt;= snapshot.Xmin() </span><span class="cov0" title="0">{
                        return false // 删除事务已提交，不可见
                }</span>
                <span class="cov0" title="0">if snapshot.IsActive(v.Xmax) </span><span class="cov0" title="0">{
                        return false // 删除事务仍然活跃，不可见
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// MarkDeleted 标记为已删除
func (v *TupleVersion) MarkDeleted(xmax XID, cmax uint32) <span class="cov0" title="0">{
        v.mu.Lock()
        defer v.mu.Unlock()
        v.Xmax = xmax
        v.Cmax = cmax
        v.Expired = true
}</span>

// MarkExpired 标记为过期
func (v *TupleVersion) MarkExpired() <span class="cov0" title="0">{
        v.mu.Lock()
        defer v.mu.Unlock()
        v.Expired = true
}</span>

// IsDeleted 检查是否已删除
func (v *TupleVersion) IsDeleted() bool <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.Xmax != 0
}</span>

// XminValue 返回xmin
func (v *TupleVersion) XminValue() XID <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.Xmin
}</span>

// XmaxValue 返回xmax
func (v *TupleVersion) XmaxValue() XID <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.Xmax
}</span>

// GetValue 返回数据
func (v *TupleVersion) GetValue() interface{} <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.Data
}</span>

// String 返回版本的字符串表示
func (v *TupleVersion) String() string <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return fmt.Sprintf("TupleVersion{data=%v, xmin=%d, xmax=%d, ctid=%s}",
                v.Data, v.Xmin, v.Xmax, v.CTID)
}</span>

// ==================== 隔离级别 ====================

// IsolationLevel 隔离级别
type IsolationLevel int

const (
        ReadUncommitted IsolationLevel = 0
        ReadCommitted   IsolationLevel = 1
        RepeatableRead  IsolationLevel = 2
        Serializable    IsolationLevel = 3
)

// String 返回隔离级别的字符串表示
func (l IsolationLevel) String() string <span class="cov0" title="0">{
        switch l </span>{
        case ReadUncommitted:<span class="cov0" title="0">
                return "ReadUncommitted"</span>
        case ReadCommitted:<span class="cov0" title="0">
                return "ReadCommitted"</span>
        case RepeatableRead:<span class="cov0" title="0">
                return "RepeatableRead"</span>
        case Serializable:<span class="cov0" title="0">
                return "Serializable"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// IsolationLevelFromString 从字符串解析隔离级别
func IsolationLevelFromString(s string) IsolationLevel <span class="cov0" title="0">{
        switch s </span>{
        case "READ UNCOMMITTED", "ReadUncommitted":<span class="cov0" title="0">
                return ReadUncommitted</span>
        case "READ COMMITTED", "ReadCommitted":<span class="cov0" title="0">
                return ReadCommitted</span>
        case "REPEATABLE READ", "RepeatableRead":<span class="cov0" title="0">
                return RepeatableRead</span>
        case "SERIALIZABLE", "Serializable":<span class="cov0" title="0">
                return Serializable</span>
        default:<span class="cov0" title="0">
                return RepeatableRead</span> // 默认
        }
}

// ==================== 可见性检查器 ====================

// VisibilityChecker 可见性检查器
type VisibilityChecker struct {
        mu sync.RWMutex
}

// NewVisibilityChecker 创建可见性检查器
func NewVisibilityChecker() *VisibilityChecker <span class="cov0" title="0">{
        return &amp;VisibilityChecker{}
}</span>

// Check 检查版本对快照是否可见
func (vc *VisibilityChecker) Check(version *TupleVersion, snapshot *Snapshot) bool <span class="cov0" title="0">{
        return version.IsVisibleTo(snapshot)
}</span>

// CheckBatch 批量检查多个版本
func (vc *VisibilityChecker) CheckBatch(versions []*TupleVersion, snapshot *Snapshot) []bool <span class="cov0" title="0">{
        vc.mu.RLock()
        defer vc.mu.RUnlock()
        
        result := make([]bool, len(versions))
        for i, version := range versions </span><span class="cov0" title="0">{
                result[i] = version.IsVisibleTo(snapshot)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// FilterVisible 过滤可见版本
func (vc *VisibilityChecker) FilterVisible(versions []*TupleVersion, snapshot *Snapshot) []*TupleVersion <span class="cov0" title="0">{
        vc.mu.RLock()
        defer vc.mu.RUnlock()
        
        visible := make([]*TupleVersion, 0)
        for _, version := range versions </span><span class="cov0" title="0">{
                if version.IsVisibleTo(snapshot) </span><span class="cov0" title="0">{
                        visible = append(visible, version)
                }</span>
        }
        <span class="cov0" title="0">return visible</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package optimizer

import (
        "context"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// TableStatistics 表统计信息
type TableStatistics struct {
        Name       string
        RowCount   int64
        ColumnStats map[string]*ColumnStatistics
}

// ColumnStatistics 列统计信息
type ColumnStatistics struct {
        Name          string
        DataType       string
        DistinctCount  int64  // NDV (Number of Distinct Values)
        NullCount      int64
        MinValue       interface{}
        MaxValue       interface{}
        NullFraction   float64
        AvgWidth      float64 // 平均字符串长度
}

// CardinalityEstimator 基数估算器接口
type CardinalityEstimator interface {
        // EstimateTableScan 估算表扫描的基数
        EstimateTableScan(tableName string) int64

        // EstimateFilter 估算过滤后的基数
        EstimateFilter(table string, filters []domain.Filter) int64

        // EstimateJoin 估算JOIN的输出行数
        EstimateJoin(left, right LogicalPlan, joinType JoinType) int64

        // EstimateDistinct 估算DISTINCT后的行数
        EstimateDistinct(table string, columns []string) int64

        // UpdateStatistics 更新表的统计信息
        UpdateStatistics(tableName string, stats *TableStatistics)
}

// SimpleCardinalityEstimator 简化的基数估算器
type SimpleCardinalityEstimator struct {
        stats map[string]*TableStatistics
}

// NewSimpleCardinalityEstimator 创建简化基数估算器
func NewSimpleCardinalityEstimator() *SimpleCardinalityEstimator <span class="cov0" title="0">{
        return &amp;SimpleCardinalityEstimator{
                stats: make(map[string]*TableStatistics),
        }
}</span>

// UpdateStatistics 更新统计信息
func (e *SimpleCardinalityEstimator) UpdateStatistics(tableName string, stats *TableStatistics) <span class="cov0" title="0">{
        e.stats[tableName] = stats
}</span>

// EstimateTableScan 估算表扫描基数
func (e *SimpleCardinalityEstimator) EstimateTableScan(tableName string) int64 <span class="cov0" title="0">{
        if stats, exists := e.stats[tableName]; exists </span><span class="cov0" title="0">{
                return stats.RowCount
        }</span>
        // 默认估计：假设1000行
        <span class="cov0" title="0">return 1000</span>
}

// EstimateFilter 估算过滤后的基数
func (e *SimpleCardinalityEstimator) EstimateFilter(table string, filters []domain.Filter) int64 <span class="cov0" title="0">{
        baseRowCount := e.EstimateTableScan(table)
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return baseRowCount
        }</span>

        // 计算每个过滤器的选择率
        <span class="cov0" title="0">totalSelectivity := 1.0
        for _, filter := range filters </span><span class="cov0" title="0">{
                sel := e.estimateFilterSelectivity(table, filter)
                if filter.LogicOp == "AND" </span><span class="cov0" title="0">{
                        // AND: 选择率相乘
                        totalSelectivity *= sel
                }</span> else<span class="cov0" title="0"> if filter.LogicOp == "OR" </span><span class="cov0" title="0">{
                        // OR: 处理OR子过滤器
                        // 简化：使用平均选择率
                        orSelectivity := 0.0
                        for i := range filter.SubFilters </span><span class="cov0" title="0">{
                                orSel := e.estimateFilterSelectivity(table, filter.SubFilters[i])
                                orSelectivity += orSel
                        }</span>
                        <span class="cov0" title="0">if len(filter.SubFilters) &gt; 0 </span><span class="cov0" title="0">{
                                totalSelectivity *= (orSelectivity / float64(len(filter.SubFilters)))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 单个条件
                        totalSelectivity *= sel
                }</span>
        }

        <span class="cov0" title="0">result := float64(baseRowCount) * totalSelectivity
        // 确保至少返回1行
        if result &lt; 1 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return int64(result)</span>
}

// estimateFilterSelectivity 估算单个过滤器的选择率
func (e *SimpleCardinalityEstimator) estimateFilterSelectivity(table string, filter domain.Filter) float64 <span class="cov0" title="0">{
        // 处理逻辑组合
        if filter.LogicOp == "AND" || filter.LogicOp == "OR" </span><span class="cov0" title="0">{
                return e.estimateLogicSelectivity(table, filter)
        }</span>

        <span class="cov0" title="0">stats, exists := e.stats[table]
        if !exists </span><span class="cov0" title="0">{
                // 没有统计信息时使用默认选择率
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        <span class="cov0" title="0">colStats, colExists := stats.ColumnStats[filter.Field]
        if !colExists </span><span class="cov0" title="0">{
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=", "!=":<span class="cov0" title="0">
                // 等值查询：选择率 = 1/NDV
                if colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        return 1.0 / float64(colStats.DistinctCount)
                }</span>
                <span class="cov0" title="0">return 0.1</span>

        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov0" title="0">
                // 范围查询
                return e.estimateRangeSelectivity(filter.Operator, filter.Value, colStats)</span>

        case "IN":<span class="cov0" title="0">
                // IN操作：假设平均每IN列表有10个值
                if valList, ok := filter.Value.([]interface{}); ok &amp;&amp; len(valList) &gt; 0 </span><span class="cov0" title="0">{
                        return float64(len(valList)) / float64(colStats.DistinctCount)
                }</span>
                <span class="cov0" title="0">return 0.1</span>

        case "BETWEEN":<span class="cov0" title="0">
                // BETWEEN操作
                if vals, ok := filter.Value.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov0" title="0">{
                        return e.estimateRangeSelectivity("&gt;=", vals[0], colStats) *
                                e.estimateRangeSelectivity("&lt;=", vals[1], colStats)
                }</span>
                <span class="cov0" title="0">return 0.3</span>

        case "LIKE":<span class="cov0" title="0">
                // LIKE操作：保守估计0.1-0.5
                return 0.25</span>

        default:<span class="cov0" title="0">
                return e.getDefaultSelectivity(filter.Operator)</span>
        }
}

// estimateLogicSelectivity 估算逻辑组合的选择率
func (e *SimpleCardinalityEstimator) estimateLogicSelectivity(table string, filter domain.Filter) float64 <span class="cov0" title="0">{
        if len(filter.SubFilters) == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">switch filter.LogicOp </span>{
        case "AND":<span class="cov0" title="0">
                // AND: 选择率相乘
                sel := 1.0
                for _, subFilter := range filter.SubFilters </span><span class="cov0" title="0">{
                        sel *= e.estimateFilterSelectivity(table, subFilter)
                }</span>
                <span class="cov0" title="0">return sel</span>

        case "OR":<span class="cov0" title="0">
                // OR: 选择率 = 1 - (1-s1)*(1-s2)*...*(1-sn)
                // 简化：使用包含关系
                sel := 0.0
                for _, subFilter := range filter.SubFilters </span><span class="cov0" title="0">{
                        subSel := e.estimateFilterSelectivity(table, subFilter)
                        sel += subSel
                }</span>
                // 避免超过1.0
                <span class="cov0" title="0">if sel &gt; 0.95 </span><span class="cov0" title="0">{
                        sel = 0.95
                }</span>
                <span class="cov0" title="0">return sel</span>

        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

// estimateRangeSelectivity 估算范围查询的选择率
func (e *SimpleCardinalityEstimator) estimateRangeSelectivity(operator string, value interface{}, colStats *ColumnStatistics) float64 <span class="cov0" title="0">{
        minVal := colStats.MinValue
        maxVal := colStats.MaxValue

        if minVal == nil || maxVal == nil </span><span class="cov0" title="0">{
                return 0.1
        }</span>

        <span class="cov0" title="0">minFloat, _ := toFloat64(minVal)
        maxFloat, _ := toFloat64(maxVal)
        valFloat, _ := toFloat64(value)

        if minFloat == maxFloat </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">rangeSize := maxFloat - minFloat
        if rangeSize == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "&gt;":<span class="cov0" title="0">
                // value &gt; min: (max - value) / (max - min)
                if valFloat &lt;= minFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (maxFloat - valFloat) / rangeSize</span>

        case "&gt;=":<span class="cov0" title="0">
                // value &gt;= min: (max - value) / (max - min)
                if valFloat &lt; minFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (maxFloat - valFloat + 0.0001) / rangeSize</span>

        case "&lt;":<span class="cov0" title="0">
                // value &lt; max: (value - min) / (max - min)
                if valFloat &gt;= maxFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (valFloat - minFloat) / rangeSize</span>

        case "&lt;=":<span class="cov0" title="0">
                // value &lt;= max: (value - min) / (max - min)
                if valFloat &gt; maxFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (valFloat - minFloat + 0.0001) / rangeSize</span>

        default:<span class="cov0" title="0">
                return 0.5</span>
        }
}

// getDefaultSelectivity 获取默认选择率
func (e *SimpleCardinalityEstimator) getDefaultSelectivity(operator string) float64 <span class="cov0" title="0">{
        switch operator </span>{
        case "=", "!=":<span class="cov0" title="0">
                return 0.1</span> // 等值查询：10%
        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov0" title="0">
                return 0.3</span> // 范围查询：30%
        case "IN":<span class="cov0" title="0">
                return 0.2</span> // IN查询：20%
        case "BETWEEN":<span class="cov0" title="0">
                return 0.3</span> // BETWEEN查询：30%
        case "LIKE":<span class="cov0" title="0">
                return 0.25</span> // LIKE查询：25%
        default:<span class="cov0" title="0">
                return 0.5</span> // 默认：50%
        }
}

// EstimateJoin 估算JOIN的基数
func (e *SimpleCardinalityEstimator) EstimateJoin(left, right LogicalPlan, joinType JoinType) int64 <span class="cov0" title="0">{
        // 获取左右表的基数
        leftCount := e.estimateRowCount(left)
        rightCount := e.estimateRowCount(right)

        if leftCount == 0 || rightCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 根据JOIN类型估算
        <span class="cov0" title="0">switch joinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN: 假设每个左表行匹配右表的1/N个行
                // 简化估计: min(left, right)
                return min(leftCount, rightCount)</span>

        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN: 输出 = 左表行数
                return leftCount</span>

        case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN: 输出 = 右表行数
                return rightCount</span>

        case FullOuterJoin:<span class="cov0" title="0">
                // FULL JOIN: 输出 ≈ left + right - matches
                return leftCount + rightCount/2</span>

        default:<span class="cov0" title="0">
                return min(leftCount, rightCount)</span>
        }
}

// estimateRowCount 估算逻辑计划的行数
func (e *SimpleCardinalityEstimator) estimateRowCount(plan LogicalPlan) int64 <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return e.EstimateTableScan(dataSource.TableName)
        }</span>

        <span class="cov0" title="0">if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                if len(selection.children) &gt; 0 </span><span class="cov0" title="0">{
                        tableName := getTableName(selection.children[0])
                        conditions := selection.Conditions()
                        // 转换表达式到过滤器
                        filters := make([]domain.Filter, len(conditions))
                        for i, cond := range conditions </span><span class="cov0" title="0">{
                                filters[i] = domain.Filter{
                                        Field:    expressionToString(cond),
                                        Operator:  "=",
                                        Value:     cond.Value,
                                }
                        }</span>
                        <span class="cov0" title="0">return e.EstimateFilter(tableName, filters)</span>
                }
        }

        // 其他算子：返回子节点的行数
        <span class="cov0" title="0">children := plan.Children()
        if len(children) &gt; 0 </span><span class="cov0" title="0">{
                return e.estimateRowCount(children[0])
        }</span>

        <span class="cov0" title="0">return 1000</span> // 默认值
}

// getTableName 获取逻辑计划的表名
func getTableName(plan LogicalPlan) string <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return dataSource.TableName
        }</span>
        <span class="cov0" title="0">children := plan.Children()
        if len(children) &gt; 0 </span><span class="cov0" title="0">{
                return getTableName(children[0])
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// EstimateDistinct 估算DISTINCT后的行数
func (e *SimpleCardinalityEstimator) EstimateDistinct(table string, columns []string) int64 <span class="cov0" title="0">{
        stats, exists := e.stats[table]
        if !exists </span><span class="cov0" title="0">{
                return e.EstimateTableScan(table) / 2
        }</span>

        <span class="cov0" title="0">if len(columns) == 0 </span><span class="cov0" title="0">{
                return stats.RowCount
        }</span>

        // 简化：取最小NDV
        <span class="cov0" title="0">minNDV := int64(math.MaxInt64)
        for _, col := range columns </span><span class="cov0" title="0">{
                if colStats, ok := stats.ColumnStats[col]; ok &amp;&amp; colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        if colStats.DistinctCount &lt; minNDV </span><span class="cov0" title="0">{
                                minNDV = colStats.DistinctCount
                        }</span>
                }
        }

        <span class="cov0" title="0">if minNDV == math.MaxInt64 </span><span class="cov0" title="0">{
                return stats.RowCount / 2
        }</span>

        <span class="cov0" title="0">return minNDV</span>
}

// CollectStatistics 从数据源收集统计信息（简化版）
func CollectStatistics(dataSource domain.DataSource, tableName string) (*TableStatistics, error) <span class="cov0" title="0">{
        // 执行查询获取所有数据
        result, err := dataSource.Query(context.Background(), tableName, &amp;domain.QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := &amp;TableStatistics{
                Name:       tableName,
                RowCount:   result.Total,
                ColumnStats: make(map[string]*ColumnStatistics),
        }

        // 为每列收集统计信息
        for _, colInfo := range result.Columns </span><span class="cov0" title="0">{
                stats.ColumnStats[colInfo.Name] = collectColumnStatistics(result.Rows, colInfo.Name, colInfo.Type)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// collectColumnStatistics 收集列的统计信息
func collectColumnStatistics(rows []domain.Row, columnName, columnType string) *ColumnStatistics <span class="cov0" title="0">{
        stats := &amp;ColumnStatistics{
                Name:    columnName,
                DataType: columnType,
        }

        // 收集值
        values := make([]interface{}, 0, len(rows))
        distinctValues := make(map[interface{}]bool)
        nullCount := int64(0)
        totalWidth := 0.0

        for _, row := range rows </span><span class="cov0" title="0">{
                val := row[columnName]
                values = append(values, val)

                if val == nil </span><span class="cov0" title="0">{
                        nullCount++
                        continue</span>
                }

                <span class="cov0" title="0">distinctValues[val] = true

                // 对于字符串类型，计算平均宽度
                if s, ok := val.(string); ok </span><span class="cov0" title="0">{
                        totalWidth += float64(len(s))
                }</span>
        }

        // 计算统计信息
        <span class="cov0" title="0">stats.NullCount = nullCount
        stats.NullFraction = float64(nullCount) / float64(len(rows))
        stats.DistinctCount = int64(len(distinctValues))

        // 计算Min和Max
        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                stats.MinValue = values[0]
                stats.MaxValue = values[0]

                for _, val := range values </span><span class="cov0" title="0">{
                        if val != nil </span><span class="cov0" title="0">{
                                if compareValues(val, stats.MinValue) &lt; 0 </span><span class="cov0" title="0">{
                                        stats.MinValue = val
                                }</span>
                                <span class="cov0" title="0">if compareValues(val, stats.MaxValue) &gt; 0 </span><span class="cov0" title="0">{
                                        stats.MaxValue = val
                                }</span>
                        }
                }

                // 计算平均宽度
                <span class="cov0" title="0">if len(values)-int(nullCount) &gt; 0 </span><span class="cov0" title="0">{
                        stats.AvgWidth = totalWidth / float64(len(values)-int(nullCount))
                }</span>
        }

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package optimizer

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/builtin"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// ExpressionEvaluator 表达式求值器
type ExpressionEvaluator struct {
        functionAPI *builtin.FunctionAPI
}

// NewExpressionEvaluator 创建表达式求值器
func NewExpressionEvaluator(fnAPI *builtin.FunctionAPI) *ExpressionEvaluator <span class="cov0" title="0">{
        return &amp;ExpressionEvaluator{
                functionAPI: fnAPI,
        }
}</span>

// NewExpressionEvaluatorWithoutAPI 创建不依赖函数API的表达式求值器
// 用于不需要调用函数的场景（如常量折叠）
func NewExpressionEvaluatorWithoutAPI() *ExpressionEvaluator <span class="cov8" title="1">{
        return &amp;ExpressionEvaluator{
                functionAPI: nil,
        }
}</span>

// Evaluate 计算表达式的值
func (e *ExpressionEvaluator) Evaluate(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">switch expr.Type </span>{
        case parser.ExprTypeColumn:<span class="cov0" title="0">
                // 列引用
                if val, exists := row[expr.Column]; exists </span><span class="cov0" title="0">{
                        return val, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("column not found: %s", expr.Column)</span>

        case parser.ExprTypeValue:<span class="cov0" title="0">
                // 字面量值
                return expr.Value, nil</span>

        case parser.ExprTypeOperator:<span class="cov0" title="0">
                // 运算符表达式
                return e.evaluateOperator(expr, row)</span>

        case parser.ExprTypeFunction:<span class="cov0" title="0">
                // 函数调用
                return e.evaluateFunction(expr, row)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported expression type: %v", expr.Type)</span>
        }
}

// evaluateOperator 计算运算符表达式
func (e *ExpressionEvaluator) evaluateOperator(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Operator == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operator is empty")
        }</span>

        // 处理逻辑运算符
        <span class="cov0" title="0">if strings.EqualFold(expr.Operator, "and") || strings.EqualFold(expr.Operator, "or") </span><span class="cov0" title="0">{
                return e.evaluateLogicalOp(expr, row)
        }</span>

        // 处理一元运算符
        <span class="cov0" title="0">if expr.Right == nil </span><span class="cov0" title="0">{
                return e.evaluateUnaryOp(expr, row)
        }</span>

        // 处理二元运算符
        <span class="cov0" title="0">if expr.Left == nil || expr.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid operator expression: missing operand")
        }</span>

        <span class="cov0" title="0">left, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left operand evaluation failed: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.Evaluate(expr.Right, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right operand evaluation failed: %w", err)
        }</span>

        // 根据运算符类型计算
        <span class="cov0" title="0">switch strings.ToLower(expr.Operator) </span>{
        case "=":<span class="cov0" title="0">
                return e.compareValues(left, right) == 0, nil</span>
        case "!=", "&lt;&gt;":<span class="cov0" title="0">
                return e.compareValues(left, right) != 0, nil</span>
        case "&gt;":<span class="cov0" title="0">
                return e.compareValues(left, right) &gt; 0, nil</span>
        case "&gt;=":<span class="cov0" title="0">
                return e.compareValues(left, right) &gt;= 0, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return e.compareValues(left, right) &lt; 0, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return e.compareValues(left, right) &lt;= 0, nil</span>
        case "+":<span class="cov0" title="0">
                return e.addValues(left, right)</span>
        case "-":<span class="cov0" title="0">
                return e.subValues(left, right)</span>
        case "*":<span class="cov0" title="0">
                return e.mulValues(left, right)</span>
        case "/":<span class="cov0" title="0">
                return e.divValues(left, right)</span>
        case "like":<span class="cov0" title="0">
                return e.likeValues(left, right), nil</span>
        case "not like":<span class="cov0" title="0">
                return !e.likeValues(left, right), nil</span>
        case "in":<span class="cov0" title="0">
                return e.inValues(left, right), nil</span>
        case "not in":<span class="cov0" title="0">
                return !e.inValues(left, right), nil</span>
        case "between":<span class="cov0" title="0">
                if vals, ok := right.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov0" title="0">{
                        return e.betweenValues(left, vals[0], vals[1]), nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported operator: %s", expr.Operator)</span>
        }
}

// evaluateLogicalOp 计算逻辑运算符
func (e *ExpressionEvaluator) evaluateLogicalOp(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Left == nil || expr.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid logical operator expression")
        }</span>

        <span class="cov0" title="0">left, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 短路求值
        <span class="cov0" title="0">if strings.EqualFold(expr.Operator, "and") </span><span class="cov0" title="0">{
                if !e.isTrue(left) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">right, err := e.Evaluate(expr.Right, row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return e.isTrue(right), nil</span>
        }

        // OR
        <span class="cov0" title="0">if e.isTrue(left) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">right, err := e.Evaluate(expr.Right, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return e.isTrue(right), nil</span>
}

// evaluateUnaryOp 计算一元运算符
func (e *ExpressionEvaluator) evaluateUnaryOp(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Left == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid unary operator expression: missing operand")
        }</span>

        <span class="cov0" title="0">operand, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch strings.ToLower(expr.Operator) </span>{
        case "-":<span class="cov0" title="0">
                // 负号
                if num, ok := toFloat64(operand); ok </span><span class="cov0" title="0">{
                        return -num, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot apply unary minus to non-numeric value")</span>
        case "+":<span class="cov0" title="0">
                // 正号
                return operand, nil</span>
        case "not":<span class="cov0" title="0">
                // 逻辑非
                return !e.isTrue(operand), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported unary operator: %s", expr.Operator)</span>
        }
}

// evaluateFunction 计算函数调用（支持自定义函数）
func (e *ExpressionEvaluator) evaluateFunction(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Function == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function name is empty")
        }</span>

        // 转换为小写以支持大小写不敏感的函数名
        <span class="cov0" title="0">funcName := strings.ToLower(expr.Function)

        // 优先从FunctionAPI获取函数（包括内置和用户函数）
        if e.functionAPI == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function API not initialized")
        }</span>

        <span class="cov0" title="0">info, err := e.functionAPI.GetFunction(funcName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function not found: %s", expr.Function)
        }</span>

        // 计算参数（带类型检查）
        <span class="cov0" title="0">args := make([]interface{}, 0, len(expr.Args))
        for i, argExpr := range expr.Args </span><span class="cov0" title="0">{
                argValue, err := e.Evaluate(&amp;argExpr, row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument %d evaluation failed for function %s: %w", i, expr.Function, err)
                }</span>

                // 类型检查和自动转换
                <span class="cov0" title="0">convertedValue, err := e.convertToExpectedType(argValue, info.Parameters, i)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument %d type conversion failed for function %s: %w", i, expr.Function, err)
                }</span>
                <span class="cov0" title="0">args = append(args, convertedValue)</span>
        }

        // 调用函数处理函数
        <span class="cov0" title="0">result, err := info.Handler(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s execution failed: %w", expr.Function, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// convertToExpectedType 将值转换为期望的类型
func (e *ExpressionEvaluator) convertToExpectedType(value interface{}, params []builtin.FunctionParam, argIndex int) (interface{}, error) <span class="cov0" title="0">{
        if argIndex &gt;= len(params) </span><span class="cov0" title="0">{
                return value, nil // 参数数量不匹配，返回原值
        }</span>

        <span class="cov0" title="0">expectedType := params[argIndex].Type

        // 如果期望类型为空或值为nil，直接返回
        if expectedType == "" || value == nil </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // 类型转换映射
        <span class="cov0" title="0">switch expectedType </span>{
        case "int", "integer":<span class="cov0" title="0">
                return e.toInt(value)</span>
        case "bigint", "long":<span class="cov0" title="0">
                return e.toInt64(value)</span>
        case "decimal", "numeric", "number":<span class="cov0" title="0">
                return e.toFloat64(value)</span>
        case "varchar", "char", "text", "string":<span class="cov0" title="0">
                return e.toString(value)</span>
        default:<span class="cov0" title="0">
                return value, nil</span> // 未知类型，返回原值
        }
}

// exists 检查值是否存在（替代 ! 运算符）
func (e *ExpressionEvaluator) exists(v interface{}) bool <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch v.(type) </span>{
        case string:<span class="cov0" title="0">
                return len(v.(string)) &gt; 0</span>
        case []interface{}:<span class="cov0" title="0">
                return len(v.([]interface{})) &gt; 0</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return len(v.(map[string]interface{})) &gt; 0</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// toInt 转换为int
func (e *ExpressionEvaluator) toInt(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to int")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return val, nil</span>
        case int8:<span class="cov0" title="0">
                return int(val), nil</span>
        case int16:<span class="cov0" title="0">
                return int(val), nil</span>
        case int32:<span class="cov0" title="0">
                return int(val), nil</span>
        case int64:<span class="cov0" title="0">
                return int(val), nil</span>
        case float32:<span class="cov0" title="0">
                return int(float64(val)), nil</span>
        case float64:<span class="cov0" title="0">
                return int(val), nil</span>
        case string:<span class="cov0" title="0">
                // 尝试解析字符串
                var result int
                _, err := fmt.Sscanf(val, "%d", &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot convert string '%s' to int: %v", val, err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to int", reflect.TypeOf(v))</span>
        }
}

// toInt64 转换为int64
func (e *ExpressionEvaluator) toInt64(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to int64")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32:<span class="cov0" title="0">
                return int64(val), nil</span>
        case float64:<span class="cov0" title="0">
                return int64(val), nil</span>
        case string:<span class="cov0" title="0">
                // 尝试解析字符串
                var result int64
                _, err := fmt.Sscanf(val, "%d", &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot convert string '%s' to int64: %v", val, err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to int64", reflect.TypeOf(v))</span>
        }
}

// toFloat64 转换为float64
func (e *ExpressionEvaluator) toFloat64(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to float64")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(val), nil</span>
        case float32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case float64:<span class="cov0" title="0">
                return val, nil</span>
        case string:<span class="cov0" title="0">
                result, err := strconv.ParseFloat(val, 64)
                if err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                // 尝试解析整数
                <span class="cov0" title="0">var intResult int64
                _, intErr := fmt.Sscanf(val, "%d", &amp;intResult)
                if intErr == nil </span><span class="cov0" title="0">{
                        return float64(intResult), nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to float64", reflect.TypeOf(v))</span>
        }
}

// toString 转换为string
func (e *ExpressionEvaluator) toString(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", val), nil</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val), nil</span>
        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", val), nil</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val), nil</span>
        }
}

// compareValues 比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func (e *ExpressionEvaluator) compareValues(a, b interface{}) int <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // 尝试数值比较
        <span class="cov0" title="0">aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                if aNum &lt; bNum </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aNum &gt; bNum </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // 字符串比较
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// addValues 加法运算
func (e *ExpressionEvaluator) addValues(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                return aNum + bNum, nil
        }</span>

        // 字符串连接
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        return aStr + bStr, nil</span>
}

// subValues 减法运算
func (e *ExpressionEvaluator) subValues(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                return aNum - bNum, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("cannot subtract non-numeric values")</span>
}

// mulValues 乘法运算
func (e *ExpressionEvaluator) mulValues(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                return aNum * bNum, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("cannot multiply non-numeric values")</span>
}

// divValues 除法运算
func (e *ExpressionEvaluator) divValues(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if !aOk || !bOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot divide non-numeric values")
        }</span>
        <span class="cov0" title="0">if bNum == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division by zero")
        }</span>
        <span class="cov0" title="0">return aNum / bNum, nil</span>
}

// likeValues LIKE 模式匹配
func (e *ExpressionEvaluator) likeValues(value, pattern interface{}) bool <span class="cov0" title="0">{
        valStr := fmt.Sprintf("%v", value)
        patStr := fmt.Sprintf("%v", pattern)

        // 简单的LIKE实现：支持 % 和 _ 通配符
        patternRegex := strings.ReplaceAll(patStr, "%", ".*")
        patternRegex = strings.ReplaceAll(patternRegex, "_", ".")
        patternRegex = "^" + patternRegex + "$"

        // 注意：完整的实现应该使用正则表达式包
        // 这里简化为使用strings.Contains和通配符匹配
        if !strings.Contains(patStr, "%") &amp;&amp; !strings.Contains(patStr, "_") </span><span class="cov0" title="0">{
                return valStr == patStr
        }</span>

        // 简化实现：只检查是否包含
        <span class="cov0" title="0">if strings.HasPrefix(patStr, "%") &amp;&amp; strings.HasSuffix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.Trim(patStr, "%")
                return strings.Contains(valStr, subPat)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.TrimPrefix(patStr, "%")
                return strings.HasSuffix(valStr, subPat)
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.TrimSuffix(patStr, "%")
                return strings.HasPrefix(valStr, subPat)
        }</span>

        <span class="cov0" title="0">return false</span>
}

// inValues IN 操作
func (e *ExpressionEvaluator) inValues(value, values interface{}) bool <span class="cov0" title="0">{
        valList, ok := values.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, v := range valList </span><span class="cov0" title="0">{
                if e.compareValues(value, v) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// betweenValues BETWEEN 操作
func (e *ExpressionEvaluator) betweenValues(value, min, max interface{}) bool <span class="cov0" title="0">{
        return e.compareValues(value, min) &gt;= 0 &amp;&amp; e.compareValues(value, max) &lt;= 0
}</span>

// isTrue 判断值是否为真
func (e *ExpressionEvaluator) isTrue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Int() != 0</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Uint() != 0</span>
        case float32, float64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Float() != 0</span>
        case string:<span class="cov0" title="0">
                return v != ""</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// JoinEliminationRule JOIN消除规则
// 消除冗余的JOIN操作，如1:1的外键主键JOIN
type JoinEliminationRule struct {
        cardinalityEstimator CardinalityEstimator
}

// Name 返回规则名称
func (r *JoinEliminationRule) Name() string <span class="cov8" title="1">{
        return "JoinElimination"
}</span>

// Match 检查规则是否匹配
func (r *JoinEliminationRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        // 检查是否包含JOIN节点
        return containsJoin(plan)
}</span>

// Apply 应用规则：消除冗余JOIN
func (r *JoinEliminationRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 尝试消除每个JOIN节点
        return r.eliminateJoins(plan), nil
}</span>

// eliminateJoins 递归消除JOIN节点
func (r *JoinEliminationRule) eliminateJoins(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if join, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                // 检查是否可以消除这个JOIN
                if r.canEliminate(join) </span><span class="cov0" title="0">{
                        // 消除JOIN：返回子节点
                        if len(join.Children()) &gt; 0 </span><span class="cov0" title="0">{
                                return join.Children()[0]
                        }</span>
                        <span class="cov0" title="0">return plan</span>
                }
        }

        // 递归处理子节点
        <span class="cov0" title="0">for i, child := range plan.Children() </span><span class="cov0" title="0">{
                newChild := r.eliminateJoins(child)
                if newChild != child </span><span class="cov0" title="0">{
                        children := plan.Children()
                        children[i] = newChild
                        plan.SetChildren(children...)
                        return plan
                }</span>
        }

        <span class="cov0" title="0">return plan</span>
}

// canEliminate 检查是否可以消除JOIN
func (r *JoinEliminationRule) canEliminate(join *LogicalJoin) bool <span class="cov0" title="0">{
        // 简化实现：检查以下情况
        // 1. 1:1的JOIN（外键主键关系）
        // 2. 连接条件包含等式
        // 3. 右表（或左表）可以被推导

        conditions := join.GetJoinConditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return false // 没有连接条件，不能消除
        }</span>

        // 检查连接条件是否为等值
        <span class="cov0" title="0">for i := range conditions </span><span class="cov0" title="0">{
                if !isEqualityCondition(conditions[i]) </span><span class="cov0" title="0">{
                        return false // 不是等值条件，不能消除
                }</span>
        }

        // 检查是否为1:1关系
        <span class="cov0" title="0">leftCardinality := r.cardinalityEstimator.EstimateFilter(getTableName(join.Children()[0]), []domain.Filter{})
        rightCardinality := r.cardinalityEstimator.EstimateFilter(getTableName(join.Children()[1]), []domain.Filter{})

        // 如果一边表很小（如1行），可以考虑消除
        if leftCardinality &lt;= 1 || rightCardinality &lt;= 1 </span><span class="cov0" title="0">{
                return true
        }</span>

        // 检查是否为外键-主键关系（简化版）
        // 实际应该从schema中提取外键信息
        <span class="cov0" title="0">if r.isForeignKeyPrimaryKeyJoin(join) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isEqualityCondition 检查条件是否为等值
func isEqualityCondition(cond *JoinCondition) bool <span class="cov0" title="0">{
        // 简化：检查连接条件的结构
        // 实际应该检查表达式类型
        return cond.Left != nil &amp;&amp; cond.Right != nil &amp;&amp; cond.Operator == "="
}</span>

// isForeignKeyPrimaryKeyJoin 检查是否为外键-主键JOIN（简化版）
func (r *JoinEliminationRule) isForeignKeyPrimaryKeyJoin(join *LogicalJoin) bool <span class="cov0" title="0">{
        // 简化实现：假设表名包含外键信息
        // 实际应该从schema中读取外键定义

        leftTables := extractTableNames(join.Children()[0])
        rightTables := extractTableNames(join.Children()[1])

        if len(leftTables) != 1 || len(rightTables) != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 简化判断：如果表名包含_id或以_id结尾，可能是主键
        <span class="cov0" title="0">leftTable := leftTables[0]
        rightTable := rightTables[0]

        // 检查连接条件
        conditions := join.GetJoinConditions()
        for _, cond := range conditions </span><span class="cov0" title="0">{
                // 如果连接条件是 id = other_id，可能是外键主键关系
                leftExpr := expressionToString(cond.Left)
                rightExpr := expressionToString(cond.Right)
                if (leftExpr == "id" || leftExpr == "id_"+leftTable) &amp;&amp;
                        (rightExpr == rightTable+"_id" || rightExpr == "id") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// expressionToString 将表达式转换为字符串（简化版）
func expressionToString(expr *parser.Expression) string <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        // 简化实现：直接返回字面量值或列名
        // 实际应该遍历表达式树
        <span class="cov0" title="0">if expr.Type == parser.ExprTypeValue </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", expr.Value)
        }</span>
        <span class="cov0" title="0">if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                return expr.Column
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// extractTableNames 从计划中提取表名
func extractTableNames(plan LogicalPlan) []string <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return []string{dataSource.TableName}
        }</span>

        <span class="cov0" title="0">tables := make(map[string]bool)
        for _, child := range plan.Children() </span><span class="cov0" title="0">{
                childTables := extractTableNames(child)
                for _, t := range childTables </span><span class="cov0" title="0">{
                        tables[t] = true
                }</span>
        }

        <span class="cov0" title="0">result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// NewJoinEliminationRule 创建JOIN消除规则
func NewJoinEliminationRule(estimator CardinalityEstimator) *JoinEliminationRule <span class="cov0" title="0">{
        return &amp;JoinEliminationRule{
                cardinalityEstimator: estimator,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// JoinReorderRule JOIN重排序规则
// 使用贪心算法选择最优的JOIN顺序
type JoinReorderRule struct {
        cardinalityEstimator CardinalityEstimator
        costModel            CostModel
}

// Name 返回规则名称
func (r *JoinReorderRule) Name() string <span class="cov8" title="1">{
        return "JoinReorder"
}</span>

// Match 检查规则是否匹配
func (r *JoinReorderRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        // 检查是否包含JOIN节点
        return containsJoin(plan)
}</span>

// containsJoin 递归检查是否包含JOIN节点
func containsJoin(plan LogicalPlan) bool <span class="cov8" title="1">{
        // 检查当前节点
        if _, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if _, ok := plan.(*LogicalDataSource); ok </span><span class="cov8" title="1">{
                // DataSource节点，不需要递归检查
                return false
        }</span>

        // 递归检查子节点
        <span class="cov8" title="1">children := plan.Children()
        if children == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, child := range children </span><span class="cov8" title="1">{
                if containsJoin(child) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Apply 应用规则：重排序JOIN顺序
func (r *JoinReorderRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] JoinReorderRule.Apply: 开始")
        // 收集所有JOIN节点
        joinNodes := collectJoins(plan)
        fmt.Println("  [DEBUG] JoinReorderRule.Apply: 收集到JOIN节点数:", len(joinNodes))

        if len(joinNodes) &lt; 2 </span><span class="cov0" title="0">{
                // 少于2个JOIN，不需要重排序
                return plan, nil
        }</span>

        // 提取涉及的表
        <span class="cov0" title="0">tables := extractTablesFromJoins(joinNodes)

        if len(tables) &lt; 2 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        // 使用贪心算法选择最优JOIN顺序
        <span class="cov0" title="0">optimalOrder, minCost := r.findOptimalJoinOrder(tables, joinNodes, optCtx)

        if minCost &gt;= math.MaxFloat64 </span><span class="cov0" title="0">{
                // 没找到有效的顺序，返回原计划
                return plan, nil
        }</span>

        // 重新构建JOIN树
        <span class="cov0" title="0">return r.rebuildJoinTree(joinNodes[0], optimalOrder, joinNodes)</span>
}

// findOptimalJoinOrder 使用贪心算法找到最优JOIN顺序
func (r *JoinReorderRule) findOptimalJoinOrder(
        tables []string,
        joinNodes []*LogicalJoin,
        optCtx *OptimizationContext,
) ([]string, float64) <span class="cov0" title="0">{

        if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil, math.MaxFloat64
        }</span>

        // 贪心算法：
        // 1. 选择基数最小的表作为起点
        // 2. 每次选择与已选表集JOIN成本最小的表
        // 3. 直到所有表都被选入

        <span class="cov0" title="0">remainingTables := make([]string, len(tables))
        copy(remainingTables, tables)

        selectedTables := []string{}
        minCost := 0.0

        // 第一轮：选择基数最小的表
        var firstTable string
        minCardinality := int64(math.MaxInt64)

        for _, table := range remainingTables </span><span class="cov0" title="0">{
                card := r.cardinalityEstimator.EstimateTableScan(table)
                if card &lt; minCardinality </span><span class="cov0" title="0">{
                        minCardinality = card
                        firstTable = table
                }</span>
        }

        <span class="cov0" title="0">selectedTables = append(selectedTables, firstTable)
        remainingTables = removeTable(remainingTables, firstTable)

        // 后续轮：贪心选择
        for len(remainingTables) &gt; 0 </span><span class="cov0" title="0">{
                bestTable := ""
                bestCost := math.MaxFloat64

                for _, table := range remainingTables </span><span class="cov0" title="0">{
                        // 估算将table加入已选表集的成本
                        cost := r.estimateJoinCost(selectedTables, table, joinNodes, optCtx)
                        if cost &lt; bestCost </span><span class="cov0" title="0">{
                                bestCost = cost
                                bestTable = table
                        }</span>
                }

                <span class="cov0" title="0">if bestTable == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">selectedTables = append(selectedTables, bestTable)
                minCost += bestCost
                remainingTables = removeTable(remainingTables, bestTable)</span>
        }

        <span class="cov0" title="0">return selectedTables, minCost</span>
}

// estimateJoinCost 估算JOIN成本
func (r *JoinReorderRule) estimateJoinCost(
        selectedTables []string,
        newTable string,
        joinNodes []*LogicalJoin,
        optCtx *OptimizationContext,
) float64 <span class="cov0" title="0">{

        // 估算newTable的基数
        newTableCard := r.cardinalityEstimator.EstimateTableScan(newTable)

        // 简化：假设均匀分布
        // 实际应该根据JOIN条件估算
        // 成本 = 表扫描成本 + 匹配成本
        scanCost := r.costModel.ScanCost(newTable, newTableCard)

        // 假设每个已选表行与新表有1/NDV的匹配
        avgDistinct := 100.0 // 默认NDV
        matchCost := float64(newTableCard) / avgDistinct

        return scanCost + matchCost
}</span>

// rebuildJoinTree 根据最优顺序重新构建JOIN树
func (r *JoinReorderRule) rebuildJoinTree(
        rootJoin *LogicalJoin,
        order []string,
        allJoins []*LogicalJoin,
) (LogicalPlan, error) <span class="cov0" title="0">{

        if len(order) == 0 </span><span class="cov0" title="0">{
                return rootJoin, nil
        }</span>

        // 简化实现：从左到右构建线性JOIN树
        // 实际应该考虑连接条件，构建最优树

        // 找到第一个表
        <span class="cov0" title="0">firstTable := order[0]

        // 查找对应的数据源节点
        firstDataSource := findDataSource(rootJoin, firstTable)
        if firstDataSource == nil </span><span class="cov0" title="0">{
                return rootJoin, nil
        }</span>

        // 逐步添加其他表
        <span class="cov0" title="0">currentPlan := LogicalPlan(firstDataSource)

        for i := 1; i &lt; len(order); i++ </span><span class="cov0" title="0">{
                nextTable := order[i]
                nextDataSource := findDataSource(rootJoin, nextTable)
                if nextDataSource == nil </span><span class="cov0" title="0">{
                        return rootJoin, nil
                }</span>

                // 创建新的JOIN节点
                <span class="cov0" title="0">newJoin := NewLogicalJoin(
                        rootJoin.GetJoinType(),
                        currentPlan,
                        nextDataSource,
                        []*JoinCondition{
                                {
                                        Left:    &amp;parser.Expression{Type: parser.ExprTypeColumn, Column: "id"},
                                        Right:   &amp;parser.Expression{Type: parser.ExprTypeColumn, Column: "id"},
                                        Operator: "=",
                                }, // 简化：假设id连接
                        },
                )

                currentPlan = newJoin</span>
        }

        <span class="cov0" title="0">return currentPlan, nil</span>
}

// collectJoins 收集所有JOIN节点
func collectJoins(plan LogicalPlan) []*LogicalJoin <span class="cov0" title="0">{
        joins := []*LogicalJoin{}

        if join, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                joins = append(joins, join)
                // 递归收集子节点的JOIN
                for _, child := range plan.Children() </span><span class="cov0" title="0">{
                        joins = append(joins, collectJoins(child)...)
                }</span>
                <span class="cov0" title="0">return joins</span>
        }

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                joins = append(joins, collectJoins(child)...)
        }</span>

        <span class="cov0" title="0">return joins</span>
}

// extractTablesFromJoins 从JOIN节点中提取表名
func extractTablesFromJoins(joins []*LogicalJoin) []string <span class="cov0" title="0">{
        tables := make(map[string]bool)

        for _, join := range joins </span><span class="cov0" title="0">{
                // 从子节点中提取表名
                extractTablesFromPlan(join, tables)
        }</span>

        <span class="cov0" title="0">result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// extractTablesFromPlan 从计划中提取表名
func extractTablesFromPlan(plan LogicalPlan, tables map[string]bool) <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                tables[dataSource.TableName] = true
                return
        }</span>

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                extractTablesFromPlan(child, tables)
        }</span>
}

// findDataSource 在计划树中查找数据源节点
func findDataSource(plan LogicalPlan, tableName string) *LogicalDataSource <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                if dataSource.TableName == tableName </span><span class="cov0" title="0">{
                        return dataSource
                }</span>
        }

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                if found := findDataSource(child, tableName); found != nil </span><span class="cov0" title="0">{
                        return found
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// removeTable 从表列表中移除表
func removeTable(tables []string, table string) []string <span class="cov0" title="0">{
        result := []string{}
        for _, t := range tables </span><span class="cov0" title="0">{
                if t != table </span><span class="cov0" title="0">{
                        result = append(result, t)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// NewJoinReorderRule 创建JOIN重排序规则
func NewJoinReorderRule(estimator CardinalityEstimator, costModel CostModel) *JoinReorderRule <span class="cov0" title="0">{
        return &amp;JoinReorderRule{
                cardinalityEstimator: estimator,
                costModel:            costModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package optimizer

import (
        "fmt"
)

// LogicalAggregate 逻辑聚合
type LogicalAggregate struct {
        aggFuncs      []*AggregationItem
        groupByFields []string
        children       []LogicalPlan
}

// NewLogicalAggregate 创建逻辑聚合
func NewLogicalAggregate(aggFuncs []*AggregationItem, groupByCols []string, child LogicalPlan) *LogicalAggregate <span class="cov8" title="1">{
        return &amp;LogicalAggregate{
                aggFuncs:      aggFuncs,
                groupByFields: groupByCols,
                children:      []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalAggregate) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalAggregate) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalAggregate) Schema() []ColumnInfo <span class="cov8" title="1">{
        columns := []ColumnInfo{}

        // 添加 GROUP BY 列
        for _, col := range p.groupByFields </span><span class="cov8" title="1">{
                columns = append(columns, ColumnInfo{
                        Name:     col,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 添加聚合函数列
        <span class="cov8" title="1">for _, agg := range p.aggFuncs </span><span class="cov0" title="0">{
                name := agg.Alias
                if name == "" </span><span class="cov0" title="0">{
                        name = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov8" title="1">return columns</span>
}

// GetAggFuncs 返回聚合函数列表
func (p *LogicalAggregate) GetAggFuncs() []*AggregationItem <span class="cov8" title="1">{
        return p.aggFuncs
}</span>

// GetGroupByCols 返回分组列列表
func (p *LogicalAggregate) GetGroupByCols() []string <span class="cov8" title="1">{
        return p.groupByFields
}</span>

// Explain 返回计划说明
func (p *LogicalAggregate) Explain() string <span class="cov8" title="1">{
        aggStr := ""
        aggFuncs := p.GetAggFuncs()
        for i, agg := range aggFuncs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        aggStr += ", "
                }</span>
                <span class="cov0" title="0">aggStr += fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)</span>
        }
        <span class="cov8" title="1">groupStr := ""
        groupByCols := p.GetGroupByCols()
        if len(groupByCols) &gt; 0 </span><span class="cov8" title="1">{
                groupStr = " GROUP BY "
                for i, col := range groupByCols </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                groupStr += ", "
                        }</span>
                        <span class="cov8" title="1">groupStr += col</span>
                }
        }
        <span class="cov8" title="1">return "Aggregate(" + aggStr + groupStr + ")"</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package optimizer

import (
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// LogicalDataSource 逻辑数据源（表扫描）
type LogicalDataSource struct {
        TableName            string
        Columns              []ColumnInfo
        TableInfo            *domain.TableInfo
        Statistics           *Statistics
        children             []LogicalPlan
        pushedDownPredicates []*parser.Expression // 下推的谓词条件
        pushedDownLimit      *LimitInfo           // 下推的Limit信息
}

// NewLogicalDataSource 创建逻辑数据源
func NewLogicalDataSource(tableName string, tableInfo *domain.TableInfo) *LogicalDataSource <span class="cov8" title="1">{
        columns := make([]ColumnInfo, 0, len(tableInfo.Columns))
        for _, col := range tableInfo.Columns </span><span class="cov8" title="1">{
                columns = append(columns, ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                })
        }</span>

        <span class="cov8" title="1">return &amp;LogicalDataSource{
                TableName: tableName,
                Columns:   columns,
                TableInfo: tableInfo,
                children:  []LogicalPlan{},
        }</span>
}

// Children 获取子节点
func (p *LogicalDataSource) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalDataSource) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalDataSource) Schema() []ColumnInfo <span class="cov8" title="1">{
        return p.Columns
}</span>

// RowCount 返回预估行数
func (p *LogicalDataSource) RowCount() int64 <span class="cov0" title="0">{
        if p.Statistics != nil </span><span class="cov0" title="0">{
                return p.Statistics.RowCount
        }</span>
        <span class="cov0" title="0">return 1000</span> // 默认估计
}

// Table 返回表名
func (p *LogicalDataSource) Table() string <span class="cov0" title="0">{
        return p.TableName
}</span>

// Explain 返回计划说明
func (p *LogicalDataSource) Explain() string <span class="cov8" title="1">{
        return "DataSource(" + p.TableName + ")"
}</span>

// PushDownPredicates 添加下推的谓词条件
func (p *LogicalDataSource) PushDownPredicates(conditions []*parser.Expression) <span class="cov8" title="1">{
        p.pushedDownPredicates = append(p.pushedDownPredicates, conditions...)
}</span>

// GetPushedDownPredicates 获取下推的谓词条件
func (p *LogicalDataSource) GetPushedDownPredicates() []*parser.Expression <span class="cov8" title="1">{
        return p.pushedDownPredicates
}</span>

// PushDownLimit 添加下推的Limit
func (p *LogicalDataSource) PushDownLimit(limit, offset int64) <span class="cov8" title="1">{
        p.pushedDownLimit = &amp;LimitInfo{
                Limit:  limit,
                Offset: offset,
        }
}</span>

// GetPushedDownLimit 获取下推的Limit
func (p *LogicalDataSource) GetPushedDownLimit() *LimitInfo <span class="cov8" title="1">{
        return p.pushedDownLimit
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package optimizer

// LogicalJoin 逻辑连接
type LogicalJoin struct {
        joinType       JoinType
        LeftTable      string
        RightTable     string
        joinConditions []*JoinCondition
        children       []LogicalPlan
}

// NewLogicalJoin 创建逻辑连接
func NewLogicalJoin(joinType JoinType, left, right LogicalPlan, conditions []*JoinCondition) *LogicalJoin <span class="cov0" title="0">{
        leftTable := ""
        if left != nil </span><span class="cov0" title="0">{
                if ds, ok := left.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                        leftTable = ds.TableName
                }</span>
        }

        <span class="cov0" title="0">rightTable := ""
        if right != nil </span><span class="cov0" title="0">{
                if ds, ok := right.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                        rightTable = ds.TableName
                }</span>
        }

        <span class="cov0" title="0">return &amp;LogicalJoin{
                joinType:       joinType,
                LeftTable:      leftTable,
                RightTable:     rightTable,
                joinConditions: conditions,
                children:       []LogicalPlan{left, right},
        }</span>
}

// Children 获取子节点
func (p *LogicalJoin) Children() []LogicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalJoin) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// GetJoinType 返回连接类型
func (p *LogicalJoin) GetJoinType() JoinType <span class="cov0" title="0">{
        return p.joinType
}</span>

// GetJoinConditions 返回连接条件
func (p *LogicalJoin) GetJoinConditions() []*JoinCondition <span class="cov0" title="0">{
        return p.joinConditions
}</span>

// Explain 返回计划说明
func (p *LogicalJoin) Explain() string <span class="cov0" title="0">{
        return "Join(" + p.LeftTable + ", " + p.RightTable + ", type=" + p.GetJoinType().String() + ")"
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package optimizer

import (
        "strconv"
)

// LogicalLimit 逻辑限制
type LogicalLimit struct {
        limitVal  int64
        offsetVal int64
        children  []LogicalPlan
}

// NewLogicalLimit 创建逻辑限制
func NewLogicalLimit(limit, offset int64, child LogicalPlan) *LogicalLimit <span class="cov8" title="1">{
        return &amp;LogicalLimit{
                limitVal:  limit,
                offsetVal: offset,
                children:  []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalLimit) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalLimit) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalLimit) Schema() []ColumnInfo <span class="cov8" title="1">{
        if len(p.children) &gt; 0 </span><span class="cov8" title="1">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// GetLimit 返回LIMIT值
func (p *LogicalLimit) GetLimit() int64 <span class="cov8" title="1">{
        return p.limitVal
}</span>

// GetOffset 返回OFFSET值
func (p *LogicalLimit) GetOffset() int64 <span class="cov8" title="1">{
        return p.offsetVal
}</span>

// Explain 返回计划说明
func (p *LogicalLimit) Explain() string <span class="cov8" title="1">{
        return "Limit(offset=" + strconv.FormatInt(p.GetOffset(), 10) + ", limit=" + strconv.FormatInt(p.GetLimit(), 10) + ")"
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package optimizer

import (
        "fmt"
        "strconv"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalProjection 逻辑投影
type LogicalProjection struct {
        Exprs        []*parser.Expression
        columnAliases []string
        Columns       []ColumnInfo
        children      []LogicalPlan
}

// NewLogicalProjection 创建逻辑投影
func NewLogicalProjection(exprs []*parser.Expression, aliases []string, child LogicalPlan) *LogicalProjection <span class="cov8" title="1">{
        columns := make([]ColumnInfo, len(exprs))
        for i, expr := range exprs </span><span class="cov8" title="1">{
                name := aliases[i]
                if name == "" </span><span class="cov0" title="0">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                                name = expr.Column
                        }</span> else<span class="cov0" title="0"> {
                                name = "expr_" + strconv.Itoa(i)
                        }</span>
                }
                <span class="cov8" title="1">columns[i] = ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                }</span>
        }

        <span class="cov8" title="1">return &amp;LogicalProjection{
                Exprs:        exprs,
                columnAliases:  aliases,
                Columns:       columns,
                children:      []LogicalPlan{child},
        }</span>
}

// Children 获取子节点
func (p *LogicalProjection) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalProjection) SetChildren(children ...LogicalPlan) <span class="cov8" title="1">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalProjection) Schema() []ColumnInfo <span class="cov0" title="0">{
        return p.Columns
}</span>

// GetExprs 返回投影表达式
func (p *LogicalProjection) GetExprs() []*parser.Expression <span class="cov8" title="1">{
        return p.Exprs
}</span>

// GetAliases 返回别名列表
func (p *LogicalProjection) GetAliases() []string <span class="cov8" title="1">{
        return p.columnAliases
}</span>

// Explain 返回计划说明
func (p *LogicalProjection) Explain() string <span class="cov8" title="1">{
        exprs := ""
        for i, expr := range p.Exprs </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        exprs += ", "
                }</span>
                <span class="cov8" title="1">if expr.Type == parser.ExprTypeColumn </span><span class="cov8" title="1">{
                        exprs += expr.Column
                }</span> else<span class="cov0" title="0"> {
                        exprs += fmt.Sprintf("%v", expr)
                }</span>
        }
        <span class="cov8" title="1">return "Projection(" + exprs + ")"</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package optimizer

// 为 LogicalSelection 和其他算子添加访问器方法
// 用于修复方法名冲突问题

import "github.com/kasuganosora/sqlexec/pkg/parser"

// SelectionConditions 过滤条件访问器
func SelectionConditions(conditions []*parser.Expression) []*parser.Expression <span class="cov0" title="0">{
        return conditions
}</span>

// SortOrderByItems 排序项访问器
func SortOrderByItems(orderBy []OrderByItem) []OrderByItem <span class="cov0" title="0">{
        result := make([]OrderByItem, 0, len(orderBy))
        for i := range orderBy </span><span class="cov0" title="0">{
                result[i] = OrderByItem{
                        Column:    orderBy[i].Column,
                        Direction: orderBy[i].Direction,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AggregateAggFuncs 聚合函数访问器
func AggregateAggFuncs(aggFuncs []*AggregationItem) []*AggregationItem <span class="cov0" title="0">{
        result := make([]*AggregationItem, 0, len(aggFuncs))
        for i := range aggFuncs </span><span class="cov0" title="0">{
                result[i] = &amp;AggregationItem{
                        Type:     aggFuncs[i].Type,
                        Expr:     aggFuncs[i].Expr,
                        Alias:    aggFuncs[i].Alias,
                        Distinct: aggFuncs[i].Distinct,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AggregateGroupByCols 分组列访问器
func AggregateGroupByCols(groupByCols []string) []string <span class="cov0" title="0">{
        result := make([]string, 0, len(groupByCols))
        copy(result, groupByCols)
        return result
}</span>

// UnionChildren Union子节点访问器
func UnionChildren(children []LogicalPlan) []LogicalPlan <span class="cov0" title="0">{
        return children
}</span>

// UnionUnionType Union类型访问器
func UnionUnionType(unionType string) string <span class="cov0" title="0">{
        return unionType
}</span>

// UnionAll Union all标志访问器
func UnionAll(all bool) bool <span class="cov0" title="0">{
        return all
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package optimizer

import (
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalSelection 逻辑过滤（选择）
type LogicalSelection struct {
        filterConditions []*parser.Expression
        children         []LogicalPlan
}

// NewLogicalSelection 创建逻辑过滤
func NewLogicalSelection(conditions []*parser.Expression, child LogicalPlan) *LogicalSelection <span class="cov8" title="1">{
        return &amp;LogicalSelection{
                filterConditions: conditions,
                children:       []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalSelection) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalSelection) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalSelection) Schema() []ColumnInfo <span class="cov8" title="1">{
        if len(p.children) &gt; 0 </span><span class="cov8" title="1">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Conditions 返回过滤条件
func (p *LogicalSelection) Conditions() []*parser.Expression <span class="cov8" title="1">{
        return p.filterConditions
}</span>

// GetConditions 返回过滤条件（用于避免与Conditions方法冲突）
func (p *LogicalSelection) GetConditions() []*parser.Expression <span class="cov8" title="1">{
        return p.filterConditions
}</span>

// Selectivity 返回选择率
func (p *LogicalSelection) Selectivity() float64 <span class="cov0" title="0">{
        // 简化实现：默认0.1（10%的选择率）
        return 0.1
}</span>

// Explain 返回计划说明
func (p *LogicalSelection) Explain() string <span class="cov8" title="1">{
        conditions := p.GetConditions()
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                return "Selection WHERE " + fmt.Sprintf("%v", conditions[0])
        }</span>
        <span class="cov0" title="0">return "Selection"</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package optimizer

// LogicalSort 逻辑排序
type LogicalSort struct {
        OrderBy  []OrderByItem
        children []LogicalPlan
}

// NewLogicalSort 创建逻辑排序
func NewLogicalSort(orderBy []OrderByItem, child LogicalPlan) *LogicalSort <span class="cov8" title="1">{
        return &amp;LogicalSort{
                OrderBy:  orderBy,
                children: []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalSort) Children() []LogicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalSort) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalSort) Schema() []ColumnInfo <span class="cov8" title="1">{
        if len(p.children) &gt; 0 </span><span class="cov8" title="1">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// GetOrderByItems 返回排序列表
func (p *LogicalSort) GetOrderByItems() []*OrderByItem <span class="cov8" title="1">{
        result := make([]*OrderByItem, 0, len(p.OrderBy))
        for i := range p.OrderBy </span><span class="cov8" title="1">{
                result = append(result, &amp;p.OrderBy[i])
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Explain 返回计划说明
func (p *LogicalSort) Explain() string <span class="cov8" title="1">{
        items := ""
        orderByItems := p.GetOrderByItems()
        for i, item := range orderByItems </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        items += ", "
                }</span>
                <span class="cov8" title="1">items += item.Column + " " + item.Direction</span>
        }
        <span class="cov8" title="1">return "Sort(" + items + ")"</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package optimizer

// LogicalUnion 逻辑联合
type LogicalUnion struct {
        children  []LogicalPlan
        unionType string
        all       bool
}

// NewLogicalUnion 创建逻辑联合
func NewLogicalUnion(children ...LogicalPlan) *LogicalUnion <span class="cov0" title="0">{
        return &amp;LogicalUnion{
                children:  children,
                unionType: "UNION",
                all:       false,
        }
}</span>

// Children 获取子节点
func (p *LogicalUnion) Children() []LogicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalUnion) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalUnion) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// GetUnionType 返回UNION类型
func (p *LogicalUnion) GetUnionType() string <span class="cov0" title="0">{
        return p.unionType
}</span>

// GetAll 返回是否包含重复行
func (p *LogicalUnion) GetAll() bool <span class="cov0" title="0">{
        return p.all
}</span>

// Explain 返回计划说明
func (p *LogicalUnion) Explain() string <span class="cov0" title="0">{
        return "Union"
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// PhysicalMergeJoin 物理归并连接
// 基于两路归并排序的连接算法，适合有序数据
type PhysicalMergeJoin struct {
        JoinType   JoinType
        Conditions  []*JoinCondition
        cost        float64
        children    []PhysicalPlan
}

// NewPhysicalMergeJoin 创建物理归并连接
func NewPhysicalMergeJoin(joinType JoinType, left, right PhysicalPlan, conditions []*JoinCondition) *PhysicalMergeJoin <span class="cov0" title="0">{
        leftRows := int64(1000) // 假设
        rightRows := int64(1000) // 假设

        // Merge Join 成本 = 合并两个有序序列
        // 时间复杂度: O(n + m)
        leftCost := left.Cost()
        rightCost := right.Cost()
        mergeCost := float64(leftRows+rightRows) * 0.05
        cost := leftCost + rightCost + mergeCost

        return &amp;PhysicalMergeJoin{
                JoinType:  joinType,
                Conditions:  conditions,
                cost:       cost,
                children:    []PhysicalPlan{left, right},
        }
}</span>

// Children 获取子节点
func (p *PhysicalMergeJoin) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalMergeJoin) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalMergeJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalMergeJoin) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行归并连接
func (p *PhysicalMergeJoin) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MergeJoin requires exactly 2 children")
        }</span>

        // 1. 执行左表和右表
        <span class="cov0" title="0">leftResult, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left table execute error: %w", err)
        }</span>

        <span class="cov0" title="0">rightResult, err := p.children[1].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right table execute error: %w", err)
        }</span>

        // 2. 获取连接条件
        <span class="cov0" title="0">leftJoinCol, rightJoinCol := getJoinColumns(p.Conditions)
        if leftJoinCol == "" || rightJoinCol == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid join conditions")
        }</span>

        // 3. 对两边数据进行排序（如果是有序数据可以跳过这一步）
        <span class="cov0" title="0">leftRows := p.sortByColumn(leftResult.Rows, leftJoinCol)
        rightRows := p.sortByColumn(rightResult.Rows, rightJoinCol)

        // 4. 执行两路归并
        output := p.mergeRows(leftRows, rightRows, leftJoinCol, rightJoinCol, p.JoinType)

        // 5. 合并列信息
        columns := []domain.ColumnInfo{}
        columns = append(columns, leftResult.Columns...)
        for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                // 检查列名冲突
                conflict := false
                for _, leftCol := range leftResult.Columns </span><span class="cov0" title="0">{
                        if leftCol.Name == col.Name </span><span class="cov0" title="0">{
                                conflict = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if conflict </span><span class="cov0" title="0">{
                        columns = append(columns, domain.ColumnInfo{
                                Name:     "right_" + col.Name,
                                Type:     col.Type,
                                Nullable: col.Nullable,
                        })
                }</span> else<span class="cov0" title="0"> {
                        columns = append(columns, col)
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// sortByColumn 按指定列排序行数据
func (p *PhysicalMergeJoin) sortByColumn(rows []domain.Row, column string) []domain.Row <span class="cov0" title="0">{
        // 使用稳定的排序算法
        sorted := make([]domain.Row, len(rows))
        copy(sorted, rows)

        // 简单冒泡排序（实际应该用更高效的算法）
        for i := 0; i &lt; len(sorted); i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(sorted)-i-1; j++ </span><span class="cov0" title="0">{
                        leftVal := sorted[j][column]
                        rightVal := sorted[j+1][column]

                        if compareValuesForSort(leftVal, rightVal) &gt; 0 </span><span class="cov0" title="0">{
                                // 交换
                                sorted[j], sorted[j+1] = sorted[j+1], sorted[j]
                        }</span>
                }
        }

        <span class="cov0" title="0">return sorted</span>
}

// mergeRows 使用两路归并算法合并已排序的行
func (p *PhysicalMergeJoin) mergeRows(
        leftRows, rightRows []domain.Row,
        leftCol, rightCol string,
        joinType JoinType,
) []domain.Row <span class="cov0" title="0">{
        
        // 使用归并排序算法
        i, j := 0, 0
        leftCount := len(leftRows)
        rightCount := len(rightRows)

        output := make([]domain.Row, 0, leftCount+rightCount)

        switch joinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN: 只有两边都有的行
                for i &lt; leftCount &amp;&amp; j &lt; rightCount </span><span class="cov0" title="0">{
                        leftVal := leftRows[i][leftCol]
                        rightVal := rightRows[j][rightCol]

                        cmp := compareValuesForSort(leftVal, rightVal)
                        if cmp &lt; 0 </span><span class="cov0" title="0">{
                                // 左值小，取左行
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                i++
                        }</span> else<span class="cov0" title="0"> if cmp &gt; 0 </span><span class="cov0" title="0">{
                                // 右值小，取右行
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                j++
                        }</span> else<span class="cov0" title="0"> {
                                // 相等，合并行并推进两个指针
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                i++
                                j++
                        }</span>
                }

        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN: 左表所有行，右表匹配的行
                for i &lt; leftCount </span><span class="cov0" title="0">{
                        leftRow := leftRows[i]
                        leftVal := leftRow[leftCol]

                        // 在右表中查找匹配
                        matchFound := false
                        for j &lt; rightCount </span><span class="cov0" title="0">{
                                rightVal := rightRows[j][rightCol]

                                if compareValuesForSort(leftVal, rightVal) == 0 </span><span class="cov0" title="0">{
                                        output = append(output, p.mergeRow(leftRow, rightRows[j]))
                                        matchFound = true
                                        break</span>
                                } else<span class="cov0" title="0"> if compareValuesForSort(leftVal, rightVal) &lt; 0 </span><span class="cov0" title="0">{
                                        // 右表的值已经更大，不需要继续查找
                                        break</span>
                                }
                                <span class="cov0" title="0">j++</span>
                        }

                        <span class="cov0" title="0">if !matchFound </span><span class="cov0" title="0">{
                                // 没有匹配，左行 + 右NULL
                                output = append(output, p.mergeRowWithNull(leftRow, rightRows[0]))
                        }</span>

                        <span class="cov0" title="0">i++</span>
                }

        case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN: 右表所有行，左表匹配的行
                for j &lt; rightCount </span><span class="cov0" title="0">{
                        rightRow := rightRows[j]
                        rightVal := rightRow[rightCol]

                        // 在左表中查找匹配
                        matchFound := false
                        for i &lt; leftCount </span><span class="cov0" title="0">{
                                leftVal := leftRows[i][leftCol]

                                if compareValuesForSort(leftVal, rightVal) == 0 </span><span class="cov0" title="0">{
                                        output = append(output, p.mergeRow(leftRows[i], rightRow))
                                        matchFound = true
                                        break</span>
                                } else<span class="cov0" title="0"> if compareValuesForSort(leftVal, rightVal) &lt; 0 </span><span class="cov0" title="0">{
                                        // 左表的值已经更大，不需要继续查找
                                        break</span>
                                }
                                <span class="cov0" title="0">i++</span>
                        }

                        <span class="cov0" title="0">if !matchFound </span><span class="cov0" title="0">{
                                // 没有匹配，左NULL + 右行
                                output = append(output, p.mergeRowWithNull(leftRows[0], rightRow))
                        }</span>

                        <span class="cov0" title="0">j++</span>
                }

        default:<span class="cov0" title="0">
                // 其他JOIN类型：默认为INNER JOIN
                return p.mergeRows(leftRows, rightRows, leftCol, rightCol, InnerJoin)</span>
        }

        <span class="cov0" title="0">return output</span>
}

// mergeRow 合并两行数据
func (p *PhysicalMergeJoin) mergeRow(left, right domain.Row) domain.Row <span class="cov0" title="0">{
        merged := make(domain.Row)

        // 添加左行数据
        for k, v := range left </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>

        // 添加右行数据
        <span class="cov0" title="0">for k, v := range right </span><span class="cov0" title="0">{
                // 检查列名冲突
                if _, exists := merged[k]; exists </span><span class="cov0" title="0">{
                        merged["right_"+k] = v
                }</span> else<span class="cov0" title="0"> {
                        merged[k] = v
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// mergeRowWithNull 合并行数据，一边为NULL
func (p *PhysicalMergeJoin) mergeRowWithNull(notNull, nullRow domain.Row) domain.Row <span class="cov0" title="0">{
        merged := make(domain.Row)

        // 添加非NULL行的数据
        for k, v := range notNull </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>

        // 添加NULL行的数据（全部为NULL）
        <span class="cov0" title="0">for k := range nullRow </span><span class="cov0" title="0">{
                if _, exists := merged[k]; !exists </span><span class="cov0" title="0">{
                        merged[k] = nil
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// getJoinColumns 从连接条件中获取列名
func getJoinColumns(conditions []*JoinCondition) (string, string) <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return "", ""
        }</span>

        // 简化：取第一个条件的字符串表示
        <span class="cov0" title="0">if conditions[0].Left != nil </span><span class="cov0" title="0">{
                leftStr := fmt.Sprintf("%v", conditions[0].Left)
                if conditions[0].Right != nil </span><span class="cov0" title="0">{
                        rightStr := fmt.Sprintf("%v", conditions[0].Right)
                        return leftStr, rightStr
                }</span>
                <span class="cov0" title="0">return leftStr, ""</span>
        }
        <span class="cov0" title="0">return "", ""</span>
}

// compareValuesForSort 为归并排序比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func compareValuesForSort(a, b interface{}) int <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // 尝试数值比较
        <span class="cov0" title="0">aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                if aNum &lt; bNum </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aNum &gt; bNum </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // 字符串比较
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Explain 返回计划说明
func (p *PhysicalMergeJoin) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf("MergeJoin(type=%s, cost=%.2f)", p.JoinType, p.cost)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/information_schema"
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// OptimizedExecutor 优化的执行器
// 集成 Optimizer 和 QueryBuilder，提供优化后的查询执行
type OptimizedExecutor struct {
        dataSource  domain.DataSource
        dsManager   *application.DataSourceManager
        optimizer   *Optimizer
        useOptimizer bool
}

// NewOptimizedExecutor 创建优化的执行器
func NewOptimizedExecutor(dataSource domain.DataSource, useOptimizer bool) *OptimizedExecutor <span class="cov0" title="0">{
        return &amp;OptimizedExecutor{
                dataSource:  dataSource,
                optimizer:   NewOptimizer(dataSource),
                useOptimizer: useOptimizer,
        }
}</span>

// NewOptimizedExecutorWithDSManager 创建带有数据源管理器的优化执行器
func NewOptimizedExecutorWithDSManager(dataSource domain.DataSource, dsManager *application.DataSourceManager, useOptimizer bool) *OptimizedExecutor <span class="cov0" title="0">{
        return &amp;OptimizedExecutor{
                dataSource: dataSource,
                dsManager:  dsManager,
                optimizer:   NewOptimizer(dataSource),
                useOptimizer: useOptimizer,
        }
}</span>

// SetUseOptimizer 设置是否使用优化器
func (e *OptimizedExecutor) SetUseOptimizer(use bool) <span class="cov0" title="0">{
        e.useOptimizer = use
}</span>

// GetQueryBuilder 获取底层的 QueryBuilder（如果存在）
// 用于设置当前数据库上下文
func (e *OptimizedExecutor) GetQueryBuilder() interface{} <span class="cov0" title="0">{
        return nil
}</span>

// GetOptimizer 获取优化器
func (e *OptimizedExecutor) GetOptimizer() interface{} <span class="cov0" title="0">{
        return e.optimizer
}</span>

// ExecuteSelect 执行 SELECT 查询（支持优化）
func (e *OptimizedExecutor) ExecuteSelect(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if this is an information_schema query
        // information_schema queries should use QueryBuilder path to access virtual tables
        if e.isInformationSchemaQuery(stmt.From) </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] Detected information_schema query, using QueryBuilder path")
                return e.executeWithBuilder(ctx, stmt)
        }</span>

        // 如果启用了优化器，使用优化路径
        <span class="cov0" title="0">if e.useOptimizer </span><span class="cov0" title="0">{
                return e.executeWithOptimizer(ctx, stmt)
        }</span>

        // 否则使用传统的 QueryBuilder 路径
        <span class="cov0" title="0">return e.executeWithBuilder(ctx, stmt)</span>
}

// isInformationSchemaQuery 检查是否是 information_schema 查询
func (e *OptimizedExecutor) isInformationSchemaQuery(tableName string) bool <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for information_schema. prefix (case-insensitive)
        <span class="cov0" title="0">return strings.HasPrefix(strings.ToLower(tableName), "information_schema.")</span>
}

// executeWithOptimizer 使用优化器执行查询
func (e *OptimizedExecutor) executeWithOptimizer(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] 开始优化查询...")

        // 1. 构建 SQLStatement
        sqlStmt := &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: stmt,
        }
        fmt.Println("  [DEBUG] SQLStatement构建完成")

        // 2. 优化查询计划
        fmt.Println("  [DEBUG] 调用 Optimize...")
        physicalPlan, err := e.optimizer.Optimize(ctx, sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("optimizer failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("  [DEBUG] Optimize完成")

        // 3. 执行物理计划
        fmt.Println("  [DEBUG] 开始执行物理计划...")
        result, err := physicalPlan.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("execute physical plan failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("  [DEBUG] 物理计划执行完成")

        // 4. 设置列信息
        tableInfo, err := e.dataSource.GetTableInfo(ctx, stmt.From)
        if err == nil </span><span class="cov0" title="0">{
                // 根据选择的列过滤
                if !isWildcard(stmt.Columns) </span><span class="cov0" title="0">{
                        result.Columns = filterColumns(tableInfo.Columns, stmt.Columns)
                }</span> else<span class="cov0" title="0"> {
                        result.Columns = tableInfo.Columns
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// getVirtualDataSource 获取 information_schema 虚拟数据源
func (e *OptimizedExecutor) getVirtualDataSource() domain.DataSource <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create information_schema virtual data source
        <span class="cov0" title="0">provider := information_schema.NewProvider(e.dsManager)
        return virtual.NewVirtualDataSource(provider)</span>
}

// executeWithBuilder 使用 QueryBuilder 执行查询（传统路径）
func (e *OptimizedExecutor) executeWithBuilder(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // If this is an information_schema query, use virtual data source
        if e.isInformationSchemaQuery(stmt.From) </span><span class="cov0" title="0">{
                vds := e.getVirtualDataSource()
                if vds != nil </span><span class="cov0" title="0">{
                        // Strip the "information_schema." prefix from the table name
                        tableName := stmt.From
                        if strings.HasPrefix(strings.ToLower(tableName), "information_schema.") </span><span class="cov0" title="0">{
                                tableName = strings.TrimPrefix(tableName, "information_schema.")
                                // Also handle case where prefix is "INFORMATION_SCHEMA."
                                tableName = strings.TrimPrefix(tableName, "INFORMATION_SCHEMA.")
                        }</span>

                        // Create a new SelectStatement with the stripped table name
                        <span class="cov0" title="0">newStmt := *stmt
                        newStmt.From = tableName

                        builder := parser.NewQueryBuilder(vds)
                        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                                Type:   parser.SQLTypeSelect,
                                Select: &amp;newStmt,
                        })</span>
                }
        }

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: stmt,
        })</span>
}

// ExecuteInsert 执行 INSERT
func (e *OptimizedExecutor) ExecuteInsert(ctx context.Context, stmt *parser.InsertStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to INSERT into information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: INSERT operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeInsert,
                Insert: stmt,
        })</span>
}

// ExecuteUpdate 执行 UPDATE
func (e *OptimizedExecutor) ExecuteUpdate(ctx context.Context, stmt *parser.UpdateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to UPDATE information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: UPDATE operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeUpdate,
                Update: stmt,
        })</span>
}

// ExecuteDelete 执行 DELETE
func (e *OptimizedExecutor) ExecuteDelete(ctx context.Context, stmt *parser.DeleteStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to DELETE from information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: DELETE operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeDelete,
                Delete: stmt,
        })</span>
}

// ExecuteCreate 执行 CREATE
func (e *OptimizedExecutor) ExecuteCreate(ctx context.Context, stmt *parser.CreateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeCreate,
                Create: stmt,
        })
}</span>

// ExecuteDrop 执行 DROP
func (e *OptimizedExecutor) ExecuteDrop(ctx context.Context, stmt *parser.DropStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:  parser.SQLTypeDrop,
                Drop:  stmt,
        })
}</span>

// ExecuteAlter 执行 ALTER
func (e *OptimizedExecutor) ExecuteAlter(ctx context.Context, stmt *parser.AlterStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:  parser.SQLTypeAlter,
                Alter: stmt,
        })
}</span>

// ExecuteCreateIndex 执行 CREATE INDEX
func (e *OptimizedExecutor) ExecuteCreateIndex(ctx context.Context, stmt *parser.CreateIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:       parser.SQLTypeCreate,
                CreateIndex: stmt,
        })
}</span>

// ExecuteDropIndex 执行 DROP INDEX
func (e *OptimizedExecutor) ExecuteDropIndex(ctx context.Context, stmt *parser.DropIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:     parser.SQLTypeDrop,
                DropIndex: stmt,
        })
}</span>

// filterColumns 过滤列信息
func filterColumns(columns []domain.ColumnInfo, selectCols []parser.SelectColumn) []domain.ColumnInfo <span class="cov0" title="0">{
        result := make([]domain.ColumnInfo, 0, len(selectCols))

        // 构建选择的列名映射
        selectMap := make(map[string]bool)
        for _, col := range selectCols </span><span class="cov0" title="0">{
                if !col.IsWildcard &amp;&amp; col.Name != "" </span><span class="cov0" title="0">{
                        selectMap[col.Name] = true
                }</span>
        }

        // 过滤列
        <span class="cov0" title="0">for _, col := range columns </span><span class="cov0" title="0">{
                if selectMap[col.Name] </span><span class="cov0" title="0">{
                        result = append(result, col)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// isInformationSchemaTable 检查表是否属于 information_schema
func (e *OptimizedExecutor) isInformationSchemaTable(tableName string) bool <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for information_schema. prefix (case-insensitive)
        <span class="cov0" title="0">if strings.Contains(tableName, ".") </span><span class="cov0" title="0">{
                parts := strings.SplitN(tableName, ".", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "information_schema" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

</pre>
		
		<pre class="file" id="file60" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Optimizer 优化器
type Optimizer struct {
        rules      RuleSet
        costModel  CostModel
        dataSource domain.DataSource
}

// NewOptimizer 创建优化器
func NewOptimizer(dataSource domain.DataSource) *Optimizer <span class="cov8" title="1">{
        return &amp;Optimizer{
                rules:     DefaultRuleSet(),
                costModel:  NewDefaultCostModel(),
                dataSource: dataSource,
        }
}</span>

// Optimize 优化查询计划
func (o *Optimizer) Optimize(ctx context.Context, stmt *parser.SQLStatement) (PhysicalPlan, error) <span class="cov8" title="1">{
        fmt.Println("  [DEBUG] Optimize: 步骤1 - 转换为逻辑计划")
        // 1. 转换为逻辑计划
        logicalPlan, err := o.convertToLogicalPlan(stmt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("convert to logical plan failed: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Println("  [DEBUG] Optimize: 逻辑计划转换完成, 类型:", logicalPlan.Explain())

        // 2. 应用优化规则
        fmt.Println("  [DEBUG] Optimize: 步骤2 - 应用优化规则")
        optCtx := &amp;OptimizationContext{
                DataSource: o.dataSource,
                TableInfo: make(map[string]*domain.TableInfo),
                Stats:      make(map[string]*Statistics),
                CostModel:  o.costModel,
        }

        optimizedPlan, err := o.rules.Apply(ctx, logicalPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apply optimization rules failed: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Println("  [DEBUG] Optimize: 优化规则应用完成")

        // 3. 转换为物理计划
        fmt.Println("  [DEBUG] Optimize: 步骤3 - 转换为物理计划")
        physicalPlan, err := o.convertToPhysicalPlan(ctx, optimizedPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("convert to physical plan failed: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Println("  [DEBUG] Optimize: 物理计划转换完成")

        return physicalPlan, nil</span>
}

// convertToLogicalPlan 将 SQL 语句转换为逻辑计划
func (o *Optimizer) convertToLogicalPlan(stmt *parser.SQLStatement) (LogicalPlan, error) <span class="cov8" title="1">{
        switch stmt.Type </span>{
        case parser.SQLTypeSelect:<span class="cov8" title="1">
                return o.convertSelect(stmt.Select)</span>
        case parser.SQLTypeInsert:<span class="cov0" title="0">
                return o.convertInsert(stmt.Insert)</span>
        case parser.SQLTypeUpdate:<span class="cov0" title="0">
                return o.convertUpdate(stmt.Update)</span>
        case parser.SQLTypeDelete:<span class="cov0" title="0">
                return o.convertDelete(stmt.Delete)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported SQL type: %s", stmt.Type)</span>
        }
}

// convertSelect 转换 SELECT 语句
func (o *Optimizer) convertSelect(stmt *parser.SelectStatement) (LogicalPlan, error) <span class="cov8" title="1">{
        fmt.Println("  [DEBUG] convertSelect: 开始转换, 表名:", stmt.From)
        // 1. 创建 DataSource
        tableInfo, err := o.dataSource.GetTableInfo(context.Background(), stmt.From)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] convertSelect: GetTableInfo 失败:", err)
                return nil, fmt.Errorf("get table info failed: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Println("  [DEBUG] convertSelect: GetTableInfo 成功, 列数:", len(tableInfo.Columns))

        var logicalPlan LogicalPlan = NewLogicalDataSource(stmt.From, tableInfo)
        fmt.Println("  [DEBUG] convertSelect: LogicalDataSource 创建完成")

        // 2. 应用 WHERE 条件（Selection）
        if stmt.Where != nil </span><span class="cov8" title="1">{
                conditions := o.extractConditions(stmt.Where)
                logicalPlan = NewLogicalSelection(conditions, logicalPlan)
        }</span>

        // 3. 应用 GROUP BY（Aggregate）
        <span class="cov8" title="1">if len(stmt.GroupBy) &gt; 0 </span><span class="cov8" title="1">{
                aggFuncs := o.extractAggFuncs(stmt.Columns)
                logicalPlan = NewLogicalAggregate(aggFuncs, stmt.GroupBy, logicalPlan)
        }</span>

        // 4. 应用 ORDER BY（Sort）
        <span class="cov8" title="1">if len(stmt.OrderBy) &gt; 0 </span><span class="cov8" title="1">{
                orderItems := make([]OrderByItem, len(stmt.OrderBy))
                for i, item := range stmt.OrderBy </span><span class="cov8" title="1">{
                        orderItems[i] = OrderByItem{
                                Column:    item.Column,
                                Direction: item.Direction,
                        }
                }</span>
                <span class="cov8" title="1">logicalPlan = NewLogicalSort(orderItems, logicalPlan)</span>
        }

        // 5. 应用 LIMIT（Limit）
        <span class="cov8" title="1">if stmt.Limit != nil </span><span class="cov8" title="1">{
                limit := *stmt.Limit
                offset := int64(0)
                if stmt.Offset != nil </span><span class="cov0" title="0">{
                        offset = *stmt.Offset
                }</span>
                <span class="cov8" title="1">logicalPlan = NewLogicalLimit(limit, offset, logicalPlan)</span>
        }

        // 6. 应用 SELECT 列（Projection）
        <span class="cov8" title="1">fmt.Printf("  [DEBUG] convertSelect: SELECT列数量: %d, IsWildcard=%v\n", len(stmt.Columns), isWildcard(stmt.Columns))
        if len(stmt.Columns) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("  [DEBUG] convertSelect: cols[0].Name='%s'\n", stmt.Columns[0].Name)
        }</span>
        <span class="cov8" title="1">if len(stmt.Columns) &gt; 0 &amp;&amp; !isWildcard(stmt.Columns) </span><span class="cov8" title="1">{
                fmt.Println("  [DEBUG] convertSelect: 创建Projection")
                exprs := make([]*parser.Expression, len(stmt.Columns))
                aliases := make([]string, len(stmt.Columns))
                for i, col := range stmt.Columns </span><span class="cov8" title="1">{
                        fmt.Printf("  [DEBUG] convertSelect: 列%d: Name='%s', Alias='%s'\n", i, col.Name, col.Alias)
                        exprs[i] = &amp;parser.Expression{
                                Type:   parser.ExprTypeColumn,
                                Column: col.Name,
                        }
                        if col.Alias != "" </span><span class="cov8" title="1">{
                                aliases[i] = col.Alias
                        }</span> else<span class="cov8" title="1"> {
                                aliases[i] = col.Name
                        }</span>
                }
                <span class="cov8" title="1">logicalPlan = NewLogicalProjection(exprs, aliases, logicalPlan)</span>
        }

        <span class="cov8" title="1">return logicalPlan, nil</span>
}

// convertInsert 转换 INSERT 语句
func (o *Optimizer) convertInsert(stmt *parser.InsertStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("INSERT statement not supported in optimizer yet")
}</span>

// convertUpdate 转换 UPDATE 语句
func (o *Optimizer) convertUpdate(stmt *parser.UpdateStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("UPDATE statement not supported in optimizer yet")
}</span>

// convertDelete 转换 DELETE 语句
func (o *Optimizer) convertDelete(stmt *parser.DeleteStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("DELETE statement not supported in optimizer yet")
}</span>

// extractConditions 从表达式中提取条件列表
func (o *Optimizer) extractConditions(expr *parser.Expression) []*parser.Expression <span class="cov8" title="1">{
        conditions := []*parser.Expression{expr}
        // 简化实现，不处理复杂表达式
        return conditions
}</span>

// extractAggFuncs 提取聚合函数
func (o *Optimizer) extractAggFuncs(cols []parser.SelectColumn) []*AggregationItem <span class="cov8" title="1">{
        aggFuncs := []*AggregationItem{}
        // TODO: 解析 SELECT 列中的聚合函数
        return aggFuncs
}</span>

// isWildcard 检查是否是通配符
func isWildcard(cols []parser.SelectColumn) bool <span class="cov8" title="1">{
        if len(cols) == 1 &amp;&amp; cols[0].IsWildcard </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// convertConditionsToFilters 将条件表达式转换为过滤器
func (o *Optimizer) convertConditionsToFilters(conditions []*parser.Expression) []domain.Filter <span class="cov8" title="1">{
        filters := []domain.Filter{}

        for _, cond := range conditions </span><span class="cov8" title="1">{
                if cond == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">filter := o.convertExpressionToFilter(cond)
                if filter != nil </span><span class="cov8" title="1">{
                        filters = append(filters, *filter)
                }</span>
        }

        <span class="cov8" title="1">fmt.Println("  [DEBUG] convertConditionsToFilters: 生成的过滤器数量:", len(filters))
        return filters</span>
}

// convertExpressionToFilter 将表达式转换为过滤器
func (o *Optimizer) convertExpressionToFilter(expr *parser.Expression) *domain.Filter <span class="cov8" title="1">{
        if expr == nil || expr.Type != parser.ExprTypeOperator </span><span class="cov0" title="0">{
                return nil
        }</span>

                // 处理二元比较表达式 (e.g., age &gt; 30, name = 'Alice')
                <span class="cov8" title="1">if expr.Left != nil &amp;&amp; expr.Right != nil &amp;&amp; expr.Operator != "" </span><span class="cov8" title="1">{
                        // 左边是列名
                        if expr.Left.Type == parser.ExprTypeColumn &amp;&amp; expr.Left.Column != "" </span><span class="cov8" title="1">{
                                // 右边是常量值
                                if expr.Right.Type == parser.ExprTypeValue </span><span class="cov8" title="1">{
                                        // 映射操作符
                                        operator := o.mapOperator(expr.Operator)
                                        return &amp;domain.Filter{
                                                Field:    expr.Left.Column,
                                                Operator:  operator,
                                                Value:     expr.Right.Value,
                                        }
                                }</span>
                        }
                }

                // 处理 AND 逻辑表达式
                <span class="cov8" title="1">if expr.Operator == "and" &amp;&amp; expr.Left != nil &amp;&amp; expr.Right != nil </span><span class="cov8" title="1">{
                        leftFilter := o.convertExpressionToFilter(expr.Left)
                        rightFilter := o.convertExpressionToFilter(expr.Right)
                        if leftFilter != nil </span><span class="cov8" title="1">{
                                return leftFilter
                        }</span>
                        <span class="cov0" title="0">if rightFilter != nil </span><span class="cov0" title="0">{
                                return rightFilter
                        }</span>
                }

        <span class="cov0" title="0">return nil</span>
}

// mapOperator 映射parser操作符到domain.Filter操作符
func (o *Optimizer) mapOperator(parserOp string) string <span class="cov8" title="1">{
        // 转换parser操作符到domain.Filter操作符
        switch parserOp </span>{
        case "gt":<span class="cov8" title="1">
                return "&gt;"</span>
        case "gte":<span class="cov0" title="0">
                return "&gt;="</span>
        case "lt":<span class="cov0" title="0">
                return "&lt;"</span>
        case "lte":<span class="cov0" title="0">
                return "&lt;="</span>
        case "eq", "===":<span class="cov0" title="0">
                return "="</span>
        case "ne", "!=":<span class="cov0" title="0">
                return "!="</span>
        default:<span class="cov0" title="0">
                return parserOp</span>
        }
}

// convertToPhysicalPlan 将逻辑计划转换为物理计划
func (o *Optimizer) convertToPhysicalPlan(ctx context.Context, logicalPlan LogicalPlan, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov8" title="1">{
        switch p := logicalPlan.(type) </span>{
        case *LogicalDataSource:<span class="cov8" title="1">
                // 获取下推的谓词条件
                pushedDownPredicates := p.GetPushedDownPredicates()
                filters := o.convertConditionsToFilters(pushedDownPredicates)
                // 获取下推的Limit
                limitInfo := p.GetPushedDownLimit()
                fmt.Printf("  [DEBUG] convertToPhysicalPlan: DataSource(%s), 下推谓词数量: %d, 下推Limit: %v\n", p.TableName, len(filters), limitInfo != nil)
                return NewPhysicalTableScan(p.TableName, p.TableInfo, o.dataSource, filters, limitInfo), nil</span>
        case *LogicalSelection:<span class="cov0" title="0">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // 转换条件为过滤器
                <span class="cov0" title="0">filters := o.convertConditionsToFilters(p.GetConditions())
                fmt.Println("  [DEBUG] convertToPhysicalPlan: Selection, 过滤器数量:", len(filters))
                return NewPhysicalSelection(p.GetConditions(), filters, child, o.dataSource), nil</span>
        case *LogicalProjection:<span class="cov8" title="1">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">exprs := p.GetExprs()
                aliases := p.GetAliases()
                fmt.Printf("  [DEBUG] convertToPhysicalPlan: Projection, 表达式数量: %d, 别名数量: %d\n", len(exprs), len(aliases))
                for i, expr := range exprs </span><span class="cov8" title="1">{
                        fmt.Printf("  [DEBUG] convertToPhysicalPlan: 表达式%d: Type=%v, Column='%s'\n", i, expr.Type, expr.Column)
                        if i &lt; len(aliases) </span><span class="cov8" title="1">{
                                fmt.Printf("  [DEBUG] convertToPhysicalPlan: 别名%d: '%s'\n", i, aliases[i])
                        }</span>
                }
                <span class="cov8" title="1">return NewPhysicalProjection(exprs, aliases, child), nil</span>
        case *LogicalLimit:<span class="cov0" title="0">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return NewPhysicalLimit(p.GetLimit(), p.GetOffset(), child), nil</span>
        case *LogicalSort:<span class="cov8" title="1">
                // 简化：暂时不实现排序
                return o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                left, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">right, err := o.convertToPhysicalPlan(ctx, p.Children()[1], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return NewPhysicalHashJoin(p.GetJoinType(), left, right, p.GetJoinConditions()), nil</span>
        case *LogicalAggregate:<span class="cov8" title="1">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return NewPhysicalHashAggregate(p.GetAggFuncs(), p.GetGroupByCols(), child), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported logical plan type: %T", p)</span>
        }
}

// ExplainPlan 解释执行计划
func ExplainPlan(plan PhysicalPlan) string <span class="cov8" title="1">{
        return explainPlan(plan, 0)
}</span>

// explainPlan 递归解释计划
func explainPlan(plan PhysicalPlan, depth int) string <span class="cov8" title="1">{
        indent := ""
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="1">{
                indent += "  "
        }</span>

        <span class="cov8" title="1">result := indent + plan.Explain() + "\n"

        for _, child := range plan.Children() </span><span class="cov8" title="1">{
                result += explainPlan(child, depth+1)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package optimizer

import (
        "container/heap"
        "context"
        "fmt"
        "sync"
        "time"
)

// Index 索引定义
type Index struct {
        Name       string
        TableName  string
        Columns    []string
        Unique     bool
        Primary    bool
        Cardinality int64 // 基数（唯一值数量）
}

// IndexManager 索引管理器
type IndexManager struct {
        mu      sync.RWMutex
        indices map[string][]*Index // table_name -&gt; indices
        stats   map[string]*IndexStats // index_name -&gt; stats
}

// IndexStats 索引统计信息
type IndexStats struct {
        Name         string
        HitCount     int64
        MissCount    int64
        AvgAccessTime time.Duration
        LastAccessed time.Time
}

// NewIndexManager 创建索引管理器
func NewIndexManager() *IndexManager <span class="cov0" title="0">{
        return &amp;IndexManager{
                indices: make(map[string][]*Index),
                stats:   make(map[string]*IndexStats),
        }
}</span>

// AddIndex 添加索引
func (im *IndexManager) AddIndex(index *Index) <span class="cov0" title="0">{
        im.mu.Lock()
        defer im.mu.Unlock()

        im.indices[index.TableName] = append(im.indices[index.TableName], index)
        im.stats[index.Name] = &amp;IndexStats{
                Name:         index.Name,
                LastAccessed: time.Now(),
        }
}</span>

// GetIndices 获取表的所有索引
func (im *IndexManager) GetIndices(tableName string) []*Index <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        if indices, ok := im.indices[tableName]; ok </span><span class="cov0" title="0">{
                result := make([]*Index, len(indices))
                copy(result, indices)
                return result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindBestIndex 查找最佳索引
func (im *IndexManager) FindBestIndex(tableName string, columns []string) *Index <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        indices, ok := im.indices[tableName]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 寻找列数匹配且基数最高的索引
        <span class="cov0" title="0">var bestIndex *Index
        maxCardinality := int64(0)

        for _, index := range indices </span><span class="cov0" title="0">{
                if len(index.Columns) &gt;= len(columns) </span><span class="cov0" title="0">{
                        // 检查前几列是否匹配
                        match := true
                        for i, col := range columns </span><span class="cov0" title="0">{
                                if i &gt;= len(index.Columns) || index.Columns[i] != col </span><span class="cov0" title="0">{
                                        match = false
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if match &amp;&amp; index.Cardinality &gt; maxCardinality </span><span class="cov0" title="0">{
                                bestIndex = index
                                maxCardinality = index.Cardinality
                        }</span>
                }
        }

        <span class="cov0" title="0">return bestIndex</span>
}

// RecordIndexAccess 记录索引访问
func (im *IndexManager) RecordIndexAccess(indexName string, duration time.Duration) <span class="cov0" title="0">{
        im.mu.Lock()
        defer im.mu.Unlock()

        if stats, ok := im.stats[indexName]; ok </span><span class="cov0" title="0">{
                stats.HitCount++
                stats.LastAccessed = time.Now()

                // 更新平均访问时间
                if stats.AvgAccessTime == 0 </span><span class="cov0" title="0">{
                        stats.AvgAccessTime = duration
                }</span> else<span class="cov0" title="0"> {
                        stats.AvgAccessTime = (stats.AvgAccessTime*time.Duration(stats.HitCount) + duration) / time.Duration(stats.HitCount+1)
                }</span>
        }
}

// GetIndexStats 获取索引统计
func (im *IndexManager) GetIndexStats(indexName string) *IndexStats <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        if stats, ok := im.stats[indexName]; ok </span><span class="cov0" title="0">{
                // 返回副本
                return &amp;IndexStats{
                        Name:         stats.Name,
                        HitCount:     stats.HitCount,
                        MissCount:    stats.MissCount,
                        AvgAccessTime: stats.AvgAccessTime,
                        LastAccessed: stats.LastAccessed,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BatchExecutor 批量执行器
type BatchExecutor struct {
        batchSize     int
        flushInterval time.Duration
        batch         []interface{}
        timer         *time.Timer
        mu            sync.Mutex
        flushFunc      func([]interface{}) error
}

// NewBatchExecutor 创建批量执行器
func NewBatchExecutor(batchSize int, flushInterval time.Duration, flushFunc func([]interface{}) error) *BatchExecutor <span class="cov0" title="0">{
        be := &amp;BatchExecutor{
                batchSize:     batchSize,
                flushInterval: flushInterval,
                flushFunc:     flushFunc,
        }
        be.timer = time.AfterFunc(flushInterval, func() </span><span class="cov0" title="0">{ be.flush() }</span>)
        <span class="cov0" title="0">return be</span>
}

// Add 添加到批次
func (be *BatchExecutor) Add(item interface{}) error <span class="cov0" title="0">{
        be.mu.Lock()
        defer be.mu.Unlock()

        be.batch = append(be.batch, item)

        if len(be.batch) &gt;= be.batchSize </span><span class="cov0" title="0">{
                return be.flush()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// flush 刷新批次
func (be *BatchExecutor) flush() error <span class="cov0" title="0">{
        be.mu.Lock()
        defer be.mu.Unlock()

        if len(be.batch) == 0 </span><span class="cov0" title="0">{
                be.timer.Reset(be.flushInterval)
                return nil
        }</span>

        <span class="cov0" title="0">items := be.batch
        be.batch = make([]interface{}, 0, be.batchSize)

        err := be.flushFunc(items)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">be.timer.Reset(be.flushInterval)
        return nil</span>
}

// Flush 手动刷新
func (be *BatchExecutor) Flush() error <span class="cov0" title="0">{
        return be.flush()
}</span>

// Close 关闭批量执行器
func (be *BatchExecutor) Close() error <span class="cov0" title="0">{
        be.timer.Stop()
        return be.Flush()
}</span>

// PriorityQueue 优先队列（用于JOIN重排序等优化）
type PriorityQueue []*PlanNode

// PlanPlan 计划节点
type PlanNode struct {
        Plan     LogicalPlan
        Cost     float64
        Priority int
        Index    int
}

// Len 实现 heap.Interface
func (pq PriorityQueue) Len() int <span class="cov0" title="0">{ return len(pq) }</span>

// Less 实现 heap.Interface
func (pq PriorityQueue) Less(i, j int) bool <span class="cov0" title="0">{
        // 优先级高的在前（成本低的优先）
        if pq[i].Priority == pq[j].Priority </span><span class="cov0" title="0">{
                return pq[i].Cost &lt; pq[j].Cost
        }</span>
        <span class="cov0" title="0">return pq[i].Priority &gt; pq[j].Priority</span>
}

// Swap 实现 heap.Interface
func (pq PriorityQueue) Swap(i, j int) <span class="cov0" title="0">{
        pq[i], pq[j] = pq[j], pq[i]
        pq[i].Index = i
        pq[j].Index = j
}</span>

// Push 实现 heap.Interface
func (pq *PriorityQueue) Push(x interface{}) <span class="cov0" title="0">{
        n := len(*pq)
        node := x.(*PlanNode)
        node.Index = n
        *pq = append(*pq, node)
}</span>

// Pop 实现 heap.Interface
func (pq *PriorityQueue) Pop() interface{} <span class="cov0" title="0">{
        old := *pq
        n := len(old)
        node := old[n-1]
        old[n-1] = nil
        node.Index = -1
        *pq = old[0 : n-1]
        return node
}</span>

// NewPriorityQueue 创建优先队列
func NewPriorityQueue() *PriorityQueue <span class="cov0" title="0">{
        pq := make(PriorityQueue, 0)
        heap.Init(&amp;pq)
        return &amp;pq
}</span>

// PerformanceOptimizer 性能优化器
type PerformanceOptimizer struct {
        indexManager  *IndexManager
        batchExecutor *BatchExecutor
}

// NewPerformanceOptimizer 创建性能优化器
func NewPerformanceOptimizer() *PerformanceOptimizer <span class="cov0" title="0">{
        return &amp;PerformanceOptimizer{
                indexManager: NewIndexManager(),
        }
}</span>

// OptimizeQuery 优化查询
func (po *PerformanceOptimizer) OptimizeQuery(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 1. 索引选择优化
        plan = po.optimizeIndexSelection(plan, optCtx)

        // 2. JOIN 重排序优化
        plan = po.optimizeJoinOrder(plan, optCtx)

        // 3. 谓词下推优化
        plan = po.optimizePredicatePushdown(plan, optCtx)

        return plan, nil
}</span>

// optimizeIndexSelection 优化索引选择
func (po *PerformanceOptimizer) optimizeIndexSelection(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // TODO: 实现索引选择优化逻辑
        // 1. 扫描过滤条件中的列
        // 2. 查找匹配的索引
        // 3. 选择基数最高的索引
        return plan
}</span>

// optimizeJoinOrder 优化JOIN顺序
func (po *PerformanceOptimizer) optimizeJoinOrder(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // TODO: 实现JOIN重排序优化逻辑
        // 1. 识别JOIN树
        // 2. 基于统计信息计算不同顺序的成本
        // 3. 选择最优顺序
        return plan
}</span>

// optimizePredicatePushdown 优化谓词下推
func (po *PerformanceOptimizer) optimizePredicatePushdown(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // TODO: 实现谓词下推优化逻辑
        // 1. 识别过滤条件
        // 2. 尽可能将过滤条件下推到数据源
        return plan
}</span>

// EstimateSelectivity 估计过滤条件的选择性
func (po *PerformanceOptimizer) EstimateSelectivity(filter Filter, stats *Statistics) float64 <span class="cov0" title="0">{
        // 简化实现：假设平均选择性为0.1
        // TODO: 基于统计信息实现更精确的选择性估计
        return 0.1
}</span>

// Filter 过滤条件（简化版）
type Filter struct {
        Column   string
        Operator string
        Value    interface{}
}

// OptimizeScan 优化扫描操作
func (po *PerformanceOptimizer) OptimizeScan(tableName string, filters []Filter, optCtx *OptimizationContext) *ScanOptimization <span class="cov0" title="0">{
        optimization := &amp;ScanOptimization{
                UseIndex:      false,
                IndexName:     "",
                PushDown:      true,
                EstimatedRows: 10000,
        }

        // 检查是否有可用的索引
        for _, filter := range filters </span><span class="cov0" title="0">{
                if index := po.indexManager.FindBestIndex(tableName, []string{filter.Column}); index != nil </span><span class="cov0" title="0">{
                        optimization.UseIndex = true
                        optimization.IndexName = index.Name
                        optimization.EstimatedRows = index.Cardinality / 10 // 假设索引选择性为10%
                        break</span>
                }
        }

        <span class="cov0" title="0">return optimization</span>
}

// ScanOptimization 扫描优化建议
type ScanOptimization struct {
        UseIndex      bool
        IndexName     string
        PushDown      bool
        EstimatedRows int64
}

// Explain 解释优化建议
func (so *ScanOptimization) Explain() string <span class="cov0" title="0">{
        if so.UseIndex </span><span class="cov0" title="0">{
                return fmt.Sprintf("建议使用索引 %s，预计扫描 %d 行", so.IndexName, so.EstimatedRows)
        }</span>
        <span class="cov0" title="0">if so.PushDown </span><span class="cov0" title="0">{
                return fmt.Sprintf("建议将过滤条件下推，预计扫描 %d 行", so.EstimatedRows)
        }</span>
        <span class="cov0" title="0">return "全表扫描"</span>
}

// MemoryPool 内存池（用于重用对象减少GC压力）
type MemoryPool struct {
        pools map[string]interface{}
        mu    sync.RWMutex
}

// NewMemoryPool 创建内存池
func NewMemoryPool() *MemoryPool <span class="cov0" title="0">{
        return &amp;MemoryPool{
                pools: make(map[string]interface{}),
        }
}</span>

// GetPool 获取指定类型的池
func (mp *MemoryPool) GetPool(key string) interface{} <span class="cov0" title="0">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()
        return mp.pools[key]
}</span>

// SetPool 设置指定类型的池
func (mp *MemoryPool) SetPool(key string, pool interface{}) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()
        mp.pools[key] = pool
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// PhysicalTableScan 物理表扫描
type PhysicalTableScan struct {
        TableName  string
        Columns    []ColumnInfo
        TableInfo  *domain.TableInfo
        cost       float64
        children   []PhysicalPlan
        dataSource domain.DataSource
        filters    []domain.Filter // 下推的过滤条件
        limitInfo  *LimitInfo      // 下推的Limit信息
}

// NewPhysicalTableScan 创建物理表扫描
func NewPhysicalTableScan(tableName string, tableInfo *domain.TableInfo, dataSource domain.DataSource, filters []domain.Filter, limitInfo *LimitInfo) *PhysicalTableScan <span class="cov8" title="1">{
        columns := make([]ColumnInfo, 0, len(tableInfo.Columns))
        for _, col := range tableInfo.Columns </span><span class="cov8" title="1">{
                columns = append(columns, ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                })
        }</span>

        // 假设表有1000行
        <span class="cov8" title="1">rowCount := int64(1000)
        
        // 如果有Limit，调整成本估计
        if limitInfo != nil &amp;&amp; limitInfo.Limit &gt; 0 </span><span class="cov8" title="1">{
                rowCount = limitInfo.Limit
        }</span>

        <span class="cov8" title="1">return &amp;PhysicalTableScan{
                TableName: tableName,
                Columns:   columns,
                TableInfo: tableInfo,
                cost:      float64(rowCount),
                children:  []PhysicalPlan{},
                dataSource: dataSource,
                filters:   filters,
                limitInfo: limitInfo,
        }</span>
}

// Children 获取子节点
func (p *PhysicalTableScan) Children() []PhysicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalTableScan) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalTableScan) Schema() []ColumnInfo <span class="cov0" title="0">{
        return p.Columns
}</span>

// Cost 返回执行成本
func (p *PhysicalTableScan) Cost() float64 <span class="cov8" title="1">{
        return p.cost
}</span>

// Execute 执行扫描
func (p *PhysicalTableScan) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 开始查询表 %s, 过滤器数: %d, Limit: %v\n", p.TableName, len(p.filters), p.limitInfo)
        
        // 如果有下推的过滤条件，使用QueryOptions中的Filters
        options := &amp;domain.QueryOptions{}
        if len(p.filters) &gt; 0 </span><span class="cov0" title="0">{
                options.Filters = p.filters
                fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 应用下推的过滤条件\n")
                for i, filter := range p.filters </span><span class="cov0" title="0">{
                        fmt.Printf("  [DEBUG]   过滤器%d: Field=%s, Operator=%s, Value=%v\n", i, filter.Field, filter.Operator, filter.Value)
                }</span>
        }
        
        // 如果有下推的Limit，应用Limit
        <span class="cov0" title="0">if p.limitInfo != nil </span><span class="cov0" title="0">{
                if p.limitInfo.Limit &gt; 0 </span><span class="cov0" title="0">{
                        options.Limit = int(p.limitInfo.Limit)
                }</span>
                <span class="cov0" title="0">if p.limitInfo.Offset &gt; 0 </span><span class="cov0" title="0">{
                        options.Offset = int(p.limitInfo.Offset)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 应用下推的Limit: limit=%d, offset=%d\n", options.Limit, options.Offset)</span>
        }
        
        <span class="cov0" title="0">result, err := p.dataSource.Query(ctx, p.TableName, options)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 查询失败 %v\n", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 查询完成，返回 %d 行\n", len(result.Rows))
        return result, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalTableScan) Explain() string <span class="cov8" title="1">{
        return fmt.Sprintf("TableScan(%s, cost=%.2f)", p.TableName, p.cost)
}</span>

// PhysicalSelection 物理过滤
type PhysicalSelection struct {
        Conditions []*parser.Expression
        Filters    []domain.Filter
        cost       float64
        children   []PhysicalPlan
        dataSource domain.DataSource
}

// NewPhysicalSelection 创建物理过滤
func NewPhysicalSelection(conditions []*parser.Expression, filters []domain.Filter, child PhysicalPlan, dataSource domain.DataSource) *PhysicalSelection <span class="cov0" title="0">{
        inputCost := child.Cost()
        cost := inputCost*1.2 + 10 // 过滤成本

        return &amp;PhysicalSelection{
                Conditions: conditions,
                Filters:    filters,
                cost:       cost,
                children:   []PhysicalPlan{child},
                dataSource: dataSource,
        }
}</span>

// Children 获取子节点
func (p *PhysicalSelection) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalSelection) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalSelection) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalSelection) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行过滤
func (p *PhysicalSelection) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalSelection has no child")
        }</span>

        // 先执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 手动应用过滤（简化实现）
        <span class="cov0" title="0">filtered := []domain.Row{}
        for _, row := range input.Rows </span><span class="cov0" title="0">{
                match := true
                for _, filter := range p.Filters </span><span class="cov0" title="0">{
                        if !matchesFilter(row, filter) </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                        filtered = append(filtered, row)
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    filtered,
                Total:    int64(len(filtered)),
        }, nil</span>
}

// matchesFilter 检查行是否匹配过滤器（简化实现）
func matchesFilter(row domain.Row, filter domain.Filter) bool <span class="cov0" title="0">{
        value, exists := row[filter.Field]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // 类型转换比较
        <span class="cov0" title="0">return compareWithOperator(value, filter.Value, filter.Operator)</span>
}

// compareWithOperator 使用指定操作符比较两个值
func compareWithOperator(left, right interface{}, op string) bool <span class="cov0" title="0">{
        leftVal, leftOk := toFloat64(left)
        if !leftOk </span><span class="cov0" title="0">{
                // 无法转换为数字，使用字符串比较
                return compareStrings(left, right, op)
        }</span>

        <span class="cov0" title="0">rightVal, rightOk := toFloat64(right)
        if rightOk </span><span class="cov0" title="0">{
                // 两者都是数字，使用数字比较
                switch op </span>{
                case "=":<span class="cov0" title="0">
                        return leftVal == rightVal</span>
                case "&gt;", "gt":<span class="cov0" title="0">
                        return leftVal &gt; rightVal</span>
                case "&gt;=", "gte":<span class="cov0" title="0">
                        return leftVal &gt;= rightVal</span>
                case "&lt;", "lt":<span class="cov0" title="0">
                        return leftVal &lt; rightVal</span>
                case "&lt;=", "lte":<span class="cov0" title="0">
                        return leftVal &lt;= rightVal</span>
                case "!=", "ne":<span class="cov0" title="0">
                        return leftVal != rightVal</span>
                }
        }

        // 默认：使用字符串比较
        <span class="cov0" title="0">return compareStrings(left, right, op)</span>
}

// compareStrings 比较字符串值
func compareStrings(left, right interface{}, op string) bool <span class="cov0" title="0">{
        leftStr := fmt.Sprintf("%v", left)
        rightStr := fmt.Sprintf("%v", right)

        switch op </span>{
        case "=":<span class="cov0" title="0">
                return leftStr == rightStr</span>
        case "!=", "ne":<span class="cov0" title="0">
                return leftStr != rightStr</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Explain 返回计划说明
func (p *PhysicalSelection) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf("Selection(cost=%.2f)", p.cost)
}</span>

// PhysicalProjection 物理投影
type PhysicalProjection struct {
        Exprs   []*parser.Expression
        Aliases  []string
        Columns  []ColumnInfo
        cost     float64
        children []PhysicalPlan
}

// NewPhysicalProjection 创建物理投影
func NewPhysicalProjection(exprs []*parser.Expression, aliases []string, child PhysicalPlan) *PhysicalProjection <span class="cov8" title="1">{
        inputCost := child.Cost()
        cost := inputCost*1.1 + float64(len(exprs))*5 // 投影成本

        columns := make([]ColumnInfo, len(exprs))
        for i, expr := range exprs </span><span class="cov8" title="1">{
                name := aliases[i]
                if name == "" </span><span class="cov0" title="0">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                                name = expr.Column
                        }</span> else<span class="cov0" title="0"> {
                                name = fmt.Sprintf("expr_%d", i)
                        }</span>
                }
                <span class="cov8" title="1">columns[i] = ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                }</span>
        }

        <span class="cov8" title="1">return &amp;PhysicalProjection{
                Exprs:    exprs,
                Aliases:   aliases,
                Columns:   columns,
                cost:      cost,
                children:  []PhysicalPlan{child},
        }</span>
}

// Children 获取子节点
func (p *PhysicalProjection) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalProjection) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalProjection) Schema() []ColumnInfo <span class="cov0" title="0">{
        return p.Columns
}</span>

// Cost 返回执行成本
func (p *PhysicalProjection) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行投影
func (p *PhysicalProjection) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalProjection has no child")
        }</span>

        // 先执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 输入行数: %d, 输入列数: %d\n", len(input.Rows), len(input.Columns))

        // 应用投影（简化实现，只支持列选择）
        output := []domain.Row{}
        for rowIdx, row := range input.Rows </span><span class="cov0" title="0">{
                newRow := make(domain.Row)
                fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 处理行 %d, 原始keys: %v\n", rowIdx, getMapKeys(row))
                for i, expr := range p.Exprs </span><span class="cov0" title="0">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                                fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 尝试提取列 %s (别名: %s)\n", expr.Column, p.Aliases[i])
                                if val, exists := row[expr.Column]; exists </span><span class="cov0" title="0">{
                                        newRow[p.Aliases[i]] = val
                                        fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 提取成功, 值: %v\n", val)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 列 %s 不存在于行中\n", expr.Column)
                                        // 简化：不支持表达式计算
                                        newRow[p.Aliases[i]] = nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 简化：不支持表达式计算
                                newRow[p.Aliases[i]] = nil
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 新行keys: %v\n", getMapKeys(newRow))
                output = append(output, newRow)</span>
        }

        // 更新列信息
        <span class="cov0" title="0">columns := make([]domain.ColumnInfo, len(p.Columns))
        for i, col := range p.Columns </span><span class="cov0" title="0">{
                columns[i] = domain.ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                }
        }</span>

        <span class="cov0" title="0">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 输出行数: %d, 输出列: %v\n", len(output), p.Aliases)
        return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// getMapKeys 获取map的所有key
func getMapKeys(m domain.Row) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Explain 返回计划说明
func (p *PhysicalProjection) Explain() string <span class="cov8" title="1">{
        return fmt.Sprintf("Projection(cost=%.2f)", p.cost)
}</span>

// PhysicalLimit 物理限制
type PhysicalLimit struct {
        Limit    int64
        Offset   int64
        cost     float64
        children []PhysicalPlan
}

// NewPhysicalLimit 创建物理限制
func NewPhysicalLimit(limit, offset int64, child PhysicalPlan) *PhysicalLimit <span class="cov8" title="1">{
        inputCost := child.Cost()
        cost := inputCost + float64(limit)*0.01 // 限制操作成本很低

        return &amp;PhysicalLimit{
                Limit:    limit,
                Offset:   offset,
                cost:     cost,
                children: []PhysicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *PhysicalLimit) Children() []PhysicalPlan <span class="cov8" title="1">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalLimit) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalLimit) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalLimit) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行限制
func (p *PhysicalLimit) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalLimit has no child")
        }</span>

        // 先执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 应用 OFFSET 和 LIMIT
        <span class="cov0" title="0">start := p.Offset
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">if start &gt;= int64(len(input.Rows)) </span><span class="cov0" title="0">{
                return &amp;domain.QueryResult{
                        Columns: input.Columns,
                        Rows:    []domain.Row{},
                        Total:    0,
                }, nil
        }</span>

        <span class="cov0" title="0">end := start + p.Limit
        if end &gt; int64(len(input.Rows)) </span><span class="cov0" title="0">{
                end = int64(len(input.Rows))
        }</span>

        <span class="cov0" title="0">output := input.Rows[start:end]

        return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalLimit) Explain() string <span class="cov8" title="1">{
        return fmt.Sprintf("Limit(offset=%d, limit=%d, cost=%.2f)", p.Offset, p.Limit, p.cost)
}</span>

// PhysicalHashJoin 物理哈希连接
type PhysicalHashJoin struct {
        JoinType   JoinType
        Conditions []*JoinCondition
        cost       float64
        children   []PhysicalPlan
}

// NewPhysicalHashJoin 创建物理哈希连接
func NewPhysicalHashJoin(joinType JoinType, left, right PhysicalPlan, conditions []*JoinCondition) *PhysicalHashJoin <span class="cov0" title="0">{
        leftRows := int64(1000) // 假设
        rightRows := int64(1000) // 假设

        // Hash Join 成本 = 构建哈希表 + 探测
        buildCost := float64(leftRows) * 0.1
        probeCost := float64(rightRows) * 0.1
        cost := left.Cost() + right.Cost() + buildCost + probeCost

        return &amp;PhysicalHashJoin{
                JoinType:   joinType,
                Conditions: conditions,
                cost:       cost,
                children:   []PhysicalPlan{left, right},
        }
}</span>

// Children 获取子节点
func (p *PhysicalHashJoin) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalHashJoin) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalHashJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalHashJoin) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行哈希连接
func (p *PhysicalHashJoin) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HashJoin requires exactly 2 children")
        }</span>

        // 获取连接条件（简化：只支持单列等值连接）
        <span class="cov0" title="0">leftJoinCol := ""
        rightJoinCol := ""
        if len(p.Conditions) &gt; 0 &amp;&amp; p.Conditions[0].Left != nil </span><span class="cov0" title="0">{
                leftJoinCol = fmt.Sprintf("%v", p.Conditions[0].Left)
        }</span>
        <span class="cov0" title="0">if len(p.Conditions) &gt; 0 &amp;&amp; p.Conditions[0].Right != nil </span><span class="cov0" title="0">{
                rightJoinCol = fmt.Sprintf("%v", p.Conditions[0].Right)
        }</span>

        // 1. 执行左表（构建端）
        <span class="cov0" title="0">leftResult, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left table execute error: %w", err)
        }</span>

        // 2. 执行右表（探测端）
        <span class="cov0" title="0">rightResult, err := p.children[1].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right table execute error: %w", err)
        }</span>

        // 3. 构建哈希表（从左表）
        <span class="cov0" title="0">hashTable := make(map[interface{}][]domain.Row)
        for _, row := range leftResult.Rows </span><span class="cov0" title="0">{
                key := row[leftJoinCol]
                hashTable[key] = append(hashTable[key], row)
        }</span>

        // 4. 探测右表并产生结果
        <span class="cov0" title="0">output := []domain.Row{}

        // 根据连接类型处理
        switch p.JoinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN：两边都有匹配
                for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := hashTable[key]; exists </span><span class="cov0" title="0">{
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        // 合并左右行
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                // 如果列名冲突，添加前缀
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        }
                }
        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN：左边所有行，右边没有匹配的用NULL填充
                // 跟踪右边已匹配的行
                rightMatched := make(map[int]bool)
                for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := hashTable[key]; exists </span><span class="cov0" title="0">{
                                // 有匹配：连接
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        // 标记右边已匹配的行 - 简化：不比较行内容
                        // 由于 map 不能直接比较，使用索引方式
                        <span class="cov0" title="0">rightMatched[len(rightResult.Rows)-1] = true</span>
                        }
                }
                // 添加左边没有匹配的行
                <span class="cov0" title="0">for _, leftRow := range leftResult.Rows </span><span class="cov0" title="0">{
                        leftKey := leftRow[leftJoinCol]
                        matched := false
                        for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                                if rightRow[rightJoinCol] == leftKey </span><span class="cov0" title="0">{
                                        matched = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                                merged := make(domain.Row)
                                for k, v := range leftRow </span><span class="cov0" title="0">{
                                        merged[k] = v
                                }</span>
                                <span class="cov0" title="0">for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                                        newKey := col.Name
                                        if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                newKey = "right_" + col.Name
                                        }</span>
                                        <span class="cov0" title="0">merged[newKey] = nil</span>
                                }
                                <span class="cov0" title="0">output = append(output, merged)</span>
                        }
                }
case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN：右边所有行，左边没有匹配的用NULL填充
                // 重新构建左表的哈希表用于RIGHT JOIN
                leftHashTable := make(map[interface{}][]domain.Row)
                for _, row := range leftResult.Rows </span><span class="cov0" title="0">{
                        key := row[leftJoinCol]
                        leftHashTable[key] = append(leftHashTable[key], row)
                }</span>

                <span class="cov0" title="0">for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := leftHashTable[key]; exists </span><span class="cov0" title="0">{
                                // 有匹配：连接
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // 无匹配：左边NULL + 右边行
                                merged := make(domain.Row)
                                for _, col := range leftResult.Columns </span><span class="cov0" title="0">{
                                        merged[col.Name] = nil
                                }</span>
                                <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                        newKey := k
                                        if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                newKey = "right_" + k
                                        }</span>
                                        <span class="cov0" title="0">merged[newKey] = v</span>
                                }
                                <span class="cov0" title="0">output = append(output, merged)</span>
                        }
                }

default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported join type: %s", p.JoinType)</span>
        }

        // 合并列信息
        <span class="cov0" title="0">columns := []domain.ColumnInfo{}
        columns = append(columns, leftResult.Columns...)
        for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                // 检查列名是否冲突
                conflict := false
                for _, leftCol := range leftResult.Columns </span><span class="cov0" title="0">{
                        if leftCol.Name == col.Name </span><span class="cov0" title="0">{
                                conflict = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if conflict </span><span class="cov0" title="0">{
                        columns = append(columns, domain.ColumnInfo{
                                Name:     "right_" + col.Name,
                                Type:     col.Type,
                                Nullable: true,
                        })
                }</span> else<span class="cov0" title="0"> {
                        columns = append(columns, col)
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:   int64(len(output)),
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalHashJoin) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf("HashJoin(type=%s, cost=%.2f)", p.JoinType, p.cost)
}</span>

// PhysicalHashAggregate 物理哈希聚合
type PhysicalHashAggregate struct {
        AggFuncs   []*AggregationItem
        GroupByCols []string
        cost        float64
        children    []PhysicalPlan
}

// NewPhysicalHashAggregate 创建物理哈希聚合
func NewPhysicalHashAggregate(aggFuncs []*AggregationItem, groupByCols []string, child PhysicalPlan) *PhysicalHashAggregate <span class="cov8" title="1">{
        inputRows := int64(1000) // 假设

        // Hash Agg 成本 = 分组 + 聚合
        groupCost := float64(inputRows) * float64(len(groupByCols)) * 0.05
        aggCost := float64(inputRows) * float64(len(aggFuncs)) * 0.05
        cost := child.Cost() + groupCost + aggCost

        return &amp;PhysicalHashAggregate{
                AggFuncs:   aggFuncs,
                GroupByCols: groupByCols,
                cost:        cost,
                children:    []PhysicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *PhysicalHashAggregate) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalHashAggregate) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalHashAggregate) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}

        // 添加 GROUP BY 列
        for _, col := range p.GroupByCols </span><span class="cov0" title="0">{
                columns = append(columns, ColumnInfo{
                        Name:     col,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 添加聚合函数列
        <span class="cov0" title="0">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                name := agg.Alias
                if name == "" </span><span class="cov0" title="0">{
                        name = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalHashAggregate) Cost() float64 <span class="cov8" title="1">{
        return p.cost
}</span>

// Execute 执行哈希聚合
func (p *PhysicalHashAggregate) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HashAggregate has no child")
        }</span>

        // 执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(p.AggFuncs) == 0 &amp;&amp; len(p.GroupByCols) == 0 </span><span class="cov0" title="0">{
                // 没有聚合函数也没有分组，直接返回
                return input, nil
        }</span>

        // 用于存储分组结果的哈希表
        <span class="cov0" title="0">type groupKey struct {
                values []interface{}
        }
        groups := make(map[interface{}]*aggregateGroup)

        // 遍历所有行，进行分组和聚合
        for _, row := range input.Rows </span><span class="cov0" title="0">{
                // 构建分组键
                key := make([]interface{}, len(p.GroupByCols))
                for i, colName := range p.GroupByCols </span><span class="cov0" title="0">{
                        key[i] = row[colName]
                }</span>

                // 将key转换为字符串作为map的key
                <span class="cov0" title="0">keyStr := fmt.Sprintf("%v", key)

                // 获取或创建分组
                group, exists := groups[keyStr]
                if !exists </span><span class="cov0" title="0">{
                        group = &amp;aggregateGroup{
                                key:    key,
                                rows:   []domain.Row{},
                                values: make(map[string]interface{}),
                        }
                        groups[keyStr] = group
                }</span>

                <span class="cov0" title="0">group.rows = append(group.rows, row)</span>
        }

        // 为每个分组计算聚合函数
        <span class="cov0" title="0">output := []domain.Row{}
        for _, group := range groups </span><span class="cov0" title="0">{
                row := make(domain.Row)

                // 添加 GROUP BY 列
                for i, colName := range p.GroupByCols </span><span class="cov0" title="0">{
                        if i &lt; len(group.key) </span><span class="cov0" title="0">{
                                row[colName] = group.key[i]
                        }</span>
                }

                // 计算聚合函数
                <span class="cov0" title="0">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                        result := p.calculateAggregation(agg, group.rows)
                        colName := agg.Alias
                        if colName == "" </span><span class="cov0" title="0">{
                                colName = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                        }</span>
                        <span class="cov0" title="0">row[colName] = result</span>
                }

                <span class="cov0" title="0">output = append(output, row)</span>
        }

        // 构建列信息
        <span class="cov0" title="0">columns := []domain.ColumnInfo{}

        // GROUP BY 列
        for _, colName := range p.GroupByCols </span><span class="cov0" title="0">{
                columns = append(columns, domain.ColumnInfo{
                        Name:     colName,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 聚合函数列
        <span class="cov0" title="0">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                colName := agg.Alias
                if colName == "" </span><span class="cov0" title="0">{
                        colName = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, domain.ColumnInfo{
                        Name:     colName,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:   int64(len(output)),
        }, nil</span>
}

// aggregateGroup 表示一个分组
type aggregateGroup struct {
        key    []interface{}
        rows   []domain.Row
        values map[string]interface{}
}

// calculateAggregation 计算聚合函数
func (p *PhysicalHashAggregate) calculateAggregation(agg *AggregationItem, rows []domain.Row) interface{} <span class="cov0" title="0">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                switch agg.Type </span>{
                case Count:<span class="cov0" title="0">
                        return int64(0)</span>
                case Sum, Avg, Max, Min:<span class="cov0" title="0">
                        return nil</span>
                }
        }

        // 获取聚合列名
        <span class="cov0" title="0">colName := agg.Expr.Column
        if colName == "" &amp;&amp; agg.Expr.Function != "" </span><span class="cov0" title="0">{
                colName = fmt.Sprintf("%s(%v)", agg.Expr.Function, agg.Expr.Args)
        }</span>

        <span class="cov0" title="0">switch agg.Type </span>{
        case Count:<span class="cov0" title="0">
                return int64(len(rows))</span>
        case Sum:<span class="cov0" title="0">
                sum := 0.0
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil </span><span class="cov0" title="0">{
                                fval, _ := toFloat64(val)
                                sum += fval
                        }</span>
                }
                <span class="cov0" title="0">return sum</span>
        case Avg:<span class="cov0" title="0">
                if len(rows) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">sum := 0.0
                count := 0
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil </span><span class="cov0" title="0">{
                                fval, _ := toFloat64(val)
                                sum += fval
                                count++
                        }</span>
                }
                <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                        return sum / float64(count)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case Max:<span class="cov0" title="0">
                var max interface{}
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil &amp;&amp; max == nil </span><span class="cov0" title="0">{
                                max = val
                        }</span> else<span class="cov0" title="0"> if val != nil &amp;&amp; max != nil </span><span class="cov0" title="0">{
                                cmp := compareValues(val, max)
                                if cmp &gt; 0 </span><span class="cov0" title="0">{
                                        max = val
                                }</span>
                        }
                }
                <span class="cov0" title="0">return max</span>
        case Min:<span class="cov0" title="0">
                var min interface{}
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil &amp;&amp; min == nil </span><span class="cov0" title="0">{
                                min = val
                        }</span> else<span class="cov0" title="0"> if val != nil &amp;&amp; min != nil </span><span class="cov0" title="0">{
                                cmp := compareValues(val, min)
                                if cmp &lt; 0 </span><span class="cov0" title="0">{
                                        min = val
                                }</span>
                        }
                }
                <span class="cov0" title="0">return min</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Explain 返回计划说明
func (p *PhysicalHashAggregate) Explain() string <span class="cov0" title="0">{
        aggFuncs := ""
        for i, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        aggFuncs += ", "
                }</span>
                <span class="cov0" title="0">aggFuncs += agg.Type.String()</span>
        }
        
        <span class="cov0" title="0">groupBy := ""
        if len(p.GroupByCols) &gt; 0 </span><span class="cov0" title="0">{
                groupBy = fmt.Sprintf(", GROUP BY(%s)", fmt.Sprintf("%v", p.GroupByCols))
        }</span>
        
        <span class="cov0" title="0">return fmt.Sprintf("HashAggregate(funcs=[%s]%s, cost=%.2f)", aggFuncs, groupBy, p.cost)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "math"
        "sort"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// PhysicalSort 物理排序
type PhysicalSort struct {
        OrderByItems []*OrderByItem
        cost         float64
        children     []PhysicalPlan
}

// NewPhysicalSort 创建物理排序
func NewPhysicalSort(orderByItems []*OrderByItem, child PhysicalPlan) *PhysicalSort <span class="cov0" title="0">{
        inputCost := child.Cost()
        // 排序成本估算：n * log(n)，n是输入行数
        // 假设1000行
        inputRows := int64(1000)
        sortCost := float64(inputRows) * float64(log2(float64(inputRows))) * 0.01
        cost := inputCost + sortCost

        return &amp;PhysicalSort{
                OrderByItems: orderByItems,
                cost:         cost,
                children:     []PhysicalPlan{child},
        }
}</span>

// log2 计算以2为底的对数
func log2(x float64) float64 <span class="cov0" title="0">{
        if x &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return math.Log2(x)</span>
}

// Children 获取子节点
func (p *PhysicalSort) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalSort) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalSort) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalSort) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行排序
func (p *PhysicalSort) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalSort has no child")
        }</span>

        // 执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(p.OrderByItems) == 0 </span><span class="cov0" title="0">{
                // 没有排序条件，直接返回
                return input, nil
        }</span>

        // 复制行以避免修改原始数据
        <span class="cov0" title="0">rows := make([]domain.Row, len(input.Rows))
        copy(rows, input.Rows)

        // 排序
        sort.Slice(rows, func(i, j int) bool </span><span class="cov0" title="0">{
                for _, item := range p.OrderByItems </span><span class="cov0" title="0">{
                        leftVal := rows[i][item.Column]
                        rightVal := rows[j][item.Column]

                        // 比较两个值
                        cmp := compareValues(leftVal, rightVal)
                        if cmp != 0 </span><span class="cov0" title="0">{
                                // DESC 需要反转比较结果
                                if item.Direction == "DESC" </span><span class="cov0" title="0">{
                                        return cmp &gt; 0
                                }</span>
                                <span class="cov0" title="0">return cmp &lt; 0</span>
                        }
                }
                // 所有排序列都相等，保持原顺序
                <span class="cov0" title="0">return i &lt; j</span>
        })

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    rows,
                Total:   input.Total,
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalSort) Explain() string <span class="cov0" title="0">{
        items := ""
        for i, item := range p.OrderByItems </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        items += ", "
                }</span>
                <span class="cov0" title="0">direction := "ASC"
                if item.Direction == "DESC" </span><span class="cov0" title="0">{
                        direction = "DESC"
                }</span>
                <span class="cov0" title="0">items += fmt.Sprintf("%s %s", item.Column, direction)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Sort(%s, cost=%.2f)", items, p.cost)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// ProcedureExecutor 存储过程执行器
type ProcedureExecutor struct {
        // 变量作用域栈
        scopeStack []*Scope
        
        // 存储过程缓存
        procedures map[string]*parser.ProcedureInfo
        
        // 函数缓存
        functions map[string]*parser.FunctionInfo
        
        // 执行上下文
        ctx context.Context
}

// Scope 变量作用域
type Scope struct {
        Variables map[string]interface{}
        Parent    *Scope
}

// NewScope 创建新作用域
func NewScope(parent *Scope) *Scope <span class="cov0" title="0">{
        return &amp;Scope{
                Variables: make(map[string]interface{}),
                Parent:    parent,
        }
}</span>

// GetVariable 获取变量值
func (s *Scope) GetVariable(name string) (interface{}, bool) <span class="cov0" title="0">{
        if val, exists := s.Variables[name]; exists </span><span class="cov0" title="0">{
                return val, true
        }</span>
        
        // 查找父作用域
        <span class="cov0" title="0">if s.Parent != nil </span><span class="cov0" title="0">{
                return s.Parent.GetVariable(name)
        }</span>
        
        <span class="cov0" title="0">return nil, false</span>
}

// SetVariable 设置变量值
func (s *Scope) SetVariable(name string, value interface{}) <span class="cov0" title="0">{
        s.Variables[name] = value
}</span>

// NewProcedureExecutor 创建存储过程执行器
func NewProcedureExecutor() *ProcedureExecutor <span class="cov0" title="0">{
        return &amp;ProcedureExecutor{
                scopeStack: make([]*Scope, 0),
                procedures: make(map[string]*parser.ProcedureInfo),
                functions:   make(map[string]*parser.FunctionInfo),
        }
}</span>

// RegisterProcedure 注册存储过程
func (pe *ProcedureExecutor) RegisterProcedure(proc *parser.ProcedureInfo) error <span class="cov0" title="0">{
        if err := parser.ValidateProcedure(&amp;parser.ProcedureStmt{
                Name:   proc.Name,
                Params: proc.Params,
                Body:   proc.Body,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("procedure validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">pe.procedures[proc.Name] = proc
        return nil</span>
}

// RegisterFunction 注册函数
func (pe *ProcedureExecutor) RegisterFunction(fn *parser.FunctionInfo) error <span class="cov0" title="0">{
        if err := parser.ValidateFunction(&amp;parser.FunctionStmt{
                Name:       fn.Name,
                ReturnType:  fn.ReturnType,
                Params:     fn.Params,
                Body:       fn.Body,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">pe.functions[fn.Name] = fn
        return nil</span>
}

// ExecuteProcedure 执行存储过程
func (pe *ProcedureExecutor) ExecuteProcedure(ctx context.Context, name string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        pe.ctx = ctx
        
        // 查找存储过程
        proc, exists := pe.procedures[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("procedure not found: %s", name)
        }</span>
        
        // 创建新作用域
        <span class="cov0" title="0">newScope := NewScope(pe.currentScope())
        pe.pushScope(newScope)
        defer pe.popScope()
        
        // 绑定参数
        if len(args) != len(proc.Params) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter count mismatch: expected %d, got %d", len(proc.Params), len(args))
        }</span>
        
        <span class="cov0" title="0">for i, param := range proc.Params </span><span class="cov0" title="0">{
                newScope.SetVariable(param.Name, args[i])
        }</span>
        
        // 执行存储过程体
        <span class="cov0" title="0">return pe.executeBlock(proc.Body)</span>
}

// ExecuteFunction 执行函数
func (pe *ProcedureExecutor) ExecuteFunction(ctx context.Context, name string, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        pe.ctx = ctx
        
        // 查找函数
        fn, exists := pe.functions[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function not found: %s", name)
        }</span>
        
        // 创建新作用域
        <span class="cov0" title="0">newScope := NewScope(pe.currentScope())
        pe.pushScope(newScope)
        defer pe.popScope()
        
        // 绑定参数
        if len(args) != len(fn.Params) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter count mismatch: expected %d, got %d", len(fn.Params), len(args))
        }</span>
        
        <span class="cov0" title="0">for i, param := range fn.Params </span><span class="cov0" title="0">{
                newScope.SetVariable(param.Name, args[i])
        }</span>
        
        // 执行函数体
        <span class="cov0" title="0">result, err := pe.executeBlockWithReturn(fn.Body)
        return result, err</span>
}

// executeBlock 执行语句块
func (pe *ProcedureExecutor) executeBlock(block *parser.BlockStmt) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // 执行声明
        <span class="cov0" title="0">for _, decl := range block.Declarations </span><span class="cov0" title="0">{
                if err := pe.executeDeclaration(decl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        // 执行语句
        <span class="cov0" title="0">for _, stmt := range block.Statements </span><span class="cov0" title="0">{
                switch s := stmt.(type) </span>{
                case *parser.IfStmt:<span class="cov0" title="0">
                        if err := pe.executeIf(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.WhileStmt:<span class="cov0" title="0">
                        if err := pe.executeWhile(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.SetStmt:<span class="cov0" title="0">
                        if err := pe.executeSet(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.CaseStmt:<span class="cov0" title="0">
                        if err := pe.executeCase(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.ReturnStmt:<span class="cov0" title="0">
                        // RETURN语句在函数中处理
                        return nil, fmt.Errorf("RETURN statement not allowed in procedure")</span>
                }
        }
        
        // 返回空结果集
        <span class="cov0" title="0">return []map[string]interface{}{}, nil</span>
}

// executeBlockWithReturn 执行语句块(支持RETURN)
func (pe *ProcedureExecutor) executeBlockWithReturn(block *parser.BlockStmt) (interface{}, error) <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // 执行声明
        <span class="cov0" title="0">for _, decl := range block.Declarations </span><span class="cov0" title="0">{
                if err := pe.executeDeclaration(decl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        // 执行语句
        <span class="cov0" title="0">for _, stmt := range block.Statements </span><span class="cov0" title="0">{
                switch s := stmt.(type) </span>{
                case *parser.IfStmt:<span class="cov0" title="0">
                        if err := pe.executeIf(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.WhileStmt:<span class="cov0" title="0">
                        if err := pe.executeWhile(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.SetStmt:<span class="cov0" title="0">
                        if err := pe.executeSet(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.CaseStmt:<span class="cov0" title="0">
                        if err := pe.executeCase(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
        case *parser.ReturnStmt:<span class="cov0" title="0">
                // RETURN语句,返回值
                result, err := pe.evaluateExpression(&amp;s.Expression)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }
        }
        
        <span class="cov0" title="0">return nil, nil</span>
}

// executeDeclaration 执行变量声明
func (pe *ProcedureExecutor) executeDeclaration(decl parser.Declaration) error <span class="cov0" title="0">{
        scope := pe.currentScope()
        
        // 设置初始值
        value := interface{}(nil)
        if decl.Initial != nil </span><span class="cov0" title="0">{
                // 初始值直接使用，无需表达式求值
                value = decl.Initial
        }</span>
        
        <span class="cov0" title="0">scope.SetVariable(decl.Name, value)
        return nil</span>
}

// executeIf 执行IF语句
func (pe *ProcedureExecutor) executeIf(ifStmt *parser.IfStmt) error <span class="cov0" title="0">{
        // 计算条件
        cond, err := pe.evaluateExpression(&amp;ifStmt.Condition)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 判断条件
        <span class="cov0" title="0">if isTrue(cond) </span><span class="cov0" title="0">{
                // 执行THEN块
                _, err := pe.executeBlock(ifStmt.Then)
                return err
        }</span>
        
        // 执行ELSE IF块
        <span class="cov0" title="0">for _, elif := range ifStmt.ElseIfs </span><span class="cov0" title="0">{
                cond, err := pe.evaluateExpression(&amp;elif.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if isTrue(cond) </span><span class="cov0" title="0">{
                        _, err := pe.executeBlock(elif.Then)
                        return err
                }</span>
        }
        
        // 执行ELSE块
        <span class="cov0" title="0">if ifStmt.Else != nil </span><span class="cov0" title="0">{
                _, err := pe.executeBlock(ifStmt.Else)
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// executeWhile 执行WHILE语句
func (pe *ProcedureExecutor) executeWhile(whileStmt *parser.WhileStmt) error <span class="cov0" title="0">{
        // 循环执行
        for </span><span class="cov0" title="0">{
                // 计算条件
                cond, err := pe.evaluateExpression(&amp;whileStmt.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // 如果条件为假,退出循环
                <span class="cov0" title="0">if !isTrue(cond) </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // 执行循环体
                <span class="cov0" title="0">_, err = pe.executeBlock(whileStmt.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// executeSet 执行SET语句
func (pe *ProcedureExecutor) executeSet(setStmt *parser.SetStmt) error <span class="cov0" title="0">{
        // 计算值
        value, err := pe.evaluateExpression(&amp;setStmt.Value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 设置变量
        <span class="cov0" title="0">scope := pe.currentScope()
        scope.SetVariable(setStmt.Variable, value)
        
        return nil</span>
}

// executeCase 执行CASE语句
func (pe *ProcedureExecutor) executeCase(caseStmt *parser.CaseStmt) error <span class="cov0" title="0">{
        // 如果有表达式,先计算
        var caseExpr interface{}
        if caseStmt.Expression.Type != "" </span><span class="cov0" title="0">{
                val, err := pe.evaluateExpression(&amp;caseStmt.Expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">caseExpr = val</span>
        }
        
        // 检查每个WHEN
        <span class="cov0" title="0">for _, when := range caseStmt.Cases </span><span class="cov0" title="0">{
                cond, err := pe.evaluateExpression(&amp;when.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // 如果没有表达式,直接判断WHEN条件
                <span class="cov0" title="0">if caseStmt.Expression.Type == "" </span><span class="cov0" title="0">{
                        if isTrue(cond) </span><span class="cov0" title="0">{
                                _, err := pe.executeBlock(when.Then)
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 有表达式,比较值
                        if compareValuesEqual(cond, caseExpr) </span><span class="cov0" title="0">{
                                _, err := pe.executeBlock(when.Then)
                                return err
                        }</span>
                }
        }
        
        // 执行ELSE块
        <span class="cov0" title="0">if caseStmt.Else != nil </span><span class="cov0" title="0">{
                _, err := pe.executeBlock(caseStmt.Else)
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// evaluateExpression 计算表达式
func (pe *ProcedureExecutor) evaluateExpression(expr *parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        // 简化实现:只支持简单的常量和变量
        if expr.Value != nil </span><span class="cov0" title="0">{
                return expr.Value, nil
        }</span>
        
        <span class="cov0" title="0">if expr.Column != "" </span><span class="cov0" title="0">{
                scope := pe.currentScope()
                val, exists := scope.GetVariable(expr.Column)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("variable not found: %s", expr.Column)
                }</span>
                <span class="cov0" title="0">return val, nil</span>
        }
        
        <span class="cov0" title="0">if expr.Function != "" </span><span class="cov0" title="0">{
                // 简化实现:不支持复杂函数
                return nil, fmt.Errorf("function evaluation not yet implemented: %s", expr.Function)
        }</span>
        
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported expression")</span>
}

// 作用域管理

// pushScope 推入新作用域
func (pe *ProcedureExecutor) pushScope(scope *Scope) <span class="cov0" title="0">{
        pe.scopeStack = append(pe.scopeStack, scope)
}</span>

// popScope 弹出作用域
func (pe *ProcedureExecutor) popScope() <span class="cov0" title="0">{
        if len(pe.scopeStack) &gt; 0 </span><span class="cov0" title="0">{
                pe.scopeStack = pe.scopeStack[:len(pe.scopeStack)-1]
        }</span>
}

// currentScope 获取当前作用域
func (pe *ProcedureExecutor) currentScope() *Scope <span class="cov0" title="0">{
        if len(pe.scopeStack) == 0 </span><span class="cov0" title="0">{
                return NewScope(nil)
        }</span>
        <span class="cov0" title="0">return pe.scopeStack[len(pe.scopeStack)-1]</span>
}

// 辅助函数

// isTrue 判断值是否为真
func isTrue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return v != 0</span>
        case float32, float64:<span class="cov0" title="0">
                return v != 0.0</span>
        case string:<span class="cov0" title="0">
                return v != "" &amp;&amp; v != "0"</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// compareValuesEqual 比较两个值是否相等


</pre>
		
		<pre class="file" id="file65" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// PredicatePushDownRule 谓词下推规则
// 将 Selection 节点尽可能下推到 DataSource
type PredicatePushDownRule struct{}

// Name 返回规则名称
func (r *PredicatePushDownRule) Name() string <span class="cov8" title="1">{
        return "PredicatePushDown"
}</span>

// Match 检查规则是否匹配
func (r *PredicatePushDownRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        _, ok := plan.(*LogicalSelection)
        return ok
}</span>

// Apply 应用规则
func (r *PredicatePushDownRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        selection, ok := plan.(*LogicalSelection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">if len(selection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">child := selection.children[0]

        // 如果子节点是 DataSource，将谓词标记到DataSource上（下推成功）
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov8" title="1">{
                // 将Selection的条件标记到DataSource，表示可以在扫描时过滤
                dataSource.PushDownPredicates(selection.Conditions())
                // 返回child，消除Selection节点（条件已下推到DataSource）
                return child, nil
        }</span>

        // 如果子节点是 Selection，合并条件
        <span class="cov0" title="0">if childSelection, ok := child.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                // 合并条件列表
                mergedConditions := append(selection.Conditions(), childSelection.Conditions()...)
                return NewLogicalSelection(mergedConditions, childSelection.Children()[0]), nil
        }</span>

        // 尝试下推到其他节点
        // 简化实现：不下推
        <span class="cov0" title="0">return plan, nil</span>
}

// ColumnPruningRule 列裁剪规则
// 移除不需要的列
type ColumnPruningRule struct{}

// Name 返回规则名称
func (r *ColumnPruningRule) Name() string <span class="cov8" title="1">{
        return "ColumnPruning"
}</span>

// Match 检查规则是否匹配
func (r *ColumnPruningRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        _, ok := plan.(*LogicalProjection)
        return ok
}</span>

// Apply 应用规则
func (r *ColumnPruningRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        projection, ok := plan.(*LogicalProjection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">if len(projection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">child := projection.children[0]

        // 收集子节点需要的列
        requiredCols := make(map[string]bool)
        for _, expr := range projection.Exprs </span><span class="cov8" title="1">{
                collectRequiredColumns(expr, requiredCols)
        }</span>
        
        // 打印需要的列
        <span class="cov8" title="1">keys := make([]string, 0, len(requiredCols))
        for k := range requiredCols </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 需要的列: %v\n", keys)

        // 如果子节点是 DataSource，调整输出列
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov8" title="1">{
                // 筛选出需要的列
                newColumns := []ColumnInfo{}
                for _, col := range dataSource.Columns </span><span class="cov8" title="1">{
                        if requiredCols[col.Name] </span><span class="cov8" title="1">{
                                newColumns = append(newColumns, col)
                        }</span>
                }
                // 如果有变化，创建新的 DataSource
                <span class="cov8" title="1">if len(newColumns) &lt; len(dataSource.Columns) </span><span class="cov8" title="1">{
                        fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 原列数: %d, 裁剪后: %d\n", len(dataSource.Columns), len(newColumns))
                        // 保存下推的谓词和Limit信息
                        predicates := dataSource.GetPushedDownPredicates()
                        limitInfo := dataSource.GetPushedDownLimit()
                        
                        newDataSource := NewLogicalDataSource(dataSource.TableName, dataSource.TableInfo)
                        newDataSource.Columns = newColumns
                        newDataSource.PushDownPredicates(predicates)
                        if limitInfo != nil </span><span class="cov8" title="1">{
                                newDataSource.PushDownLimit(limitInfo.Limit, limitInfo.Offset)
                        }</span>
                        <span class="cov8" title="1">projection.children[0] = newDataSource
                        fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 列裁剪完成\n")</span>
                }
        }

        <span class="cov8" title="1">return plan, nil</span>
}

// collectRequiredColumns 收集表达式需要的列
func collectRequiredColumns(expr *parser.Expression, cols map[string]bool) <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if expr.Type == parser.ExprTypeColumn &amp;&amp; expr.Column != "" </span><span class="cov8" title="1">{
                cols[expr.Column] = true
        }</span>

        // 递归处理子表达式
        <span class="cov8" title="1">collectRequiredColumns(expr.Left, cols)
        collectRequiredColumns(expr.Right, cols)</span>
}

// ProjectionEliminationRule 投影消除规则
// 移除不必要的投影节点
type ProjectionEliminationRule struct{}

// Name 返回规则名称
func (r *ProjectionEliminationRule) Name() string <span class="cov8" title="1">{
        return "ProjectionElimination"
}</span>

// Match 检查规则是否匹配
func (r *ProjectionEliminationRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        _, ok := plan.(*LogicalProjection)
        return ok
}</span>

// Apply 应用规则
func (r *ProjectionEliminationRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        projection, ok := plan.(*LogicalProjection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">if len(projection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">child := projection.children[0]

        // 如果投影只是简单地传递所有列，可以消除
        childSchema := child.Schema()
        if len(projection.Exprs) == len(childSchema) </span><span class="cov8" title="1">{
                allPassThrough := true
                for i, expr := range projection.Exprs </span><span class="cov8" title="1">{
                        if expr.Type != parser.ExprTypeColumn || expr.Column != childSchema[i].Name </span><span class="cov0" title="0">{
                                allPassThrough = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if allPassThrough </span><span class="cov8" title="1">{
                        return child, nil
                }</span>
        }

        <span class="cov8" title="1">return plan, nil</span>
}

// LimitPushDownRule Limit 下推规则
// 将 Limit 尽可能下推
type LimitPushDownRule struct{}

// Name 返回规则名称
func (r *LimitPushDownRule) Name() string <span class="cov8" title="1">{
        return "LimitPushDown"
}</span>

// Match 检查规则是否匹配
func (r *LimitPushDownRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        _, ok := plan.(*LogicalLimit)
        return ok
}</span>

// Apply 应用规则
func (r *LimitPushDownRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        limit, ok := plan.(*LogicalLimit)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">if len(limit.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov8" title="1">child := limit.children[0]

        // 如果子节点是 DataSource，下推到DataSource
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov8" title="1">{
                // 标记Limit到DataSource
                dataSource.PushDownLimit(limit.GetLimit(), limit.GetOffset())
                // 返回child，消除Limit节点（已下推）
                return child, nil
        }</span>

        // 如果子节点是 Selection，可以下推到Selection的子节点
        <span class="cov0" title="0">if selection, ok := child.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                // 创建新的 Selection，其子节点是新的 Limit
                newLimit := NewLogicalLimit(limit.GetLimit(), limit.GetOffset(), selection.Children()[0])
                return NewLogicalSelection(selection.Conditions(), newLimit), nil
        }</span>

        <span class="cov0" title="0">return plan, nil</span>
}

// ConstantFoldingRule 常量折叠规则
// 计算常量表达式
type ConstantFoldingRule struct{}

// Name 返回规则名称
func (r *ConstantFoldingRule) Name() string <span class="cov8" title="1">{
        return "ConstantFolding"
}</span>

// Match 检查规则是否匹配
func (r *ConstantFoldingRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        // 简化实现：总是匹配
        return true
}</span>

// Apply 应用规则
func (r *ConstantFoldingRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        evaluator := NewExpressionEvaluatorWithoutAPI()
        return r.foldConstants(plan, evaluator)
}</span>

// foldConstants 递归折叠常量表达式
func (r *ConstantFoldingRule) foldConstants(plan LogicalPlan, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov8" title="1">{
        // 先处理子节点
        children := plan.Children()
        for i, child := range children </span><span class="cov8" title="1">{
                newChild, err := r.foldConstants(child, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if newChild != child </span><span class="cov0" title="0">{
                        plan.SetChildren(children...)
                        children[i] = newChild
                }</span>
        }

        // 根据不同的算子类型进行常量折叠
        <span class="cov8" title="1">switch p := plan.(type) </span>{
        case *LogicalSelection:<span class="cov8" title="1">
                return r.foldSelectionConstants(p, evaluator)</span>
        case *LogicalProjection:<span class="cov8" title="1">
                return r.foldProjectionConstants(p, evaluator)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                return r.foldJoinConstants(p, evaluator)</span>
        }

        <span class="cov8" title="1">return plan, nil</span>
}

// foldSelectionConstants 折叠 Selection 中的常量
func (r *ConstantFoldingRule) foldSelectionConstants(selection *LogicalSelection, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov8" title="1">{
        newConditions := []*parser.Expression{}
        changed := false

        for _, cond := range selection.Conditions() </span><span class="cov8" title="1">{
                folded, isConst, err := r.tryFoldExpression(cond, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if isConst </span><span class="cov0" title="0">{
                        // 常量表达式
                        if folded == nil </span><span class="cov0" title="0">{
                                // 条件永远为假，可以丢弃整个 Selection
                                return selection, nil
                        }</span>
                        // 检查是否为 false 布尔值
                        <span class="cov0" title="0">if folded.Value != nil </span><span class="cov0" title="0">{
                                if boolVal, ok := folded.Value.(bool); ok &amp;&amp; !boolVal </span><span class="cov0" title="0">{
                                        // 条件永远为假，可以丢弃整个 Selection
                                        return selection, nil
                                }</span>
                        }
                        // 条件永远为真，可以移除这个条件
                        <span class="cov0" title="0">changed = true</span>
                } else<span class="cov8" title="1"> {
                        newConditions = append(newConditions, folded)
                }</span>
        }

        <span class="cov8" title="1">if changed </span><span class="cov0" title="0">{
                if len(newConditions) == 0 </span><span class="cov0" title="0">{
                        // 所有条件都被移除，返回子节点
                        if len(selection.children) &gt; 0 </span><span class="cov0" title="0">{
                                return selection.children[0], nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0]), nil
                }</span>
        }

        <span class="cov8" title="1">return selection, nil</span>
}

// foldProjectionConstants 折叠 Projection 中的常量
func (r *ConstantFoldingRule) foldProjectionConstants(projection *LogicalProjection, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov8" title="1">{
        newExprs := []*parser.Expression{}
        changed := false

        for _, expr := range projection.Exprs </span><span class="cov8" title="1">{
                folded, isConst, err := r.tryFoldExpression(expr, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if isConst </span><span class="cov0" title="0">{
                        newExprs = append(newExprs, folded)
                        changed = true
                }</span> else<span class="cov8" title="1"> {
                        newExprs = append(newExprs, expr)
                }</span>
        }

        <span class="cov8" title="1">if changed </span><span class="cov0" title="0">{
                projection.Exprs = newExprs
        }</span>

        <span class="cov8" title="1">return projection, nil</span>
}

// foldJoinConstants 折叠 Join 中的常量
func (r *ConstantFoldingRule) foldJoinConstants(join *LogicalJoin, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov0" title="0">{
        // 简化：不处理
        return join, nil
}</span>

// tryFoldExpression 尝试折叠表达式
// 返回: (新表达式, 是否是常量, 错误)
func (r *ConstantFoldingRule) tryFoldExpression(expr *parser.Expression, evaluator *ExpressionEvaluator) (*parser.Expression, bool, error) <span class="cov8" title="1">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>

        // 如果是字面量，已经是常量
        <span class="cov8" title="1">if expr.Type == parser.ExprTypeValue </span><span class="cov8" title="1">{
                return expr, true, nil
        }</span>

        // 如果是列引用，不能折叠
        <span class="cov8" title="1">if expr.Type == parser.ExprTypeColumn </span><span class="cov8" title="1">{
                return expr, false, nil
        }</span>

        // 如果是运算符，尝试计算
        <span class="cov8" title="1">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator != "" </span><span class="cov8" title="1">{
                // 一元运算符
                if expr.Right == nil &amp;&amp; expr.Left != nil </span><span class="cov0" title="0">{
                        leftFolded, leftIsConst, err := r.tryFoldExpression(expr.Left, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                        <span class="cov0" title="0">if leftIsConst </span><span class="cov0" title="0">{
                                // 尝试计算
                                result, err := evaluator.Evaluate(&amp;parser.Expression{
                                        Type:     parser.ExprTypeOperator,
                                        Operator: expr.Operator,
                                        Left:     &amp;parser.Expression{Type: parser.ExprTypeValue, Value: leftFolded},
                                }, parser.Row{})
                                if err == nil </span><span class="cov0" title="0">{
                                        return &amp;parser.Expression{
                                                Type:  parser.ExprTypeValue,
                                                Value: result,
                                        }, true, nil
                                }</span>
                        }
                        <span class="cov0" title="0">expr.Left = leftFolded
                        return expr, false, nil</span>
                }

                // 二元运算符
                <span class="cov8" title="1">if expr.Left != nil &amp;&amp; expr.Right != nil </span><span class="cov8" title="1">{
                        leftFolded, leftIsConst, err := r.tryFoldExpression(expr.Left, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                        <span class="cov8" title="1">rightFolded, rightIsConst, err := r.tryFoldExpression(expr.Right, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>

                        <span class="cov8" title="1">if leftIsConst &amp;&amp; rightIsConst </span><span class="cov0" title="0">{
                                // 两个操作数都是常量，可以计算
                                result, err := evaluator.Evaluate(&amp;parser.Expression{
                                        Type:     parser.ExprTypeOperator,
                                        Operator: expr.Operator,
                                        Left:     &amp;parser.Expression{Type: parser.ExprTypeValue, Value: leftFolded},
                                        Right:    &amp;parser.Expression{Type: parser.ExprTypeValue, Value: rightFolded},
                                }, parser.Row{})
                                if err == nil </span><span class="cov0" title="0">{
                                        return &amp;parser.Expression{
                                                Type:  parser.ExprTypeValue,
                                                Value: result,
                                        }, true, nil
                                }</span>
                        }

                        <span class="cov8" title="1">expr.Left = leftFolded
                        expr.Right = rightFolded
                        if leftFolded != expr.Left || rightFolded != expr.Right </span><span class="cov0" title="0">{
                                return expr, false, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return expr, false, nil</span>
}

// DefaultRuleSet 返回默认规则集
func DefaultRuleSet() RuleSet <span class="cov8" title="1">{
        rules := RuleSet{
                &amp;PredicatePushDownRule{},
                &amp;ColumnPruningRule{},
                &amp;ProjectionEliminationRule{},
                &amp;LimitPushDownRule{},
                &amp;ConstantFoldingRule{},
                &amp;JoinReorderRule{},
                &amp;JoinEliminationRule{},
                &amp;SemiJoinRewriteRule{},
        }
        fmt.Println("  [DEBUG] DefaultRuleSet: 创建规则集, 数量:", len(rules))
        for i, r := range rules </span><span class="cov8" title="1">{
                fmt.Printf("  [DEBUG]   规则%d: %s\n", i, r.Name())
        }</span>
        <span class="cov8" title="1">return rules</span>
}

// RuleExecutor 规则执行器
type RuleExecutor struct {
        rules RuleSet
}

// NewRuleExecutor 创建规则执行器
func NewRuleExecutor(rules RuleSet) *RuleExecutor <span class="cov0" title="0">{
        return &amp;RuleExecutor{
                rules: rules,
        }
}</span>

// Execute 执行所有规则
func (re *RuleExecutor) Execute(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] RuleExecutor: 开始执行规则, 规则数量:", len(re.rules))
        current := plan
        maxIterations := 10 // 防止无限循环
        iterations := 0

        for iterations &lt; maxIterations </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] RuleExecutor: 迭代", iterations+1)
                changed := false

                for _, rule := range re.rules </span><span class="cov0" title="0">{
                        if rule.Match(current) </span><span class="cov0" title="0">{
                                fmt.Println("  [DEBUG] RuleExecutor: 规则", rule.Name(), "匹配")
                                newPlan, err := rule.Apply(ctx, current, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("rule %s failed: %w", rule.Name(), err)
                                }</span>
                                <span class="cov0" title="0">if newPlan != current </span><span class="cov0" title="0">{
                                        current = newPlan
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleExecutor: 规则", rule.Name(), "已应用")
                                }</span>
                        }

                        // 递归应用到子节点
                        <span class="cov0" title="0">children := current.Children()
                        fmt.Println("  [DEBUG] RuleExecutor: 处理子节点, 子节点数:", len(children))
                        for i, child := range children </span><span class="cov0" title="0">{
                                fmt.Println("  [DEBUG] RuleExecutor: 递归处理子节点", i, "类型:", child.Explain())
                                newChild, err := re.Execute(ctx, child, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if newChild != child </span><span class="cov0" title="0">{
                                        children = current.Children()
                                        children[i] = newChild
                                        current.SetChildren(children...)
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleExecutor: 子节点", i, "已更新")
                                }</span>
                        }
                }

                <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                        fmt.Println("  [DEBUG] RuleExecutor: 没有变化，退出")
                        break</span>
                }

                <span class="cov0" title="0">iterations++</span>
        }

        <span class="cov0" title="0">fmt.Println("  [DEBUG] RuleExecutor: 执行完成, 总迭代次数:", iterations)
        return current, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package optimizer

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// SemiJoinRewriteRule 半连接重写规则
// 将EXISTS和IN子查询重写为更高效的连接形式
type SemiJoinRewriteRule struct {
        cardinalityEstimator CardinalityEstimator
}

// Name 返回规则名称
func (r *SemiJoinRewriteRule) Name() string <span class="cov8" title="1">{
        return "SemiJoinRewrite"
}</span>

// Match 检查规则是否匹配
func (r *SemiJoinRewriteRule) Match(plan LogicalPlan) bool <span class="cov8" title="1">{
        // 检查是否包含EXISTS或IN子查询
        return containsSubquery(plan, "EXISTS") || containsSubquery(plan, "IN")
}</span>

// containsSubquery 检查是否包含指定类型的子查询
func containsSubquery(plan LogicalPlan, queryType string) bool <span class="cov8" title="1">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov8" title="1">{
                for _, cond := range selection.Conditions() </span><span class="cov8" title="1">{
                        if isSubquery(cond, queryType) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, child := range plan.Children() </span><span class="cov8" title="1">{
                if containsSubquery(child, queryType) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isSubquery 检查表达式是否为子查询
func isSubquery(expr *parser.Expression, queryType string) bool <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // 检查是否为子查询节点
        // 简化实现：检查函数名
        <span class="cov8" title="1">if expr.Type == parser.ExprTypeFunction </span><span class="cov0" title="0">{
                if expr.Function == queryType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // 递归检查子表达式
        <span class="cov8" title="1">if isSubquery(expr.Left, queryType) || isSubquery(expr.Right, queryType) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// Apply 应用规则：重写半连接
func (r *SemiJoinRewriteRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 1. 查找EXISTS子查询并重写为JOIN
        plan = r.rewriteExistsToJoin(plan)

        // 2. 查找IN子查询并重写为JOIN
        plan = r.rewriteInToJoin(plan)

        return plan, nil
}</span>

// rewriteExistsToJoin 将EXISTS子查询重写为JOIN + DISTINCT
func (r *SemiJoinRewriteRule) rewriteExistsToJoin(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                rewritten := false

                // 遍历条件，查找EXISTS子查询
                newConditions := make([]*parser.Expression, 0, len(selection.Conditions()))

                for _, cond := range selection.Conditions() </span><span class="cov0" title="0">{
                        if r.isExistsSubquery(cond) </span><span class="cov0" title="0">{
                                // EXISTS (SELECT ...) -&gt; INNER JOIN
                                // 重写为: EXISTS (SELECT ...) = TRUE
                                // 注意：实际应该提取子查询表名，创建JOIN
                                // 这里简化为保留条件，标记为已重写
                                newConditions = append(newConditions, cond)
                                rewritten = true
                        }</span> else<span class="cov0" title="0"> {
                                newConditions = append(newConditions, cond)
                        }</span>
                }

                <span class="cov0" title="0">if rewritten </span><span class="cov0" title="0">{
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0])
                }</span>

                <span class="cov0" title="0">return selection</span>
        }

        // 递归处理子节点
        <span class="cov0" title="0">children := plan.Children()
        for i, child := range children </span><span class="cov0" title="0">{
                newChild := r.rewriteExistsToJoin(child)
                if newChild != child </span><span class="cov0" title="0">{
                        newChildren := make([]LogicalPlan, len(children))
                        copy(newChildren, children)
                        newChildren[i] = newChild
                        plan.SetChildren(newChildren...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return plan</span>
}

// rewriteInToJoin 将IN子查询重写为JOIN
func (r *SemiJoinRewriteRule) rewriteInToJoin(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                rewritten := false

                // 遍历条件，查找IN子查询
                newConditions := make([]*parser.Expression, 0, len(selection.Conditions()))

                for _, cond := range selection.Conditions() </span><span class="cov0" title="0">{
                        if r.isInSubquery(cond) </span><span class="cov0" title="0">{
                                // column IN (SELECT ...) -&gt; JOIN
                                // 重写为: column IN (SELECT ...) = TRUE
                                // 注意：实际应该提取子查询表名，创建JOIN
                                // 这里简化为保留条件，标记为已重写
                                newConditions = append(newConditions, cond)
                                rewritten = true
                        }</span> else<span class="cov0" title="0"> {
                                newConditions = append(newConditions, cond)
                        }</span>
                }

                <span class="cov0" title="0">if rewritten </span><span class="cov0" title="0">{
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0])
                }</span>

                <span class="cov0" title="0">return selection</span>
        }

        // 递归处理子节点
        <span class="cov0" title="0">children := plan.Children()
        for i, child := range children </span><span class="cov0" title="0">{
                newChild := r.rewriteInToJoin(child)
                if newChild != child </span><span class="cov0" title="0">{
                        newChildren := make([]LogicalPlan, len(children))
                        copy(newChildren, children)
                        newChildren[i] = newChild
                        plan.SetChildren(newChildren...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return plan</span>
}

// isExistsSubquery 检查是否为EXISTS子查询
func (r *SemiJoinRewriteRule) isExistsSubquery(expr *parser.Expression) bool <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if expr.Type == parser.ExprTypeFunction &amp;&amp; expr.Function == "EXISTS" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if r.isExistsSubquery(expr.Left) || r.isExistsSubquery(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isInSubquery 检查是否为IN子查询
func (r *SemiJoinRewriteRule) isInSubquery(expr *parser.Expression) bool <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // IN操作符
        <span class="cov0" title="0">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "IN" </span><span class="cov0" title="0">{
                // 检查右侧是否为子查询
                if expr.Right != nil &amp;&amp; expr.Right.Type == parser.ExprTypeFunction </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if r.isInSubquery(expr.Left) || r.isInSubquery(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// NewSemiJoinRewriteRule 创建半连接重写规则
func NewSemiJoinRewriteRule(estimator CardinalityEstimator) *SemiJoinRewriteRule <span class="cov0" title="0">{
        return &amp;SemiJoinRewriteRule{
                cardinalityEstimator: estimator,
        }
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalPlan 逻辑计划接口
type LogicalPlan interface {
        // Children 获取子节点
        Children() []LogicalPlan

        // SetChildren 设置子节点
        SetChildren(children ...LogicalPlan)

        // Schema 返回输出列
        Schema() []ColumnInfo

        // Explain 返回计划说明
        Explain() string
}

// PhysicalPlan 物理计划接口
type PhysicalPlan interface {
        // Children 获取子节点
        Children() []PhysicalPlan

        // SetChildren 设置子节点
        SetChildren(children ...PhysicalPlan)

        // Schema 返回输出列
        Schema() []ColumnInfo

        // Cost 返回执行成本
        Cost() float64

        // Execute 执行计划
        Execute(ctx context.Context) (*domain.QueryResult, error)

        // Explain 返回计划说明
        Explain() string
}

// ColumnInfo 列信息
type ColumnInfo struct {
        Name     string
        Type     string
        Nullable bool
        // 可以扩展更多字段
}

// JoinType 连接类型
type JoinType int

const (
        InnerJoin JoinType = iota
        LeftOuterJoin
        RightOuterJoin
        FullOuterJoin
)

// String 返回 JoinType 的字符串表示
func (jt JoinType) String() string <span class="cov8" title="1">{
        switch jt </span>{
        case InnerJoin:<span class="cov8" title="1">
                return "INNER JOIN"</span>
        case LeftOuterJoin:<span class="cov8" title="1">
                return "LEFT OUTER JOIN"</span>
        case RightOuterJoin:<span class="cov8" title="1">
                return "RIGHT OUTER JOIN"</span>
        case FullOuterJoin:<span class="cov8" title="1">
                return "FULL OUTER JOIN"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// AggregationType 聚合函数类型
type AggregationType int

const (
        Count AggregationType = iota
        Sum
        Avg
        Max
        Min
)

// String 返回 AggregationType 的字符串表示
func (at AggregationType) String() string <span class="cov8" title="1">{
        switch at </span>{
        case Count:<span class="cov8" title="1">
                return "COUNT"</span>
        case Sum:<span class="cov8" title="1">
                return "SUM"</span>
        case Avg:<span class="cov8" title="1">
                return "AVG"</span>
        case Max:<span class="cov8" title="1">
                return "MAX"</span>
        case Min:<span class="cov8" title="1">
                return "MIN"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// AggregationItem 聚合项
type AggregationItem struct {
        Type     AggregationType
        Expr     *parser.Expression
        Alias    string
        Distinct bool
}

// JoinCondition 连接条件
type JoinCondition struct {
        Left     *parser.Expression
        Right    *parser.Expression
        Operator string
}

// LimitInfo Limit信息
type LimitInfo struct {
        Limit  int64
        Offset int64
}

// OrderByItem 排序项
type OrderByItem struct {
        Column    string
        Direction string // "ASC" or "DESC"
}

// Statistics 统计信息（简化版）
type Statistics struct {
        RowCount   int64
        UniqueKeys int64
        NullCount  int64
}

// OptimizationContext 优化上下文
type OptimizationContext struct {
        DataSource domain.DataSource
        TableInfo  map[string]*domain.TableInfo
        Stats      map[string]*Statistics
        CostModel  CostModel
}

// CostModel 成本模型
type CostModel interface {
        // ScanCost 计算扫描成本
        ScanCost(tableName string, rowCount int64) float64

        // FilterCost 计算过滤成本
        FilterCost(inputRows int64, selectivity float64) float64

        // JoinCost 计算连接成本
        JoinCost(leftRows, rightRows int64, joinType JoinType) float64

        // AggregateCost 计算聚合成本
        AggregateCost(inputRows int64, groupByCols int) float64

        // ProjectCost 计算投影成本
        ProjectCost(inputRows int64, projCols int) float64
}

// DefaultCostModel 默认成本模型
type DefaultCostModel struct {
        CPUFactor    float64
        IoFactor     float64
        MemoryFactor float64
}

// NewDefaultCostModel 创建默认成本模型
func NewDefaultCostModel() *DefaultCostModel <span class="cov8" title="1">{
        return &amp;DefaultCostModel{
                CPUFactor:    0.01,
                IoFactor:     0.1,
                MemoryFactor: 0.001,
        }
}</span>

// ScanCost 计算扫描成本
func (cm *DefaultCostModel) ScanCost(tableName string, rowCount int64) float64 <span class="cov8" title="1">{
        // 成本 = IO 读取 + CPU 处理
        return float64(rowCount)*cm.IoFactor + float64(rowCount)*cm.CPUFactor
}</span>

// FilterCost 计算过滤成本
func (cm *DefaultCostModel) FilterCost(inputRows int64, selectivity float64) float64 <span class="cov8" title="1">{
        // 成本 = 读取所有行 + 比较成本
        outputRows := float64(inputRows) * selectivity
        return float64(inputRows)*cm.CPUFactor + outputRows
}</span>

// JoinCost 计算连接成本
func (cm *DefaultCostModel) JoinCost(leftRows, rightRows int64, joinType JoinType) float64 <span class="cov8" title="1">{
        // 假设使用 hash join
        // 成本 = 构建 hash + 探测 hash
        buildCost := float64(leftRows) * cm.CPUFactor
        probeCost := float64(rightRows) * cm.CPUFactor
        memoryCost := float64(leftRows) * cm.MemoryFactor
        return buildCost + probeCost + memoryCost
}</span>

// AggregateCost 计算聚合成本
func (cm *DefaultCostModel) AggregateCost(inputRows int64, groupByCols int) float64 <span class="cov8" title="1">{
        // 成本 = 分组 + 聚合
        groupCost := float64(inputRows) * cm.CPUFactor * float64(groupByCols)
        aggCost := float64(inputRows) * cm.CPUFactor
        return groupCost + aggCost
}</span>

// ProjectCost 计算投影成本
func (cm *DefaultCostModel) ProjectCost(inputRows int64, projCols int) float64 <span class="cov8" title="1">{
        // 成本 = 计算每个表达式
        return float64(inputRows) * float64(projCols) * cm.CPUFactor
}</span>

// OptimizationRule 优化规则接口
type OptimizationRule interface {
        // Name 规则名称
        Name() string

        // Match 检查规则是否匹配
        Match(plan LogicalPlan) bool

        // Apply 应用规则，返回优化后的计划
        Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error)
}

// RuleSet 规则集合
type RuleSet []OptimizationRule

// Apply 应用所有规则
func (rs RuleSet) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="1">{
        fmt.Println("  [DEBUG] RuleSet.Apply: 开始, 当前计划:", plan.Explain())
        current := plan
        changed := true
        maxIterations := 10 // 防止无限循环
        iterations := 0

        // 迭代应用规则，直到不再变化
        for changed &amp;&amp; iterations &lt; maxIterations </span><span class="cov8" title="1">{
                changed = false
                iterations++
                fmt.Println("  [DEBUG] RuleSet.Apply: 迭代", iterations)

                for _, rule := range rs </span><span class="cov8" title="1">{
                        if rule.Match(current) </span><span class="cov8" title="1">{
                                fmt.Println("  [DEBUG] RuleSet.Apply: 匹配规则", rule.Name())
                                newPlan, err := rule.Apply(ctx, current, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("rule %s failed: %w", rule.Name(), err)
                                }</span>
                                <span class="cov8" title="1">if newPlan != nil &amp;&amp; newPlan != current </span><span class="cov8" title="1">{
                                        current = newPlan
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleSet.Apply: 规则", rule.Name(), "应用成功")
                                }</span>
                        }
                }

                // 递归应用到子节点
                <span class="cov8" title="1">children := current.Children()
                if len(children) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Println("  [DEBUG] RuleSet.Apply: 递归处理子节点, 数量:", len(children))
                        for i, child := range children </span><span class="cov8" title="1">{
                                newChild, err := rs.Apply(ctx, child, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if newChild != child </span><span class="cov8" title="1">{
                                        fmt.Println("  [DEBUG] RuleSet.Apply: 子节点", i, "已更新")
                                        allChildren := current.Children()
                                        allChildren[i] = newChild
                                        current.SetChildren(allChildren...)
                                        changed = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">fmt.Println("  [DEBUG] RuleSet.Apply: 完成, 总迭代次数:", iterations)
        return current, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package optimizer

import (
        "fmt"
        "reflect"
        "strconv"
)

// toFloat64 转换值为float64
// 这个函数用于数值类型转换
func toFloat64(val interface{}) (float64, bool) <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">switch v := val.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return float64(reflect.ValueOf(v).Int()), true</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return float64(reflect.ValueOf(v).Uint()), true</span>
        case float32, float64:<span class="cov0" title="0">
                return float64(reflect.ValueOf(v).Float()), true</span>
        case string:<span class="cov0" title="0">
                // 尝试从字符串解析数字
                f, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov0" title="0">{
                        return f, true
                }</span>
                <span class="cov0" title="0">return 0, false</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// toNumber 转换值为数值
// 这个函数用于比较和排序
func toNumber(val interface{}) (float64, bool) <span class="cov0" title="0">{
        return toFloat64(val)
}</span>

// compareValues 比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func compareValues(a, b interface{}) int <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // 尝试数值比较
        <span class="cov0" title="0">aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                if aNum &lt; bNum </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aNum &gt; bNum </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // 降级到字符串比较
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// compareValuesEqual 比较两个值是否相等
func compareValuesEqual(v1, v2 interface{}) bool <span class="cov0" title="0">{
        if v1 == nil &amp;&amp; v2 == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if v1 == nil || v2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 尝试数值比较
        <span class="cov0" title="0">if n1, ok1 := toFloat64(v1); ok1 </span><span class="cov0" title="0">{
                if n2, ok2 := toFloat64(v2); ok2 </span><span class="cov0" title="0">{
                        return n1 == n2
                }</span>
        }

        // 降级到字符串比较
        <span class="cov0" title="0">return fmt.Sprintf("%v", v1) == fmt.Sprintf("%v", v2)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "sort"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// WindowOperator 窗口函数执行算子
type WindowOperator struct {
        // 子算子
        child PhysicalPlan

        // 窗口函数定义
        windowFuncs []*WindowFunctionDef

        // 执行上下文
        ctx context.Context

        // 表达式求值器
        evaluator *ExpressionEvaluator
}

// WindowFunctionDef 窗口函数定义
type WindowFunctionDef struct {
        Expr      *parser.WindowExpression
        ResultCol string // 结果列名
}

// NewWindowOperator 创建窗口函数算子
func NewWindowOperator(child PhysicalPlan, windowFuncs []*parser.WindowExpression) *WindowOperator <span class="cov0" title="0">{
        funcDefs := make([]*WindowFunctionDef, len(windowFuncs))
        for i, wf := range windowFuncs </span><span class="cov0" title="0">{
                funcDefs[i] = &amp;WindowFunctionDef{
                        Expr:      wf,
                        ResultCol: fmt.Sprintf("window_%d", i),
                }
        }</span>

        <span class="cov0" title="0">return &amp;WindowOperator{
                child:       child,
                windowFuncs: funcDefs,
                evaluator:   NewExpressionEvaluatorWithoutAPI(),
        }</span>
}

// Execute 执行窗口函数
func (op *WindowOperator) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        op.ctx = ctx

        // 1. 从子算子获取数据
        result, err := op.child.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute child: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Rows) == 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // 2. 处理每个窗口函数
        <span class="cov0" title="0">for _, wfDef := range op.windowFuncs </span><span class="cov0" title="0">{
                result.Rows, err = op.executeWindowFunction(result.Rows, wfDef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute window function %s: %w", wfDef.Expr.FuncName, err)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeWindowFunction 执行单个窗口函数
func (op *WindowOperator) executeWindowFunction(rows []domain.Row, wfDef *WindowFunctionDef) ([]domain.Row, error) <span class="cov0" title="0">{
        wf := wfDef.Expr

        // 3. 分区
        partitions := op.partitionRows(rows, wf.Spec.PartitionBy)

        // 4. 在每个分区内执行窗口函数
        result := make([]domain.Row, 0, len(rows))
        for _, partition := range partitions </span><span class="cov0" title="0">{
                // 5. 排序
                sortedPartition := op.sortRows(partition, wf.Spec.OrderBy)

                // 6. 计算窗口函数值
                for i, row := range sortedPartition </span><span class="cov0" title="0">{
                        // 克隆行
                        newRow := make(domain.Row)
                        for k, v := range row </span><span class="cov0" title="0">{
                                newRow[k] = v
                        }</span>

                        // 计算窗口函数
                        <span class="cov0" title="0">value, err := op.computeWindowValue(sortedPartition, i, wf)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">newRow[wfDef.ResultCol] = value
                        result = append(result, newRow)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// partitionRows 根据分区表达式分割行
func (op *WindowOperator) partitionRows(rows []domain.Row, partitionBy []parser.Expression) [][]domain.Row <span class="cov0" title="0">{
        if len(partitionBy) == 0 </span><span class="cov0" title="0">{
                // 无分区,所有行为一个分区
                return [][]domain.Row{rows}
        }</span>

        // 使用map分组
        <span class="cov0" title="0">partitions := make(map[string][]domain.Row)

        for _, row := range rows </span><span class="cov0" title="0">{
                // 计算分区键
                key := op.computePartitionKey(row, partitionBy)

                // 添加到对应分区
                partitions[key] = append(partitions[key], row)
        }</span>

        // 转换为slice
        <span class="cov0" title="0">result := make([][]domain.Row, 0, len(partitions))
        for _, partition := range partitions </span><span class="cov0" title="0">{
                result = append(result, partition)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// computePartitionKey 计算分区键
func (op *WindowOperator) computePartitionKey(row domain.Row, partitionBy []parser.Expression) string <span class="cov0" title="0">{
        keyParts := make([]interface{}, len(partitionBy))

        for i, expr := range partitionBy </span><span class="cov0" title="0">{
                value, err := op.evaluator.Evaluate(&amp;expr, parser.Row(row))
                if err != nil </span><span class="cov0" title="0">{
                        keyParts[i] = fmt.Sprintf("ERROR:%v", err)
                }</span> else<span class="cov0" title="0"> {
                        keyParts[i] = value
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", keyParts)</span>
}

// sortRows 根据排序表达式排序行
func (op *WindowOperator) sortRows(rows []domain.Row, orderBy []parser.OrderItem) []domain.Row <span class="cov0" title="0">{
        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                return rows
        }</span>

        // 克隆行,避免修改原始数据
        <span class="cov0" title="0">sorted := make([]domain.Row, len(rows))
        copy(sorted, rows)

        // 排序
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov0" title="0">{
                return op.compareRows(sorted[i], sorted[j], orderBy)
        }</span>)

        <span class="cov0" title="0">return sorted</span>
}

// compareRows 比较两行
func (op *WindowOperator) compareRows(row1, row2 domain.Row, orderBy []parser.OrderItem) bool <span class="cov0" title="0">{
        for _, orderItem := range orderBy </span><span class="cov0" title="0">{
                val1, err1 := op.evaluator.Evaluate(&amp;orderItem.Expr, parser.Row(row1))
                val2, err2 := op.evaluator.Evaluate(&amp;orderItem.Expr, parser.Row(row2))

                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cmp := compareValues(val1, val2)

                if cmp != 0 </span><span class="cov0" title="0">{
                        if orderItem.Direction == parser.SortDesc </span><span class="cov0" title="0">{
                                return cmp &gt; 0
                        }</span>
                        <span class="cov0" title="0">return cmp &lt; 0</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// computeWindowValue 计算窗口函数值
func (op *WindowOperator) computeWindowValue(rows []domain.Row, rowIndex int, wf *parser.WindowExpression) (interface{}, error) <span class="cov0" title="0">{
        switch wf.FuncName </span>{
        case "ROW_NUMBER":<span class="cov0" title="0">
                return op.computeRowNumber(rowIndex), nil</span>

        case "RANK":<span class="cov0" title="0">
                return op.computeRank(rows, rowIndex), nil</span>

        case "DENSE_RANK":<span class="cov0" title="0">
                return op.computeDenseRank(rows, rowIndex), nil</span>

        case "LAG":<span class="cov0" title="0">
                return op.computeLag(rows, rowIndex, wf.Args)</span>

        case "LEAD":<span class="cov0" title="0">
                return op.computeLead(rows, rowIndex, wf.Args)</span>

        case "COUNT", "SUM", "AVG", "MIN", "MAX":<span class="cov0" title="0">
                return op.computeAggregateWindow(rows, rowIndex, wf)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported window function: %s", wf.FuncName)</span>
        }
}

// ROW_NUMBER实现
func (op *WindowOperator) computeRowNumber(rowIndex int) int64 <span class="cov0" title="0">{
        return int64(rowIndex + 1)
}</span>

// RANK实现
func (op *WindowOperator) computeRank(rows []domain.Row, rowIndex int) int64 <span class="cov0" title="0">{
        if rowIndex == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">currentRow := rows[rowIndex]
        prevRow := rows[rowIndex-1]

        // 如果当前行与前一行相同,则排名相同
        if op.isEqual(currentRow, prevRow) </span><span class="cov0" title="0">{
                return op.computeRank(rows, rowIndex-1)
        }</span>

        // 否则排名为当前行号
        <span class="cov0" title="0">return int64(rowIndex + 1)</span>
}

// DENSE_RANK实现
func (op *WindowOperator) computeDenseRank(rows []domain.Row, rowIndex int) int64 <span class="cov0" title="0">{
        if rowIndex == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">currentRow := rows[rowIndex]
        prevRow := rows[rowIndex-1]

        // 如果当前行与前一行相同,则密集排名相同
        if op.isEqual(currentRow, prevRow) </span><span class="cov0" title="0">{
                return op.computeDenseRank(rows, rowIndex-1)
        }</span>

        // 否则寻找不同的行数
        <span class="cov0" title="0">rank := int64(1)
        for i := 1; i &lt;= rowIndex; i++ </span><span class="cov0" title="0">{
                if !op.isEqual(rows[i], rows[i-1]) </span><span class="cov0" title="0">{
                        rank++
                }</span>
        }

        <span class="cov0" title="0">return rank</span>
}

// LAG实现
func (op *WindowOperator) computeLag(rows []domain.Row, rowIndex int, args []parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LAG() requires 1 argument")
        }</span>

        // 获取偏移量(默认为1)
        <span class="cov0" title="0">offset := 1
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;args[0], nil)
                if err == nil </span><span class="cov0" title="0">{
                        if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                offset = int(offsetInt)
                        }</span>
                }
        }

        // 计算目标行索引
        <span class="cov0" title="0">targetIndex := rowIndex - offset

        if targetIndex &lt; 0 </span><span class="cov0" title="0">{
                // 超出范围,返回NULL
                return nil, nil
        }</span>

        // 返回目标行的值
        <span class="cov0" title="0">return op.getRowValue(rows[targetIndex], args[0])</span>
}

// LEAD实现
func (op *WindowOperator) computeLead(rows []domain.Row, rowIndex int, args []parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LEAD() requires 1 argument")
        }</span>

        // 获取偏移量(默认为1)
        <span class="cov0" title="0">offset := 1
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;args[0], nil)
                if err == nil </span><span class="cov0" title="0">{
                        if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                offset = int(offsetInt)
                        }</span>
                }
        }

        // 计算目标行索引
        <span class="cov0" title="0">targetIndex := rowIndex + offset

        if targetIndex &gt;= len(rows) </span><span class="cov0" title="0">{
                // 超出范围,返回NULL
                return nil, nil
        }</span>

        // 返回目标行的值
        <span class="cov0" title="0">return op.getRowValue(rows[targetIndex], args[0])</span>
}

// 聚合窗口函数实现
func (op *WindowOperator) computeAggregateWindow(rows []domain.Row, rowIndex int, wf *parser.WindowExpression) (interface{}, error) <span class="cov0" title="0">{
        // 确定窗口范围
        start, end := op.getWindowBounds(rows, rowIndex, wf.Spec.Frame)

        // 计算聚合值
        switch wf.FuncName </span>{
        case "COUNT":<span class="cov0" title="0">
                return op.computeCount(rows, start, end), nil</span>
        case "SUM":<span class="cov0" title="0">
                return op.computeSum(rows, start, end, wf.Args[0])</span>
        case "AVG":<span class="cov0" title="0">
                return op.computeAvg(rows, start, end, wf.Args[0])</span>
        case "MIN":<span class="cov0" title="0">
                return op.computeMin(rows, start, end, wf.Args[0])</span>
        case "MAX":<span class="cov0" title="0">
                return op.computeMax(rows, start, end, wf.Args[0])</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported aggregate window function: %s", wf.FuncName)</span>
        }
}

// getWindowBounds 获取窗口边界
func (op *WindowOperator) getWindowBounds(rows []domain.Row, rowIndex int, frame *parser.WindowFrame) (int, int) <span class="cov0" title="0">{
        if frame == nil </span><span class="cov0" title="0">{
                // 无帧定义,默认从第一行到当前行
                return 0, rowIndex + 1
        }</span>

        <span class="cov0" title="0">start := rowIndex
        end := rowIndex + 1

        // 处理起始边界
        switch frame.Start.Type </span>{
        case parser.BoundUnboundedPreceding:<span class="cov0" title="0">
                start = 0</span>
        case parser.BoundPreceding:<span class="cov0" title="0">
                if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.Start.Value); ok </span><span class="cov0" title="0">{
                        start = rowIndex - offsetVal
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        case parser.BoundCurrentRow:<span class="cov0" title="0">
                start = rowIndex</span>
        case parser.BoundFollowing:<span class="cov0" title="0">
                if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.Start.Value); ok </span><span class="cov0" title="0">{
                        start = rowIndex + offsetVal
                        if start &gt;= len(rows) </span><span class="cov0" title="0">{
                                start = len(rows) - 1
                        }</span>
                }
        }

        // 处理结束边界
        <span class="cov0" title="0">if frame.End != nil </span><span class="cov0" title="0">{
                switch frame.End.Type </span>{
                case parser.BoundCurrentRow:<span class="cov0" title="0">
                        end = rowIndex + 1</span>
                case parser.BoundFollowing:<span class="cov0" title="0">
                        if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.End.Value); ok </span><span class="cov0" title="0">{
                                end = rowIndex + offsetVal + 1
                                if end &gt; len(rows) </span><span class="cov0" title="0">{
                                        end = len(rows)
                                }</span>
                        }
                case parser.BoundUnboundedFollowing:<span class="cov0" title="0">
                        end = len(rows)</span>
                }
        }

        <span class="cov0" title="0">return start, end</span>
}

// getFrameOffset 获取帧偏移
func (op *WindowOperator) getFrameOffset(row domain.Row, expr parser.Expression) (int, bool) <span class="cov0" title="0">{
        val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(row))
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                return int(offsetInt), true
        }</span>

        <span class="cov0" title="0">return 0, false</span>
}

// 辅助函数

// isEqual 比较两行是否相等(根据ORDER BY列)
func (op *WindowOperator) isEqual(row1, row2 domain.Row) bool <span class="cov0" title="0">{
        // 简化实现:比较所有列
        // 实际应该只比较ORDER BY的列
        for k, v1 := range row1 </span><span class="cov0" title="0">{
                v2, ok := row2[k]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !compareValuesEqual(v1, v2) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return len(row1) == len(row2)</span>
}

// getRowValue 获取行的指定列值
func (op *WindowOperator) getRowValue(row domain.Row, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        return op.evaluator.Evaluate(&amp;expr, parser.Row(row))
}</span>

// 聚合函数

// computeCount 计数
func (op *WindowOperator) computeCount(rows []domain.Row, start, end int) int64 <span class="cov0" title="0">{
        count := int64(0)
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                if rows[i] != nil </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// computeSum 求和
func (op *WindowOperator) computeSum(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        var sum float64
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fval, ok := toFloat64(val)
                if ok </span><span class="cov0" title="0">{
                        sum += fval
                }</span>
        }
        <span class="cov0" title="0">return sum, nil</span>
}

// computeAvg 平均值
func (op *WindowOperator) computeAvg(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        sum, count := 0.0, 0

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fval, ok := toFloat64(val)
                if ok </span><span class="cov0" title="0">{
                        sum += fval
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return sum / float64(count), nil</span>
}

// computeMin 最小值
func (op *WindowOperator) computeMin(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        minVal := interface{}(nil)

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if minVal == nil || compareValues(val, minVal) &lt; 0 </span><span class="cov0" title="0">{
                        minVal = val
                }</span>
        }

        <span class="cov0" title="0">return minVal, nil</span>
}

// computeMax 最大值
func (op *WindowOperator) computeMax(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        maxVal := interface{}(nil)

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if maxVal == nil || compareValues(val, maxVal) &gt; 0 </span><span class="cov0" title="0">{
                        maxVal = val
                }</span>
        }

        <span class="cov0" title="0">return maxVal, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package parser

import (
        "fmt"
        "strings"

        "github.com/pingcap/tidb/pkg/parser"
        "github.com/pingcap/tidb/pkg/parser/ast"
        _ "github.com/pingcap/tidb/pkg/parser/test_driver"
)

// SQLAdapter SQL 解析适配器
type SQLAdapter struct {
        parser *parser.Parser
}

// NewSQLAdapter 创建 SQL 适配器
func NewSQLAdapter() *SQLAdapter <span class="cov8" title="1">{
        return &amp;SQLAdapter{
                parser: parser.New(),
        }
}</span>

// Parse 解析 SQL 语句
func (a *SQLAdapter) Parse(sql string) (*ParseResult, error) <span class="cov8" title="1">{
        stmtNodes, _, err := a.parser.Parse(sql, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ParseResult{
                        Success: false,
                        Error:   err.Error(),
                }, fmt.Errorf("parse SQL failed: %w", err)
        }</span>

        <span class="cov8" title="1">if len(stmtNodes) == 0 </span><span class="cov0" title="0">{
                return &amp;ParseResult{
                        Success: false,
                        Error:   "no statements found",
                }, fmt.Errorf("no statements found")
        }</span>

        // 只处理第一条语句
        <span class="cov8" title="1">stmt := stmtNodes[0]
        statement, err := a.convertToStatement(stmt)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ParseResult{
                        Success: false,
                        Error:   err.Error(),
                }, err
        }</span>

        <span class="cov8" title="1">return &amp;ParseResult{
                Statement: statement,
                Success:   true,
        }, nil</span>
}

// ParseMulti 解析多条 SQL 语句
func (a *SQLAdapter) ParseMulti(sql string) ([]*ParseResult, error) <span class="cov0" title="0">{
        stmtNodes, _, err := a.parser.Parse(sql, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse SQL failed: %w", err)
        }</span>

        <span class="cov0" title="0">results := make([]*ParseResult, 0, len(stmtNodes))
        for _, stmt := range stmtNodes </span><span class="cov0" title="0">{
                statement, err := a.convertToStatement(stmt)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, &amp;ParseResult{
                                Success: false,
                                Error:   err.Error(),
                        })
                        continue</span>
                }
                <span class="cov0" title="0">results = append(results, &amp;ParseResult{
                        Statement: statement,
                        Success:   true,
                })</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// convertToStatement 将 AST 节点转换为 SQLStatement
func (a *SQLAdapter) convertToStatement(node ast.StmtNode) (*SQLStatement, error) <span class="cov8" title="1">{
        stmt := &amp;SQLStatement{
                RawSQL: node.Text(),
        }

        switch stmtNode := node.(type) </span>{
        case *ast.SelectStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeSelect
                selectStmt, err := a.convertSelectStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Select = selectStmt</span>

        case *ast.InsertStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeInsert
                insertStmt, err := a.convertInsertStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Insert = insertStmt</span>

        case *ast.UpdateStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeUpdate
                updateStmt, err := a.convertUpdateStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Update = updateStmt</span>

        case *ast.DeleteStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeDelete
                deleteStmt, err := a.convertDeleteStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Delete = deleteStmt</span>

        case *ast.CreateTableStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeCreate
                createStmt, err := a.convertCreateTableStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Create = createStmt</span>

        case *ast.DropTableStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeDrop
                dropStmt, err := a.convertDropTableStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Drop = dropStmt</span>

        case *ast.TruncateTableStmt:<span class="cov0" title="0">
                stmt.Type = SQLTypeDrop
                stmt.Drop = &amp;DropStatement{
                        Type:     "TABLE",
                        Name:     stmtNode.Table.Name.String(),
                        IfExists: false,
                }</span>

        case *ast.AlterTableStmt:<span class="cov0" title="0">
                stmt.Type = SQLTypeAlter
                alterStmt, err := a.convertAlterTableStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stmt.Alter = alterStmt</span>

        case *ast.CreateIndexStmt:<span class="cov0" title="0">
                stmt.Type = SQLTypeCreate
                createIndexStmt, err := a.convertCreateIndexStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stmt.CreateIndex = createIndexStmt</span>

        case *ast.DropIndexStmt:<span class="cov0" title="0">
                stmt.Type = SQLTypeDrop
                dropIndexStmt, err := a.convertDropIndexStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stmt.DropIndex = dropIndexStmt</span>

        case *ast.UseStmt:<span class="cov0" title="0">
                stmt.Type = SQLTypeUse
                useStmt := a.convertUseStmt(stmtNode)
                stmt.Use = useStmt</span>

        case *ast.ShowStmt:<span class="cov8" title="1">
                stmt.Type = SQLTypeShow
                showStmt, err := a.convertShowStmt(stmtNode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stmt.Show = showStmt</span>

        case *ast.ExplainStmt:<span class="cov8" title="1">
                // DESCRIBE/DESC statements are parsed as ExplainStmt with a ShowStmt inside
                if showStmt, ok := stmtNode.Stmt.(*ast.ShowStmt); ok &amp;&amp; showStmt.Tp == ast.ShowColumns </span><span class="cov8" title="1">{
                        stmt.Type = SQLTypeDescribe
                        describeStmt, err := a.convertDescribeFromShowStmt(showStmt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">stmt.Describe = describeStmt</span>
                } else<span class="cov0" title="0"> {
                        // Regular EXPLAIN statement
                        stmt.Type = SQLTypeExplain
                        explainStmt := &amp;ExplainStatement{
                                TargetSQL: stmt.RawSQL,
                                Format:    "TREE", // Default format
                                Analyze:   strings.HasPrefix(strings.ToUpper(stmt.RawSQL), "EXPLAIN ANALYZE"),
                        }

                        // Try to extract the inner SELECT statement
                        if stmtNode.Stmt != nil </span><span class="cov0" title="0">{
                                if selectStmt, ok := stmtNode.Stmt.(*ast.SelectStmt); ok </span><span class="cov0" title="0">{
                                        selectStmt, err := a.convertSelectStmt(selectStmt)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">explainStmt.Query = selectStmt</span>
                                }
                        }

                        <span class="cov0" title="0">stmt.Explain = explainStmt</span>
                }

        default:<span class="cov0" title="0">
                stmt.Type = SQLTypeUnknown</span>
        }

        <span class="cov8" title="1">return stmt, nil</span>
}

// convertSelectStmt 转换 SELECT 语句
func (a *SQLAdapter) convertSelectStmt(stmt *ast.SelectStmt) (*SelectStatement, error) <span class="cov8" title="1">{
        selectStmt := &amp;SelectStatement{
                Distinct: stmt.Distinct,
        }

        // 解析 SELECT 列
        if stmt.Fields != nil </span><span class="cov8" title="1">{
                selectStmt.Columns = make([]SelectColumn, 0, len(stmt.Fields.Fields))
                for _, field := range stmt.Fields.Fields </span><span class="cov8" title="1">{
                        col, err := a.convertSelectField(field)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">selectStmt.Columns = append(selectStmt.Columns, *col)</span>
                }
        }

        // 解析 FROM
        <span class="cov8" title="1">if stmt.From != nil &amp;&amp; stmt.From.TableRefs != nil </span><span class="cov8" title="1">{
                // 从 Join 的左表获取主表名
                if tableSource, ok := stmt.From.TableRefs.Left.(*ast.TableSource); ok </span><span class="cov8" title="1">{
                        if tableName, ok := tableSource.Source.(*ast.TableName); ok </span><span class="cov8" title="1">{
                                // Preserve full qualified table name (schema.table)
                                fullName := tableName.Name.String()
                                if tableName.Schema.String() != "" </span><span class="cov0" title="0">{
                                        fullName = tableName.Schema.String() + "." + fullName
                                }</span>
                                <span class="cov8" title="1">selectStmt.From = fullName</span>
                        }
                }

                // 解析 JOIN（从右表）
                <span class="cov8" title="1">if stmt.From.TableRefs.Right != nil </span><span class="cov8" title="1">{
                        selectStmt.Joins = a.convertJoinTree(stmt.From.TableRefs.Right)
                }</span>
        }

        // 解析 WHERE
        <span class="cov8" title="1">if stmt.Where != nil </span><span class="cov8" title="1">{
                expr, err := a.convertExpression(stmt.Where)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">selectStmt.Where = expr</span>
        }

        // 解析 GROUP BY
        <span class="cov8" title="1">if stmt.GroupBy != nil </span><span class="cov8" title="1">{
                selectStmt.GroupBy = make([]string, 0, len(stmt.GroupBy.Items))
                for _, item := range stmt.GroupBy.Items </span><span class="cov8" title="1">{
                        if col, ok := item.Expr.(*ast.ColumnNameExpr); ok </span><span class="cov8" title="1">{
                                selectStmt.GroupBy = append(selectStmt.GroupBy, col.Name.Name.String())
                        }</span>
                }
        }

        // 解析 HAVING
        <span class="cov8" title="1">if stmt.Having != nil </span><span class="cov8" title="1">{
                expr, err := a.convertExpression(stmt.Having.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">selectStmt.Having = expr</span>
        }

        // 解析 ORDER BY
        <span class="cov8" title="1">if stmt.OrderBy != nil </span><span class="cov8" title="1">{
                selectStmt.OrderBy = make([]OrderByItem, 0, len(stmt.OrderBy.Items))
                for _, item := range stmt.OrderBy.Items </span><span class="cov8" title="1">{
                        direction := "ASC"
                        if item.Desc </span><span class="cov8" title="1">{
                                direction = "DESC"
                        }</span>
                        <span class="cov8" title="1">if col, ok := item.Expr.(*ast.ColumnNameExpr); ok </span><span class="cov8" title="1">{
                                selectStmt.OrderBy = append(selectStmt.OrderBy, OrderByItem{
                                        Column:    col.Name.Name.String(),
                                        Direction: direction,
                                })
                        }</span>
                }
        }

        // 解析 LIMIT
        <span class="cov8" title="1">if stmt.Limit != nil </span><span class="cov8" title="1">{
                // 处理LIMIT值
                if stmt.Limit.Count != nil </span><span class="cov8" title="1">{
                        // 尝试多种方式提取值
                        if valExpr, ok := stmt.Limit.Count.(ast.ValueExpr); ok </span><span class="cov8" title="1">{
                                val := valExpr.GetValue()
                                // 确保转换为int64
                                var i64 int64
                                switch v := val.(type) </span>{
                                case int:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int8:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int16:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int32:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int64:<span class="cov0" title="0">
                                        i64 = v</span>
                                case uint:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint8:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint16:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint32:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint64:<span class="cov8" title="1">
                                        i64 = int64(v)</span>
                                }
                                <span class="cov8" title="1">selectStmt.Limit = &amp;i64</span>
                        }
                }
                // 处理OFFSET值
                <span class="cov8" title="1">if stmt.Limit.Offset != nil </span><span class="cov0" title="0">{
                        if valExpr, ok := stmt.Limit.Offset.(ast.ValueExpr); ok </span><span class="cov0" title="0">{
                                val := valExpr.GetValue()
                                // 确保转换为int64
                                var i64 int64
                                switch v := val.(type) </span>{
                                case int:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int8:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int16:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int32:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case int64:<span class="cov0" title="0">
                                        i64 = v</span>
                                case uint:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint8:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint16:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint32:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                case uint64:<span class="cov0" title="0">
                                        i64 = int64(v)</span>
                                }
                                <span class="cov0" title="0">selectStmt.Offset = &amp;i64</span>
                        }
                }
        }

        <span class="cov8" title="1">return selectStmt, nil</span>
}

// convertJoinTree 递归转换 JOIN 树
func (a *SQLAdapter) convertJoinTree(node ast.ResultSetNode) []JoinInfo <span class="cov8" title="1">{
        result := make([]JoinInfo, 0)

        if node == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov8" title="1">switch n := node.(type) </span>{
        case *ast.Join:<span class="cov0" title="0">
                // 先处理左子树的 JOIN（如果有）
                if leftJoins := a.convertJoinTree(n.Left); len(leftJoins) &gt; 0 </span><span class="cov0" title="0">{
                        result = append(result, leftJoins...)
                }</span>

                // 处理当前 JOIN
                <span class="cov0" title="0">joinType := JoinTypeInner
                switch n.Tp </span>{
                case ast.LeftJoin:<span class="cov0" title="0">
                        joinType = JoinTypeLeft</span>
                case ast.RightJoin:<span class="cov0" title="0">
                        joinType = JoinTypeRight</span>
                case ast.CrossJoin:<span class="cov0" title="0">
                        joinType = JoinTypeCross</span>
                }

                <span class="cov0" title="0">joinInfo := JoinInfo{
                        Type: joinType,
                }

                // 从右表获取表名
                if tableSource, ok := n.Right.(*ast.TableSource); ok </span><span class="cov0" title="0">{
                        if tableName, ok := tableSource.Source.(*ast.TableName); ok </span><span class="cov0" title="0">{
                                joinInfo.Table = tableName.Name.String()
                                if tableSource.AsName.L != "" </span><span class="cov0" title="0">{
                                        joinInfo.Alias = tableSource.AsName.String()
                                }</span>
                        }
                }

                // 解析 ON 条件
                <span class="cov0" title="0">if n.On != nil &amp;&amp; n.On.Expr != nil </span><span class="cov0" title="0">{
                        expr, _ := a.convertExpression(n.On.Expr)
                        joinInfo.Condition = expr
                }</span>

                <span class="cov0" title="0">result = append(result, joinInfo)

                // 处理右子树的 JOIN（如果有）
                if rightJoins := a.convertJoinTree(n.Right); len(rightJoins) &gt; 0 </span><span class="cov0" title="0">{
                        result = append(result, rightJoins...)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// convertInsertStmt 转换 INSERT 语句
func (a *SQLAdapter) convertInsertStmt(stmt *ast.InsertStmt) (*InsertStatement, error) <span class="cov8" title="1">{
        // 从 TableRefsClause 获取表名
        var tableName string
        if stmt.Table != nil &amp;&amp; stmt.Table.TableRefs != nil </span><span class="cov8" title="1">{
                if tableSource, ok := stmt.Table.TableRefs.Left.(*ast.TableSource); ok </span><span class="cov8" title="1">{
                        if tableNameNode, ok := tableSource.Source.(*ast.TableName); ok </span><span class="cov8" title="1">{
                                tableName = tableNameNode.Name.String()
                        }</span>
                }
        }

        <span class="cov8" title="1">insertStmt := &amp;InsertStatement{
                Table: tableName,
        }

        // 解析列名
        if stmt.Columns != nil </span><span class="cov8" title="1">{
                insertStmt.Columns = make([]string, 0, len(stmt.Columns))
                for _, col := range stmt.Columns </span><span class="cov8" title="1">{
                        insertStmt.Columns = append(insertStmt.Columns, col.Name.String())
                }</span>
        }

        // 解析值列表 (Lists 是 [][]ExprNode)
        <span class="cov8" title="1">insertStmt.Values = make([][]interface{}, 0, len(stmt.Lists))
        for _, rowExprs := range stmt.Lists </span><span class="cov8" title="1">{
                rowValues := make([]interface{}, 0, len(rowExprs))
                for _, expr := range rowExprs </span><span class="cov8" title="1">{
                        val, err := a.extractValue(expr)
                        if err != nil </span><span class="cov0" title="0">{
                                // 如果无法提取值，跳过
                                rowValues = append(rowValues, nil)
                                continue</span>
                        }
                        <span class="cov8" title="1">rowValues = append(rowValues, val)</span>
                }
                <span class="cov8" title="1">insertStmt.Values = append(insertStmt.Values, rowValues)</span>
        }

        <span class="cov8" title="1">return insertStmt, nil</span>
}

// convertUpdateStmt 转换 UPDATE 语句
func (a *SQLAdapter) convertUpdateStmt(stmt *ast.UpdateStmt) (*UpdateStatement, error) <span class="cov8" title="1">{
        // 从 TableRefsClause 获取表名
        var tableName string
        if stmt.TableRefs != nil &amp;&amp; stmt.TableRefs.TableRefs != nil </span><span class="cov8" title="1">{
                if tableSource, ok := stmt.TableRefs.TableRefs.Left.(*ast.TableSource); ok </span><span class="cov8" title="1">{
                        if tableNameNode, ok := tableSource.Source.(*ast.TableName); ok </span><span class="cov8" title="1">{
                                tableName = tableNameNode.Name.String()
                        }</span>
                }
        }

        <span class="cov8" title="1">updateStmt := &amp;UpdateStatement{
                Table: tableName,
                Set:   make(map[string]interface{}),
        }

        // 解析 SET 子句 (List 是 []*Assignment)
        for _, assign := range stmt.List </span><span class="cov8" title="1">{
                col := assign.Column.Name.String()
                val, err := a.extractValue(assign.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">updateStmt.Set[col] = val</span>
        }

        // 解析 WHERE
        <span class="cov8" title="1">if stmt.Where != nil </span><span class="cov8" title="1">{
                expr, err := a.convertExpression(stmt.Where)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">updateStmt.Where = expr</span>
        }

        // 解析 ORDER BY
        <span class="cov8" title="1">if stmt.Order != nil </span><span class="cov0" title="0">{
                updateStmt.OrderBy = make([]OrderByItem, 0, len(stmt.Order.Items))
                for _, item := range stmt.Order.Items </span><span class="cov0" title="0">{
                        direction := "ASC"
                        if item.Desc </span><span class="cov0" title="0">{
                                direction = "DESC"
                        }</span>
                        <span class="cov0" title="0">if col, ok := item.Expr.(*ast.ColumnNameExpr); ok </span><span class="cov0" title="0">{
                                updateStmt.OrderBy = append(updateStmt.OrderBy, OrderByItem{
                                        Column:    col.Name.Name.String(),
                                        Direction: direction,
                                })
                        }</span>
                }
        }

        // 解析 LIMIT
        <span class="cov8" title="1">if stmt.Limit != nil </span><span class="cov0" title="0">{
                if stmt.Limit.Count != nil </span><span class="cov0" title="0">{
                        val, err := a.extractValue(stmt.Limit.Count)
                        if err == nil </span><span class="cov0" title="0">{
                                if v, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                        updateStmt.Limit = &amp;v
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return updateStmt, nil</span>
}

// convertDeleteStmt 转换 DELETE 语句
func (a *SQLAdapter) convertDeleteStmt(stmt *ast.DeleteStmt) (*DeleteStatement, error) <span class="cov8" title="1">{
        // 从 TableRefsClause 获取表名
        var tableName string
        if stmt.TableRefs != nil &amp;&amp; stmt.TableRefs.TableRefs != nil </span><span class="cov8" title="1">{
                if tableSource, ok := stmt.TableRefs.TableRefs.Left.(*ast.TableSource); ok </span><span class="cov8" title="1">{
                        if tableNameNode, ok := tableSource.Source.(*ast.TableName); ok </span><span class="cov8" title="1">{
                                tableName = tableNameNode.Name.String()
                        }</span>
                }
        }

        <span class="cov8" title="1">deleteStmt := &amp;DeleteStatement{
                Table: tableName,
        }

        // 解析 WHERE
        if stmt.Where != nil </span><span class="cov8" title="1">{
                expr, err := a.convertExpression(stmt.Where)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">deleteStmt.Where = expr</span>
        }

        // 解析 ORDER BY
        <span class="cov8" title="1">if stmt.Order != nil </span><span class="cov0" title="0">{
                deleteStmt.OrderBy = make([]OrderByItem, 0, len(stmt.Order.Items))
                for _, item := range stmt.Order.Items </span><span class="cov0" title="0">{
                        direction := "ASC"
                        if item.Desc </span><span class="cov0" title="0">{
                                direction = "DESC"
                        }</span>
                        <span class="cov0" title="0">if col, ok := item.Expr.(*ast.ColumnNameExpr); ok </span><span class="cov0" title="0">{
                                deleteStmt.OrderBy = append(deleteStmt.OrderBy, OrderByItem{
                                        Column:    col.Name.Name.String(),
                                        Direction: direction,
                                })
                        }</span>
                }
        }

        // 解析 LIMIT
        <span class="cov8" title="1">if stmt.Limit != nil </span><span class="cov0" title="0">{
                if stmt.Limit.Count != nil </span><span class="cov0" title="0">{
                        val, err := a.extractValue(stmt.Limit.Count)
                        if err == nil </span><span class="cov0" title="0">{
                                if v, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                        deleteStmt.Limit = &amp;v
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return deleteStmt, nil</span>
}

// convertCreateTableStmt 转换 CREATE TABLE 语句
func (a *SQLAdapter) convertCreateTableStmt(stmt *ast.CreateTableStmt) (*CreateStatement, error) <span class="cov8" title="1">{
        createStmt := &amp;CreateStatement{
                Type:    "TABLE",
                Name:    stmt.Table.Name.String(),
                Columns: make([]ColumnInfo, 0),
                Options: make(map[string]interface{}),
        }

        // 解析列定义
        for _, col := range stmt.Cols </span><span class="cov8" title="1">{
                colInfo := ColumnInfo{
                        Name:     col.Name.Name.String(),
                        Type:     col.Tp.String(),
                        Nullable: true, // 默认可空
                        Default:  nil,
                }

                // 从 Options 解析列属性
                for _, opt := range col.Options </span><span class="cov8" title="1">{
                        switch opt.Tp </span>{
                        case ast.ColumnOptionNotNull, ast.ColumnOptionPrimaryKey:<span class="cov8" title="1">
                                colInfo.Nullable = false
                                colInfo.Primary = opt.Tp == ast.ColumnOptionPrimaryKey</span>
                        case ast.ColumnOptionDefaultValue:<span class="cov0" title="0">
                                if opt.Expr != nil </span><span class="cov0" title="0">{
                                        val, _ := a.extractValue(opt.Expr)
                                        colInfo.Default = val
                                }</span>
                        case ast.ColumnOptionAutoIncrement:<span class="cov0" title="0">
                                colInfo.AutoInc = true</span>
                        case ast.ColumnOptionUniqKey:<span class="cov0" title="0">
                                colInfo.Unique = true</span>
                        }
                }

                <span class="cov8" title="1">createStmt.Columns = append(createStmt.Columns, colInfo)</span>
        }

        <span class="cov8" title="1">return createStmt, nil</span>
}

// convertDropTableStmt 转换 DROP TABLE 语句
func (a *SQLAdapter) convertDropTableStmt(stmt *ast.DropTableStmt) (*DropStatement, error) <span class="cov8" title="1">{
        return &amp;DropStatement{
                Type:     "TABLE",
                Name:     stmt.Tables[0].Name.String(),
                IfExists: stmt.IfExists,
        }, nil
}</span>

// convertAlterTableStmt 转换 ALTER TABLE 语句
func (a *SQLAdapter) convertAlterTableStmt(stmt *ast.AlterTableStmt) (*AlterStatement, error) <span class="cov0" title="0">{
        alterStmt := &amp;AlterStatement{
                Type:    "TABLE",
                Name:    stmt.Table.Name.String(),
                Actions: make([]AlterAction, 0),
        }

        for _, spec := range stmt.Specs </span><span class="cov0" title="0">{
                action := AlterAction{
                        Type: fmt.Sprintf("%d", int(spec.Tp)),
                }

                if spec.NewColumnName != nil </span><span class="cov0" title="0">{
                        action.OldName = spec.OldColumnName.Name.String()
                        action.NewName = spec.NewColumnName.Name.String()
                }</span>

                <span class="cov0" title="0">alterStmt.Actions = append(alterStmt.Actions, action)</span>
        }

        <span class="cov0" title="0">return alterStmt, nil</span>
}

// convertSelectField 转换 SELECT 字段
func (a *SQLAdapter) convertSelectField(field *ast.SelectField) (*SelectColumn, error) <span class="cov8" title="1">{
        col := &amp;SelectColumn{}

        // 检查通配符：使用字符串检查
        if field.WildCard != nil </span><span class="cov8" title="1">{
                col.IsWildcard = true
                col.Name = "*"
                return col, nil
        }</span>

        // 处理列名
        <span class="cov8" title="1">if expr, ok := field.Expr.(*ast.ColumnNameExpr); ok </span><span class="cov8" title="1">{
                col.Name = expr.Name.Name.String()
                col.Table = expr.Name.Schema.String()
                col.IsWildcard = expr.Name.Name.String() == "*"
        }</span>

        <span class="cov8" title="1">if field.AsName.L != "" </span><span class="cov8" title="1">{
                col.Alias = field.AsName.String()
        }</span>

        <span class="cov8" title="1">return col, nil</span>
}

// convertExpression 转换表达式
func (a *SQLAdapter) convertExpression(node ast.ExprNode) (*Expression, error) <span class="cov8" title="1">{
        expr := &amp;Expression{}

        switch n := node.(type) </span>{
        case *ast.BinaryOperationExpr:<span class="cov8" title="1">
                expr.Type = ExprTypeOperator
                expr.Operator = n.Op.String()
                left, _ := a.convertExpression(n.L)
                right, _ := a.convertExpression(n.R)
                expr.Left = left
                expr.Right = right</span>

        case *ast.ColumnNameExpr:<span class="cov8" title="1">
                expr.Type = ExprTypeColumn
                expr.Column = n.Name.Name.String()
                if n.Name.Schema.L != "" </span><span class="cov0" title="0">{
                        expr.Column = n.Name.Schema.String() + "." + expr.Column
                }</span>

        case ast.ValueExpr:<span class="cov8" title="1">
                // ValueExpr 是接口类型
                expr.Type = ExprTypeValue
                expr.Value = n.GetValue()</span>

        case *ast.FuncCallExpr:<span class="cov0" title="0">
                expr.Type = ExprTypeFunction
                expr.Function = n.FnName.String()
                args := make([]Expression, 0)
                for _, arg := range n.Args </span><span class="cov0" title="0">{
                        converted, _ := a.convertExpression(arg)
                        args = append(args, *converted)
                }</span>
                <span class="cov0" title="0">expr.Args = args</span>

        case *ast.PatternLikeOrIlikeExpr:<span class="cov0" title="0">
                // 处理 LIKE 表达式
                expr.Type = ExprTypeOperator
                if n.Not </span><span class="cov0" title="0">{
                        expr.Operator = "NOT LIKE"
                }</span> else<span class="cov0" title="0"> {
                        expr.Operator = "LIKE"
                }</span>
                <span class="cov0" title="0">left, _ := a.convertExpression(n.Expr)
                right, _ := a.convertExpression(n.Pattern)
                expr.Left = left
                expr.Right = right</span>

        case *ast.BetweenExpr:<span class="cov0" title="0">
                // 处理 BETWEEN 表达式
                expr.Type = ExprTypeOperator
                if n.Not </span><span class="cov0" title="0">{
                        expr.Operator = "NOT BETWEEN"
                }</span> else<span class="cov0" title="0"> {
                        expr.Operator = "BETWEEN"
                }</span>
                <span class="cov0" title="0">left, _ := a.convertExpression(n.Expr)
                expr.Left = left
                // 存储两个边界值
                leftBound, _ := a.convertExpression(n.Left)
                rightBound, _ := a.convertExpression(n.Right)
                // 将 BETWEEN 转换为一个包含两个值的列表
                // expr.Left: 列, expr.Right: [min, max]
                expr.Right = &amp;Expression{
                        Type:  ExprTypeValue,
                        Value: []interface{}{leftBound, rightBound},
                }</span>

        default:<span class="cov8" title="1">
                expr.Type = ExprTypeValue</span>
        }

        <span class="cov8" title="1">return expr, nil</span>
}

// extractValue 提取值
func (a *SQLAdapter) extractValue(node ast.ExprNode) (interface{}, error) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("node is nil")
        }</span>

        // 尝试转换为ValueExpr
        <span class="cov8" title="1">if valExpr, ok := node.(ast.ValueExpr); ok </span><span class="cov8" title="1">{
                return valExpr.GetValue(), nil
        }</span>

        // 如果不是ValueExpr，可能是其他表达式类型
        // 对于LIMIT，我们可能需要使用不同的方法
        <span class="cov0" title="0">return nil, fmt.Errorf("not a value expression: %T", node)</span>
}

// convertShowStmt 转换 SHOW 语句
func (a *SQLAdapter) convertShowStmt(stmt *ast.ShowStmt) (*ShowStatement, error) <span class="cov8" title="1">{
        showStmt := &amp;ShowStatement{}

        // 获取 SHOW 类型
        switch stmt.Tp </span>{
        case ast.ShowTables:<span class="cov8" title="1">
                showStmt.Type = "TABLES"</span>
        case ast.ShowDatabases:<span class="cov8" title="1">
                showStmt.Type = "DATABASES"</span>
        case ast.ShowColumns:<span class="cov8" title="1">
                showStmt.Type = "COLUMNS"
                if stmt.Table != nil </span><span class="cov8" title="1">{
                        showStmt.Table = stmt.Table.Name.String()
                }</span>
        case ast.ShowCreateTable:<span class="cov8" title="1">
                showStmt.Type = "CREATE_TABLE"
                if stmt.Table != nil </span><span class="cov8" title="1">{
                        showStmt.Table = stmt.Table.Name.String()
                }</span>
        default:<span class="cov0" title="0">
                showStmt.Type = "UNKNOWN"</span>
        }

        // 处理 LIKE 子句
        <span class="cov8" title="1">if stmt.Pattern != nil </span><span class="cov8" title="1">{
                showStmt.Like = stmt.Pattern.OriginalText()
        }</span>

        // 处理 WHERE 子句
        <span class="cov8" title="1">if stmt.Where != nil </span><span class="cov0" title="0">{
                showStmt.Where = stmt.Where.OriginalText()
        }</span>

        <span class="cov8" title="1">return showStmt, nil</span>
}

// convertDescribeFromShowStmt 从 ShowStmt 转换 DESCRIBE 语句
// DESCRIBE/DESC 语句被 TiDB parser 解析为 ExplainStmt，其中包含一个 ShowStmt
func (a *SQLAdapter) convertDescribeFromShowStmt(stmt *ast.ShowStmt) (*DescribeStatement, error) <span class="cov8" title="1">{
        describeStmt := &amp;DescribeStatement{}

        // 获取表名
        if stmt.Table != nil </span><span class="cov8" title="1">{
                describeStmt.Table = stmt.Table.Name.String()
        }</span>

        // 获取列名（如果有）
        <span class="cov8" title="1">if stmt.Column != nil </span><span class="cov8" title="1">{
                describeStmt.Column = stmt.Column.Name.String()
        }</span>

        <span class="cov8" title="1">return describeStmt, nil</span>
}

// convertUseStmt 转换 USE 语句
func (a *SQLAdapter) convertUseStmt(stmt *ast.UseStmt) *UseStatement <span class="cov0" title="0">{
        // UseStmt.DBName is a CIStr (C identifier string)
        // Convert it to regular Go string
        dbName := string(stmt.DBName)
        
        useStmt := &amp;UseStatement{
                Database: dbName,
        }
        return useStmt
}</span>

// convertCreateIndexStmt 转换 CREATE INDEX 语句
func (a *SQLAdapter) convertCreateIndexStmt(stmt *ast.CreateIndexStmt) (*CreateIndexStatement, error) <span class="cov0" title="0">{
        createIndexStmt := &amp;CreateIndexStatement{
                IndexName: stmt.IndexName,
                IfExists:  stmt.IfNotExists,
                Unique:    stmt.KeyType == ast.IndexKeyTypeUnique,
        }

        // 获取表名
        if stmt.Table != nil </span><span class="cov0" title="0">{
                createIndexStmt.TableName = stmt.Table.Name.String()
        }</span>

        // 获取索引类型（BTREE, HASH, FULLTEXT）
        // 默认为 BTREE
        <span class="cov0" title="0">if stmt.IndexOption != nil </span><span class="cov0" title="0">{
                createIndexStmt.IndexType = "BTREE" // 默认值
                // 注意：TiDB 的 IndexOption 可能包含索引类型信息
                // 这里简化处理，实际可能需要更复杂的解析
        }</span> else<span class="cov0" title="0"> {
                createIndexStmt.IndexType = "BTREE"
        }</span>

        // 获取列名（从 IndexPartSpecifications）
        <span class="cov0" title="0">if len(stmt.IndexPartSpecifications) &gt; 0 </span><span class="cov0" title="0">{
                // 获取第一个列名（简化处理，不支持多列索引）
                spec := stmt.IndexPartSpecifications[0]
                if spec.Column != nil </span><span class="cov0" title="0">{
                        createIndexStmt.ColumnName = spec.Column.Name.String()
                }</span> else<span class="cov0" title="0"> {
                        // 如果 Column 为 nil，可能是表达式索引或其他情况
                        return nil, fmt.Errorf("invalid index specification: column is required")
                }</span>
        } else<span class="cov0" title="0"> {
                // 如果没有 IndexPartSpecifications，返回错误
                return nil, fmt.Errorf("CREATE INDEX requires at least one column")
        }</span>

        <span class="cov0" title="0">return createIndexStmt, nil</span>
}

// convertDropIndexStmt 转换 DROP INDEX 语句
func (a *SQLAdapter) convertDropIndexStmt(stmt *ast.DropIndexStmt) (*DropIndexStatement, error) <span class="cov0" title="0">{
        dropIndexStmt := &amp;DropIndexStatement{
                IndexName: stmt.IndexName,
                IfExists:  stmt.IfExists,
        }

        // 获取表名
        if stmt.Table != nil </span><span class="cov0" title="0">{
                dropIndexStmt.TableName = stmt.Table.Name.String()
        }</span>

        <span class="cov0" title="0">return dropIndexStmt, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package parser

import (
        "context"
        "fmt"
        "strings"

        domain "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// QueryBuilder 查询构建器
type QueryBuilder struct {
        dataSource domain.DataSource
}

// NewQueryBuilder 创建查询构建器
func NewQueryBuilder(dataSource domain.DataSource) *QueryBuilder <span class="cov0" title="0">{
        return &amp;QueryBuilder{
                dataSource: dataSource,
        }
}</span>

// BuildAndExecute 构建并执行 SQL 语句
func (b *QueryBuilder) BuildAndExecute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        adapter := NewSQLAdapter()
        result, err := adapter.Parse(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse SQL failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse failed: %s", result.Error)
        }</span>

        <span class="cov0" title="0">return b.ExecuteStatement(ctx, result.Statement)</span>
}

// ExecuteStatement 执行解析后的语句
func (b *QueryBuilder) ExecuteStatement(ctx context.Context, stmt *SQLStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        switch stmt.Type </span>{
        case SQLTypeSelect:<span class="cov0" title="0">
                return b.executeSelect(ctx, stmt.Select)</span>
        case SQLTypeInsert:<span class="cov0" title="0">
                return b.executeInsert(ctx, stmt.Insert)</span>
        case SQLTypeUpdate:<span class="cov0" title="0">
                return b.executeUpdate(ctx, stmt.Update)</span>
        case SQLTypeDelete:<span class="cov0" title="0">
                return b.executeDelete(ctx, stmt.Delete)</span>
        case SQLTypeCreate:<span class="cov0" title="0">
                // 优先处理 CREATE INDEX
                if stmt.CreateIndex != nil </span><span class="cov0" title="0">{
                        return b.executeCreateIndex(ctx, stmt.CreateIndex)
                }</span>
                <span class="cov0" title="0">return b.executeCreate(ctx, stmt.Create)</span>
        case SQLTypeDrop:<span class="cov0" title="0">
                // 优先处理 DROP INDEX
                if stmt.DropIndex != nil </span><span class="cov0" title="0">{
                        return b.executeDropIndex(ctx, stmt.DropIndex)
                }</span>
                <span class="cov0" title="0">return b.executeDrop(ctx, stmt.Drop)</span>
        case SQLTypeAlter:<span class="cov0" title="0">
                return b.executeAlter(ctx, stmt.Alter)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported SQL type: %s", stmt.Type)</span>
        }
}

// executeSelect 执行 SELECT
func (b *QueryBuilder) executeSelect(ctx context.Context, stmt *SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 构建 QueryOptions
        options := &amp;domain.QueryOptions{}

        // 检查是否是 select *
        isSelectAll := false
        for _, col := range stmt.Columns </span><span class="cov0" title="0">{
                if col.IsWildcard </span><span class="cov0" title="0">{
                        isSelectAll = true
                        break</span>
                }
        }
        <span class="cov0" title="0">options.SelectAll = isSelectAll

        // 处理 WHERE 条件
        if stmt.Where != nil </span><span class="cov0" title="0">{
                options.Filters = b.convertExpressionToFilters(stmt.Where)
        }</span>

        // 处理 ORDER BY
        <span class="cov0" title="0">if len(stmt.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                options.OrderBy = stmt.OrderBy[0].Column
                options.Order = stmt.OrderBy[0].Direction
        }</span>

        // 处理 LIMIT
        <span class="cov0" title="0">if stmt.Limit != nil </span><span class="cov0" title="0">{
                options.Limit = int(*stmt.Limit)
        }</span>

        // 处理 OFFSET
        <span class="cov0" title="0">if stmt.Offset != nil </span><span class="cov0" title="0">{
                options.Offset = int(*stmt.Offset)
        }</span>

        // 执行查询
        <span class="cov0" title="0">result, err := b.dataSource.Query(ctx, stmt.From, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        // 如果是 select *，需要确保返回的行数据不包含隐藏字段
        <span class="cov0" title="0">if isSelectAll </span><span class="cov0" title="0">{
                // 数据源层已经过滤了 _ttl 字段，这里再次确保
                // 构建新的行数据，只包含列定义中的字段
                filteredRows := make([]domain.Row, 0, len(result.Rows))
                for _, row := range result.Rows </span><span class="cov0" title="0">{
                        filteredRow := make(domain.Row)
                        for _, col := range result.Columns </span><span class="cov0" title="0">{
                                if val, exists := row[col.Name]; exists </span><span class="cov0" title="0">{
                                        filteredRow[col.Name] = val
                                }</span>
                        }
                        <span class="cov0" title="0">filteredRows = append(filteredRows, filteredRow)</span>
                }
                <span class="cov0" title="0">result.Rows = filteredRows
                return result, nil</span>
        }

        // 如果不是 select *，则需要根据 SELECT 的列来过滤结果
        <span class="cov0" title="0">if len(stmt.Columns) &gt; 0 </span><span class="cov0" title="0">{
                // 构建列名列表
                selectedColumns := make([]string, 0, len(stmt.Columns))
                for _, col := range stmt.Columns </span><span class="cov0" title="0">{
                        // 跳过空列名和以 _ 开头的列名
                        if len(col.Name) &gt; 0 &amp;&amp; col.Name[0] != '_' </span><span class="cov0" title="0">{
                                selectedColumns = append(selectedColumns, col.Name)
                        }</span>
                }

                // 如果没有有效的列名，则使用数据源返回的列
                <span class="cov0" title="0">if len(selectedColumns) == 0 </span><span class="cov0" title="0">{
                        return result, nil
                }</span>

                // 构建新的列定义
                <span class="cov0" title="0">newColumns := make([]domain.ColumnInfo, 0, len(selectedColumns))
                for _, colName := range selectedColumns </span><span class="cov0" title="0">{
                        // 查找对应的列定义
                        found := false
                        for _, col := range result.Columns </span><span class="cov0" title="0">{
                                if col.Name == colName </span><span class="cov0" title="0">{
                                        newColumns = append(newColumns, col)
                                        found = true
                                        break</span>
                                }
                        }
                        // 如果没有找到列定义（比如 _ttl 这种隐藏字段），则创建一个基本的列定义
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                newColumns = append(newColumns, domain.ColumnInfo{
                                        Name:     colName,
                                        Type:     "int64",
                                        Nullable: true,
                                        Primary:  false,
                                })
                        }</span>
                }

                // 过滤行数据，只保留选择的列
                <span class="cov0" title="0">filteredRows := make([]domain.Row, 0, len(result.Rows))
                for _, row := range result.Rows </span><span class="cov0" title="0">{
                        filteredRow := make(domain.Row)
                        for _, colName := range selectedColumns </span><span class="cov0" title="0">{
                                if val, exists := row[colName]; exists </span><span class="cov0" title="0">{
                                        filteredRow[colName] = val
                                }</span>
                        }
                        <span class="cov0" title="0">filteredRows = append(filteredRows, filteredRow)</span>
                }

                // 更新结果
                <span class="cov0" title="0">result.Columns = newColumns
                result.Rows = filteredRows</span>
        }

        // TODO: 处理 JOIN
        // TODO: 处理聚合函数
        // TODO: 处理 GROUP BY
        // TODO: 处理 HAVING

        <span class="cov0" title="0">return result, nil</span>
}

// executeInsert 执行 INSERT
func (b *QueryBuilder) executeInsert(ctx context.Context, stmt *InsertStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, INSERT operation not allowed")
        }</span>

        // 转换值为行数据
        <span class="cov0" title="0">rows := make([]domain.Row, 0, len(stmt.Values))
        for _, values := range stmt.Values </span><span class="cov0" title="0">{
                row := make(domain.Row)
                for i, col := range stmt.Columns </span><span class="cov0" title="0">{
                        if i &lt; len(values) </span><span class="cov0" title="0">{
                                row[col] = values[i]
                        }</span>
                }
                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        <span class="cov0" title="0">options := &amp;domain.InsertOptions{
                Replace: false,
        }

        affected, err := b.dataSource.Insert(ctx, stmt.Table, rows, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insert failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Total: affected,
        }, nil</span>
}

// executeUpdate 执行 UPDATE
func (b *QueryBuilder) executeUpdate(ctx context.Context, stmt *UpdateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, UPDATE operation not allowed")
        }</span>

        // 转换 WHERE 条件
        <span class="cov0" title="0">var filters []domain.Filter
        if stmt.Where != nil </span><span class="cov0" title="0">{
                filters = b.convertExpressionToFilters(stmt.Where)
        }</span>

        // 转换更新数据
        <span class="cov0" title="0">updates := make(domain.Row)
        for col, val := range stmt.Set </span><span class="cov0" title="0">{
                updates[col] = val
        }</span>

        <span class="cov0" title="0">options := &amp;domain.UpdateOptions{
                Upsert: false,
        }

        affected, err := b.dataSource.Update(ctx, stmt.Table, filters, updates, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Total: affected,
        }, nil</span>
}

// executeDelete 执行 DELETE
func (b *QueryBuilder) executeDelete(ctx context.Context, stmt *DeleteStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, DELETE operation not allowed")
        }</span>

        // 转换 WHERE 条件
        <span class="cov0" title="0">var filters []domain.Filter
        if stmt.Where != nil </span><span class="cov0" title="0">{
                filters = b.convertExpressionToFilters(stmt.Where)
        }</span>

        <span class="cov0" title="0">options := &amp;domain.DeleteOptions{
                Force: false,
        }

        affected, err := b.dataSource.Delete(ctx, stmt.Table, filters, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("delete failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Total: affected,
        }, nil</span>
}

// executeCreate 执行 CREATE
func (b *QueryBuilder) executeCreate(ctx context.Context, stmt *CreateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, CREATE operation not allowed")
        }</span>

        <span class="cov0" title="0">if stmt.Type == "TABLE" </span><span class="cov0" title="0">{
                tableInfo := &amp;domain.TableInfo{
                        Name:    stmt.Name,
                        Columns: make([]domain.ColumnInfo, 0, len(stmt.Columns)),
                }

                for _, col := range stmt.Columns </span><span class="cov0" title="0">{
                        tableInfo.Columns = append(tableInfo.Columns, domain.ColumnInfo{
                                Name:     col.Name,
                                Type:     col.Type,
                                Nullable: col.Nullable,
                                Primary:  col.Primary,
                                Default:  fmt.Sprintf("%v", col.Default),
                        })
                }</span>

                <span class="cov0" title="0">err := b.dataSource.CreateTable(ctx, tableInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("create table failed: %w", err)
                }</span>

                <span class="cov0" title="0">return &amp;domain.QueryResult{
                        Total: 0,
                }, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported create type: %s", stmt.Type)</span>
}

// executeDrop 执行 DROP
func (b *QueryBuilder) executeDrop(ctx context.Context, stmt *DropStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, DROP operation not allowed")
        }</span>

        <span class="cov0" title="0">if stmt.Type == "TABLE" </span><span class="cov0" title="0">{
                err := b.dataSource.DropTable(ctx, stmt.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("drop table failed: %w", err)
                }</span>

                <span class="cov0" title="0">return &amp;domain.QueryResult{
                        Total: 0,
                }, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported drop type: %s", stmt.Type)</span>
}

// executeAlter 执行 ALTER
func (b *QueryBuilder) executeAlter(ctx context.Context, stmt *AlterStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("ALTER TABLE is not currently supported")
}</span>

// executeCreateIndex 执行 CREATE INDEX
func (b *QueryBuilder) executeCreateIndex(ctx context.Context, stmt *CreateIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, CREATE INDEX operation not allowed")
        }</span>

        // 检查数据源是否支持索引操作
        <span class="cov0" title="0">indexManager, ok := b.dataSource.(interface {
                CreateIndex(tableName, columnName string, indexType string, unique bool) error
        })
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source does not support CREATE INDEX")
        }</span>

        // 转换索引类型
        <span class="cov0" title="0">var idxType string
        switch strings.ToUpper(stmt.IndexType) </span>{
        case "BTREE", "B-TREE":<span class="cov0" title="0">
                idxType = "btree"</span>
        case "HASH":<span class="cov0" title="0">
                idxType = "hash"</span>
        case "FULLTEXT", "FULL-TEXT":<span class="cov0" title="0">
                idxType = "fulltext"</span>
        default:<span class="cov0" title="0">
                idxType = "btree"</span> // 默认使用 btree
        }

        // 调用数据源的 CreateIndex 方法
        <span class="cov0" title="0">err := indexManager.CreateIndex(stmt.TableName, stmt.ColumnName, idxType, stmt.Unique)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create index failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Total: 0,
        }, nil</span>
}

// executeDropIndex 执行 DROP INDEX
func (b *QueryBuilder) executeDropIndex(ctx context.Context, stmt *DropIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 检查数据源是否可写
        if !b.dataSource.IsWritable() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source is read-only, DROP INDEX operation not allowed")
        }</span>

        // 检查数据源是否支持索引操作
        <span class="cov0" title="0">indexManager, ok := b.dataSource.(interface {
                DropIndex(tableName, indexName string) error
        })
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data source does not support DROP INDEX")
        }</span>

        // 调用数据源的 DropIndex 方法
        <span class="cov0" title="0">err := indexManager.DropIndex(stmt.TableName, stmt.IndexName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("drop index failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Total: 0,
        }, nil</span>
}

// convertExpressionToFilters 将表达式转换为过滤器列表
func (b *QueryBuilder) convertExpressionToFilters(expr *Expression) []domain.Filter <span class="cov0" title="0">{
        return b.convertExpressionToFiltersInternal(expr, false)
}</span>

// convertExpressionToFiltersInternal 内部递归函数
func (b *QueryBuilder) convertExpressionToFiltersInternal(expr *Expression, isInOr bool) []domain.Filter <span class="cov0" title="0">{
        filters := make([]domain.Filter, 0)

        if expr == nil </span><span class="cov0" title="0">{
                return filters
        }</span>

        <span class="cov0" title="0">switch expr.Type </span>{
        case ExprTypeOperator:<span class="cov0" title="0">
                if expr.Left != nil &amp;&amp; expr.Right != nil </span><span class="cov0" title="0">{
                        if expr.Operator == "and" || expr.Operator == "or" </span><span class="cov0" title="0">{
                                leftFilters := b.convertExpressionToFiltersInternal(expr.Left, expr.Operator == "or")
                                rightFilters := b.convertExpressionToFiltersInternal(expr.Right, expr.Operator == "or")

                                if len(leftFilters) &gt; 0 || len(rightFilters) &gt; 0 </span><span class="cov0" title="0">{
                                        logicOp := strings.ToUpper(expr.Operator)
                                        filters = append(filters, domain.Filter{
                                                LogicOp:    logicOp,
                                                SubFilters: append(leftFilters, rightFilters...),
                                        })
                                }</span>
                                <span class="cov0" title="0">return filters</span>
                        }

                        <span class="cov0" title="0">if expr.Left.Type == ExprTypeColumn &amp;&amp; expr.Right.Type == ExprTypeValue </span><span class="cov0" title="0">{
                                operator := b.convertOperator(expr.Operator)
                                value := b.convertValue(expr.Right.Value)
                                filters = append(filters, domain.Filter{
                                        Field:    expr.Left.Column,
                                        Operator: operator,
                                        Value:    value,
                                })
                                return filters
                        }</span>

                        // 处理 BETWEEN 操作符
                        <span class="cov0" title="0">if expr.Left.Type == ExprTypeColumn &amp;&amp; expr.Right.Type == ExprTypeValue </span><span class="cov0" title="0">{
                                if expr.Operator == "BETWEEN" || expr.Operator == "NOT BETWEEN" </span><span class="cov0" title="0">{
                                        // expr.Right.Value 应该是 [min, max] 的数组
                                        if valueSlice, ok := expr.Right.Value.([]interface{}); ok &amp;&amp; len(valueSlice) &gt;= 2 </span><span class="cov0" title="0">{
                                                // 获取左边界和右边界的值
                                                minValue := b.extractExpressionValue(valueSlice[0])
                                                maxValue := b.extractExpressionValue(valueSlice[1])
                                                if minValue != nil &amp;&amp; maxValue != nil </span><span class="cov0" title="0">{
                                                        operator := expr.Operator
                                                        filters = append(filters, domain.Filter{
                                                                Field:    expr.Left.Column,
                                                                Operator: operator,
                                                                Value:    []interface{}{minValue, maxValue},
                                                        })
                                                        return filters
                                                }</span>
                                        }
                                }
                        }
                }

        case ExprTypeFunction:<span class="cov0" title="0">
                if expr.Function == "in" </span><span class="cov0" title="0">{
                        if len(expr.Args) &gt; 1 </span><span class="cov0" title="0">{
                                if expr.Args[0].Type == ExprTypeColumn </span><span class="cov0" title="0">{
                                        values := make([]interface{}, 0)
                                        for i := 1; i &lt; len(expr.Args); i++ </span><span class="cov0" title="0">{
                                                if expr.Args[i].Type == ExprTypeValue </span><span class="cov0" title="0">{
                                                        values = append(values, b.convertValue(expr.Args[i].Value))
                                                }</span>
                                        }
                                        <span class="cov0" title="0">filters = append(filters, domain.Filter{
                                                Field:    expr.Args[0].Column,
                                                Operator: "IN",
                                                Value:    values,
                                        })
                                        return filters</span>
                                }
                        }
                }

        case ExprTypeColumn:<span class="cov0" title="0">
                if expr.Type == ExprTypeColumn </span><span class="cov0" title="0">{
                        filters = append(filters, domain.Filter{
                                Field:    expr.Column,
                                Operator: "=",
                                Value:    true,
                        })
                        return filters
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// convertOperator 转换操作符
func (b *QueryBuilder) convertOperator(op string) string <span class="cov0" title="0">{
        switch op </span>{
        case "==":<span class="cov0" title="0">
                return "="</span>
        case "!=":<span class="cov0" title="0">
                return "!="</span>
        case "eq", "EQ":<span class="cov0" title="0"> // TiDB Parser使用小写"eq"
                return "="</span>
        case "ne", "NE":<span class="cov0" title="0"> // TiDB Parser使用小写"ne"
                return "!="</span>
        case "&gt;", "gt", "GT":<span class="cov0" title="0">
                return "&gt;"</span>
        case "&lt;", "lt", "LT":<span class="cov0" title="0">
                return "&lt;"</span>
        case "&gt;=", "ge", "GE":<span class="cov0" title="0">
                return "&gt;="</span>
        case "&lt;=", "le", "LE":<span class="cov0" title="0">
                return "&lt;="</span>
        case "like", "LIKE":<span class="cov0" title="0">
                return "LIKE"</span>
        case "in", "IN":<span class="cov0" title="0">
                return "IN"</span>
        case "between", "BETWEEN":<span class="cov0" title="0">
                return "BETWEEN"</span>
        case "and", "AND":<span class="cov0" title="0"> // TiDB Parser使用小写"and"
                return "AND"</span>
        case "or", "OR":<span class="cov0" title="0"> // TiDB Parser使用小写"or"
                return "OR"</span>
        default:<span class="cov0" title="0">
                return op</span>
        }
}

// convertValue 转换值，进行类型验证和转换
func (b *QueryBuilder) convertValue(val interface{}) interface{} <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := val.(type) </span>{
        case int:<span class="cov0" title="0">
                // 显式处理int类型
                return int64(v)</span>
        case int8:<span class="cov0" title="0">
                return int64(v)</span>
        case int16:<span class="cov0" title="0">
                return int64(v)</span>
        case int32:<span class="cov0" title="0">
                return int64(v)</span>
        case int64:<span class="cov0" title="0">
                return v</span>
        case uint:<span class="cov0" title="0">
                return int64(v)</span>
        case uint8:<span class="cov0" title="0">
                return int64(v)</span>
        case uint16:<span class="cov0" title="0">
                return int64(v)</span>
        case uint32:<span class="cov0" title="0">
                return int64(v)</span>
        case uint64:<span class="cov0" title="0">
                return int64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        case float64:<span class="cov0" title="0">
                return v</span>
        case string:<span class="cov0" title="0">
                return v</span>
        case bool:<span class="cov0" title="0">
                return v</span>
        case []interface{}:<span class="cov0" title="0">
                result := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        result[i] = b.convertValue(item)
                }</span>
                <span class="cov0" title="0">return result</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}

// extractExpressionValue 从表达式或值中提取实际值
func (b *QueryBuilder) extractExpressionValue(val interface{}) interface{} <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 如果是 Expression 类型，提取其值
        <span class="cov0" title="0">if expr, ok := val.(*Expression); ok &amp;&amp; expr != nil </span><span class="cov0" title="0">{
                if expr.Type == ExprTypeValue </span><span class="cov0" title="0">{
                        return expr.Value
                }</span>
                // 递归处理嵌套表达式
                <span class="cov0" title="0">if expr.Left != nil </span><span class="cov0" title="0">{
                        return b.extractExpressionValue(expr.Left)
                }</span>
        }

        <span class="cov0" title="0">return b.convertValue(val)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package parser

import (
        "fmt"
)

// CTEInfo CTE(公用表表达式)信息
type CTEInfo struct {
        Name       string          // CTE名称
        Alias      string          // CTE别名
        Subquery   *SelectStatement // CTE子查询
        Columns    []string        // 列别名(可选)
        Recursive  bool            // 是否为递归CTE
}

// WithClause WITH子句(CTE定义)
type WithClause struct {
        CTEs        []*CTEInfo // CTE列表
        IsRecursive bool         // 是否递归
}

// 解析CTE相关函数
// 注意: 由于TiDB Parser的限制,这里提供辅助函数

// NewWithClause 创建WITH子句
func NewWithClause(isRecursive bool) *WithClause <span class="cov0" title="0">{
        return &amp;WithClause{
                CTEs:        make([]*CTEInfo, 0),
                IsRecursive: isRecursive,
        }
}</span>

// AddCTE 添加CTE
func (wc *WithClause) AddCTE(name string, subquery *SelectStatement, columns ...string) <span class="cov0" title="0">{
        cte := &amp;CTEInfo{
                Name:      name,
                Subquery:  subquery,
                Columns:   columns,
                Recursive: wc.IsRecursive,
        }
        wc.CTEs = append(wc.CTEs, cte)
}</span>

// GetCTE 获取CTE
func (wc *WithClause) GetCTE(name string) *CTEInfo <span class="cov0" title="0">{
        for _, cte := range wc.CTEs </span><span class="cov0" title="0">{
                if cte.Name == name </span><span class="cov0" title="0">{
                        return cte
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// HasCTE 检查是否存在CTE
func (wc *WithClause) HasCTE(name string) bool <span class="cov0" title="0">{
        return wc.GetCTE(name) != nil
}</span>

// GetCTENames 获取所有CTE名称
func (wc *WithClause) GetCTENames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(wc.CTEs))
        for _, cte := range wc.CTEs </span><span class="cov0" title="0">{
                names = append(names, cte.Name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// ParseCTEFromTiDB 从TiDB Parser的AST解析CTE
// 注意: TiDB Parser不完全支持CTE解析,这里提供手动构建接口
func ParseCTEFromTiDB(astNode interface{}) (*WithClause, error) <span class="cov0" title="0">{
        // 如果TiDB Parser有CTE支持,可以在这里实现
        // 目前提供手动构建接口
        
        // 示例: 手动构建CTE
        /*
                SELECT * FROM t WHERE id IN (WITH cte AS (SELECT id FROM t2) SELECT * FROM cte)
        
                构建方式:
                wc := parser.NewWithClause(false)
                wc.AddCTE("cte", subqueryStmt)
        */
        
        return nil, fmt.Errorf("CTE parsing from TiDB AST not yet implemented, use manual construction")
}</span>

// CTEOptimizer CTE优化器
type CTEOptimizer struct {
        // 优化配置
        InlineThreshold int  // 内联阈值(行数)
        CacheEnabled   bool // 是否启用缓存
}

// NewCTEOptimizer 创建CTE优化器
func NewCTEOptimizer() *CTEOptimizer <span class="cov0" title="0">{
        return &amp;CTEOptimizer{
                InlineThreshold: 1000,
                CacheEnabled:   true,
        }
}</span>

// Optimize 优化CTE
// 策略:
// 1. CTE只引用一次: 内联(Inline)
// 2. CTE多次引用: 物化(Materialize)并缓存
// 3. 递归CTE: 强制物化
func (opt *CTEOptimizer) Optimize(withClause *WithClause, selectStmt *SelectStatement) (*SelectStatement, error) <span class="cov0" title="0">{
        if withClause == nil || len(withClause.CTEs) == 0 </span><span class="cov0" title="0">{
                return selectStmt, nil
        }</span>

        // 分析每个CTE的引用次数
        <span class="cov0" title="0">refCounts := opt.analyzeCTEReferences(selectStmt)

        // 优化每个CTE
        for _, cte := range withClause.CTEs </span><span class="cov0" title="0">{
                count := refCounts[cte.Name]

                if cte.Recursive </span><span class="cov0" title="0">{
                        // 递归CTE必须物化
                        cte.Subquery = opt.materializeCTE(cte.Subquery)
                }</span> else<span class="cov0" title="0"> if count == 1 </span><span class="cov0" title="0">{
                        // 只引用一次,直接内联
                        opt.inlineCTE(selectStmt, cte)
                }</span> else<span class="cov0" title="0"> if count &gt; 1 &amp;&amp; opt.CacheEnabled </span><span class="cov0" title="0">{
                        // 多次引用,物化并缓存
                        cte.Subquery = opt.materializeCTE(cte.Subquery)
                }</span>
        }

        <span class="cov0" title="0">return selectStmt, nil</span>
}

// analyzeCTEReferences 分析CTE引用次数
func (opt *CTEOptimizer) analyzeCTEReferences(stmt *SelectStatement) map[string]int <span class="cov0" title="0">{
        refCounts := make(map[string]int)
        opt.collectReferences(stmt, refCounts)
        return refCounts
}</span>

// collectReferences 递归收集CTE引用
func (opt *CTEOptimizer) collectReferences(stmt *SelectStatement, refCounts map[string]int) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 检查FROM子句中的CTE引用
        // 注意: 当前SelectStatement.From是string类型,不是表列表
        // 需要解析FROM字符串来识别CTE引用
        <span class="cov0" title="0">if stmt.From != "" </span>{<span class="cov0" title="0">
                // 简化的实现: 假设FROM中可能有CTE引用
                // 实际需要更复杂的SQL解析
                // 这里暂时不实现,因为当前SelectStatement结构不支持表列表
        }</span>

        // 检查JOIN子句中的CTE引用
        <span class="cov0" title="0">for _, join := range stmt.Joins </span><span class="cov0" title="0">{
                if join.Alias != "" </span><span class="cov0" title="0">{
                        refCounts[join.Alias]++
                }</span>
        }
}

// inlineCTE 内联CTE到主查询
func (opt *CTEOptimizer) inlineCTE(mainStmt *SelectStatement, cte *CTEInfo) {<span class="cov0" title="0">
        // 将CTE子查询替换到主查询中引用CTE的位置
        // 这是一个简化的实现
        
        // 实际实现需要:
        // 1. 找到所有引用CTE的表引用
        // 2. 将表引用替换为CTE的子查询
        // 3. 可能需要添加子查询别名
}</span>

// materializeCTE 物化CTE
func (opt *CTEOptimizer) materializeCTE(subquery *SelectStatement) *SelectStatement <span class="cov0" title="0">{
        // 为CTE添加物化标记
        // 实际实现会创建临时表或使用内存缓存

        // 注意: SelectStatement当前没有Hints字段
        // 物化标记应该通过其他方式传递,例如在执行上下文中
        // 这里只是一个占位符实现
        return subquery
}</span>

// CTEContext CTE执行上下文
type CTEContext struct {
        // CTE缓存
        CTEResults map[string][]map[string]interface{}
        
        // CTE是否已物化
        CTEMaterialized map[string]bool
}

// NewCTEContext 创建CTE执行上下文
func NewCTEContext() *CTEContext <span class="cov0" title="0">{
        return &amp;CTEContext{
                CTEResults:     make(map[string][]map[string]interface{}),
                CTEMaterialized: make(map[string]bool),
        }
}</span>

// GetCTEResult 获取CTE结果
func (ctx *CTEContext) GetCTEResult(cteName string) ([]map[string]interface{}, bool) <span class="cov0" title="0">{
        result, exists := ctx.CTEResults[cteName]
        return result, exists
}</span>

// SetCTEResult 设置CTE结果
func (ctx *CTEContext) SetCTEResult(cteName string, result []map[string]interface{}) <span class="cov0" title="0">{
        ctx.CTEResults[cteName] = result
        ctx.CTEMaterialized[cteName] = true
}</span>

// IsCTEMaterialized 检查CTE是否已物化
func (ctx *CTEContext) IsCTEMaterialized(cteName string) bool <span class="cov0" title="0">{
        return ctx.CTEMaterialized[cteName]
}</span>

// ClearCTE 清除指定CTE的缓存
func (ctx *CTEContext) ClearCTE(cteName string) <span class="cov0" title="0">{
        delete(ctx.CTEResults, cteName)
        delete(ctx.CTEMaterialized, cteName)
}</span>

// ClearAll 清除所有CTE缓存
func (ctx *CTEContext) ClearAll() <span class="cov0" title="0">{
        ctx.CTEResults = make(map[string][]map[string]interface{})
        ctx.CTEMaterialized = make(map[string]bool)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package parser

import (
        "fmt"
        "log"

        "github.com/pingcap/tidb/pkg/parser/ast"
)

// StmtHandler SQL 语句处理器接口
type StmtHandler interface {
        Handle(stmt ast.StmtNode) (result interface{}, err error)
}

// HandlerChain 处理器链
type HandlerChain struct {
        handlers map[string]StmtHandler
        defaultHandler StmtHandler
}

// NewHandlerChain 创建新的处理器链
func NewHandlerChain() *HandlerChain <span class="cov0" title="0">{
        return &amp;HandlerChain{
                handlers: make(map[string]StmtHandler),
        }
}</span>

// RegisterHandler 注册处理器
func (c *HandlerChain) RegisterHandler(stmtType string, handler StmtHandler) <span class="cov0" title="0">{
        c.handlers[stmtType] = handler
}</span>

// SetDefaultHandler 设置默认处理器
func (c *HandlerChain) SetDefaultHandler(handler StmtHandler) <span class="cov0" title="0">{
        c.defaultHandler = handler
}</span>

// Handle 处理 SQL 语句
func (c *HandlerChain) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SQL 语句为空")
        }</span>

        <span class="cov0" title="0">stmtType := GetStmtType(stmt)
        log.Printf("SQL 语句类型: %s", stmtType)

        // 查找对应的处理器
        handler, ok := c.handlers[stmtType]
        if !ok </span><span class="cov0" title="0">{
                // 使用默认处理器
                if c.defaultHandler != nil </span><span class="cov0" title="0">{
                        return c.defaultHandler.Handle(stmt)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("不支持的 SQL 语句类型: %s", stmtType)</span>
        }

        <span class="cov0" title="0">return handler.Handle(stmt)</span>
}

// QueryHandler SELECT 查询处理器
type QueryHandler struct{}

// NewQueryHandler 创建查询处理器
func NewQueryHandler() *QueryHandler <span class="cov0" title="0">{
        return &amp;QueryHandler{}
}</span>

// Handle 处理 SELECT 语句
func (h *QueryHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        selectStmt, ok := stmt.(*ast.SelectStmt)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("不是 SELECT 语句")
        }</span>

        <span class="cov0" title="0">log.Printf("处理 SELECT 语句")
        
        // 提取查询信息
        info := ExtractSQLInfo(stmt)
        log.Printf("涉及表: %v", info.Tables)
        log.Printf("涉及列: %v", info.Columns)

        // 返回查询结果
        return &amp;QueryResult{
                Type:     "SELECT",
                Tables:   info.Tables,
                Columns:  info.Columns,
                Stmt:     selectStmt,
        }, nil</span>
}

// DMLHandler DML 语句处理器（INSERT/UPDATE/DELETE）
type DMLHandler struct{}

// NewDMLHandler 创建 DML 处理器
func NewDMLHandler() *DMLHandler <span class="cov0" title="0">{
        return &amp;DMLHandler{}
}</span>

// Handle 处理 DML 语句
func (h *DMLHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        info := ExtractSQLInfo(stmt)

        var stmtType string
        switch stmt.(type) </span>{
        case *ast.InsertStmt:<span class="cov0" title="0">
                stmtType = "INSERT"</span>
        case *ast.UpdateStmt:<span class="cov0" title="0">
                stmtType = "UPDATE"</span>
        case *ast.DeleteStmt:<span class="cov0" title="0">
                stmtType = "DELETE"</span>
        default:<span class="cov0" title="0">
                stmtType = "UNKNOWN"</span>
        }

        <span class="cov0" title="0">log.Printf("处理 %s 语句", stmtType)
        log.Printf("涉及表: %v", info.Tables)
        log.Printf("涉及列: %v", info.Columns)

        return &amp;DMLResult{
                Type:    stmtType,
                Tables:  info.Tables,
                Columns: info.Columns,
                Affected: 1, // 默认影响行数
        }, nil</span>
}

// DDLHandler DDL 语句处理器（CREATE/DROP/ALTER）
type DDLHandler struct{}

// NewDDLHandler 创建 DDL 处理器
func NewDDLHandler() *DDLHandler <span class="cov0" title="0">{
        return &amp;DDLHandler{}
}</span>

// Handle 处理 DDL 语句
func (h *DDLHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        info := ExtractSQLInfo(stmt)

        var stmtType string
        switch stmt.(type) </span>{
        case *ast.CreateTableStmt:<span class="cov0" title="0">
                stmtType = "CREATE_TABLE"</span>
        case *ast.DropTableStmt:<span class="cov0" title="0">
                stmtType = "DROP_TABLE"</span>
        case *ast.CreateDatabaseStmt:<span class="cov0" title="0">
                stmtType = "CREATE_DATABASE"</span>
        case *ast.DropDatabaseStmt:<span class="cov0" title="0">
                stmtType = "DROP_DATABASE"</span>
        case *ast.AlterTableStmt:<span class="cov0" title="0">
                stmtType = "ALTER_TABLE"</span>
        case *ast.TruncateTableStmt:<span class="cov0" title="0">
                stmtType = "TRUNCATE_TABLE"</span>
        default:<span class="cov0" title="0">
                stmtType = "UNKNOWN"</span>
        }

        <span class="cov0" title="0">log.Printf("处理 %s 语句", stmtType)
        log.Printf("涉及表: %v", info.Tables)
        log.Printf("涉及数据库: %v", info.Databases)

        return &amp;DDLResult{
                Type:      stmtType,
                Tables:    info.Tables,
                Databases: info.Databases,
        }, nil</span>
}

// SetHandler SET 语句处理器
type SetHandler struct{}

// NewSetHandler 创建 SET 处理器
func NewSetHandler() *SetHandler <span class="cov0" title="0">{
        return &amp;SetHandler{}
}</span>

// Handle 处理 SET 语句
func (h *SetHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        setStmt, ok := stmt.(*ast.SetStmt)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("不是 SET 语句")
        }</span>

        <span class="cov0" title="0">log.Printf("处理 SET 语句，变量数量: %d", len(setStmt.Variables))

        vars := make(map[string]interface{})
        for _, variable := range setStmt.Variables </span><span class="cov0" title="0">{
                varName := variable.Name
                if varName == "" </span><span class="cov0" title="0">{
                        varName = SetNames
                }</span>
                
                <span class="cov0" title="0">varValue := ""
                if variable.Value != nil </span><span class="cov0" title="0">{
                        varValue = fmt.Sprintf("%v", variable.Value)
                }</span>

                <span class="cov0" title="0">vars[varName] = varValue
                log.Printf("设置变量: %s = %s", varName, varValue)</span>
        }

        <span class="cov0" title="0">return &amp;SetResult{
                Type:  "SET",
                Vars:  vars,
                Count: len(setStmt.Variables),
        }, nil</span>
}

// ShowHandler SHOW 语句处理器
type ShowHandler struct{}

// NewShowHandler 创建 SHOW 处理器
func NewShowHandler() *ShowHandler <span class="cov0" title="0">{
        return &amp;ShowHandler{}
}</span>

// Handle 处理 SHOW 语句
func (h *ShowHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        showStmt, ok := stmt.(*ast.ShowStmt)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("不是 SHOW 语句")
        }</span>

        <span class="cov0" title="0">log.Printf("处理 SHOW 语句")

        info := ExtractSQLInfo(stmt)

        return &amp;ShowResult{
                Type:   "SHOW",
                ShowTp: fmt.Sprintf("%v", showStmt.Tp),
                Tables: info.Tables,
        }, nil</span>
}

// UseHandler USE 语句处理器
type UseHandler struct{}

// NewUseHandler 创建 USE 处理器
func NewUseHandler() *UseHandler <span class="cov0" title="0">{
        return &amp;UseHandler{}
}</span>

// Handle 处理 USE 语句
func (h *UseHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        useStmt, ok := stmt.(*ast.UseStmt)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("不是 USE 语句")
        }</span>

        <span class="cov0" title="0">dbName := useStmt.DBName

        log.Printf("处理 USE 语句，切换到数据库: %s", dbName)

        return &amp;UseResult{
                Type:     "USE",
                Database: dbName,
        }, nil</span>
}

// DefaultHandler 默认处理器
type DefaultHandler struct{}

// NewDefaultHandler 创建默认处理器
func NewDefaultHandler() *DefaultHandler <span class="cov0" title="0">{
        return &amp;DefaultHandler{}
}</span>

// Handle 处理未知类型语句
func (h *DefaultHandler) Handle(stmt ast.StmtNode) (interface{}, error) <span class="cov0" title="0">{
        stmtType := GetStmtType(stmt)
        log.Printf("使用默认处理器处理语句: %s", stmtType)
        
        return &amp;DefaultResult{
                Type: stmtType,
                Stmt: stmt,
        }, nil
}</span>

// 查询结果
type QueryResult struct {
        Type    string
        Tables  []string
        Columns []string
        Stmt    *ast.SelectStmt
}

// DML 结果
type DMLResult struct {
        Type     string
        Tables   []string
        Columns  []string
        Affected int64
}

// DDL 结果
type DDLResult struct {
        Type      string
        Tables    []string
        Databases []string
}

// SET 结果
type SetResult struct {
        Type  string
        Vars  map[string]interface{}
        Count int
}

// SHOW 结果
type ShowResult struct {
        Type   string
        ShowTp string
        Tables []string
}

// USE 结果
type UseResult struct {
        Type     string
        Database string
}

// 默认结果
type DefaultResult struct {
        Type string
        Stmt ast.StmtNode
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package parser

import (
        "fmt"
        "strings"

        "github.com/pingcap/tidb/pkg/parser"
        "github.com/pingcap/tidb/pkg/parser/ast"
        _ "github.com/pingcap/tidb/pkg/parser/test_driver"
)

// Parser SQL 解析器，封装 TiDB parser
type Parser struct {
        parser *parser.Parser
}

// NewParser 创建新的 SQL 解析器
func NewParser() *Parser <span class="cov8" title="1">{
        return &amp;Parser{
                parser: parser.New(),
        }
}</span>

// ParseSQL 解析 SQL 语句，返回 AST 节点列表
func (p *Parser) ParseSQL(sql string) ([]ast.StmtNode, error) <span class="cov8" title="1">{
        stmtNodes, warnings, err := p.parser.ParseSQL(sql)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("解析 SQL 失败: %w", err)
        }</span>
        <span class="cov8" title="1">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                // 记录警告信息
                for _, warn := range warnings </span><span class="cov0" title="0">{
                        fmt.Printf("解析警告: %s\n", warn.Error())
                }</span>
        }
        <span class="cov8" title="1">return stmtNodes, nil</span>
}

// ParseOneStmt 解析单条 SQL 语句
func (p *Parser) ParseOneStmt(sql string) (ast.StmtNode, error) <span class="cov8" title="1">{
        stmts, err := p.ParseSQL(sql)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(stmts) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("未解析到 SQL 语句")
        }</span>
        <span class="cov8" title="1">return stmts[0], nil</span>
}

// ParseOneStmtText 解析 SQL 文本（去除注释和空白）
func (p *Parser) ParseOneStmtText(sql string) (ast.StmtNode, error) <span class="cov8" title="1">{
        // 去除首尾空白
        sql = strings.TrimSpace(sql)
        if sql == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SQL 语句为空")
        }</span>
        <span class="cov8" title="1">return p.ParseOneStmt(sql)</span>
}

// ParseSelectStmt 解析 SELECT 语句
func (p *Parser) ParseSelectStmt(sql string) (*ast.SelectStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">selectStmt, ok := stmt.(*ast.SelectStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 SELECT 语句")
        }</span>
        <span class="cov8" title="1">return selectStmt, nil</span>
}

// ParseInsertStmt 解析 INSERT 语句
func (p *Parser) ParseInsertStmt(sql string) (*ast.InsertStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">insertStmt, ok := stmt.(*ast.InsertStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 INSERT 语句")
        }</span>
        <span class="cov8" title="1">return insertStmt, nil</span>
}

// ParseUpdateStmt 解析 UPDATE 语句
func (p *Parser) ParseUpdateStmt(sql string) (*ast.UpdateStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">updateStmt, ok := stmt.(*ast.UpdateStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 UPDATE 语句")
        }</span>
        <span class="cov8" title="1">return updateStmt, nil</span>
}

// ParseDeleteStmt 解析 DELETE 语句
func (p *Parser) ParseDeleteStmt(sql string) (*ast.DeleteStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">deleteStmt, ok := stmt.(*ast.DeleteStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 DELETE 语句")
        }</span>
        <span class="cov8" title="1">return deleteStmt, nil</span>
}

// ParseSetStmt 解析 SET 语句
func (p *Parser) ParseSetStmt(sql string) (*ast.SetStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">setStmt, ok := stmt.(*ast.SetStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 SET 语句")
        }</span>
        <span class="cov8" title="1">return setStmt, nil</span>
}

// ParseShowStmt 解析 SHOW 语句
func (p *Parser) ParseShowStmt(sql string) (*ast.ShowStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">showStmt, ok := stmt.(*ast.ShowStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 SHOW 语句")
        }</span>
        <span class="cov8" title="1">return showStmt, nil</span>
}

// ParseUseStmt 解析 USE 语句
func (p *Parser) ParseUseStmt(sql string) (*ast.UseStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">useStmt, ok := stmt.(*ast.UseStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 USE 语句")
        }</span>
        <span class="cov8" title="1">return useStmt, nil</span>
}

// ParseCreateTableStmt 解析 CREATE TABLE 语句
func (p *Parser) ParseCreateTableStmt(sql string) (*ast.CreateTableStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">createTableStmt, ok := stmt.(*ast.CreateTableStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 CREATE TABLE 语句")
        }</span>
        <span class="cov8" title="1">return createTableStmt, nil</span>
}

// ParseDropTableStmt 解析 DROP TABLE 语句
func (p *Parser) ParseDropTableStmt(sql string) (*ast.DropTableStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">dropTableStmt, ok := stmt.(*ast.DropTableStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 DROP TABLE 语句")
        }</span>
        <span class="cov8" title="1">return dropTableStmt, nil</span>
}

// ParseCreateDatabaseStmt 解析 CREATE DATABASE 语句
func (p *Parser) ParseCreateDatabaseStmt(sql string) (*ast.CreateDatabaseStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">createDBStmt, ok := stmt.(*ast.CreateDatabaseStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 CREATE DATABASE 语句")
        }</span>
        <span class="cov8" title="1">return createDBStmt, nil</span>
}

// ParseDropDatabaseStmt 解析 DROP DATABASE 语句
func (p *Parser) ParseDropDatabaseStmt(sql string) (*ast.DropDatabaseStmt, error) <span class="cov8" title="1">{
        stmt, err := p.ParseOneStmt(sql)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">dropDBStmt, ok := stmt.(*ast.DropDatabaseStmt)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("不是 DROP DATABASE 语句")
        }</span>
        <span class="cov8" title="1">return dropDBStmt, nil</span>
}

// GetStmtType 获取 SQL 语句类型
func GetStmtType(stmt ast.StmtNode) string <span class="cov8" title="1">{
        if stmt == nil </span><span class="cov8" title="1">{
                return "UNKNOWN"
        }</span>
        
        <span class="cov8" title="1">switch stmt.(type) </span>{
        case *ast.SelectStmt:<span class="cov8" title="1">
                return "SELECT"</span>
        case *ast.InsertStmt:<span class="cov8" title="1">
                return "INSERT"</span>
        case *ast.UpdateStmt:<span class="cov8" title="1">
                return "UPDATE"</span>
        case *ast.DeleteStmt:<span class="cov8" title="1">
                return "DELETE"</span>
        case *ast.SetStmt:<span class="cov8" title="1">
                return "SET"</span>
        case *ast.ShowStmt:<span class="cov8" title="1">
                return "SHOW"</span>
        case *ast.UseStmt:<span class="cov8" title="1">
                return "USE"</span>
        case *ast.CreateTableStmt:<span class="cov8" title="1">
                return "CREATE_TABLE"</span>
        case *ast.DropTableStmt:<span class="cov8" title="1">
                return "DROP_TABLE"</span>
        case *ast.CreateDatabaseStmt:<span class="cov8" title="1">
                return "CREATE_DATABASE"</span>
        case *ast.DropDatabaseStmt:<span class="cov8" title="1">
                return "DROP_DATABASE"</span>
        case *ast.AlterTableStmt:<span class="cov0" title="0">
                return "ALTER_TABLE"</span>
        case *ast.TruncateTableStmt:<span class="cov0" title="0">
                return "TRUNCATE_TABLE"</span>
        case *ast.BeginStmt:<span class="cov0" title="0">
                return "BEGIN"</span>
        case *ast.CommitStmt:<span class="cov0" title="0">
                return "COMMIT"</span>
        case *ast.RollbackStmt:<span class="cov0" title="0">
                return "ROLLBACK"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// IsWriteOperation 判断是否为写操作
func IsWriteOperation(stmt ast.StmtNode) bool <span class="cov8" title="1">{
        switch stmt.(type) </span>{
        case *ast.InsertStmt, *ast.UpdateStmt, *ast.DeleteStmt,
                *ast.CreateTableStmt, *ast.DropTableStmt, *ast.CreateDatabaseStmt,
                *ast.DropDatabaseStmt, *ast.AlterTableStmt, *ast.TruncateTableStmt:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// IsReadOperation 判断是否为读操作
func IsReadOperation(stmt ast.StmtNode) bool <span class="cov8" title="1">{
        switch stmt.(type) </span>{
        case *ast.SelectStmt, *ast.ShowStmt:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// IsTransactionOperation 判断是否为事务操作
func IsTransactionOperation(stmt ast.StmtNode) bool <span class="cov8" title="1">{
        switch stmt.(type) </span>{
        case *ast.BeginStmt, *ast.CommitStmt, *ast.RollbackStmt:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package parser

import (
        "fmt"
)

// ProcedureInfo 存储过程信息
type ProcedureInfo struct {
        Name     string
        Params   []ProcedureParam
        Body     *BlockStmt
        Returns  []ColumnInfo // 返回值(用于函数)
}

// FunctionInfo 函数信息
type FunctionInfo struct {
        Name       string
        Params     []ProcedureParam
        ReturnType string
        Body       *BlockStmt
}

// ProcedureParam 参数定义
type ProcedureParam struct {
        Name      string
        ParamType ParamType
        DataType  string
}

// ParamType 参数类型
type ParamType int

const (
        ParamTypeIn     ParamType = iota // IN参数
        ParamTypeOut                     // OUT参数
        ParamTypeInOut                   // INOUT参数
)

// BlockStmt 语句块
type BlockStmt struct {
        Declarations []Declaration
        Statements  []Statement
}

// Declaration 变量声明
type Declaration struct {
        Name     string
        DataType string
        Initial  interface{} // 初始值(可选)
}

// Statement 语句
type Statement interface{}

// ProcedureStmt 存储过程语句
type ProcedureStmt struct {
        Name   string
        Params []ProcedureParam
        Body   *BlockStmt
}

// FunctionStmt 函数语句
type FunctionStmt struct {
        Name       string
        Params     []ProcedureParam
        ReturnType string
        Body       *BlockStmt
}

// IfStmt IF语句
type IfStmt struct {
        Condition  Expression
        Then       *BlockStmt
        ElseIfs    []*ElseIfStmt
        Else       *BlockStmt
}

// ElseIfStmt ELSE IF语句
type ElseIfStmt struct {
        Condition Expression
        Then      *BlockStmt
}

// WhileStmt WHILE语句
type WhileStmt struct {
        Condition Expression
        Body      *BlockStmt
}

// CaseStmt CASE语句
type CaseStmt struct {
        Expression Expression // 可选的表达式
        Cases      []CaseWhen
        Else       *BlockStmt
}

// CaseWhen CASE WHEN
type CaseWhen struct {
        Condition Expression
        Then      *BlockStmt
}

// SetStmt SET语句
type SetStmt struct {
        Variable string
        Value    Expression
}

// DeclareStmt DECLARE语句
type DeclareStmt struct {
        Variables []Declaration
}

// ReturnStmt RETURN语句
type ReturnStmt struct {
        Expression Expression // 返回值(可选)
}

// CallStmt CALL语句
type CallStmt struct {
        ProcedureName string
        Args         []Expression // 参数
}

// 创建辅助函数

// NewProcedure 创建存储过程
func NewProcedure(name string, body *BlockStmt, params ...ProcedureParam) *ProcedureStmt <span class="cov0" title="0">{
        return &amp;ProcedureStmt{
                Name:   name,
                Params: params,
                Body:   body,
        }
}</span>

// NewFunction 创建函数
func NewFunction(name string, returnType string, body *BlockStmt, params ...ProcedureParam) *FunctionStmt <span class="cov0" title="0">{
        return &amp;FunctionStmt{
                Name:       name,
                ReturnType:  returnType,
                Params:     params,
                Body:       body,
        }
}</span>

// NewBlock 创建语句块
func NewBlock(decls []Declaration, stmts []Statement) *BlockStmt <span class="cov0" title="0">{
        return &amp;BlockStmt{
                Declarations: decls,
                Statements:  stmts,
        }
}</span>

// NewIf 创建IF语句
func NewIf(condition Expression, thenBlock *BlockStmt) *IfStmt <span class="cov0" title="0">{
        return &amp;IfStmt{
                Condition: condition,
                Then:      thenBlock,
                ElseIfs:   []*ElseIfStmt{},
                Else:      nil,
        }
}</span>

// AddElseIf 添加ELSE IF
func (is *IfStmt) AddElseIf(condition Expression, thenBlock *BlockStmt) <span class="cov0" title="0">{
        is.ElseIfs = append(is.ElseIfs, &amp;ElseIfStmt{
                Condition: condition,
                Then:      thenBlock,
        })
}</span>

// AddElse 添加ELSE
func (is *IfStmt) AddElse(elseBlock *BlockStmt) <span class="cov0" title="0">{
        is.Else = elseBlock
}</span>

// NewWhile 创建WHILE语句
func NewWhile(condition Expression, body *BlockStmt) *WhileStmt <span class="cov0" title="0">{
        return &amp;WhileStmt{
                Condition: condition,
                Body:      body,
        }
}</span>

// NewCase 创建CASE语句
func NewCase(expr Expression) *CaseStmt <span class="cov0" title="0">{
        return &amp;CaseStmt{
                Expression: expr,
                Cases:      []CaseWhen{},
                Else:       nil,
        }
}</span>

// AddWhen 添加WHEN
func (cs *CaseStmt) AddWhen(condition Expression, thenBlock *BlockStmt) <span class="cov0" title="0">{
        cs.Cases = append(cs.Cases, CaseWhen{
                Condition: condition,
                Then:      thenBlock,
        })
}</span>

// AddElse 添加ELSE
func (cs *CaseStmt) AddElse(elseBlock *BlockStmt) <span class="cov0" title="0">{
        cs.Else = elseBlock
}</span>

// NewSet 创建SET语句
func NewSet(variable string, value Expression) *SetStmt <span class="cov0" title="0">{
        return &amp;SetStmt{
                Variable: variable,
                Value:    value,
        }
}</span>

// NewDeclare 创建DECLARE语句
func NewDeclare(decls ...Declaration) *DeclareStmt <span class="cov0" title="0">{
        return &amp;DeclareStmt{
                Variables: decls,
        }
}</span>

// NewParam 创建参数
func NewParam(name string, paramType ParamType, dataType string) ProcedureParam <span class="cov0" title="0">{
        return ProcedureParam{
                Name:      name,
                ParamType: paramType,
                DataType:  dataType,
        }
}</span>

// NewReturn 创建RETURN语句
func NewReturn(expr Expression) *ReturnStmt <span class="cov0" title="0">{
        return &amp;ReturnStmt{
                Expression: expr,
        }
}</span>

// NewCall 创建CALL语句
func NewCall(procedureName string, args ...Expression) *CallStmt <span class="cov0" title="0">{
        return &amp;CallStmt{
                ProcedureName: procedureName,
                Args:         args,
        }
}</span>

// 变量帮助函数

// ParseVariableName 解析变量名
// 支持格式: @var_name, @@var_name(系统变量), :var_name(绑定变量)
func ParseVariableName(name string) (string, error) <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("empty variable name")
        }</span>
        
        // 移除前缀
        <span class="cov0" title="0">switch </span>{
        case name[0] == '@':<span class="cov0" title="0">
                if len(name) &gt; 1 &amp;&amp; name[1] == '@' </span><span class="cov0" title="0">{
                        // 系统变量: @@var_name
                        return name[2:], nil
                }</span>
                // 用户变量: @var_name
                <span class="cov0" title="0">return name[1:], nil</span>
        case name[0] == ':':<span class="cov0" title="0">
                // 绑定变量: :var_name
                return name[1:], nil</span>
        default:<span class="cov0" title="0">
                // 无前缀
                return name, nil</span>
        }
}

// 验证函数

// ValidateProcedure 验证存储过程
func ValidateProcedure(proc *ProcedureStmt) error <span class="cov0" title="0">{
        if proc == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("procedure is nil")
        }</span>
        
        <span class="cov0" title="0">if proc.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("procedure name is required")
        }</span>
        
        <span class="cov0" title="0">if proc.Body == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("procedure body is required")
        }</span>
        
        // 检查参数名重复
        <span class="cov0" title="0">paramNames := make(map[string]bool)
        for _, param := range proc.Params </span><span class="cov0" title="0">{
                if param.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("parameter name is required")
                }</span>
                
                <span class="cov0" title="0">if paramNames[param.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate parameter name: %s", param.Name)
                }</span>
                <span class="cov0" title="0">paramNames[param.Name] = true</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateFunction 验证函数
func ValidateFunction(fn *FunctionStmt) error <span class="cov0" title="0">{
        if fn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function is nil")
        }</span>
        
        <span class="cov0" title="0">if fn.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("function name is required")
        }</span>
        
        <span class="cov0" title="0">if fn.ReturnType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("function return type is required")
        }</span>
        
        <span class="cov0" title="0">if fn.Body == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function body is required")
        }</span>
        
        // 检查参数名重复
        <span class="cov0" title="0">paramNames := make(map[string]bool)
        for _, param := range fn.Params </span><span class="cov0" title="0">{
                if param.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("parameter name is required")
                }</span>
                
                <span class="cov0" title="0">if paramNames[param.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate parameter name: %s", param.Name)
                }</span>
                <span class="cov0" title="0">paramNames[param.Name] = true</span>
        }
        
        // 检查函数体是否有RETURN语句
        <span class="cov0" title="0">hasReturn := false
        for _, stmt := range fn.Body.Statements </span><span class="cov0" title="0">{
                if _, ok := stmt.(*ReturnStmt); ok </span><span class="cov0" title="0">{
                        hasReturn = true
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if !hasReturn </span><span class="cov0" title="0">{
                return fmt.Errorf("function must have a RETURN statement")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// 类型转换

// ToProcedureParamType 转换参数类型字符串为ParamType
func ToProcedureParamType(mode string) (ParamType, error) <span class="cov0" title="0">{
        switch mode </span>{
        case "IN":<span class="cov0" title="0">
                return ParamTypeIn, nil</span>
        case "OUT":<span class="cov0" title="0">
                return ParamTypeOut, nil</span>
        case "INOUT":<span class="cov0" title="0">
                return ParamTypeInOut, nil</span>
        default:<span class="cov0" title="0">
                return ParamTypeIn, fmt.Errorf("unknown parameter type: %s", mode)</span>
        }
}

// ToString 返回参数类型的字符串表示
func (pt ParamType) ToString() string <span class="cov0" title="0">{
        switch pt </span>{
        case ParamTypeIn:<span class="cov0" title="0">
                return "IN"</span>
        case ParamTypeOut:<span class="cov0" title="0">
                return "OUT"</span>
        case ParamTypeInOut:<span class="cov0" title="0">
                return "INOUT"</span>
        default:<span class="cov0" title="0">
                return "IN"</span>
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package parser

import (
        "fmt"
)

// SQLType SQL 语句类型
type SQLType string

const (
        SQLTypeSelect    SQLType = "SELECT"
        SQLTypeInsert    SQLType = "INSERT"
        SQLTypeUpdate    SQLType = "UPDATE"
        SQLTypeDelete    SQLType = "DELETE"
        SQLTypeCreate    SQLType = "CREATE"
        SQLTypeDrop      SQLType = "DROP"
        SQLTypeAlter     SQLType = "ALTER"
        SQLTypeTruncate  SQLType = "TRUNCATE"
        SQLTypeShow      SQLType = "SHOW"
        SQLTypeDescribe  SQLType = "DESCRIBE"
        SQLTypeExplain   SQLType = "EXPLAIN"
        SQLTypeBegin     SQLType = "BEGIN"
        SQLTypeCommit    SQLType = "COMMIT"
        SQLTypeRollback  SQLType = "ROLLBACK"
        SQLTypeUse       SQLType = "USE"
        SQLTypeUnknown   SQLType = "UNKNOWN"

        // 排序方向
        SortAsc  = "ASC"
        SortDesc = "DESC"
)

// SQLStatement SQL 语句
type SQLStatement struct {
        Type       SQLType               `json:"type"`
        RawSQL     string                `json:"raw_sql"`
        Select     *SelectStatement       `json:"select,omitempty"`
        Insert     *InsertStatement       `json:"insert,omitempty"`
        Update     *UpdateStatement       `json:"update,omitempty"`
        Delete     *DeleteStatement       `json:"delete,omitempty"`
        Create     *CreateStatement       `json:"create,omitempty"`
        Drop       *DropStatement         `json:"drop,omitempty"`
        Alter      *AlterStatement        `json:"alter,omitempty"`
        CreateIndex *CreateIndexStatement `json:"create_index,omitempty"`
        DropIndex   *DropIndexStatement   `json:"drop_index,omitempty"`
        Show       *ShowStatement        `json:"show,omitempty"`
        Describe   *DescribeStatement    `json:"describe,omitempty"`
        Explain    *ExplainStatement     `json:"explain,omitempty"`
        Begin      *TransactionStatement `json:"begin,omitempty"`
        Commit     *TransactionStatement `json:"commit,omitempty"`
        Rollback   *TransactionStatement `json:"rollback,omitempty"`
        Use        *UseStatement        `json:"use,omitempty"`
}

// SelectStatement SELECT 语句
type SelectStatement struct {
        Distinct   bool            `json:"distinct"`
        Columns    []SelectColumn  `json:"columns"`
        From       string          `json:"from"`
        Joins      []JoinInfo      `json:"joins,omitempty"`
        Where      *Expression     `json:"where,omitempty"`
        GroupBy    []string        `json:"group_by,omitempty"`
        Having     *Expression     `json:"having,omitempty"`
        OrderBy    []OrderByItem   `json:"order_by,omitempty"`
        Limit      *int64          `json:"limit,omitempty"`
        Offset     *int64          `json:"offset,omitempty"`
}

// InsertStatement INSERT 语句
type InsertStatement struct {
        Table      string         `json:"table"`
        Columns    []string       `json:"columns,omitempty"`
        Values     [][]interface{} `json:"values"`
        OnDuplicate *UpdateStatement `json:"on_duplicate,omitempty"`
}

// UpdateStatement UPDATE 语句
type UpdateStatement struct {
        Table   string            `json:"table"`
        Set     map[string]interface{} `json:"set"`
        Where   *Expression       `json:"where,omitempty"`
        OrderBy []OrderByItem     `json:"order_by,omitempty"`
        Limit   *int64            `json:"limit,omitempty"`
}

// DeleteStatement DELETE 语句
type DeleteStatement struct {
        Table   string        `json:"table"`
        Where   *Expression   `json:"where,omitempty"`
        OrderBy []OrderByItem `json:"order_by,omitempty"`
        Limit   *int64        `json:"limit,omitempty"`
}

// CreateStatement CREATE 语句
type CreateStatement struct {
        Type      string           `json:"type"` // TABLE, DATABASE, INDEX, etc.
        Name      string           `json:"name"`
        Columns   []ColumnInfo     `json:"columns,omitempty"`
        Options   map[string]interface{} `json:"options,omitempty"`
}

// DropStatement DROP 语句
type DropStatement struct {
        Type      string `json:"type"` // TABLE, DATABASE, INDEX, etc.
        Name      string `json:"name"`
        IfExists  bool   `json:"if_exists"`
}

// AlterStatement ALTER 语句
type AlterStatement struct {
        Type      string            `json:"type"` // TABLE, etc.
        Name      string            `json:"name"`
        Actions   []AlterAction     `json:"actions,omitempty"`
}

// AlterAction ALTER 操作
type AlterAction struct {
        Type     string            `json:"type"` // ADD, DROP, MODIFY, CHANGE, etc.
        Column   *ColumnInfo       `json:"column,omitempty"`
        OldName  string            `json:"old_name,omitempty"`
        NewName  string            `json:"new_name,omitempty"`
}

// CreateIndexStatement CREATE INDEX 语句
type CreateIndexStatement struct {
        IndexName  string   `json:"index_name"`
        TableName  string   `json:"table_name"`
        ColumnName string   `json:"column_name"`
        IndexType  string   `json:"index_type"` // BTREE, HASH, FULLTEXT
        Unique     bool     `json:"unique"`
        IfExists   bool     `json:"if_exists"`
}

// DropIndexStatement DROP INDEX 语句
type DropIndexStatement struct {
        IndexName string `json:"index_name"`
        TableName string `json:"table_name"`
        IfExists  bool   `json:"if_exists"`
}

// ShowStatement SHOW 语句
type ShowStatement struct {
        Type   string `json:"type"` // TABLES, DATABASES, COLUMNS, etc.
        Table  string `json:"table,omitempty"`
        Where  string `json:"where,omitempty"`
        Like   string `json:"like,omitempty"`
}

// DescribeStatement DESCRIBE 语句
type DescribeStatement struct {
        Table  string `json:"table"`
        Column string `json:"column,omitempty"`
}

// ExplainStatement EXPLAIN 语句
type ExplainStatement struct {
        Query      *SelectStatement `json:"query,omitempty"`      // The query to explain
        TargetSQL  string          `json:"target_sql,omitempty"` // Raw SQL string
        Format     string          `json:"format,omitempty"`    // Format type (e.g., "TREE", "JSON")
        Analyze    bool            `json:"analyze,omitempty"`   // EXPLAIN ANALYZE
}

// UseStatement USE 语句
type UseStatement struct {
        Database string `json:"database"` // 数据库名
}

// SelectColumn SELECT 列
type SelectColumn struct {
        Name      string      `json:"name"`
        Alias     string      `json:"alias,omitempty"`
        Table     string      `json:"table,omitempty"`
        Expr      *Expression `json:"expr,omitempty"`
        IsWildcard bool       `json:"is_wildcard"` // 是否是 *
}

// JoinInfo JOIN 信息
type JoinInfo struct {
        Type      JoinType   `json:"type"`
        Table     string     `json:"table"`
        Alias     string     `json:"alias,omitempty"`
        Condition *Expression `json:"condition,omitempty"`
}

// JoinType JOIN 类型
type JoinType string

const (
        JoinTypeInner  JoinType = "INNER"
        JoinTypeLeft   JoinType = "LEFT"
        JoinTypeRight  JoinType = "RIGHT"
        JoinTypeFull   JoinType = "FULL"
        JoinTypeCross  JoinType = "CROSS"
)

// TransactionStatement 事务语句
type TransactionStatement struct {
        Level string `json:"level,omitempty"` // 隔离级别：READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE
}

// Expression 表达式
type Expression struct {
        Type      ExprType         `json:"type"`
        Column    string           `json:"column,omitempty"`
        Value     interface{}      `json:"value,omitempty"`
        Operator  string           `json:"operator,omitempty"`
        Left      *Expression      `json:"left,omitempty"`
        Right     *Expression      `json:"right,omitempty"`
        Args      []Expression     `json:"args,omitempty"`
        Function  string           `json:"function,omitempty"`
}

// ExprType 表达式类型
type ExprType string

const (
        ExprTypeColumn    ExprType = "COLUMN"
        ExprTypeValue     ExprType = "VALUE"
        ExprTypeOperator  ExprType = "OPERATOR"
        ExprTypeFunction  ExprType = "FUNCTION"
        ExprTypeList      ExprType = "LIST"
)

// OrderByItem 排序项
type OrderByItem struct {
        Column    string `json:"column"`
        Direction string `json:"direction"` // ASC, DESC
}

// ColumnInfo 列信息（用于 DDL）
type ColumnInfo struct {
        Name      string      `json:"name"`
        Type      string      `json:"type"`
        Nullable  bool        `json:"nullable"`
        Primary   bool        `json:"primary"`
        Default   interface{} `json:"default,omitempty"`
        AutoInc   bool        `json:"auto_increment"`
        Unique    bool        `json:"unique"`
        Comment   string      `json:"comment,omitempty"`
}

// ParseResult 解析结果
type ParseResult struct {
        Statement *SQLStatement `json:"statement"`
        Success   bool          `json:"success"`
        Error     string        `json:"error,omitempty"`
}

// ParserError 解析错误
type ParserError struct {
        SQL     string `json:"sql"`
        Message string `json:"message"`
        Pos     int    `json:"pos"`
}

func (e *ParserError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("SQL parse error at position %d: %s", e.Pos, e.Message)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package parser

import (
        "github.com/pingcap/tidb/pkg/parser/ast"
)

const (
        SetNames  = "SET NAMES"
        SetCharset = "SET CHARSET"
)

// SQLInfo 提取的 SQL 信息
type SQLInfo struct {
        Tables     []string // 涉及的表名
        Columns    []string // 涉及的列名
        Databases  []string // 涉及的数据库名
        WhereExpr  ast.ExprNode // WHERE 条件表达式
        LimitExpr  *ast.Limit   // LIMIT 表达式
        OrderByItems []*ast.ByItem // ORDER BY 子句
        GroupByItems []*ast.ByItem    // GROUP BY 子句
        Having     ast.ExprNode      // HAVING 子句
        IsSelect   bool
        IsInsert   bool
        IsUpdate   bool
        IsDelete   bool
        IsDDL      bool
}

// SQLVisitor AST 访问器，用于提取 SQL 信息
type SQLVisitor struct {
        info *SQLInfo
}

// NewSQLVisitor 创建新的 SQL 访问器
func NewSQLVisitor() *SQLVisitor <span class="cov0" title="0">{
        return &amp;SQLVisitor{
                info: &amp;SQLInfo{
                        Tables:    make([]string, 0),
                        Columns:   make([]string, 0),
                        Databases: make([]string, 0),
                },
        }
}</span>

// GetInfo 获取提取的 SQL 信息
func (v *SQLVisitor) GetInfo() *SQLInfo <span class="cov0" title="0">{
        return v.info
}</span>

// Enter 进入节点
func (v *SQLVisitor) Enter(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        switch node := n.(type) </span>{
        case *ast.TableName:<span class="cov0" title="0">
                // 提取表名
                v.info.Tables = append(v.info.Tables, node.Name.String())</span>
        case *ast.ColumnName:<span class="cov0" title="0">
                // 提取列名
                if node.Name.String() != "" </span><span class="cov0" title="0">{
                        v.info.Columns = append(v.info.Columns, node.Name.String())
                }</span>
        case *ast.SelectStmt:<span class="cov0" title="0">
                v.info.IsSelect = true</span>
        case *ast.InsertStmt:<span class="cov0" title="0">
                v.info.IsInsert = true</span>
        case *ast.UpdateStmt:<span class="cov0" title="0">
                v.info.IsUpdate = true</span>
        case *ast.DeleteStmt:<span class="cov0" title="0">
                v.info.IsDelete = true</span>
        case *ast.CreateTableStmt, *ast.DropTableStmt, *ast.CreateDatabaseStmt, *ast.DropDatabaseStmt:<span class="cov0" title="0">
                v.info.IsDDL = true</span>
        }
        <span class="cov0" title="0">return n, false</span>
}

// Leave 离开节点
func (v *SQLVisitor) Leave(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        return n, true
}</span>

// ExtractSQLInfo 提取 SQL 信息
func ExtractSQLInfo(stmt ast.StmtNode) *SQLInfo <span class="cov0" title="0">{
        visitor := NewSQLVisitor()
        stmt.Accept(visitor)
        
        // 提取更多详细信息
        if selectStmt, ok := stmt.(*ast.SelectStmt); ok </span><span class="cov0" title="0">{
                visitor.info.WhereExpr = selectStmt.Where
                visitor.info.LimitExpr = selectStmt.Limit
                if selectStmt.OrderBy != nil </span><span class="cov0" title="0">{
                        visitor.info.OrderByItems = selectStmt.OrderBy.Items
                }</span>
                <span class="cov0" title="0">if selectStmt.GroupBy != nil </span><span class="cov0" title="0">{
                        visitor.info.GroupByItems = selectStmt.GroupBy.Items
                }</span>
                <span class="cov0" title="0">visitor.info.Having = nil</span> // Having 需要特殊处理
        }
        
        <span class="cov0" title="0">return visitor.GetInfo()</span>
}

// ExtractTableNames 提取表名
func ExtractTableNames(stmt ast.StmtNode) []string <span class="cov0" title="0">{
        info := ExtractSQLInfo(stmt)
        return info.Tables
}</span>

// ExtractColumnNames 提取列名
func ExtractColumnNames(stmt ast.StmtNode) []string <span class="cov0" title="0">{
        info := ExtractSQLInfo(stmt)
        return info.Columns
}</span>

// ExtractDatabaseNames 提取数据库名
func ExtractDatabaseNames(stmt ast.StmtNode) []string <span class="cov0" title="0">{
        info := ExtractSQLInfo(stmt)
        return info.Databases
}</span>

// TableVisitor 表名访问器
type TableVisitor struct {
        tables []string
}

// NewTableVisitor 创建表名访问器
func NewTableVisitor() *TableVisitor <span class="cov0" title="0">{
        return &amp;TableVisitor{
                tables: make([]string, 0),
        }
}</span>

// GetTables 获取表名列表
func (v *TableVisitor) GetTables() []string <span class="cov0" title="0">{
        return v.tables
}</span>

// Enter 进入节点
func (v *TableVisitor) Enter(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        if table, ok := n.(*ast.TableName); ok </span><span class="cov0" title="0">{
                tableName := table.Name.String()
                if tableName != "" </span><span class="cov0" title="0">{
                        v.tables = append(v.tables, tableName)
                }</span>
        }
        <span class="cov0" title="0">return n, false</span>
}

// Leave 离开节点
func (v *TableVisitor) Leave(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        return n, true
}</span>

// ColumnVisitor 列名访问器
type ColumnVisitor struct {
        columns []string
}

// NewColumnVisitor 创建列名访问器
func NewColumnVisitor() *ColumnVisitor <span class="cov0" title="0">{
        return &amp;ColumnVisitor{
                columns: make([]string, 0),
        }
}</span>

// GetColumns 获取列名列表
func (v *ColumnVisitor) GetColumns() []string <span class="cov0" title="0">{
        return v.columns
}</span>

// Enter 进入节点
func (v *ColumnVisitor) Enter(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        if col, ok := n.(*ast.ColumnName); ok </span><span class="cov0" title="0">{
                colName := col.Name.String()
                if colName != "" </span><span class="cov0" title="0">{
                        v.columns = append(v.columns, colName)
                }</span>
        }
        <span class="cov0" title="0">return n, false</span>
}

// Leave 离开节点
func (v *ColumnVisitor) Leave(n ast.Node) (ast.Node, bool) <span class="cov0" title="0">{
        return n, true
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package parser

import (
        "fmt"
)

// WindowSpec 窗口规范
type WindowSpec struct {
        Name       string          // 窗口名称(如果有)
        PartitionBy []Expression   // PARTITION BY表达式
        OrderBy     []OrderItem     // ORDER BY表达式
        Frame       *WindowFrame     // 窗口帧定义
}

// WindowFrame 窗口帧
type WindowFrame struct {
        Mode      FrameMode       // 帧模式(ROWS/RANGE)
        Start      FrameBound      // 起始边界
        End        *FrameBound     // 结束边界(可为空)
}

// FrameMode 帧模式
type FrameMode int

const (
        FrameModeRows  FrameMode = iota // ROWS
        FrameModeRange                  // RANGE
        FrameModeGroups                 // GROUPS(暂不支持)
)

// FrameBound 帧边界
type FrameBound struct {
        Type  BoundType
        Value Expression // 帧偏移值(可为空)
}

// BoundType 边界类型
type BoundType int

const (
        BoundUnboundedPreceding BoundType = iota // UNBOUNDED PRECEDING
        BoundPreceding                        // n PRECEDING
        BoundCurrentRow                      // CURRENT ROW
        BoundFollowing                        // n FOLLOWING
        BoundUnboundedFollowing               // UNBOUNDED FOLLOWING
)

// WindowExpression 窗口函数表达式
type WindowExpression struct {
        FuncName  string       // 函数名
        Args      []Expression // 函数参数
        Spec      *WindowSpec  // 窗口规范
        Distinct  bool         // DISTINCT标记
}

// OrderItem 排序项
type OrderItem struct {
        Expr      Expression
        Direction string
}

// 支持的窗口函数
var SupportedWindowFunctions = map[string]bool{
        // 排名函数
        "ROW_NUMBER":  true,
        "RANK":       true,
        "DENSE_RANK":  true,
        "PERCENT_RANK": true,
        "CUME_DIST":   true,
        "NTILE":       true,
        
        // 偏移函数
        "LAG":    true,
        "LEAD":   true,
        "FIRST_VALUE": true,
        "LAST_VALUE":  true,
        "NTH_VALUE":   true,
        
        // 聚合窗口函数
        "COUNT":   true,
        "SUM":     true,
        "AVG":     true,
        "MIN":     true,
        "MAX":     true,
        "STDDEV":  true,
        "VAR":     true,
}

// ParseWindowSpec 解析窗口规范
func ParseWindowSpec(windowName string, partitionBy []Expression, orderBy []OrderItem, frame *WindowFrame) *WindowSpec <span class="cov0" title="0">{
        return &amp;WindowSpec{
                Name:       windowName,
                PartitionBy: partitionBy,
                OrderBy:     orderBy,
                Frame:       frame,
        }
}</span>

// ParseWindowFrame 解析窗口帧
func ParseWindowFrame(mode FrameMode, start BoundType, startValue Expression, end BoundType, endValue Expression) *WindowFrame <span class="cov0" title="0">{
        frame := &amp;WindowFrame{
                Mode: mode,
                Start: FrameBound{
                        Type:  start,
                        Value: startValue,
                },
        }
        
        if end != BoundUnboundedFollowing </span><span class="cov0" title="0">{
                frame.End = &amp;FrameBound{
                        Type:  end,
                        Value: endValue,
                }
        }</span>
        
        <span class="cov0" title="0">return frame</span>
}

// NewWindowExpression 创建窗口函数表达式
func NewWindowExpression(funcName string, args []Expression, spec *WindowSpec) (*WindowExpression, error) <span class="cov0" title="0">{
        if !SupportedWindowFunctions[funcName] </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported window function: %s", funcName)
        }</span>
        
        <span class="cov0" title="0">return &amp;WindowExpression{
                FuncName: funcName,
                Args:     args,
                Spec:     spec,
                Distinct: false,
        }, nil</span>
}

// IsWindowFunction 检查是否为窗口函数
func IsWindowFunction(funcName string) bool <span class="cov0" title="0">{
        return SupportedWindowFunctions[funcName]
}</span>

// WindowType 窗口函数类型
type WindowType int

const (
        WindowTypeRanking     WindowType = iota // 排名函数
        WindowTypeOffset                         // 偏移函数
        WindowTypeAggregate                      // 聚合函数
        WindowTypeValue                          // 值函数
)

// GetWindowType 获取窗口函数类型
func (we *WindowExpression) GetWindowType() WindowType <span class="cov0" title="0">{
        switch we.FuncName </span>{
        case "ROW_NUMBER", "RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE":<span class="cov0" title="0">
                return WindowTypeRanking</span>
        case "LAG", "LEAD":<span class="cov0" title="0">
                return WindowTypeOffset</span>
        case "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE":<span class="cov0" title="0">
                return WindowTypeValue</span>
        default:<span class="cov0" title="0">
                return WindowTypeAggregate</span>
        }
}

// IsRankingFunction 检查是否为排名函数
func (we *WindowExpression) IsRankingFunction() bool <span class="cov0" title="0">{
        return we.GetWindowType() == WindowTypeRanking
}</span>

// IsOffsetFunction 检查是否为偏移函数
func (we *WindowExpression) IsOffsetFunction() bool <span class="cov0" title="0">{
        return we.GetWindowType() == WindowTypeOffset
}</span>

// IsAggregateFunction 检查是否为聚合函数
func (we *WindowExpression) IsAggregateFunction() bool <span class="cov0" title="0">{
        return we.GetWindowType() == WindowTypeAggregate
}</span>

// IsValueFunction 检查是否为值函数
func (we *WindowExpression) IsValueFunction() bool <span class="cov0" title="0">{
        return we.GetWindowType() == WindowTypeValue
}</span>

// 窗口函数帮助函数

// CreateRankingWindow 创建排名窗口
func CreateRankingWindow(funcName string, partitionBy []Expression, orderBy []OrderItem) *WindowExpression <span class="cov0" title="0">{
        return &amp;WindowExpression{
                FuncName: funcName,
                Args:     []Expression{},
                Spec: &amp;WindowSpec{
                        PartitionBy: partitionBy,
                        OrderBy:     orderBy,
                },
        }
}</span>

// CreateOffsetWindow 创建偏移窗口
func CreateOffsetWindow(funcName string, args []Expression, partitionBy []Expression, orderBy []OrderItem) *WindowExpression <span class="cov0" title="0">{
        spec := &amp;WindowSpec{
                PartitionBy: partitionBy,
                OrderBy:     orderBy,
        }
        
        // LAG/LEAD默认为UNBOUNDED PRECEDING
        defaultFrame := &amp;WindowFrame{
                Mode:  FrameModeRows,
                Start:  FrameBound{Type: BoundUnboundedPreceding},
                End:    &amp;FrameBound{Type: BoundCurrentRow},
        }
        spec.Frame = defaultFrame
        
        return &amp;WindowExpression{
                FuncName: funcName,
                Args:     args,
                Spec:     spec,
        }
}</span>

// CreateAggregateWindow 创建聚合窗口
func CreateAggregateWindow(funcName string, args []Expression, partitionBy []Expression, orderBy []OrderItem, frame *WindowFrame) *WindowExpression <span class="cov0" title="0">{
        spec := &amp;WindowSpec{
                PartitionBy: partitionBy,
                OrderBy:     orderBy,
                Frame:       frame,
        }
        
        // 聚合函数默认为UNBOUNDED PRECEDING TO UNBOUNDED FOLLOWING
        if frame == nil </span><span class="cov0" title="0">{
                spec.Frame = &amp;WindowFrame{
                        Mode:  FrameModeRows,
                        Start:  FrameBound{Type: BoundUnboundedPreceding},
                        End:    &amp;FrameBound{Type: BoundUnboundedFollowing},
                }
        }</span>
        
        <span class="cov0" title="0">return &amp;WindowExpression{
                FuncName: funcName,
                Args:     args,
                Spec:     spec,
        }</span>
}

// 窗口函数验证

// ValidateWindowExpression 验证窗口函数表达式
func ValidateWindowExpression(we *WindowExpression) error <span class="cov0" title="0">{
        // 检查函数名是否支持
        if !IsWindowFunction(we.FuncName) </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported window function: %s", we.FuncName)
        }</span>
        
        // 检查参数数量
        <span class="cov0" title="0">switch we.FuncName </span>{
        case "ROW_NUMBER", "RANK", "DENSE_RANK":<span class="cov0" title="0">
                if len(we.Args) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s() requires no arguments", we.FuncName)
                }</span>
        case "NTILE":<span class="cov0" title="0">
                if len(we.Args) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("NTILE() requires 1 argument")
                }</span>
        case "LAG", "LEAD":<span class="cov0" title="0">
                if len(we.Args) == 0 || len(we.Args) &gt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s() requires 1 or 2 arguments", we.FuncName)
                }</span>
        case "FIRST_VALUE", "LAST_VALUE":<span class="cov0" title="0">
                if len(we.Args) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s() requires 1 argument", we.FuncName)
                }</span>
        }
        
        // 检查窗口规范
        <span class="cov0" title="0">if we.Spec == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("window function requires OVER clause")
        }</span>
        
        // 检查ORDER BY
        <span class="cov0" title="0">if we.Spec.OrderBy == nil || len(we.Spec.OrderBy) == 0 </span><span class="cov0" title="0">{
                // 排名函数和偏移函数需要ORDER BY
                if we.IsRankingFunction() || we.IsOffsetFunction() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s() requires ORDER BY in OVER clause", we.FuncName)
                }</span>
        }
        
        // 检查帧定义
        <span class="cov0" title="0">if we.Spec.Frame != nil </span><span class="cov0" title="0">{
                // ROWS模式需要ORDER BY
                if we.Spec.Frame.Mode == FrameModeRows &amp;&amp; len(we.Spec.OrderBy) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ROWS frame requires ORDER BY")
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Clone 克隆窗口表达式
func (we *WindowExpression) Clone() *WindowExpression <span class="cov0" title="0">{
        clonedArgs := make([]Expression, len(we.Args))
        copy(clonedArgs, we.Args)
        
        var clonedSpec *WindowSpec
        if we.Spec != nil </span><span class="cov0" title="0">{
                clonedPartitionBy := make([]Expression, len(we.Spec.PartitionBy))
                copy(clonedPartitionBy, we.Spec.PartitionBy)
                
                clonedOrderBy := make([]OrderItem, len(we.Spec.OrderBy))
                copy(clonedOrderBy, we.Spec.OrderBy)
                
                clonedSpec = &amp;WindowSpec{
                        Name:       we.Spec.Name,
                        PartitionBy: clonedPartitionBy,
                        OrderBy:     clonedOrderBy,
                }
                
                if we.Spec.Frame != nil </span><span class="cov0" title="0">{
                        clonedSpec.Frame = &amp;WindowFrame{
                                Mode:  we.Spec.Frame.Mode,
                                Start:  we.Spec.Frame.Start,
                        }
                        if we.Spec.Frame.End != nil </span><span class="cov0" title="0">{
                                clonedSpec.Frame.End = &amp;FrameBound{
                                        Type:  we.Spec.Frame.End.Type,
                                        Value: we.Spec.Frame.End.Value,
                                }
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return &amp;WindowExpression{
                FuncName: we.FuncName,
                Args:     clonedArgs,
                Spec:     clonedSpec,
                Distinct: we.Distinct,
        }</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package reliability

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// BackupType 备份类型
type BackupType int

const (
        BackupTypeFull BackupType = iota
        BackupTypeIncremental
        BackupTypeDifferential
)

// BackupStatus 备份状态
type BackupStatus int

const (
        BackupStatusPending BackupStatus = iota
        BackupStatusRunning
        BackupStatusCompleted
        BackupStatusFailed
)

// BackupMetadata 备份元数据
type BackupMetadata struct {
        ID          string
        Type        BackupType
        Status      BackupStatus
        StartTime   time.Time
        EndTime     time.Time
        Tables      []string
        RecordCount int
        Size        int64
        Checksum    string
        FilePath    string
        Error       string
}

// BackupManager 备份管理器
type BackupManager struct {
        metadata     map[string]*BackupMetadata
        backups      []string
        metadataLock sync.RWMutex
        backupDir    string
}

// NewBackupManager 创建备份管理器
func NewBackupManager(backupDir string) *BackupManager <span class="cov0" title="0">{
        // 确保备份目录存在
        os.MkdirAll(backupDir, 0755)

        return &amp;BackupManager{
                metadata:  make(map[string]*BackupMetadata),
                backups:   make([]string, 0),
                backupDir: backupDir,
        }
}</span>

// Backup 备份数据
func (bm *BackupManager) Backup(backupType BackupType, tables []string, data interface{}) (string, error) <span class="cov0" title="0">{
        metadata := &amp;BackupMetadata{
                ID:        generateBackupID(),
                Type:      backupType,
                Status:    BackupStatusRunning,
                StartTime: time.Now(),
                Tables:    tables,
        }

        bm.metadataLock.Lock()
        bm.metadata[metadata.ID] = metadata
        bm.metadataLock.Unlock()

        // 序列化数据
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                metadata.Status = BackupStatusFailed
                metadata.Error = err.Error()
                metadata.EndTime = time.Now()
                return metadata.ID, err
        }</span>

        // 压缩数据
        <span class="cov0" title="0">compressed, err := compressData(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                metadata.Status = BackupStatusFailed
                metadata.Error = err.Error()
                metadata.EndTime = time.Now()
                return metadata.ID, err
        }</span>

        // 写入文件
        <span class="cov0" title="0">filePath := filepath.Join(bm.backupDir, fmt.Sprintf("%s.backup.gz", metadata.ID))
        err = os.WriteFile(filePath, compressed, 0644)
        if err != nil </span><span class="cov0" title="0">{
                metadata.Status = BackupStatusFailed
                metadata.Error = err.Error()
                metadata.EndTime = time.Now()
                return metadata.ID, err
        }</span>

        // 更新元数据
        <span class="cov0" title="0">metadata.Status = BackupStatusCompleted
        metadata.EndTime = time.Now()
        metadata.Size = int64(len(compressed))
        metadata.FilePath = filePath
        metadata.RecordCount = calculateRecordCount(data)

        // 计算校验和
        metadata.Checksum = calculateChecksum(compressed)

        bm.metadataLock.Lock()
        bm.backups = append(bm.backups, metadata.ID)
        bm.metadataLock.Unlock()

        return metadata.ID, nil</span>
}

// Restore 恢复数据
func (bm *BackupManager) Restore(backupID string, data interface{}) error <span class="cov0" title="0">{
        bm.metadataLock.RLock()
        metadata, ok := bm.metadata[backupID]
        bm.metadataLock.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return errors.New("backup not found")
        }</span>

        <span class="cov0" title="0">if metadata.Status != BackupStatusCompleted </span><span class="cov0" title="0">{
                return fmt.Errorf("backup not completed, status: %d", metadata.Status)
        }</span>

        // 读取文件
        <span class="cov0" title="0">compressed, err := os.ReadFile(metadata.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 验证校验和
        <span class="cov0" title="0">if calculateChecksum(compressed) != metadata.Checksum </span><span class="cov0" title="0">{
                return errors.New("checksum verification failed")
        }</span>

        // 解压数据
        <span class="cov0" title="0">jsonData, err := decompressData(compressed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 反序列化
        <span class="cov0" title="0">err = json.Unmarshal(jsonData, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBackup 获取备份元数据
func (bm *BackupManager) GetBackup(backupID string) (*BackupMetadata, error) <span class="cov0" title="0">{
        bm.metadataLock.RLock()
        defer bm.metadataLock.RUnlock()

        metadata, ok := bm.metadata[backupID]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("backup not found")
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

// ListBackups 列出所有备份
func (bm *BackupManager) ListBackups() []*BackupMetadata <span class="cov0" title="0">{
        bm.metadataLock.RLock()
        defer bm.metadataLock.RUnlock()

        backups := make([]*BackupMetadata, 0, len(bm.backups))
        for _, id := range bm.backups </span><span class="cov0" title="0">{
                if metadata, ok := bm.metadata[id]; ok </span><span class="cov0" title="0">{
                        backups = append(backups, metadata)
                }</span>
        }

        <span class="cov0" title="0">return backups</span>
}

// DeleteBackup 删除备份
func (bm *BackupManager) DeleteBackup(backupID string) error <span class="cov0" title="0">{
        bm.metadataLock.Lock()
        defer bm.metadataLock.Unlock()

        metadata, ok := bm.metadata[backupID]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("backup not found")
        }</span>

        // 删除文件
        <span class="cov0" title="0">if metadata.FilePath != "" </span><span class="cov0" title="0">{
                err := os.Remove(metadata.FilePath)
                if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 删除元数据
        <span class="cov0" title="0">delete(bm.metadata, backupID)

        // 从列表中移除
        for i, id := range bm.backups </span><span class="cov0" title="0">{
                if id == backupID </span><span class="cov0" title="0">{
                        bm.backups = append(bm.backups[:i], bm.backups[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// CleanOldBackups 清理旧备份
func (bm *BackupManager) CleanOldBackups(olderThan time.Duration, keepCount int) error <span class="cov0" title="0">{
        bm.metadataLock.Lock()
        defer bm.metadataLock.Unlock()

        now := time.Now()
        toBeDeleted := make([]string, 0)

        // 标记过期的备份
        for _, metadata := range bm.metadata </span><span class="cov0" title="0">{
                if now.Sub(metadata.EndTime) &gt; olderThan </span><span class="cov0" title="0">{
                        toBeDeleted = append(toBeDeleted, metadata.ID)
                }</span>
        }

        // 保留最近的N个备份
        <span class="cov0" title="0">if len(toBeDeleted) &gt; 0 &amp;&amp; keepCount &gt; 0 </span><span class="cov0" title="0">{
                // 按时间排序
                allBackups := make([]*BackupMetadata, 0, len(bm.metadata))
                for _, metadata := range bm.metadata </span><span class="cov0" title="0">{
                        if metadata.Status == BackupStatusCompleted </span><span class="cov0" title="0">{
                                allBackups = append(allBackups, metadata)
                        }</span>
                }

                // 简单的冒泡排序（按时间降序）
                <span class="cov0" title="0">for i := 0; i &lt; len(allBackups); i++ </span><span class="cov0" title="0">{
                        for j := i + 1; j &lt; len(allBackups); j++ </span><span class="cov0" title="0">{
                                if allBackups[i].EndTime.Before(allBackups[j].EndTime) </span><span class="cov0" title="0">{
                                        allBackups[i], allBackups[j] = allBackups[j], allBackups[i]
                                }</span>
                        }
                }

                // 保留最新的
                <span class="cov0" title="0">keepSet := make(map[string]bool)
                for i := 0; i &lt; keepCount &amp;&amp; i &lt; len(allBackups); i++ </span><span class="cov0" title="0">{
                        keepSet[allBackups[i].ID] = true
                }</span>

                // 过滤掉需要保留的
                <span class="cov0" title="0">filtered := make([]string, 0, len(toBeDeleted))
                for _, id := range toBeDeleted </span><span class="cov0" title="0">{
                        if !keepSet[id] </span><span class="cov0" title="0">{
                                filtered = append(filtered, id)
                        }</span>
                }
                <span class="cov0" title="0">toBeDeleted = filtered</span>
        }

        // 删除备份
        <span class="cov0" title="0">for _, id := range toBeDeleted </span><span class="cov0" title="0">{
                if metadata, ok := bm.metadata[id]; ok </span><span class="cov0" title="0">{
                        if metadata.FilePath != "" </span><span class="cov0" title="0">{
                                os.Remove(metadata.FilePath)
                        }</span>
                        <span class="cov0" title="0">delete(bm.metadata, id)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetBackupStats 获取备份统计信息
func (bm *BackupManager) GetBackupStats() (totalBackups int, totalSize int64, err error) <span class="cov0" title="0">{
        bm.metadataLock.RLock()
        defer bm.metadataLock.RUnlock()

        for _, metadata := range bm.metadata </span><span class="cov0" title="0">{
                if metadata.Status == BackupStatusCompleted </span><span class="cov0" title="0">{
                        totalBackups++
                        totalSize += metadata.Size
                }</span>
        }

        <span class="cov0" title="0">return totalBackups, totalSize, nil</span>
}

// compressData 压缩数据
func compressData(data []byte) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        writer := gzip.NewWriter(&amp;buf)

        _, err := writer.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = writer.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// decompressData 解压数据
func decompressData(compressed []byte) ([]byte, error) <span class="cov0" title="0">{
        reader, err := gzip.NewReader(bytes.NewReader(compressed))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// generateBackupID 生成备份ID
func generateBackupID() string <span class="cov0" title="0">{
        return fmt.Sprintf("backup_%d", time.Now().UnixNano())
}</span>

// calculateRecordCount 计算记录数
func calculateRecordCount(data interface{}) int <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 简化实现，实际应该根据数据类型计算
        <span class="cov0" title="0">switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return len(v)</span>
        case []interface{}:<span class="cov0" title="0">
                return len(v)</span>
        case map[string][]interface{}:<span class="cov0" title="0">
                count := 0
                for _, rows := range v </span><span class="cov0" title="0">{
                        count += len(rows)
                }</span>
                <span class="cov0" title="0">return count</span>
        default:<span class="cov0" title="0">
                return 1</span>
        }
}

// calculateChecksum 计算校验和
func calculateChecksum(data []byte) string <span class="cov0" title="0">{
        sum := 0
        for _, b := range data </span><span class="cov0" title="0">{
                sum += int(b)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", sum)</span>
}

// ExportMetadata 导出备份元数据
func (bm *BackupManager) ExportMetadata() ([]byte, error) <span class="cov0" title="0">{
        bm.metadataLock.RLock()
        defer bm.metadataLock.RUnlock()

        return json.MarshalIndent(bm.metadata, "", "  ")
}</span>

// ImportMetadata 导入备份元数据
func (bm *BackupManager) ImportMetadata(data []byte) error <span class="cov0" title="0">{
        bm.metadataLock.Lock()
        defer bm.metadataLock.Unlock()

        metadataMap := make(map[string]*BackupMetadata)
        err := json.Unmarshal(data, &amp;metadataMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bm.metadata = metadataMap
        bm.backups = make([]string, 0, len(metadataMap))
        for id := range metadataMap </span><span class="cov0" title="0">{
                bm.backups = append(bm.backups, id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package reliability

import (
        "errors"
        "fmt"
        "sync"
        "time"
)

// ErrorType 错误类型
type ErrorType int

const (
        ErrorTypeConnection ErrorType = iota
        ErrorTypeTimeout
        ErrorTypeQuery
        ErrorTypeTransaction
        ErrorTypeDataCorruption
        ErrorTypeResourceExhausted
)

// Severity 严重程度
type Severity int

const (
        SeverityLow Severity = iota
        SeverityMedium
        SeverityHigh
        SeverityCritical
)

// RecoveryAction 恢复动作
type RecoveryAction int

const (
        ActionRetry RecoveryAction = iota
        ActionFallback
        ActionAbort
        ActionIgnore
)

// ErrorInfo 错误信息
type ErrorInfo struct {
        Type      ErrorType
        Severity  Severity
        Message   string
        Err       error
        Timestamp time.Time
        Context   map[string]interface{}
}

// RecoveryStrategy 恢复策略
type RecoveryStrategy struct {
        MaxRetries      int
        RetryInterval   time.Duration
        BackoffFactor   float64
        Action          RecoveryAction
        OnError         func(*ErrorInfo)
        OnSuccess       func()
}

// ErrorRecoveryManager 错误恢复管理器
type ErrorRecoveryManager struct {
        strategies map[ErrorType]*RecoveryStrategy
        errorLog   []*ErrorInfo
        logLock    sync.RWMutex
}

// NewErrorRecoveryManager 创建错误恢复管理器
func NewErrorRecoveryManager() *ErrorRecoveryManager <span class="cov0" title="0">{
        return &amp;ErrorRecoveryManager{
                strategies: make(map[ErrorType]*RecoveryStrategy),
                errorLog:   make([]*ErrorInfo, 0),
        }
}</span>

// RegisterStrategy 注册恢复策略
func (m *ErrorRecoveryManager) RegisterStrategy(errorType ErrorType, strategy *RecoveryStrategy) <span class="cov0" title="0">{
        m.strategies[errorType] = strategy
}</span>

// ExecuteWithRetry 使用重试执行操作
func (m *ErrorRecoveryManager) ExecuteWithRetry(errorType ErrorType, fn func() error) error <span class="cov0" title="0">{
        strategy, ok := m.strategies[errorType]
        if !ok </span><span class="cov0" title="0">{
                // 默认策略：重试3次，间隔1秒
                strategy = &amp;RecoveryStrategy{
                        MaxRetries:    3,
                        RetryInterval: 1 * time.Second,
                        BackoffFactor: 1.0,
                        Action:        ActionRetry,
                }
        }</span>

        <span class="cov0" title="0">var lastErr error
        interval := strategy.RetryInterval

        for attempt := 0; attempt &lt;= strategy.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                err := fn()
                if err == nil </span><span class="cov0" title="0">{
                        if strategy.OnSuccess != nil </span><span class="cov0" title="0">{
                                strategy.OnSuccess()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err

                // 记录错误
                errorInfo := &amp;ErrorInfo{
                        Type:      errorType,
                        Severity:  SeverityMedium,
                        Message:   fmt.Sprintf("Attempt %d failed", attempt+1),
                        Err:       err,
                        Timestamp: time.Now(),
                        Context: map[string]interface{}{
                                "attempt": attempt + 1,
                        },
                }

                m.logError(errorInfo)

                if strategy.OnError != nil </span><span class="cov0" title="0">{
                        strategy.OnError(errorInfo)
                }</span>

                // 如果还有重试机会，等待
                <span class="cov0" title="0">if attempt &lt; strategy.MaxRetries </span><span class="cov0" title="0">{
                        time.Sleep(interval)
                        interval = time.Duration(float64(interval) * strategy.BackoffFactor)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("max retries (%d) exceeded, last error: %w", strategy.MaxRetries, lastErr)</span>
}

// ExecuteWithFallback 使用备用方案执行
func (m *ErrorRecoveryManager) ExecuteWithFallback(errorType ErrorType, primary, fallback func() error) error <span class="cov0" title="0">{
        strategy, ok := m.strategies[errorType]
        if ok &amp;&amp; strategy.Action == ActionFallback </span><span class="cov0" title="0">{
                // 执行备用方案
                err := fallback()
                if err == nil </span><span class="cov0" title="0">{
                        m.logError(&amp;ErrorInfo{
                                Type:      errorType,
                                Severity:  SeverityLow,
                                Message:   "Fallback successful",
                                Timestamp: time.Now(),
                        })
                        return nil
                }</span>
        }

        // 执行主方案
        <span class="cov0" title="0">err := primary()
        if err != nil </span><span class="cov0" title="0">{
                // 如果备用方案存在，尝试执行
                if fallback != nil </span><span class="cov0" title="0">{
                        fallbackErr := fallback()
                        if fallbackErr == nil </span><span class="cov0" title="0">{
                                m.logError(&amp;ErrorInfo{
                                        Type:      errorType,
                                        Severity:  SeverityLow,
                                        Message:   "Fallback successful",
                                        Timestamp: time.Now(),
                                })
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// logError 记录错误
func (m *ErrorRecoveryManager) logError(errorInfo *ErrorInfo) <span class="cov0" title="0">{
        m.logLock.Lock()
        defer m.logLock.Unlock()

        m.errorLog = append(m.errorLog, errorInfo)

        // 保持日志大小在合理范围
        if len(m.errorLog) &gt; 1000 </span><span class="cov0" title="0">{
                m.errorLog = m.errorLog[len(m.errorLog)-1000:]
        }</span>
}

// GetErrorLog 获取错误日志
func (m *ErrorRecoveryManager) GetErrorLog(offset, limit int) []*ErrorInfo <span class="cov0" title="0">{
        m.logLock.RLock()
        defer m.logLock.RUnlock()

        start := offset
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(m.errorLog) </span><span class="cov0" title="0">{
                end = len(m.errorLog)
        }</span>

        <span class="cov0" title="0">if start &gt;= end </span><span class="cov0" title="0">{
                return []*ErrorInfo{}
        }</span>

        <span class="cov0" title="0">return m.errorLog[start:end]</span>
}

// GetErrorStats 获取错误统计
func (m *ErrorRecoveryManager) GetErrorStats() map[ErrorType]int <span class="cov0" title="0">{
        m.logLock.RLock()
        defer m.logLock.RUnlock()

        stats := make(map[ErrorType]int)
        for _, err := range m.errorLog </span><span class="cov0" title="0">{
                stats[err.Type]++
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// IsRetryable 判断错误是否可重试
func (m *ErrorRecoveryManager) IsRetryable(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">strategy, ok := m.strategies[ErrorTypeConnection]
        if ok &amp;&amp; strategy.Action == ActionRetry </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// CircuitBreaker 断路器
type CircuitBreaker struct {
        failureThreshold int
        failureCount     int
        successThreshold int
        successCount     int
        state            CircuitState
        lastFailureTime  time.Time
        timeout          time.Duration
}

// CircuitState 断路器状态
type CircuitState int

const (
        StateClosed CircuitState = iota
        StateOpen
        StateHalfOpen
)

// NewCircuitBreaker 创建断路器
func NewCircuitBreaker(failureThreshold int, timeout time.Duration) *CircuitBreaker <span class="cov0" title="0">{
        return &amp;CircuitBreaker{
                failureThreshold: failureThreshold,
                successThreshold: 3,
                state:            StateClosed,
                timeout:          timeout,
        }
}</span>

// Execute 执行操作（带断路器保护）
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov0" title="0">{
        if cb.state == StateOpen </span><span class="cov0" title="0">{
                if time.Since(cb.lastFailureTime) &gt; cb.timeout </span><span class="cov0" title="0">{
                        cb.state = StateHalfOpen
                        cb.successCount = 0
                }</span> else<span class="cov0" title="0"> {
                        return errors.New("circuit breaker is open")
                }</span>
        }

        <span class="cov0" title="0">err := fn()

        if err != nil </span><span class="cov0" title="0">{
                cb.onFailure()
                return err
        }</span>

        <span class="cov0" title="0">cb.onSuccess()
        return nil</span>
}

// onSuccess 成功回调
func (cb *CircuitBreaker) onSuccess() <span class="cov0" title="0">{
        cb.failureCount = 0

        if cb.state == StateHalfOpen </span><span class="cov0" title="0">{
                cb.successCount++
                if cb.successCount &gt;= cb.successThreshold </span><span class="cov0" title="0">{
                        cb.state = StateClosed
                }</span>
        }
}

// onFailure 失败回调
func (cb *CircuitBreaker) onFailure() <span class="cov0" title="0">{
        cb.failureCount++
        cb.lastFailureTime = time.Now()

        if cb.failureCount &gt;= cb.failureThreshold </span><span class="cov0" title="0">{
                cb.state = StateOpen
        }</span>
}

// GetState 获取断路器状态
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov0" title="0">{
        return cb.state
}</span>

// Reset 重置断路器
func (cb *CircuitBreaker) Reset() <span class="cov0" title="0">{
        cb.failureCount = 0
        cb.successCount = 0
        cb.state = StateClosed
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package reliability

import (
        "context"
        "errors"
        "sync"
        "time"
)

// NodeStatus 节点状态
type NodeStatus int

const (
        NodeStatusHealthy NodeStatus = iota
        NodeStatusDegraded
        NodeStatusUnhealthy
        NodeStatusOffline
)

// Node 节点
type Node struct {
        ID       string
        Address  string
        Weight   int
        Status   NodeStatus
        LastPing time.Time
        Load     float64
}

// HealthChecker 健康检查器接口
type HealthChecker interface {
        Check(node *Node) error
}

// FailoverManager 故障转移管理器
type FailoverManager struct {
        nodes          []*Node
        activeNode     *Node
        checker        HealthChecker
        checkInterval  time.Duration
        failureTimeout time.Duration
        stopChan       chan struct{}
        mu             sync.RWMutex
}

// NewFailoverManager 创建故障转移管理器
func NewFailoverManager(checker HealthChecker, checkInterval, failureTimeout time.Duration) *FailoverManager <span class="cov0" title="0">{
        return &amp;FailoverManager{
                nodes:          make([]*Node, 0),
                checker:        checker,
                checkInterval:  checkInterval,
                failureTimeout: failureTimeout,
                stopChan:       make(chan struct{}),
        }
}</span>

// AddNode 添加节点
func (fm *FailoverManager) AddNode(id, address string, weight int) error <span class="cov0" title="0">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.ID == id </span><span class="cov0" title="0">{
                        return errors.New("node already exists")
                }</span>
        }

        <span class="cov0" title="0">node := &amp;Node{
                ID:       id,
                Address:  address,
                Weight:   weight,
                Status:   NodeStatusHealthy,
                LastPing: time.Now(),
                Load:     0,
        }

        fm.nodes = append(fm.nodes, node)

        // 如果没有活跃节点，设置这个为活跃节点
        if fm.activeNode == nil </span><span class="cov0" title="0">{
                fm.activeNode = node
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveNode 移除节点
func (fm *FailoverManager) RemoveNode(id string) error <span class="cov0" title="0">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        for i, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.ID == id </span><span class="cov0" title="0">{
                        if fm.activeNode != nil &amp;&amp; fm.activeNode.ID == id </span><span class="cov0" title="0">{
                                // 需要切换到其他节点
                                fm.activeNode = nil
                                fm.selectActiveNode()
                        }</span>
                        <span class="cov0" title="0">fm.nodes = append(fm.nodes[:i], fm.nodes[i+1:]...)
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return errors.New("node not found")</span>
}

// GetActiveNode 获取活跃节点
func (fm *FailoverManager) GetActiveNode() *Node <span class="cov0" title="0">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()
        return fm.activeNode
}</span>

// selectActiveNode 选择活跃节点
func (fm *FailoverManager) selectActiveNode() <span class="cov0" title="0">{
        if len(fm.nodes) == 0 </span><span class="cov0" title="0">{
                fm.activeNode = nil
                return
        }</span>

        // 选择健康且权重最高的节点
        <span class="cov0" title="0">var bestNode *Node
        maxWeight := 0

        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusHealthy &amp;&amp; node.Weight &gt; maxWeight </span><span class="cov0" title="0">{
                        bestNode = node
                        maxWeight = node.Weight
                }</span>
        }

        <span class="cov0" title="0">fm.activeNode = bestNode</span>
}

// Start 启动故障转移管理器
func (fm *FailoverManager) Start() <span class="cov0" title="0">{
        go fm.runHealthCheck()
}</span>

// Stop 停止故障转移管理器
func (fm *FailoverManager) Stop() <span class="cov0" title="0">{
        close(fm.stopChan)
}</span>

// runHealthCheck 运行健康检查
func (fm *FailoverManager) runHealthCheck() <span class="cov0" title="0">{
        ticker := time.NewTicker(fm.checkInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        fm.checkAllNodes()</span>
                case &lt;-fm.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// checkAllNodes 检查所有节点
func (fm *FailoverManager) checkAllNodes() <span class="cov0" title="0">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        now := time.Now()
        needsFailover := false

        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                err := fm.checker.Check(node)
                if err != nil </span><span class="cov0" title="0">{
                        // 节点健康检查失败
                        if node.Status != NodeStatusUnhealthy </span><span class="cov0" title="0">{
                                node.Status = NodeStatusUnhealthy
                                if fm.activeNode != nil &amp;&amp; fm.activeNode.ID == node.ID </span><span class="cov0" title="0">{
                                        needsFailover = true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // 节点健康
                        if node.Status == NodeStatusUnhealthy </span><span class="cov0" title="0">{
                                node.Status = NodeStatusHealthy
                        }</span>
                }
                <span class="cov0" title="0">node.LastPing = now</span>
        }

        <span class="cov0" title="0">if needsFailover </span><span class="cov0" title="0">{
                fm.selectActiveNode()
        }</span>
}

// GetNodeStatus 获取节点状态
func (fm *FailoverManager) GetNodeStatus(id string) (*Node, error) <span class="cov0" title="0">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()

        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.ID == id </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("node not found")</span>
}

// GetAllNodes 获取所有节点
func (fm *FailoverManager) GetAllNodes() []*Node <span class="cov0" title="0">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()

        nodes := make([]*Node, len(fm.nodes))
        copy(nodes, fm.nodes)
        return nodes
}</span>

// UpdateNodeLoad 更新节点负载
func (fm *FailoverManager) UpdateNodeLoad(id string, load float64) error <span class="cov0" title="0">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.ID == id </span><span class="cov0" title="0">{
                        node.Load = load

                        // 根据负载调整状态
                        if load &gt; 0.8 &amp;&amp; node.Status == NodeStatusHealthy </span><span class="cov0" title="0">{
                                node.Status = NodeStatusDegraded
                        }</span> else<span class="cov0" title="0"> if load &lt;= 0.8 &amp;&amp; node.Status == NodeStatusDegraded </span><span class="cov0" title="0">{
                                node.Status = NodeStatusHealthy
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return errors.New("node not found")</span>
}

// ManualFailover 手动故障转移
func (fm *FailoverManager) ManualFailover(targetNodeID string) error <span class="cov0" title="0">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        // 查找目标节点
        var targetNode *Node
        for _, node := range fm.nodes </span><span class="cov0" title="0">{
                if node.ID == targetNodeID </span><span class="cov0" title="0">{
                        targetNode = node
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetNode == nil </span><span class="cov0" title="0">{
                return errors.New("target node not found")
        }</span>

        <span class="cov0" title="0">if targetNode.Status == NodeStatusUnhealthy </span><span class="cov0" title="0">{
                return errors.New("target node is unhealthy")
        }</span>

        <span class="cov0" title="0">fm.activeNode = targetNode
        return nil</span>
}

// LoadBalancer 负载均衡器
type LoadBalancer struct {
        nodes    []*Node
        current  int
        mu       sync.RWMutex
}

// NewLoadBalancer 创建负载均衡器
func NewLoadBalancer() *LoadBalancer <span class="cov0" title="0">{
        return &amp;LoadBalancer{
                nodes:   make([]*Node, 0),
                current: 0,
        }
}</span>

// AddNode 添加节点
func (lb *LoadBalancer) AddNode(node *Node) <span class="cov0" title="0">{
        lb.mu.Lock()
        defer lb.mu.Unlock()

        lb.nodes = append(lb.nodes, node)
}</span>

// NextNode 获取下一个节点（轮询）
func (lb *LoadBalancer) NextNode() *Node <span class="cov0" title="0">{
        lb.mu.Lock()
        defer lb.mu.Unlock()

        if len(lb.nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 跳过不健康的节点
        <span class="cov0" title="0">healthyNodes := make([]*Node, 0, len(lb.nodes))
        for _, node := range lb.nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusHealthy || node.Status == NodeStatusDegraded </span><span class="cov0" title="0">{
                        healthyNodes = append(healthyNodes, node)
                }</span>
        }

        <span class="cov0" title="0">if len(healthyNodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">node := healthyNodes[lb.current]
        lb.current = (lb.current + 1) % len(healthyNodes)

        return node</span>
}

// LeastLoadedNode 获取负载最低的节点
func (lb *LoadBalancer) LeastLoadedNode() *Node <span class="cov0" title="0">{
        lb.mu.RLock()
        defer lb.mu.RUnlock()

        if len(lb.nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var bestNode *Node
        minLoad := 1.0

        for _, node := range lb.nodes </span><span class="cov0" title="0">{
                if (node.Status == NodeStatusHealthy || node.Status == NodeStatusDegraded) &amp;&amp;
                        node.Load &lt; minLoad </span><span class="cov0" title="0">{
                        bestNode = node
                        minLoad = node.Load
                }</span>
        }

        <span class="cov0" title="0">return bestNode</span>
}

// ExecuteWithRetryAndFailover 使用重试和故障转移执行操作
func ExecuteWithRetryAndFailover(ctx context.Context, fm *FailoverManager, lb *LoadBalancer, fn func(*Node) error) error <span class="cov0" title="0">{
        maxRetries := 3
        var lastErr error

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // 获取节点
                <span class="cov0" title="0">node := lb.NextNode()
                if node == nil </span><span class="cov0" title="0">{
                        node = fm.GetActiveNode()
                }</span>
                <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                        return errors.New("no available nodes")
                }</span>

                // 执行操作
                <span class="cov0" title="0">err := fn(node)
                if err == nil </span><span class="cov0" title="0">{
                        // 更新负载（假设操作成功）
                        fm.UpdateNodeLoad(node.ID, node.Load*0.9)
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // 更新负载（假设操作失败）
                fm.UpdateNodeLoad(node.ID, node.Load*1.1)

                // 如果是最后一次重试，尝试故障转移
                if i == maxRetries-1 </span><span class="cov0" title="0">{
                        if activeNode := fm.GetActiveNode(); activeNode != nil &amp;&amp; activeNode.ID != node.ID </span><span class="cov0" title="0">{
                                err := fn(activeNode)
                                if err == nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">lastErr = err</span>
                        }
                }
        }

        <span class="cov0" title="0">return lastErr</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package application

import (
        "context"
        "fmt"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ==================== 数据源管理器 ====================

// DataSourceManager 数据源管理器
type DataSourceManager struct {
        sources      map[string]domain.DataSource
        registry      *Registry
        defaultDS     string
        enabledTypes  map[domain.DataSourceType]bool
        mu            sync.RWMutex
}

// NewDataSourceManager 创建数据源管理器
func NewDataSourceManager() *DataSourceManager <span class="cov8" title="1">{
        return &amp;DataSourceManager{
                sources:     make(map[string]domain.DataSource),
                registry:     NewRegistry(),
                enabledTypes: make(map[domain.DataSourceType]bool),
        }
}</span>

// NewDataSourceManagerWithRegistry 使用指定注册表创建数据源管理器
func NewDataSourceManagerWithRegistry(registry *Registry) *DataSourceManager <span class="cov8" title="1">{
        return &amp;DataSourceManager{
                sources:     make(map[string]domain.DataSource),
                registry:     registry,
                enabledTypes: make(map[domain.DataSourceType]bool),
        }
}</span>

// SetEnabledTypes 设置启用的数据源类型
func (m *DataSourceManager) SetEnabledTypes(types []domain.DataSourceType) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.enabledTypes = make(map[domain.DataSourceType]bool)
        for _, t := range types </span><span class="cov8" title="1">{
                m.enabledTypes[t] = true
        }</span>
}

// Register 注册数据源
func (m *DataSourceManager) Register(name string, ds domain.DataSource) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.sources[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("data source %s already registered", name)
        }</span>

        <span class="cov8" title="1">if m.defaultDS == "" </span><span class="cov8" title="1">{
                m.defaultDS = name
        }</span>

        <span class="cov8" title="1">m.sources[name] = ds
        return nil</span>
}

// Unregister 注销数据源
func (m *DataSourceManager) Unregister(name string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.sources[name]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("data source %s not found", name)
        }</span>

        // 关闭数据源
        <span class="cov8" title="1">ds := m.sources[name]
        if err := ds.Close(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close data source: %w", err)
        }</span>

        <span class="cov8" title="1">delete(m.sources, name)

        // 如果删除的是默认数据源，重新设置默认值
        if m.defaultDS == name </span><span class="cov8" title="1">{
                m.defaultDS = ""
                for n := range m.sources </span><span class="cov0" title="0">{
                        m.defaultDS = n
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Get 获取数据源
func (m *DataSourceManager) Get(name string) (domain.DataSource, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        ds, ok := m.sources[name]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data source %s not found", name)
        }</span>
        <span class="cov8" title="1">return ds, nil</span>
}

// GetDefault 获取默认数据源
func (m *DataSourceManager) GetDefault() (domain.DataSource, error) <span class="cov8" title="1">{
        if m.defaultDS == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no default data source set")
        }</span>
        <span class="cov8" title="1">return m.Get(m.defaultDS)</span>
}

// CreateFromConfig 从配置创建数据源
func (m *DataSourceManager) CreateFromConfig(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 检查数据源类型是否启用
        if len(m.enabledTypes) &gt; 0 &amp;&amp; !m.enabledTypes[config.Type] </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data source type %s is not enabled", config.Type)
        }</span>

        // 使用注册表创建数据源
        <span class="cov8" title="1">return m.registry.Create(config)</span>
}

// IsTypeEnabled 检查数据源类型是否启用
func (m *DataSourceManager) IsTypeEnabled(t domain.DataSourceType) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if len(m.enabledTypes) == 0 </span><span class="cov8" title="1">{
                // 如果没有设置启用的类型，默认全部启用
                return true
        }</span>

        <span class="cov8" title="1">return m.enabledTypes[t]</span>
}

// SetDefault 设置默认数据源
func (m *DataSourceManager) SetDefault(name string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.sources[name]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("data source %s not found", name)
        }</span>

        <span class="cov8" title="1">m.defaultDS = name
        return nil</span>
}

// List 列出所有数据源
func (m *DataSourceManager) List() []string <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        names := make([]string, 0, len(m.sources))
        for name := range m.sources </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// ConnectAll 连接所有数据源
func (m *DataSourceManager) ConnectAll(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for name, ds := range m.sources </span><span class="cov8" title="1">{
                if !ds.IsConnected() </span><span class="cov8" title="1">{
                        if err := ds.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to connect data source %s: %w", name, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// CloseAll 关闭所有数据源
func (m *DataSourceManager) CloseAll(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var lastErr error
        for name, ds := range m.sources </span><span class="cov8" title="1">{
                if err := ds.Close(ctx); err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to close data source %s: %w", name, err)
                }</span>
        }
        <span class="cov8" title="1">return lastErr</span>
}

// CreateAndRegister 创建并注册数据源
func (m *DataSourceManager) CreateAndRegister(ctx context.Context, name string, config *domain.DataSourceConfig) error <span class="cov8" title="1">{
        // 创建数据源
        ds, err := m.CreateFromConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data source: %w", err)
        }</span>

        // 连接数据源
        <span class="cov8" title="1">if err := ds.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect data source: %w", err)
        }</span>

        // 注册数据源
        <span class="cov8" title="1">if err := m.Register(name, ds); err != nil </span><span class="cov0" title="0">{
                ds.Close(ctx)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetRegistry 获取注册表
func (m *DataSourceManager) GetRegistry() *Registry <span class="cov0" title="0">{
        return m.registry
}</span>

// ==================== 便捷查询方法 ====================

// GetTables 获取指定数据源的表列表
func (m *DataSourceManager) GetTables(ctx context.Context, dsName string) ([]string, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ds.GetTables(ctx)</span>
}

// GetTableInfo 获取指定数据源的表信息
func (m *DataSourceManager) GetTableInfo(ctx context.Context, dsName, tableName string) (*domain.TableInfo, error) <span class="cov0" title="0">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ds.GetTableInfo(ctx, tableName)</span>
}

// Query 查询指定数据源的数据
func (m *DataSourceManager) Query(ctx context.Context, dsName, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ds.Query(ctx, tableName, options)</span>
}

// Insert 向指定数据源插入数据
func (m *DataSourceManager) Insert(ctx context.Context, dsName, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return ds.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新指定数据源的数据
func (m *DataSourceManager) Update(ctx context.Context, dsName, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return ds.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除指定数据源的数据
func (m *DataSourceManager) Delete(ctx context.Context, dsName, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return ds.Delete(ctx, tableName, filters, options)</span>
}

// CreateTable 在指定数据源创建表
func (m *DataSourceManager) CreateTable(ctx context.Context, dsName string, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ds.CreateTable(ctx, tableInfo)</span>
}

// DropTable 在指定数据源删除表
func (m *DataSourceManager) DropTable(ctx context.Context, dsName, tableName string) error <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ds.DropTable(ctx, tableName)</span>
}

// TruncateTable 清空指定数据源的表
func (m *DataSourceManager) TruncateTable(ctx context.Context, dsName, tableName string) error <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ds.TruncateTable(ctx, tableName)</span>
}

// Execute 在指定数据源执行SQL
func (m *DataSourceManager) Execute(ctx context.Context, dsName, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        ds, err := m.Get(dsName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ds.Execute(ctx, sql)</span>
}

// GetStatus 获取数据源状态
func (m *DataSourceManager) GetStatus() map[string]bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        status := make(map[string]bool)
        for name, ds := range m.sources </span><span class="cov8" title="1">{
                status[name] = ds.IsConnected()
        }</span>
        <span class="cov8" title="1">return status</span>
}

// GetDefaultName 获取默认数据源名称
func (m *DataSourceManager) GetDefaultName() string <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.defaultDS
}</span>

// ==================== 全局数据源管理器 ====================

var (
        defaultManager = NewDataSourceManager()
        managerOnce   sync.Once
)

// GetDefaultManager 获取默认数据源管理器
func GetDefaultManager() *DataSourceManager <span class="cov8" title="1">{
        return defaultManager
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package application

import (
        "fmt"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ==================== 工厂注册表 ====================

// Registry 数据源工厂注册表
type Registry struct {
        factories map[domain.DataSourceType]domain.DataSourceFactory
        mu        sync.RWMutex
}

// NewRegistry 创建注册表
func NewRegistry() *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                factories: make(map[domain.DataSourceType]domain.DataSourceFactory),
        }
}</span>

// Register 注册数据源工厂
func (r *Registry) Register(factory domain.DataSourceFactory) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        factoryType := factory.GetType()
        if _, exists := r.factories[factoryType]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("factory %s already registered", factoryType)
        }</span>

        <span class="cov8" title="1">r.factories[factoryType] = factory
        return nil</span>
}

// Unregister 注销数据源工厂
func (r *Registry) Unregister(factoryType domain.DataSourceType) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.factories[factoryType]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("factory %s not found", factoryType)
        }</span>

        <span class="cov8" title="1">delete(r.factories, factoryType)
        return nil</span>
}

// Get 获取数据源工厂
func (r *Registry) Get(factoryType domain.DataSourceType) (domain.DataSourceFactory, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        factory, ok := r.factories[factoryType]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("factory %s not found", factoryType)
        }</span>
        <span class="cov8" title="1">return factory, nil</span>
}

// Create 使用工厂创建数据源
func (r *Registry) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        factory, err := r.Get(config.Type)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return factory.Create(config)</span>
}

// List 列出所有已注册的工厂
func (r *Registry) List() []domain.DataSourceType <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        types := make([]domain.DataSourceType, 0, len(r.factories))
        for t := range r.factories </span><span class="cov8" title="1">{
                types = append(types, t)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// Exists 检查工厂是否存在
func (r *Registry) Exists(factoryType domain.DataSourceType) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        _, exists := r.factories[factoryType]
        return exists
}</span>

// Clear 清空所有注册的工厂
func (r *Registry) Clear() <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.factories = make(map[domain.DataSourceType]domain.DataSourceFactory)
}</span>

// ==================== 全局注册表 ====================

var (
        globalRegistry = NewRegistry()
        registryOnce   sync.Once
)

// GetRegistry 获取全局注册表
func GetRegistry() *Registry <span class="cov8" title="1">{
        return globalRegistry
}</span>

// RegisterFactory 注册数据源工厂（全局便捷函数）
func RegisterFactory(factory domain.DataSourceFactory) error <span class="cov8" title="1">{
        return globalRegistry.Register(factory)
}</span>

// UnregisterFactory 注销数据源工厂（全局便捷函数）
func UnregisterFactory(factoryType domain.DataSourceType) error <span class="cov8" title="1">{
        return globalRegistry.Unregister(factoryType)
}</span>

// GetFactory 获取数据源工厂（全局便捷函数）
func GetFactory(factoryType domain.DataSourceType) (domain.DataSourceFactory, error) <span class="cov8" title="1">{
        return globalRegistry.Get(factoryType)
}</span>

// CreateDataSource 使用全局注册表创建数据源
func CreateDataSource(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        return globalRegistry.Create(config)
}</span>

// GetSupportedTypes 获取支持的数据源类型
func GetSupportedTypes() []domain.DataSourceType <span class="cov8" title="1">{
        return globalRegistry.List()
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package csv

import (
        "context"
        "encoding/csv"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
)

// CSVAdapter CSV文件数据源适配器
// 继承 MVCCDataSource，只负责CSV格式的加载和写回
type CSVAdapter struct {
        *memory.MVCCDataSource
        filePath  string
        delimiter rune
        hasHeader bool
        writable  bool
}

// NewCSVAdapter 创建CSV数据源适配器
func NewCSVAdapter(config *domain.DataSourceConfig, filePath string) *CSVAdapter <span class="cov8" title="1">{
        delimiter := ','
        hasHeader := true
        writable := false // CSV默认只读

        // 从配置中读取选项
        if config.Options != nil </span><span class="cov8" title="1">{
                if d, ok := config.Options["delimiter"]; ok </span><span class="cov8" title="1">{
                        if str, ok := d.(string); ok &amp;&amp; len(str) &gt; 0 </span><span class="cov8" title="1">{
                                delimiter = rune(str[0])
                        }</span>
                }
                <span class="cov8" title="1">if h, ok := config.Options["header"]; ok </span><span class="cov8" title="1">{
                        if b, ok := h.(bool); ok </span><span class="cov8" title="1">{
                                hasHeader = b
                        }</span>
                }
                <span class="cov8" title="1">if w, ok := config.Options["writable"]; ok </span><span class="cov8" title="1">{
                        if b, ok := w.(bool); ok </span><span class="cov8" title="1">{
                                writable = b
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;CSVAdapter{
                MVCCDataSource: memory.NewMVCCDataSource(config),
                filePath:       filePath,
                delimiter:      delimiter,
                hasHeader:      hasHeader,
                writable:       writable,
        }</span>
}

// Connect 连接数据源 - 加载CSV文件到内存
func (a *CSVAdapter) Connect(ctx context.Context) error <span class="cov8" title="1">{
        // 读取CSV文件
        file, err := os.Open(a.filePath)
        if err != nil </span><span class="cov8" title="1">{
                return domain.NewErrNotConnected("csv")
        }</span>
        <span class="cov8" title="1">defer file.Close()

        reader := csv.NewReader(file)
        reader.Comma = a.delimiter

        // 读取所有行
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read CSV file: %w", err)
        }</span>

        <span class="cov8" title="1">if len(records) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("CSV file is empty")
        }</span>

        // 推断列信息
        <span class="cov8" title="1">var headers []string
        var dataRows [][]string

        if a.hasHeader </span><span class="cov8" title="1">{
                headers = records[0]
                dataRows = records[1:]
        }</span> else<span class="cov8" title="1"> {
                headers = make([]string, len(records[0]))
                for i := range headers </span><span class="cov8" title="1">{
                        headers[i] = fmt.Sprintf("column_%d", i+1)
                }</span>
                <span class="cov8" title="1">dataRows = records</span>
        }

        // 推断列类型
        <span class="cov8" title="1">columns := a.inferColumnTypes(headers, dataRows)

        // 转换为Row格式
        rows := a.convertToRows(headers, columns, dataRows)

        // 创建表信息
        tableInfo := &amp;domain.TableInfo{
                Name:    "csv_data",
                Schema:  "",
                Columns: columns,
        }

        // 加载到MVCC内存源
        if err := a.LoadTable("csv_data", tableInfo, rows); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load CSV data: %w", err)
        }</span>

        // 连接MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Connect(ctx)</span>
}

// Close 关闭连接 - 可选写回CSV文件
func (a *CSVAdapter) Close(ctx context.Context) error <span class="cov8" title="1">{
        // 如果是可写模式，需要写回CSV文件
        if a.writable </span><span class="cov8" title="1">{
                if err := a.writeBack(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write back CSV file: %w", err)
                }</span>
        }

        // 关闭MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Close(ctx)</span>
}

// GetConfig 获取数据源配置
func (a *CSVAdapter) GetConfig() *domain.DataSourceConfig <span class="cov8" title="1">{
        return a.MVCCDataSource.GetConfig()
}</span>

// GetTables 获取所有表（MVCCDataSource提供）
func (a *CSVAdapter) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTables(ctx)
}</span>

// GetTableInfo 获取表信息（MVCCDataSource提供）
func (a *CSVAdapter) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTableInfo(ctx, tableName)
}</span>

// Query 查询数据（MVCCDataSource提供）
func (a *CSVAdapter) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.Query(ctx, tableName, options)
}</span>

// Insert 插入数据（MVCCDataSource提供）
func (a *CSVAdapter) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("csv", "insert")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新数据（MVCCDataSource提供）
func (a *CSVAdapter) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("csv", "update")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除数据（MVCCDataSource提供）
func (a *CSVAdapter) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("csv", "delete")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Delete(ctx, tableName, filters, options)</span>
}

// CreateTable 创建表（CSV不支持）
func (a *CSVAdapter) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("csv", "create table")
}</span>

// DropTable 删除表（CSV不支持）
func (a *CSVAdapter) DropTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("csv", "drop table")
}</span>

// TruncateTable 清空表（CSV不支持）
func (a *CSVAdapter) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("csv", "truncate table")
}</span>

// Execute 执行SQL（CSV不支持）
func (a *CSVAdapter) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return nil, domain.NewErrUnsupportedOperation("csv", "execute SQL")
}</span>

// ==================== 私有方法 ====================

// inferColumnTypes 推断列类型
func (a *CSVAdapter) inferColumnTypes(headers []string, rows [][]string) []domain.ColumnInfo <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return []domain.ColumnInfo{}
        }</span>

        // 采样前100行推断类型
        <span class="cov8" title="1">sampleSize := 100
        if len(rows) &lt; sampleSize </span><span class="cov8" title="1">{
                sampleSize = len(rows)
        }</span>

        <span class="cov8" title="1">typeCounts := make([]map[string]int, len(rows[0]))
        for i := range typeCounts </span><span class="cov8" title="1">{
                typeCounts[i] = map[string]int{
                        "int64":   0,
                        "float64": 0,
                        "bool":    0,
                        "string":  0,
                }
        }</span>

        // 统计每列的类型
        <span class="cov8" title="1">for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                row := rows[i]
                for j, value := range row </span><span class="cov8" title="1">{
                        if j &gt;= len(typeCounts) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">value = strings.TrimSpace(value)
                        if value == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">colType := a.detectType(value)
                        typeCounts[j][colType]++</span>
                }
        }

        // 选择每列的最常见类型
        <span class="cov8" title="1">columns := make([]domain.ColumnInfo, len(headers))
        for j, header := range headers </span><span class="cov8" title="1">{
                maxCount := 0
                bestType := "string"
                if j &lt; len(typeCounts) </span><span class="cov8" title="1">{
                        for t, count := range typeCounts[j] </span><span class="cov8" title="1">{
                                if count &gt; maxCount </span><span class="cov8" title="1">{
                                        maxCount = count
                                        bestType = t
                                }</span>
                        }
                }

                <span class="cov8" title="1">columns[j] = domain.ColumnInfo{
                        Name:     strings.TrimSpace(header),
                        Type:     bestType,
                        Nullable: true,
                }</span>
        }

        <span class="cov8" title="1">return columns</span>
}

// detectType 检测值的类型
func (a *CSVAdapter) detectType(value string) string <span class="cov8" title="1">{
        // 尝试解析为布尔值
        if strings.EqualFold(value, "true") || strings.EqualFold(value, "false") </span><span class="cov0" title="0">{
                return "bool"
        }</span>

        // 尝试解析为整数
        <span class="cov8" title="1">if _, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                return "int64"
        }</span>

        // 尝试解析为浮点数
        <span class="cov8" title="1">if _, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return "float64"
        }</span>

        <span class="cov8" title="1">return "string"</span>
}

// convertToRows 转换CSV行为Row格式
func (a *CSVAdapter) convertToRows(headers []string, columns []domain.ColumnInfo, rows [][]string) []domain.Row <span class="cov8" title="1">{
        result := make([]domain.Row, len(rows))

        for i, row := range rows </span><span class="cov8" title="1">{
                rowMap := make(domain.Row)
                for j, value := range row </span><span class="cov8" title="1">{
                        if j &gt;= len(headers) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov8" title="1">colName := strings.TrimSpace(headers[j])
                        colType := columns[j].Type
                        parsedValue := a.parseValue(value, colType)
                        rowMap[colName] = parsedValue</span>
                }
                <span class="cov8" title="1">result[i] = rowMap</span>
        }

        <span class="cov8" title="1">return result</span>
}

// parseValue 解析值
func (a *CSVAdapter) parseValue(value string, colType string) interface{} <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch colType </span>{
        case "int64":<span class="cov8" title="1">
                if intVal, err := strconv.ParseInt(trimmed, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return intVal
                }</span>
        case "float64":<span class="cov0" title="0">
                if floatVal, err := strconv.ParseFloat(trimmed, 64); err == nil </span><span class="cov0" title="0">{
                        return floatVal
                }</span>
        case "bool":<span class="cov0" title="0">
                if boolVal, err := strconv.ParseBool(trimmed); err == nil </span><span class="cov0" title="0">{
                        return boolVal
                }</span>
        }

        <span class="cov8" title="1">return trimmed</span>
}

// writeBack 写回CSV文件
func (a *CSVAdapter) writeBack() error <span class="cov8" title="1">{
        // 获取最新数据
        schema, rows, err := a.GetLatestTableData("csv_data")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 打开文件准备写入
        <span class="cov8" title="1">file, err := os.Create(a.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        writer := csv.NewWriter(file)
        writer.Comma = a.delimiter
        defer writer.Flush()

        // 写入header
        headers := make([]string, len(schema.Columns))
        for i, col := range schema.Columns </span><span class="cov8" title="1">{
                headers[i] = col.Name
        }</span>

        <span class="cov8" title="1">if a.hasHeader </span><span class="cov8" title="1">{
                if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 写入数据
        <span class="cov8" title="1">for _, row := range rows </span><span class="cov8" title="1">{
                record := make([]string, len(headers))
                for i, header := range headers </span><span class="cov8" title="1">{
                        record[i] = fmt.Sprintf("%v", row[header])
                }</span>

                <span class="cov8" title="1">if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// IsConnected 检查是否已连接（MVCCDataSource提供）
func (a *CSVAdapter) IsConnected() bool <span class="cov8" title="1">{
        return a.MVCCDataSource.IsConnected()
}</span>

// IsWritable 检查是否可写
func (a *CSVAdapter) IsWritable() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// SupportsWrite 实现IsWritableSource接口
func (a *CSVAdapter) SupportsWrite() bool <span class="cov8" title="1">{
        return a.writable
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package csv

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// CSVFactory CSV 数据源工厂
type CSVFactory struct{}

// NewCSVFactory 创建 CSV 数据源工厂
func NewCSVFactory() *CSVFactory <span class="cov8" title="1">{
        return &amp;CSVFactory{}
}</span>

// GetType 实现DataSourceFactory接口
func (f *CSVFactory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return domain.DataSourceTypeCSV
}</span>

// Create 实现DataSourceFactory接口
func (f *CSVFactory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        // 使用CSVAdapter（继承MVCCDataSource）
        return NewCSVAdapter(config, config.Name), nil
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package domain

import "context"

// ==================== 数据源能力接口 ====================

// IsMVCCable 判断数据源是否支持MVCC的接口
// 实现此接口的数据源支持多版本并发控制
type IsMVCCable interface {
        // SupportsMVCC 是否支持MVCC
        SupportsMVCC() bool
        
        // BeginTx 开始事务
        BeginTx(ctx context.Context, readOnly bool) (int64, error)
        
        // CommitTx 提交事务
        CommitTx(ctx context.Context, txnID int64) error
        
        // RollbackTx 回滚事务
        RollbackTx(ctx context.Context, txnID int64) error
}

// IsWritableSource 判断数据源是否可写的接口
// 注意：DataSource接口已经包含了IsWritable()方法
// 这个接口用于标记数据源明确支持写操作
type IsWritableSource interface {
        DataSource
        
        // SupportsWrite 明确声明支持写操作
        SupportsWrite() bool
}

// ==================== 辅助函数 ====================

// HasMVCCSupport 检查数据源是否支持MVCC
// 如果实现了IsMVCCable接口，使用其返回值
// 否则返回false（默认不支持）
func HasMVCCSupport(ds DataSource) bool <span class="cov0" title="0">{
        if mvccable, ok := ds.(IsMVCCable); ok </span><span class="cov0" title="0">{
                return mvccable.SupportsMVCC()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// HasWriteSupport 检查数据源是否可写
// 如果实现了IsWritableSource接口，使用其返回值
// 否则使用DataSource的IsWritable()方法
func HasWriteSupport(ds DataSource) bool <span class="cov0" title="0">{
        if writable, ok := ds.(IsWritableSource); ok </span><span class="cov0" title="0">{
                return writable.SupportsWrite()
        }</span>
        // 默认使用DataSource接口的IsWritable()方法
        <span class="cov0" title="0">return ds.IsWritable()</span>
}

// GetMVCCDataSource 获取支持MVCC的数据源
// 返回IsMVCCable接口和是否支持
func GetMVCCDataSource(ds DataSource) (IsMVCCable, bool) <span class="cov0" title="0">{
        mvccable, ok := ds.(IsMVCCable)
        return mvccable, ok
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package domain

import "fmt"

// 数据源领域错误

// ErrNotConnected 未连接错误
type ErrNotConnected struct {
        DataSourceType string
}

func (e *ErrNotConnected) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("data source %s is not connected", e.DataSourceType)
}</span>

// ErrReadOnly 只读错误
type ErrReadOnly struct {
        DataSourceType string
        Operation      string
}

func (e *ErrReadOnly) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("data source %s is read-only, cannot %s", e.DataSourceType, e.Operation)
}</span>

// ErrTableNotFound 表不存在错误
type ErrTableNotFound struct {
        TableName string
}

func (e *ErrTableNotFound) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("table %s not found", e.TableName)
}</span>

// ErrColumnNotFound 列不存在错误
type ErrColumnNotFound struct {
        ColumnName string
        TableName  string
}

func (e *ErrColumnNotFound) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("column %s not found in table %s", e.ColumnName, e.TableName)
}</span>

// ErrUnsupportedOperation 不支持的操作错误
type ErrUnsupportedOperation struct {
        DataSourceType string
        Operation      string
}

func (e *ErrUnsupportedOperation) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("operation %s is not supported by %s data source", e.Operation, e.DataSourceType)
}</span>

// ErrConstraintViolation 约束违反错误
type ErrConstraintViolation struct {
        Constraint string
        Message    string
}

func (e *ErrConstraintViolation) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("constraint violation: %s - %s", e.Constraint, e.Message)
}</span>

// ErrInvalidConfig 配置无效错误
type ErrInvalidConfig struct {
        ConfigKey string
        Message   string
}

func (e *ErrInvalidConfig) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid config for %s: %s", e.ConfigKey, e.Message)
}</span>

// ErrConnectionFailed 连接失败错误
type ErrConnectionFailed struct {
        DataSourceType string
        Reason         string
}

func (e *ErrConnectionFailed) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("failed to connect to %s data source: %s", e.DataSourceType, e.Reason)
}</span>

// ErrQueryFailed 查询失败错误
type ErrQueryFailed struct {
        Query   string
        Reason  string
}

func (e *ErrQueryFailed) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("query failed: %s - %s", e.Query, e.Reason)
}</span>

// ErrTypeConversion 类型转换错误
type ErrTypeConversion struct {
        FieldName  string
        FromType   string
        ToType     string
        Value      interface{}
}

func (e *ErrTypeConversion) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("type conversion failed for field %s: cannot convert %v from %s to %s",
                e.FieldName, e.Value, e.FromType, e.ToType)
}</span>

// 辅助函数

// NewErrNotConnected 创建未连接错误
func NewErrNotConnected(dataSourceType string) *ErrNotConnected <span class="cov8" title="1">{
        return &amp;ErrNotConnected{DataSourceType: dataSourceType}
}</span>

// NewErrReadOnly 创建只读错误
func NewErrReadOnly(dataSourceType, operation string) *ErrReadOnly <span class="cov8" title="1">{
        return &amp;ErrReadOnly{DataSourceType: dataSourceType, Operation: operation}
}</span>

// NewErrTableNotFound 创建表不存在错误
func NewErrTableNotFound(tableName string) *ErrTableNotFound <span class="cov8" title="1">{
        return &amp;ErrTableNotFound{TableName: tableName}
}</span>

// NewErrUnsupportedOperation 创建不支持操作错误
func NewErrUnsupportedOperation(dataSourceType, operation string) *ErrUnsupportedOperation <span class="cov8" title="1">{
        return &amp;ErrUnsupportedOperation{DataSourceType: dataSourceType, Operation: operation}
}</span>

// NewErrConstraintViolation 创建约束违反错误
func NewErrConstraintViolation(constraint, message string) *ErrConstraintViolation <span class="cov8" title="1">{
        return &amp;ErrConstraintViolation{Constraint: constraint, Message: message}
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package domain

// DataSourceType 数据源类型
type DataSourceType string

// String 返回数据源类型的字符串表示
func (t DataSourceType) String() string <span class="cov8" title="1">{
        return string(t)
}</span>

const (
        // DataSourceTypeMemory 内存数据源
        DataSourceTypeMemory DataSourceType = "memory"
        // DataSourceTypeMySQL MySQL数据源
        DataSourceTypeMySQL DataSourceType = "mysql"
        // DataSourceTypePostgreSQL PostgreSQL数据源
        DataSourceTypePostgreSQL DataSourceType = "postgresql"
        // DataSourceTypeSQLite SQLite数据源
        DataSourceTypeSQLite DataSourceType = "sqlite"
        // DataSourceTypeCSV CSV文件数据源
        DataSourceTypeCSV DataSourceType = "csv"
        // DataSourceTypeExcel Excel文件数据源
        DataSourceTypeExcel DataSourceType = "excel"
        // DataSourceTypeJSON JSON文件数据源
        DataSourceTypeJSON DataSourceType = "json"
        // DataSourceTypeParquet Parquet文件数据源
        DataSourceTypeParquet DataSourceType = "parquet"
)

// DataSourceConfig 数据源配置
type DataSourceConfig struct {
        Type     DataSourceType         `json:"type"`
        Name     string                 `json:"name"`
        Host     string                 `json:"host,omitempty"`
        Port     int                    `json:"port,omitempty"`
        Username string                 `json:"username,omitempty"`
        Password string                 `json:"password,omitempty"`
        Database string                 `json:"database,omitempty"`
        Writable  bool                   `json:"writable,omitempty"` // 是否可写，默认true
        Options  map[string]interface{} `json:"options,omitempty"`
}

// TableInfo 表信息
type TableInfo struct {
        Name       string       `json:"name"`
        Schema     string       `json:"schema,omitempty"`
        Columns    []ColumnInfo `json:"columns"`
        Temporary  bool         `json:"temporary,omitempty"` // 是否是临时表
}

// ColumnInfo 列信息
type ColumnInfo struct {
        Name         string           `json:"name"`
        Type         string           `json:"type"`
        Nullable     bool             `json:"nullable"`
        Primary      bool             `json:"primary"`
        Default      string           `json:"default,omitempty"`
        Unique       bool             `json:"unique,omitempty"`          // 唯一约束
        AutoIncrement bool            `json:"auto_increment,omitempty"` // 自动递增
        ForeignKey   *ForeignKeyInfo  `json:"foreign_key,omitempty"`    // 外键约束
}

// ForeignKeyInfo 外键信息
type ForeignKeyInfo struct {
        Table    string `json:"table"`              // 引用的表
        Column   string `json:"column"`             // 引用的列
        OnDelete string `json:"on_delete,omitempty"`  // 删除策略：CASCADE, SET NULL, NO ACTION
        OnUpdate string `json:"on_update,omitempty"`  // 更新策略
}

// Row 行数据
type Row map[string]interface{}

// QueryResult 查询结果
type QueryResult struct {
        Columns []ColumnInfo `json:"columns"`
        Rows    []Row        `json:"rows"`
        Total   int64        `json:"total"`
}

// Filter 查询过滤器
type Filter struct {
        Field      string      `json:"field"`
        Operator   string      `json:"operator"` // =, !=, &gt;, &lt;, &gt;=, &lt;=, LIKE, IN, BETWEEN
        Value      interface{} `json:"value"`
        LogicOp    string      `json:"logic_op,omitempty"`    // AND, OR (用于多条件组合)
        SubFilters []Filter    `json:"sub_filters,omitempty"` // 子过滤器（用于逻辑组合）
}

// QueryOptions 查询选项
type QueryOptions struct {
        Filters      []Filter `json:"filters,omitempty"`
        OrderBy      string   `json:"order_by,omitempty"`
        Order        string   `json:"order,omitempty"` // ASC, DESC
        Limit        int      `json:"limit,omitempty"`
        Offset       int      `json:"offset,omitempty"`
        SelectAll    bool     `json:"select_all,omitempty"`     // 是否是 select *
        SelectColumns []string `json:"select_columns,omitempty"` // 指定要查询的列（列裁剪）
}

// InsertOptions 插入选项
type InsertOptions struct {
        Replace bool `json:"replace,omitempty"` // 如果存在则替换
}

// UpdateOptions 更新选项
type UpdateOptions struct {
        Upsert bool `json:"upsert,omitempty"` // 如果不存在则插入
}

// DeleteOptions 删除选项
type DeleteOptions struct {
        Force bool `json:"force,omitempty"` // 强制删除
}

// TransactionOptions 事务选项
type TransactionOptions struct {
        IsolationLevel string `json:"isolation_level,omitempty"` // READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE
        ReadOnly       bool   `json:"read_only,omitempty"`        // 只读事务
}

// ConstraintType 约束类型
type ConstraintType string

const (
        ConstraintTypeUnique     ConstraintType = "unique"
        ConstraintTypeForeignKey ConstraintType = "foreign_key"
        ConstraintTypeCheck      ConstraintType = "check"
        ConstraintTypePrimaryKey  ConstraintType = "primary_key"
)

// IndexType 索引类型
type IndexType string

const (
        IndexTypeBTree    IndexType = "btree"
        IndexTypeHash     IndexType = "hash"
        IndexTypeFullText IndexType = "fulltext"
)

// ForeignKeyReference 外键引用信息
type ForeignKeyReference struct {
        Table   string   `json:"table"`
        Columns []string `json:"columns"`
}

// Constraint 约束信息
type Constraint struct {
        Name       string                `json:"name"`
        Type       ConstraintType         `json:"type"`
        Columns    []string              `json:"columns"`
        Table      string                `json:"table"`
        References *ForeignKeyReference  `json:"references,omitempty"`
        CheckExpr  string                `json:"check_expr,omitempty"`
        Enabled    bool                  `json:"enabled"`
}

// Index 索引信息
type Index struct {
        Name     string      `json:"name"`
        Table    string      `json:"table"`
        Columns  []string    `json:"columns"`
        Type     IndexType   `json:"type"`
        Unique   bool        `json:"unique"`
        Primary  bool        `json:"primary"`
        Enabled  bool        `json:"enabled"`
}

// Schema 模式信息
type Schema struct {
        Name        string       `json:"name"`
        Tables      []*TableInfo `json:"tables"`
        Indexes     []*Index     `json:"indexes"`
        Constraints []*Constraint `json:"constraints"`
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package excel

import (
        "context"
        "fmt"
        "strconv"

        "github.com/xuri/excelize/v2"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
)

// ExcelAdapter Excel文件数据源适配器
// 继承 MVCCDataSource，只负责Excel格式的加载和写回
type ExcelAdapter struct {
        *memory.MVCCDataSource
        filePath  string
        sheetName string
        writable  bool
        file      *excelize.File
}

// NewExcelAdapter 创建Excel数据源适配器
func NewExcelAdapter(config *domain.DataSourceConfig, filePath string) *ExcelAdapter <span class="cov8" title="1">{
        sheetName := ""
        writable := false // Excel默认只读

        // 从配置中读取选项
        if config.Options != nil </span><span class="cov8" title="1">{
                if s, ok := config.Options["sheet_name"]; ok </span><span class="cov8" title="1">{
                        if str, ok := s.(string); ok </span><span class="cov8" title="1">{
                                sheetName = str
                        }</span>
                }
                <span class="cov8" title="1">if w, ok := config.Options["writable"]; ok </span><span class="cov8" title="1">{
                        if b, ok := w.(bool); ok </span><span class="cov8" title="1">{
                                writable = b
                        }</span>
                }
        }

        // 确保config.Writable与writable一致
        <span class="cov8" title="1">config.Writable = writable

        return &amp;ExcelAdapter{
                MVCCDataSource: memory.NewMVCCDataSource(config),
                filePath:       filePath,
                sheetName:      sheetName,
                writable:       writable,
        }</span>
}

// Connect 连接数据源 - 加载Excel文件到内存
func (a *ExcelAdapter) Connect(ctx context.Context) error <span class="cov8" title="1">{
        // 打开Excel文件
        file, err := excelize.OpenFile(a.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return domain.NewErrNotConnected("excel")
        }</span>

        <span class="cov8" title="1">a.file = file

        // 确定使用的工作表
        sheets := file.GetSheetList()
        if len(sheets) == 0 </span><span class="cov0" title="0">{
                file.Close()
                return fmt.Errorf("no sheets found in excel file")
        }</span>

        <span class="cov8" title="1">if a.sheetName != "" </span><span class="cov8" title="1">{
                // 检查指定的工作表是否存在
                found := false
                for _, sheet := range sheets </span><span class="cov8" title="1">{
                        if sheet == a.sheetName </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        file.Close()
                        return fmt.Errorf("sheet not found: %s", a.sheetName)
                }</span>
        } else<span class="cov8" title="1"> {
                // 使用第一个工作表
                a.sheetName = sheets[0]
        }</span>

        // 读取所有行
        <span class="cov8" title="1">rows, err := file.GetRows(a.sheetName)
        if err != nil </span><span class="cov0" title="0">{
                file.Close()
                return fmt.Errorf("failed to read excel rows: %w", err)
        }</span>

        <span class="cov8" title="1">if len(rows) == 0 </span><span class="cov8" title="1">{
                file.Close()
                return fmt.Errorf("sheet is empty: %s", a.sheetName)
        }</span>

        // 第一行是列头
        <span class="cov8" title="1">headers := rows[0]
        dataRows := rows[1:]

        // 推断列信息（传入headers）
        columns := a.inferColumnTypes(headers, dataRows)
        
        // 转换为Row格式
        convertedRows := a.convertToRows(headers, columns, dataRows)

        // 创建表信息
        tableInfo := &amp;domain.TableInfo{
                Name:    a.sheetName,
                Schema:  "",
                Columns: columns,
        }

        // 加载到MVCC内存源
        if err := a.LoadTable(a.sheetName, tableInfo, convertedRows); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return fmt.Errorf("failed to load Excel data: %w", err)
        }</span>

        // 连接MVCC数据源
        <span class="cov8" title="1">if err := a.MVCCDataSource.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close 关闭连接 - 可选写回Excel文件
func (a *ExcelAdapter) Close(ctx context.Context) error <span class="cov8" title="1">{
        // 如果是可写模式，需要写回Excel文件
        if a.writable &amp;&amp; a.file != nil </span><span class="cov8" title="1">{
                if err := a.writeBack(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write back Excel file: %w", err)
                }</span>
        }

        // 关闭Excel文件
        <span class="cov8" title="1">if a.file != nil </span><span class="cov8" title="1">{
                a.file.Close()
                a.file = nil
        }</span>

        // 关闭MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Close(ctx)</span>
}

// GetConfig 获取数据源配置
func (a *ExcelAdapter) GetConfig() *domain.DataSourceConfig <span class="cov8" title="1">{
        return a.MVCCDataSource.GetConfig()
}</span>

// GetTables 获取所有表（MVCCDataSource提供）
func (a *ExcelAdapter) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTables(ctx)
}</span>

// GetTableInfo 获取表信息（MVCCDataSource提供）
func (a *ExcelAdapter) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTableInfo(ctx, tableName)
}</span>

// Query 查询数据（MVCCDataSource提供）
func (a *ExcelAdapter) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.Query(ctx, tableName, options)
}</span>

// Insert 插入数据（MVCCDataSource提供）
func (a *ExcelAdapter) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("excel", "insert")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新数据（MVCCDataSource提供）
func (a *ExcelAdapter) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("excel", "update")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除数据（MVCCDataSource提供）
func (a *ExcelAdapter) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("excel", "delete")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Delete(ctx, tableName, filters, options)</span>
}

// CreateTable 创建表（Excel不支持）
func (a *ExcelAdapter) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("excel", "create table")
}</span>

// DropTable 删除表（Excel不支持）
func (a *ExcelAdapter) DropTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("excel", "drop table")
}</span>

// TruncateTable 清空表（保留header，删除数据行）
func (a *ExcelAdapter) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        if !a.writable </span><span class="cov0" title="0">{
                return domain.NewErrReadOnly("excel", "truncate table")
        }</span>

        // 使用MVCCDataSource的truncate（这会创建新版本）
        <span class="cov8" title="1">return a.MVCCDataSource.TruncateTable(ctx, tableName)</span>
}

// Execute 执行SQL（Excel不支持）
func (a *ExcelAdapter) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return nil, domain.NewErrUnsupportedOperation("excel", "execute SQL")
}</span>

// ==================== 私有方法 ====================

// inferColumnTypes 推断列类型（使用headers作为列名）
func (a *ExcelAdapter) inferColumnTypes(headers []string, rows [][]string) []domain.ColumnInfo <span class="cov8" title="1">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return []domain.ColumnInfo{}
        }</span>

        <span class="cov8" title="1">if len(rows) == 0 </span><span class="cov0" title="0">{
                // 如果没有数据行，只返回headers信息
                columns := make([]domain.ColumnInfo, len(headers))
                for i, header := range headers </span><span class="cov0" title="0">{
                        columns[i] = domain.ColumnInfo{
                                Name:     header,
                                Type:     "string",
                                Nullable: true,
                        }
                }</span>
                <span class="cov0" title="0">return columns</span>
        }

        // 采样前100行推断类型
        <span class="cov8" title="1">sampleSize := 100
        if len(rows) &lt; sampleSize </span><span class="cov8" title="1">{
                sampleSize = len(rows)
        }</span>

        <span class="cov8" title="1">typeCounts := make([]map[string]int, len(headers))
        for i := range typeCounts </span><span class="cov8" title="1">{
                typeCounts[i] = map[string]int{
                        "int64":   0,
                        "float64": 0,
                        "bool":    0,
                        "string":  0,
                }
        }</span>

        // 统计每列的类型
        <span class="cov8" title="1">for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                row := rows[i]
                for j, value := range row </span><span class="cov8" title="1">{
                        if j &gt;= len(typeCounts) || j &gt;= len(headers) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">value = value // already trimmed by excelize
                        if value == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">colType := a.detectType(value)
                        typeCounts[j][colType]++</span>
                }
        }

        // 选择每列的最常见类型
        <span class="cov8" title="1">columns := make([]domain.ColumnInfo, len(headers))
        for j := 0; j &lt; len(headers); j++ </span><span class="cov8" title="1">{
                maxCount := 0
                bestType := "string"
                for t, count := range typeCounts[j] </span><span class="cov8" title="1">{
                        if count &gt; maxCount </span><span class="cov8" title="1">{
                                maxCount = count
                                bestType = t
                        }</span>
                }

                <span class="cov8" title="1">columns[j] = domain.ColumnInfo{
                        Name:     headers[j],  // 使用实际的header名称
                        Type:     bestType,
                        Nullable: true,
                }</span>
        }

        <span class="cov8" title="1">return columns</span>
}

// detectType 检测值的类型
func (a *ExcelAdapter) detectType(value string) string <span class="cov8" title="1">{
        // 尝试解析为布尔值
        if value == "true" || value == "false" </span><span class="cov0" title="0">{
                return "bool"
        }</span>

        // 尝试解析为整数
        <span class="cov8" title="1">if _, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                return "int64"
        }</span>

        // 尝试解析为浮点数
        <span class="cov8" title="1">if _, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return "float64"
        }</span>

        <span class="cov8" title="1">return "string"</span>
}

// convertToRows 转换Excel行为Row格式
func (a *ExcelAdapter) convertToRows(headers []string, columns []domain.ColumnInfo, rows [][]string) []domain.Row <span class="cov8" title="1">{
        result := make([]domain.Row, len(rows))

        for i, row := range rows </span><span class="cov8" title="1">{
                rowMap := make(domain.Row)
                for j, value := range row </span><span class="cov8" title="1">{
                        if j &gt;= len(columns) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov8" title="1">colName := columns[j].Name
                        colType := columns[j].Type
                        parsedValue := a.parseValue(value, colType)
                        rowMap[colName] = parsedValue</span>
                }
                <span class="cov8" title="1">result[i] = rowMap</span>
        }

        <span class="cov8" title="1">return result</span>
}

// parseValue 解析值
func (a *ExcelAdapter) parseValue(value string, colType string) interface{} <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch colType </span>{
        case "int64":<span class="cov8" title="1">
                if intVal, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return intVal
                }</span>
        case "float64":<span class="cov0" title="0">
                if floatVal, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return floatVal
                }</span>
        case "bool":<span class="cov0" title="0">
                if value == "true" </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov0" title="0"> if value == "false" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return value</span>
}

// writeBack 写回Excel文件
func (a *ExcelAdapter) writeBack() error <span class="cov8" title="1">{
        // 获取最新数据
        schema, rows, err := a.GetLatestTableData(a.sheetName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清空工作表
        <span class="cov8" title="1">if err := a.file.DeleteSheet(a.sheetName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建新工作表
        <span class="cov8" title="1">index, err := a.file.NewSheet(a.sheetName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.file.SetActiveSheet(index)

        // 写入header
        for i, col := range schema.Columns </span><span class="cov8" title="1">{
                cell, _ := excelize.CoordinatesToCellName(i+1, 1)
                a.file.SetCellValue(a.sheetName, cell, col.Name)
        }</span>

        // 写入数据
        <span class="cov8" title="1">for i, row := range rows </span><span class="cov8" title="1">{
                rowNum := i + 2 // 跳过header行
                for j, col := range schema.Columns </span><span class="cov8" title="1">{
                        cell, _ := excelize.CoordinatesToCellName(j+1, rowNum)
                        if val, exists := row[col.Name]; exists </span><span class="cov8" title="1">{
                                a.file.SetCellValue(a.sheetName, cell, val)
                        }</span>
                }
        }

        // 保存文件
        <span class="cov8" title="1">return a.file.SaveAs(a.filePath)</span>
}

// IsConnected 检查是否已连接（MVCCDataSource提供）
func (a *ExcelAdapter) IsConnected() bool <span class="cov8" title="1">{
        return a.MVCCDataSource.IsConnected()
}</span>

// IsWritable 检查是否可写
func (a *ExcelAdapter) IsWritable() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// SupportsWrite 实现IsWritableSource接口
func (a *ExcelAdapter) SupportsWrite() bool <span class="cov8" title="1">{
        return a.writable
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package excel

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ExcelFactory Excel 数据源工厂
type ExcelFactory struct{}

// NewExcelFactory 创建 Excel 数据源工厂
func NewExcelFactory() *ExcelFactory <span class="cov8" title="1">{
        return &amp;ExcelFactory{}
}</span>

// GetType 实现DataSourceFactory接口
func (f *ExcelFactory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return domain.DataSourceTypeExcel
}</span>

// Create 实现DataSourceFactory接口
func (f *ExcelFactory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        // 使用ExcelAdapter（继承MVCCDataSource）
        return NewExcelAdapter(config, config.Name), nil
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package file

import (
        "context"
        "os"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        errors "github.com/kasuganosora/sqlexec/pkg/resource/infrastructure/errors"
        "github.com/kasuganosora/sqlexec/pkg/resource/util"
)

// ==================== File DataSource 基类 ====================

// FileDataSource 文件数据源基类
type FileDataSource struct {
        config    *domain.DataSourceConfig
        connected bool
        writable  bool
        filePath  string
        columns   []domain.ColumnInfo
        mu        sync.RWMutex
}

// NewFileDataSource 创建文件数据源基类
func NewFileDataSource(config *domain.DataSourceConfig, filePath string, writable bool) *FileDataSource <span class="cov0" title="0">{
        return &amp;FileDataSource{
                config:   config,
                filePath: filePath,
                writable: writable,
                columns:  []domain.ColumnInfo{},
        }
}</span>

// IsConnected 检查是否已连接
func (f *FileDataSource) IsConnected() bool <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.connected
}</span>

// GetConfig 获取配置
func (f *FileDataSource) GetConfig() *domain.DataSourceConfig <span class="cov0" title="0">{
        return f.config
}</span>

// IsWritable 检查是否可写
func (f *FileDataSource) IsWritable() bool <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.writable
}</span>

// SetWritable 设置可写状态
func (f *FileDataSource) SetWritable(writable bool) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.writable = writable
}</span>

// GetFilePath 获取文件路径
func (f *FileDataSource) GetFilePath() string <span class="cov0" title="0">{
        return f.filePath
}</span>

// SetColumns 设置列信息
func (f *FileDataSource) SetColumns(columns []domain.ColumnInfo) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.columns = columns
}</span>

// GetColumns 获取列信息
func (f *FileDataSource) GetColumns() []domain.ColumnInfo <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.columns
}</span>

// FilterColumns 过滤列信息（通用方法）
func (f *FileDataSource) FilterColumns(neededColumns []string) []domain.ColumnInfo <span class="cov0" title="0">{
        columns := f.GetColumns()
        if len(neededColumns) == 0 </span><span class="cov0" title="0">{
                return columns
        }</span>

        <span class="cov0" title="0">filtered := make([]domain.ColumnInfo, 0, len(neededColumns))
        neededMap := make(map[string]bool)
        for _, col := range neededColumns </span><span class="cov0" title="0">{
                neededMap[col] = true
        }</span>

        <span class="cov0" title="0">for _, col := range columns </span><span class="cov0" title="0">{
                if neededMap[col.Name] </span><span class="cov0" title="0">{
                        filtered = append(filtered, col)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// CheckConnected 检查连接状态
func (f *FileDataSource) CheckConnected() error <span class="cov0" title="0">{
        if !f.IsConnected() </span><span class="cov0" title="0">{
                return domain.NewErrNotConnected(string(f.config.Type))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckWritable 检查可写状态
func (f *FileDataSource) CheckWritable() error <span class="cov0" title="0">{
        if !f.IsWritable() </span><span class="cov0" title="0">{
                return domain.NewErrReadOnly(string(f.config.Type), "write operation")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckFileExists 检查文件是否存在
func (f *FileDataSource) CheckFileExists() error <span class="cov0" title="0">{
        if _, err := os.Stat(f.filePath); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return errors.NewErrFileNotFound(f.filePath, string(f.config.Type))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CheckTableExists 检查表是否存在（文件数据源默认返回一个表）
func (f *FileDataSource) CheckTableExists(tableName string, expectedTableName string) error <span class="cov0" title="0">{
        if tableName != expectedTableName </span><span class="cov0" title="0">{
                return domain.NewErrTableNotFound(tableName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTables 获取所有表（文件数据源默认返回一个表）
func (f *FileDataSource) GetTables(ctx context.Context, tableName string) ([]string, error) <span class="cov0" title="0">{
        if err := f.CheckConnected(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return []string{tableName}, nil</span>
}

// GetTableInfo 获取表信息（文件数据源默认实现）
func (f *FileDataSource) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov0" title="0">{
        if err := f.CheckConnected(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := f.CheckTableExists(tableName, getDefaultTableName()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;domain.TableInfo{
                Name:    getDefaultTableName(),
                Columns: f.GetColumns(),
        }, nil</span>
}

// Execute 执行自定义SQL（文件数据源不支持）
func (f *FileDataSource) Execute(ctx context.Context, sqlStr string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return nil, errors.NewErrSQLNotSupported(string(f.config.Type))
}</span>

// Insert 插入数据（文件数据源默认只读实现）
func (f *FileDataSource) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return 0, errors.NewErrOperationNotSupported(string(f.config.Type), "insert")</span>
}

// Update 更新数据（文件数据源默认只读实现）
func (f *FileDataSource) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return 0, errors.NewErrOperationNotSupported(string(f.config.Type), "update")</span>
}

// Delete 删除数据（文件数据源默认只读实现）
func (f *FileDataSource) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return 0, errors.NewErrOperationNotSupported(string(f.config.Type), "delete")</span>
}

// CreateTable 创建表（文件数据源默认只读实现）
func (f *FileDataSource) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return errors.NewErrOperationNotSupported(string(f.config.Type), "create table")</span>
}

// DropTable 删除表（文件数据源默认只读实现）
func (f *FileDataSource) DropTable(ctx context.Context, tableName string) error <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return errors.NewErrOperationNotSupported(string(f.config.Type), "drop table")</span>
}

// TruncateTable 清空表（文件数据源默认只读实现）
func (f *FileDataSource) TruncateTable(ctx context.Context, tableName string) error <span class="cov0" title="0">{
        if err := f.CheckWritable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return errors.NewErrOperationNotSupported(string(f.config.Type), "truncate table")</span>
}

// ApplyQueryOperations 应用查询操作（过滤器、排序、分页）
func (f *FileDataSource) ApplyQueryOperations(rows []domain.Row, options *domain.QueryOptions) []domain.Row <span class="cov0" title="0">{
        return util.ApplyQueryOperations(rows, options, &amp;f.columns)
}</span>

// getDefaultTableName 获取默认表名
func getDefaultTableName() string <span class="cov0" title="0">{
        return "data"
}</span>

// SetConnected 设置连接状态
func (f *FileDataSource) SetConnected(connected bool) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.connected = connected
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package file

import (
        "strconv"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ==================== Schema 推断器实现 ====================

// DefaultSchemaInferor 默认 Schema 推断器
type DefaultSchemaInferor struct {
        sampleSize int
}

// NewDefaultSchemaInferor 创建默认 Schema 推断器
func NewDefaultSchemaInferor() *DefaultSchemaInferor <span class="cov0" title="0">{
        return &amp;DefaultSchemaInferor{
                sampleSize: 1000,
        }
}</span>

// InferSchema 推断表结构
func (s *DefaultSchemaInferor) InferSchema(headers []string, samples [][]string) ([]domain.ColumnInfo, error) <span class="cov0" title="0">{
        columns := make([]domain.ColumnInfo, len(headers))

        for i, header := range headers </span><span class="cov0" title="0">{
                colType := s.inferColumnType(i, samples)
                columns[i] = domain.ColumnInfo{
                        Name:     strings.TrimSpace(header),
                        Type:     colType,
                        Nullable: true,
                        Primary:  false,
                }
        }</span>

        <span class="cov0" title="0">return columns, nil</span>
}

// inferColumnType 推断列类型
func (s *DefaultSchemaInferor) inferColumnType(colIndex int, samples [][]string) string <span class="cov0" title="0">{
        if len(samples) == 0 </span><span class="cov0" title="0">{
                return "VARCHAR"
        }</span>

        <span class="cov0" title="0">typeCounts := map[string]int{
                "INTEGER": 0,
                "FLOAT":   0,
                "BOOLEAN": 0,
                "VARCHAR": 0,
        }

        for _, row := range samples </span><span class="cov0" title="0">{
                if colIndex &gt;= len(row) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">value := strings.TrimSpace(row[colIndex])
                if value == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">colType := s.detectType(value)
                typeCounts[colType]++</span>
        }

        // 选择最常见的类型
        <span class="cov0" title="0">maxCount := 0
        bestType := "VARCHAR"
        for t, count := range typeCounts </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                        bestType = t
                }</span>
        }

        <span class="cov0" title="0">return bestType</span>
}

// detectType 检测值的类型
func (s *DefaultSchemaInferor) detectType(value string) string <span class="cov0" title="0">{
        // 尝试解析为布尔值
        if strings.EqualFold(value, "true") || strings.EqualFold(value, "false") </span><span class="cov0" title="0">{
                return "BOOLEAN"
        }</span>

        // 尝试解析为整数
        <span class="cov0" title="0">if _, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                return "INTEGER"
        }</span>

        // 尝试解析为浮点数
        <span class="cov0" title="0">if _, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return "FLOAT"
        }</span>

        <span class="cov0" title="0">return "VARCHAR"</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package file

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/util"
)

// ==================== 文件操作工具函数 ====================

// GetFileExtension 获取文件扩展名
func GetFileExtension(filePath string) string <span class="cov0" title="0">{
        ext := filepath.Ext(filePath)
        return strings.ToLower(ext)
}</span>

// IsSupportedFileType 检查文件类型是否支持
func IsSupportedFileType(filePath string) bool <span class="cov0" title="0">{
        ext := GetFileExtension(filePath)
        supportedTypes := []string{".csv", ".json", ".xlsx", ".xls", ".parquet"}

        for _, t := range supportedTypes </span><span class="cov0" title="0">{
                if ext == t </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetDataSourceTypeFromFileExt 根据文件扩展名获取数据源类型
func GetDataSourceTypeFromFileExt(filePath string) domain.DataSourceType <span class="cov0" title="0">{
        ext := GetFileExtension(filePath)

        switch ext </span>{
        case ".csv":<span class="cov0" title="0">
                return domain.DataSourceTypeCSV</span>
        case ".json":<span class="cov0" title="0">
                return domain.DataSourceTypeJSON</span>
        case ".xlsx", ".xls":<span class="cov0" title="0">
                return domain.DataSourceTypeExcel</span>
        case ".parquet":<span class="cov0" title="0">
                return domain.DataSourceTypeParquet</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// EnsureFileExists 确保文件存在，如果不存在则创建
func EnsureFileExists(filePath string) error <span class="cov0" title="0">{
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // 创建文件
                dir := filepath.Dir(filePath)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">file, err := os.Create(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return file.Close()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFileSize 获取文件大小
func GetFileSize(filePath string) (int64, error) <span class="cov0" title="0">{
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return info.Size(), nil</span>
}

// ReadFileContent 读取文件内容
func ReadFileContent(filePath string) ([]byte, error) <span class="cov0" title="0">{
        return os.ReadFile(filePath)
}</span>

// WriteFileContent 写入文件内容
func WriteFileContent(filePath string, content []byte) error <span class="cov0" title="0">{
        return os.WriteFile(filePath, content, 0644)
}</span>

// ==================== 行处理工具函数 ====================

// FilterRowsByNeededColumns 根据需要的列过滤行
func FilterRowsByNeededColumns(rows []domain.Row, neededColumns []string) []domain.Row <span class="cov0" title="0">{
        if len(neededColumns) == 0 </span><span class="cov0" title="0">{
                return rows
        }</span>

        <span class="cov0" title="0">result := make([]domain.Row, len(rows))
        for i, row := range rows </span><span class="cov0" title="0">{
                filtered := make(domain.Row)
                for _, col := range neededColumns </span><span class="cov0" title="0">{
                        if val, ok := row[col]; ok </span><span class="cov0" title="0">{
                                filtered[col] = val
                        }</span>
                }
                <span class="cov0" title="0">result[i] = filtered</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ApplyFiltersToRows 对行应用过滤器
func ApplyFiltersToRows(rows []domain.Row, filters []domain.Filter) []domain.Row <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return rows
        }</span>

        <span class="cov0" title="0">result := make([]domain.Row, 0)
        for _, row := range rows </span><span class="cov0" title="0">{
                if util.MatchesFilters(row, filters) </span><span class="cov0" title="0">{
                        result = append(result, row)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// SortRows 对行排序
func SortRows(rows []domain.Row, orderBy string, order string) []domain.Row <span class="cov0" title="0">{
        options := &amp;domain.QueryOptions{
                OrderBy: orderBy,
                Order:   order,
        }
        return util.ApplyOrder(rows, options)
}</span>

// PaginateRows 对行分页
func PaginateRows(rows []domain.Row, offset, limit int) []domain.Row <span class="cov0" title="0">{
        return util.ApplyPagination(rows, offset, limit)
}</span>

// ConvertRowToStringMap 将行转换为字符串映射
func ConvertRowToStringMap(row domain.Row) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for k, v := range row </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        result[k] = fmt.Sprintf("%v", v)
                }</span> else<span class="cov0" title="0"> {
                        result[k] = ""
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// MergeRows 合并多个行集
func MergeRows(rowSets ...[]domain.Row) []domain.Row <span class="cov0" title="0">{
        totalLen := 0
        for _, set := range rowSets </span><span class="cov0" title="0">{
                totalLen += len(set)
        }</span>

        <span class="cov0" title="0">result := make([]domain.Row, 0, totalLen)
        for _, set := range rowSets </span><span class="cov0" title="0">{
                result = append(result, set...)
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package cache

import (
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/util"
)

// ==================== 查询缓存 ====================

// CacheEntry 缓存条目
type CacheEntry struct {
        result      *domain.QueryResult
        createdAt   time.Time
        expiresAt   time.Time
        accessCount int64
        lastAccess  time.Time
        query       string
}

// QueryCache 查询缓存
type QueryCache struct {
        cache   map[string]*CacheEntry
        maxSize int
        ttl     time.Duration
        mu      sync.RWMutex
}

// NewQueryCache 创建查询缓存
func NewQueryCache() *QueryCache <span class="cov8" title="1">{
        return &amp;QueryCache{
                cache:   make(map[string]*CacheEntry),
                maxSize: 100,
                ttl:     5 * time.Minute,
        }
}</span>

// NewQueryCacheWithConfig 使用配置创建查询缓存
func NewQueryCacheWithConfig(maxSize int, ttl time.Duration) *QueryCache <span class="cov8" title="1">{
        return &amp;QueryCache{
                cache:   make(map[string]*CacheEntry),
                maxSize: maxSize,
                ttl:     ttl,
        }
}</span>

// Get 获取缓存
func (c *QueryCache) Get(query string) (*domain.QueryResult, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[query]
        if !exists </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // 检查是否过期
        <span class="cov8" title="1">if time.Now().After(entry.expiresAt) </span><span class="cov8" title="1">{
                delete(c.cache, query)
                return nil, false
        }</span>

        // 更新访问信息
        <span class="cov8" title="1">entry.lastAccess = time.Now()
        entry.accessCount++

        return entry.result, true</span>
}

// Set 设置缓存
func (c *QueryCache) Set(query string, result *domain.QueryResult) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // 检查缓存大小
        if len(c.cache) &gt;= c.maxSize </span><span class="cov8" title="1">{
                c.evict()
        }</span>

        <span class="cov8" title="1">now := time.Now()
        c.cache[query] = &amp;CacheEntry{
                result:      result,
                createdAt:   now,
                expiresAt:   now.Add(c.ttl),
                accessCount: 1,
                lastAccess:  now,
                query:       query,
        }</span>
}

// Invalidate 使表的缓存失效
func (c *QueryCache) Invalidate(tableName string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for query := range c.cache </span><span class="cov8" title="1">{
                if util.ContainsTable(query, tableName) </span><span class="cov8" title="1">{
                        delete(c.cache, query)
                }</span>
        }
}

// Clear 清空缓存
func (c *QueryCache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.cache = make(map[string]*CacheEntry)
}</span>

// Stats 获取统计信息
func (c *QueryCache) Stats() map[string]interface{} <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        totalAccess := int64(0)
        hitCount := int64(0)

        for _, entry := range c.cache </span><span class="cov8" title="1">{
                totalAccess += entry.accessCount
                if entry.accessCount &gt; 1 </span><span class="cov8" title="1">{
                        hitCount++
                }</span>
        }

        <span class="cov8" title="1">hitRate := float64(0)
        if totalAccess &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(hitCount) / float64(totalAccess)
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "size":         len(c.cache),
                "max_size":     c.maxSize,
                "ttl":          c.ttl,
                "total_access": totalAccess,
                "hit_count":    hitCount,
                "hit_rate":     hitRate,
        }</span>
}

// evict 淘汰最少使用的条目
func (c *QueryCache) evict() <span class="cov8" title="1">{
        var lruQuery string
        var lruAccess int64

        for query, entry := range c.cache </span><span class="cov8" title="1">{
                if lruAccess == 0 || entry.accessCount &lt; lruAccess </span><span class="cov8" title="1">{
                        lruAccess = entry.accessCount
                        lruQuery = query
                }</span>
        }

        <span class="cov8" title="1">if lruQuery != "" </span><span class="cov8" title="1">{
                delete(c.cache, lruQuery)
        }</span>
}

// SetMaxSize 设置最大缓存大小
func (c *QueryCache) SetMaxSize(size int) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.maxSize = size
}</span>

// SetTTL 设置缓存过期时间
func (c *QueryCache) SetTTL(ttl time.Duration) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.ttl = ttl
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package infrastructure

import "github.com/kasuganosora/sqlexec/pkg/resource/domain"

// ==================== 基础设施错误 ====================

// ErrFileNotFound 文件不存在错误
type ErrFileNotFound struct {
        FilePath string
        FileType string
}

func (e *ErrFileNotFound) Error() string <span class="cov0" title="0">{
        return e.FileType + " file not found: " + e.FilePath
}</span>

// ErrSQLNotSupported SQL执行不支持错误
type ErrSQLNotSupported struct {
        DataSourceType string
}

func (e *ErrSQLNotSupported) Error() string <span class="cov0" title="0">{
        return e.DataSourceType + " data source does not support SQL execution"
}</span>

// ErrOperationNotSupported 操作不支持错误
type ErrOperationNotSupported struct {
        DataSourceType string
        Operation      string
}

func (e *ErrOperationNotSupported) Error() string <span class="cov0" title="0">{
        return e.Operation + " not supported for " + e.DataSourceType + " data source"
}</span>

// ErrPoolExhausted 连接池耗尽错误
type ErrPoolExhausted struct {
        Message string
}

func (e *ErrPoolExhausted) Error() string <span class="cov0" title="0">{
        return "connection pool exhausted: " + e.Message
}</span>

// ErrCacheMiss 缓存未命中错误
type ErrCacheMiss struct {
        Key string
}

func (e *ErrCacheMiss) Error() string <span class="cov0" title="0">{
        return "cache miss for key: " + e.Key
}</span>

// ErrTypeConversion 类型转换错误
type ErrTypeConversion struct {
        FieldName string
        FromType  string
        ToType    string
        Value     interface{}
}

func (e *ErrTypeConversion) Error() string <span class="cov0" title="0">{
        return "type conversion failed for field " + e.FieldName +
                ": cannot convert " + e.FromType + " to " + e.ToType
}</span>

// 辅助函数

// NewErrFileNotFound 创建文件不存在错误
func NewErrFileNotFound(filePath, fileType string) *ErrFileNotFound <span class="cov0" title="0">{
        return &amp;ErrFileNotFound{FilePath: filePath, FileType: fileType}
}</span>

// NewErrSQLNotSupported 创建SQL不支持错误
func NewErrSQLNotSupported(dataSourceType string) *ErrSQLNotSupported <span class="cov0" title="0">{
        return &amp;ErrSQLNotSupported{DataSourceType: dataSourceType}
}</span>

// NewErrOperationNotSupported 创建操作不支持错误
func NewErrOperationNotSupported(dataSourceType, operation string) *ErrOperationNotSupported <span class="cov0" title="0">{
        return &amp;ErrOperationNotSupported{
                DataSourceType: dataSourceType,
                Operation:      operation,
        }
}</span>

// WrapDomainError 包装领域错误为基础设施错误
func WrapDomainError(err error) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *domain.ErrNotConnected:<span class="cov0" title="0">
                return e</span>
        case *domain.ErrReadOnly:<span class="cov0" title="0">
                return e</span>
        case *domain.ErrTableNotFound:<span class="cov0" title="0">
                return e</span>
        case *domain.ErrUnsupportedOperation:<span class="cov0" title="0">
                return e</span>
        case *domain.ErrConstraintViolation:<span class="cov0" title="0">
                return e</span>
        case *domain.ErrInvalidConfig:<span class="cov0" title="0">
                return e</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package pool

import (
        "container/list"
        "database/sql"
        "sync"
        "time"

        errors "github.com/kasuganosora/sqlexec/pkg/resource/infrastructure/errors"
)

// ==================== 连接池 ====================

// ConnectionWrapper 连接包装器
type ConnectionWrapper struct {
        conn      *sql.DB
        createdAt time.Time
        lastUsed  time.Time
        inUse     bool
}

// ConnectionPool 连接池
type ConnectionPool struct {
        maxOpen     int
        maxIdle     int
        lifetime    time.Duration
        idleTimeout time.Duration
        connections *list.List
        mu          sync.RWMutex
        metrics     *PoolMetrics
}

// PoolMetrics 池指标
type PoolMetrics struct {
        Created   int64
        Destroyed int64
        Acquired  int64
        Released  int64
        Errors    int64
        mu        sync.RWMutex
}

// NewConnectionPool 创建连接池
func NewConnectionPool() *ConnectionPool <span class="cov8" title="1">{
        return &amp;ConnectionPool{
                maxOpen:     10,
                maxIdle:     5,
                lifetime:    30 * time.Minute,
                idleTimeout: 5 * time.Minute,
                connections: list.New(),
                metrics:     &amp;PoolMetrics{},
        }
}</span>

// NewConnectionPoolWithConfig 使用配置创建连接池
func NewConnectionPoolWithConfig(maxOpen, maxIdle int, lifetime, idleTimeout time.Duration) *ConnectionPool <span class="cov8" title="1">{
        return &amp;ConnectionPool{
                maxOpen:     maxOpen,
                maxIdle:     maxIdle,
                lifetime:    lifetime,
                idleTimeout: idleTimeout,
                connections: list.New(),
                metrics:     &amp;PoolMetrics{},
        }
}</span>

// SetMaxOpenConns 设置最大连接数
func (p *ConnectionPool) SetMaxOpenConns(max int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.maxOpen = max
}</span>

// SetMaxIdleConns 设置最大空闲连接数
func (p *ConnectionPool) SetMaxIdleConns(max int) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.maxIdle = max
}</span>

// SetConnMaxLifetime 设置连接最大生命周期
func (p *ConnectionPool) SetConnMaxLifetime(lifetime time.Duration) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.lifetime = lifetime
}</span>

// SetIdleTimeout 设置空闲超时
func (p *ConnectionPool) SetIdleTimeout(timeout time.Duration) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.idleTimeout = timeout
}</span>

// Get 获取连接
func (p *ConnectionPool) Get() (*sql.DB, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // 检查连接数
        if p.connections.Len() &gt;= p.maxOpen </span><span class="cov8" title="1">{
                p.metrics.IncDeIncrementErrors()
                return nil, &amp;errors.ErrPoolExhausted{Message: "connection pool exhausted"}
        }</span>

        // 查找空闲连接
        <span class="cov8" title="1">for e := p.connections.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                conn, ok := e.Value.(*ConnectionWrapper)
                if ok &amp;&amp; !conn.inUse </span><span class="cov8" title="1">{
                        // 检查连接是否过期
                        if time.Since(conn.lastUsed) &gt; p.idleTimeout </span><span class="cov8" title="1">{
                                p.connections.Remove(e)
                                p.metrics.DecDeIncrementDestroyed()
                                continue</span>
                        }

                        // 检查连接生命周期
                        <span class="cov8" title="1">if time.Since(conn.createdAt) &gt; p.lifetime </span><span class="cov0" title="0">{
                                p.connections.Remove(e)
                                p.metrics.DecDeIncrementDestroyed()
                                continue</span>
                        }

                        // 重用连接
                        <span class="cov8" title="1">conn.inUse = true
                        conn.lastUsed = time.Now()
                        p.metrics.IncDeIncrementAcquired()
                        return conn.conn, nil</span>
                }
        }

        // 没有空闲连接，需要在实际使用中由调用者提供新连接
        <span class="cov8" title="1">p.metrics.IncDeIncrementCreated()
        return nil, nil</span>
}

// Release 释放连接
func (p *ConnectionPool) Release(conn *sql.DB) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // 查找连接
        for e := p.connections.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                wrapper, ok := e.Value.(*ConnectionWrapper)
                if ok &amp;&amp; wrapper.conn == conn </span><span class="cov8" title="1">{
                        wrapper.inUse = false
                        wrapper.lastUsed = time.Now()
                        p.metrics.IncDeIncrementReleased()
                        return
                }</span>
        }
}

// AddConnection 添加连接到池
func (p *ConnectionPool) AddConnection(conn *sql.DB) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.connections.PushBack(&amp;ConnectionWrapper{
                conn:      conn,
                createdAt: time.Now(),
                lastUsed:  time.Now(),
                inUse:     false,
        })

        // 更新metrics
        p.metrics.IncDeIncrementCreated()
}</span>

// Close 关闭连接池
func (p *ConnectionPool) Close() error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        for e := p.connections.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                if _, ok := e.Value.(*ConnectionWrapper); ok </span><span class="cov8" title="1">{
                        p.connections.Remove(e)
                        p.metrics.IncDeIncrementDestroyed()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetMetrics 获取池指标
func (p *ConnectionPool) GetMetrics() *PoolMetrics <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.metrics
}</span>

// Stats 获取统计信息
func (p *ConnectionPool) Stats() map[string]interface{} <span class="cov8" title="1">{
        metrics := p.GetMetrics()
        return map[string]interface{}{
                "max_open":        p.maxOpen,
                "max_idle":        p.maxIdle,
                "current_open":    p.connections.Len(),
                "total_created":   metrics.GetCreated(),
                "total_destroyed": metrics.GetDestroyed(),
                "total_acquired":  metrics.GetAcquired(),
                "total_released":  metrics.GetReleased(),
                "total_errors":    metrics.GetErrors(),
        }
}</span>

// ==================== 池指标 ====================

// IncDeIncrementCreated 增加创建计数
func (m *PoolMetrics) IncDeIncrementCreated() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Created++
}</span>

// DecDeIncrementCreated 减少创建计数
func (m *PoolMetrics) DecDeIncrementCreated() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.Created &gt; 0 </span><span class="cov8" title="1">{
                m.Created--
        }</span>
}

// IncDeIncrementDestroyed 增加销毁计数
func (m *PoolMetrics) IncDeIncrementDestroyed() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Destroyed++
}</span>

// DecDeIncrementDestroyed 减少销毁计数
func (m *PoolMetrics) DecDeIncrementDestroyed() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.Destroyed &gt; 0 </span><span class="cov8" title="1">{
                m.Destroyed--
        }</span>
}

// IncDeIncrementAcquired 增加获取计数
func (m *PoolMetrics) IncDeIncrementAcquired() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Acquired++
}</span>

// IncDeIncrementReleased 增加释放计数
func (m *PoolMetrics) IncDeIncrementReleased() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Released++
}</span>

// IncDeIncrementErrors 增加错误计数
func (m *PoolMetrics) IncDeIncrementErrors() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Errors++
}</span>

// GetCreated 获取创建计数
func (m *PoolMetrics) GetCreated() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.Created
}</span>

// GetDestroyed 获取销毁计数
func (m *PoolMetrics) GetDestroyed() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.Destroyed
}</span>

// GetAcquired 获取获取计数
func (m *PoolMetrics) GetAcquired() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.Acquired
}</span>

// GetReleased 获取释放计数
func (m *PoolMetrics) GetReleased() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.Released
}</span>

// GetErrors 获取错误计数
func (m *PoolMetrics) GetErrors() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.Errors
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package json

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
)

// JSONAdapter JSON文件数据源适配器
// 继承 MVCCDataSource，只负责JSON格式的加载和写回
type JSONAdapter struct {
        *memory.MVCCDataSource
        filePath  string
        arrayRoot string
        writable  bool
}

// NewJSONAdapter 创建JSON数据源适配器
func NewJSONAdapter(config *domain.DataSourceConfig, filePath string) *JSONAdapter <span class="cov8" title="1">{
        arrayRoot := ""
        writable := false // JSON默认只读

        // 从配置中读取选项
        if config.Options != nil </span><span class="cov8" title="1">{
                if r, ok := config.Options["array_root"]; ok </span><span class="cov8" title="1">{
                        if str, ok := r.(string); ok </span><span class="cov8" title="1">{
                                arrayRoot = str
                        }</span>
                }
                <span class="cov8" title="1">if w, ok := config.Options["writable"]; ok </span><span class="cov8" title="1">{
                        if b, ok := w.(bool); ok </span><span class="cov8" title="1">{
                                writable = b
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;JSONAdapter{
                MVCCDataSource: memory.NewMVCCDataSource(config),
                filePath:       filePath,
                arrayRoot:      arrayRoot,
                writable:       writable,
        }</span>
}

// Connect 连接数据源 - 加载JSON文件到内存
func (a *JSONAdapter) Connect(ctx context.Context) error <span class="cov8" title="1">{
        // 读取JSON文件
        data, err := os.ReadFile(a.filePath)
        if err != nil </span><span class="cov8" title="1">{
                return domain.NewErrNotConnected("json")
        }</span>

        // 解析JSON
        <span class="cov8" title="1">var jsonData interface{}
        if err := json.Unmarshal(data, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // 获取数据数组
        <span class="cov8" title="1">var rows []interface{}

        if a.arrayRoot != "" </span><span class="cov8" title="1">{
                // 从指定根节点获取数组
                if obj, ok := jsonData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if arr, ok := obj[a.arrayRoot].([]interface{}); ok </span><span class="cov8" title="1">{
                                rows = arr
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // 尝试直接解析为数组
                if arr, ok := jsonData.([]interface{}); ok </span><span class="cov8" title="1">{
                        rows = arr
                }</span>
        }

        <span class="cov8" title="1">if len(rows) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no data found in JSON file")
        }</span>

        // 推断列信息
        <span class="cov8" title="1">columns := a.inferColumnTypes(rows)

        // 转换为Row格式
        convertedRows := a.convertToRows(rows)

        // 创建表信息
        tableInfo := &amp;domain.TableInfo{
                Name:    "json_data",
                Schema:  "",
                Columns: columns,
        }

        // 加载到MVCC内存源
        if err := a.LoadTable("json_data", tableInfo, convertedRows); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load JSON data: %w", err)
        }</span>

        // 连接MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Connect(ctx)</span>
}

// Close 关闭连接 - 可选写回JSON文件
func (a *JSONAdapter) Close(ctx context.Context) error <span class="cov8" title="1">{
        // 如果是可写模式，需要写回JSON文件
        if a.writable </span><span class="cov8" title="1">{
                if err := a.writeBack(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write back JSON file: %w", err)
                }</span>
        }

        // 关闭MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Close(ctx)</span>
}

// GetConfig 获取数据源配置
func (a *JSONAdapter) GetConfig() *domain.DataSourceConfig <span class="cov8" title="1">{
        return a.MVCCDataSource.GetConfig()
}</span>

// GetTables 获取所有表（MVCCDataSource提供）
func (a *JSONAdapter) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTables(ctx)
}</span>

// GetTableInfo 获取表信息（MVCCDataSource提供）
func (a *JSONAdapter) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTableInfo(ctx, tableName)
}</span>

// Query 查询数据（MVCCDataSource提供）
func (a *JSONAdapter) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.Query(ctx, tableName, options)
}</span>

// Insert 插入数据（MVCCDataSource提供）
func (a *JSONAdapter) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("json", "insert")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新数据（MVCCDataSource提供）
func (a *JSONAdapter) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("json", "update")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除数据（MVCCDataSource提供）
func (a *JSONAdapter) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("json", "delete")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Delete(ctx, tableName, filters, options)</span>
}

// CreateTable 创建表（JSON不支持）
func (a *JSONAdapter) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("json", "create table")
}</span>

// DropTable 删除表（JSON不支持）
func (a *JSONAdapter) DropTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("json", "drop table")
}</span>

// TruncateTable 清空表（JSON不支持）
func (a *JSONAdapter) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("json", "truncate table")
}</span>

// Execute 执行SQL（JSON不支持）
func (a *JSONAdapter) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return nil, domain.NewErrUnsupportedOperation("json", "execute SQL")
}</span>

// ==================== 私有方法 ====================

// inferColumnTypes 推断列类型
func (a *JSONAdapter) inferColumnTypes(rows []interface{}) []domain.ColumnInfo <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return []domain.ColumnInfo{}
        }</span>

        // 采样前100行推断类型
        <span class="cov8" title="1">sampleSize := 100
        if len(rows) &lt; sampleSize </span><span class="cov8" title="1">{
                sampleSize = len(rows)
        }</span>

        // 收集所有字段
        <span class="cov8" title="1">fieldsMap := make(map[string][]interface{})
        for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                if row, ok := rows[i].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        for key, value := range row </span><span class="cov8" title="1">{
                                fieldsMap[key] = append(fieldsMap[key], value)
                        }</span>
                }
        }

        // 推断每列的类型
        <span class="cov8" title="1">columns := make([]domain.ColumnInfo, 0, len(fieldsMap))
        for field, values := range fieldsMap </span><span class="cov8" title="1">{
                colType := a.inferType(values)
                columns = append(columns, domain.ColumnInfo{
                        Name:     field,
                        Type:     colType,
                        Nullable: true,
                })
        }</span>

        <span class="cov8" title="1">return columns</span>
}

// inferType 推断值的类型
func (a *JSONAdapter) inferType(values []interface{}) string <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return "string"
        }</span>

        <span class="cov8" title="1">typeCounts := map[string]int{
                "int64":   0,
                "float64": 0,
                "bool":    0,
                "string":  0,
        }

        for _, value := range values </span><span class="cov8" title="1">{
                if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">colType := a.detectType(value)
                typeCounts[colType]++</span>
        }

        // 选择最常见的类型
        <span class="cov8" title="1">maxCount := 0
        bestType := "string"
        for t, count := range typeCounts </span><span class="cov8" title="1">{
                if count &gt; maxCount </span><span class="cov8" title="1">{
                        maxCount = count
                        bestType = t
                }</span>
        }

        <span class="cov8" title="1">return bestType</span>
}

// detectType 检测值的类型
func (a *JSONAdapter) detectType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return "bool"</span>
        case float64:<span class="cov8" title="1">
                // 检查是否是整数
                if v == float64(int64(v)) </span><span class="cov8" title="1">{
                        return "int64"
                }</span>
                <span class="cov8" title="1">return "float64"</span>
        case string:<span class="cov8" title="1">
                return "string"</span>
        case nil:<span class="cov0" title="0">
                return "string"</span>
        case []interface{}, map[string]interface{}:<span class="cov0" title="0">
                return "string"</span>
        default:<span class="cov0" title="0">
                return "string"</span>
        }
}

// convertToRows 转换JSON行为Row格式
func (a *JSONAdapter) convertToRows(rows []interface{}) []domain.Row <span class="cov8" title="1">{
        result := make([]domain.Row, 0, len(rows))

        for _, row := range rows </span><span class="cov8" title="1">{
                if rowMap, ok := row.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        result = append(result, domain.Row(rowMap))
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// writeBack 写回JSON文件
func (a *JSONAdapter) writeBack() error <span class="cov8" title="1">{
        // 获取最新数据
        _, rows, err := a.GetLatestTableData("json_data")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 转换回JSON数组格式
        <span class="cov8" title="1">jsonArray := make([]map[string]interface{}, len(rows))
        for i, row := range rows </span><span class="cov8" title="1">{
                jsonArray[i] = make(map[string]interface{})
                for k, v := range row </span><span class="cov8" title="1">{
                        jsonArray[i][k] = v
                }</span>
        }

        <span class="cov8" title="1">var jsonData interface{}
        if a.arrayRoot != "" </span><span class="cov0" title="0">{
                // 包装在指定根节点下
                jsonData = map[string]interface{}{
                        a.arrayRoot: jsonArray,
                }
        }</span> else<span class="cov8" title="1"> {
                // 直接是数组
                jsonData = jsonArray
        }</span>

        // 序列化为JSON
        <span class="cov8" title="1">data, err := json.MarshalIndent(jsonData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 写入文件
        <span class="cov8" title="1">return os.WriteFile(a.filePath, data, 0644)</span>
}

// IsConnected 检查是否已连接（MVCCDataSource提供）
func (a *JSONAdapter) IsConnected() bool <span class="cov8" title="1">{
        return a.MVCCDataSource.IsConnected()
}</span>

// IsWritable 检查是否可写
func (a *JSONAdapter) IsWritable() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// SupportsWrite 实现IsWritableSource接口
func (a *JSONAdapter) SupportsWrite() bool <span class="cov8" title="1">{
        return a.writable
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package json

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// JSONFactory JSON 数据源工厂
type JSONFactory struct{}

// NewJSONFactory 创建 JSON 数据源工厂
func NewJSONFactory() *JSONFactory <span class="cov8" title="1">{
        return &amp;JSONFactory{}
}</span>

// GetType 实现 DataSourceFactory 接口
func (f *JSONFactory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return domain.DataSourceTypeJSON
}</span>

// Create 实现 DataSourceFactory 接口
func (f *JSONFactory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        // 使用JSONAdapter（继承MVCCDataSource）
        return NewJSONAdapter(config, config.Name), nil
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package memory

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ==================== Factory ====================

// MemoryFactory 内存数据源工厂
type MemoryFactory struct{}

// NewMemoryFactory 创建内存数据源工厂
func NewMemoryFactory() *MemoryFactory <span class="cov8" title="1">{
        return &amp;MemoryFactory{}
}</span>

// GetType 实现DataSourceFactory接口
func (f *MemoryFactory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return domain.DataSourceTypeMemory
}</span>

// Create 实现DataSourceFactory接口
func (f *MemoryFactory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        // 内存数据源默认可写
        writable := true
        if config != nil </span><span class="cov8" title="1">{
                writable = config.Writable
        }</span>
        <span class="cov8" title="1">return NewMVCCDataSource(&amp;domain.DataSourceConfig{
                Type:     domain.DataSourceTypeMemory,
                Name:     config.Name,
                Writable: writable,
        }), nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package memory

import (
        "fmt"
        "strings"
        "sync"
)

// IndexType 索引类型
type IndexType string

const (
        IndexTypeBTree    IndexType = "btree"
        IndexTypeHash     IndexType = "hash"
        IndexTypeFullText IndexType = "fulltext"
)

// Index 索引接口
type Index interface {
        // Insert 插入键值
        Insert(key interface{}, rowIDs []int64) error

        // Delete 删除键值
        Delete(key interface{}) error

        // Find 查找键值对应的行ID
        Find(key interface{}) ([]int64, bool)

        // FindRange 范围查询（仅B-Tree支持）
        FindRange(min, max interface{}) ([]int64, error)

        // GetIndexInfo 获取索引信息
        GetIndexInfo() *IndexInfo
}

// IndexInfo 索引信息
type IndexInfo struct {
        Name      string
        TableName string
        Column    string
        Type      IndexType
        Unique    bool
}

// ==================== B-Tree 索引实现 ====================

// BTreeIndex B-Tree 索引
type BTreeIndex struct {
        info  *IndexInfo
        root  *BTreeNode
        height int
        mu    sync.RWMutex
        unique bool
}

// BTreeNode B-Tree 节点（简化版，使用切片实现）
// 实际实现应该使用真正的B+ Tree结构
type BTreeNode struct {
        isLeaf   bool
        keys     []interface{}
        children []*BTreeNode
        mu       sync.RWMutex
}

// NewBTreeNode 创建B-Tree节点
func NewBTreeNode(isLeaf bool) *BTreeNode <span class="cov0" title="0">{
        return &amp;BTreeNode{
                isLeaf:   isLeaf,
                keys:     make([]interface{}, 0),
                children: make([]*BTreeNode, 0),
        }
}</span>

// NewBTreeIndex 创建B-Tree索引
func NewBTreeIndex(tableName, columnName string, unique bool) *BTreeIndex <span class="cov0" title="0">{
        return &amp;BTreeIndex{
                info: &amp;IndexInfo{
                        Name:      fmt.Sprintf("idx_%s_%s", tableName, columnName),
                        TableName: tableName,
                        Column:    columnName,
                        Type:      IndexTypeBTree,
                        Unique:    unique,
                },
                root:  NewBTreeNode(true),
                height: 1,
                unique: unique,
        }
}</span>

// Insert 插入键值到B-Tree索引
func (idx *BTreeIndex) Insert(key interface{}, rowIDs []int64) error <span class="cov0" title="0">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        // 简化实现：插入到root节点
        // 实际应该实现B+ Tree的插入逻辑
        idx.root.keys = append(idx.root.keys, key)
        return nil
}</span>

// Delete 从B-Tree索引删除键值
func (idx *BTreeIndex) Delete(key interface{}) error <span class="cov0" title="0">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        // 简化实现：从root节点删除
        // 实际应该实现B+ Tree的删除逻辑
        for i, k := range idx.root.keys </span><span class="cov0" title="0">{
                if k == key </span><span class="cov0" title="0">{
                        idx.root.keys = append(idx.root.keys[:i], idx.root.keys[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("key not found: %v", key)</span>
}

// Find 在B-Tree索引查找键值
func (idx *BTreeIndex) Find(key interface{}) ([]int64, bool) <span class="cov0" title="0">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        // 简化实现：在root节点查找
        // 实际应该实现B+ Tree的查找逻辑
        for _, k := range idx.root.keys </span><span class="cov0" title="0">{
                if k == key </span><span class="cov0" title="0">{
                        // 简化返回
                        return []int64{1}, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// FindRange 在B-Tree索引范围查询
func (idx *BTreeIndex) FindRange(min, max interface{}) ([]int64, error) <span class="cov0" title="0">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        // 简化实现：在root节点范围查询
        // 实际应该实现B+ Tree的范围查询逻辑
        var results []int64
        for _, k := range idx.root.keys </span><span class="cov0" title="0">{
                if compareKeys(k, min) &gt;= 0 &amp;&amp; compareKeys(k, max) &lt;= 0 </span><span class="cov0" title="0">{
                        results = append(results, 1)
                }</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

// GetIndexInfo 获取索引信息
func (idx *BTreeIndex) GetIndexInfo() *IndexInfo <span class="cov0" title="0">{
        return idx.info
}</span>

// ==================== Hash 索引实现 ====================

// HashIndex 哈希索引
type HashIndex struct {
        info  *IndexInfo
        data  map[interface{}][]int64
        mu    sync.RWMutex
        unique bool
}

// NewHashIndex 创建哈希索引
func NewHashIndex(tableName, columnName string, unique bool) *HashIndex <span class="cov0" title="0">{
        return &amp;HashIndex{
                info: &amp;IndexInfo{
                        Name:      fmt.Sprintf("idx_%s_%s", tableName, columnName),
                        TableName: tableName,
                        Column:    columnName,
                        Type:      IndexTypeHash,
                        Unique:    unique,
                },
                data:  make(map[interface{}][]int64),
                unique: unique,
        }
}</span>

// Insert 插入键值到哈希索引
func (idx *HashIndex) Insert(key interface{}, rowIDs []int64) error <span class="cov0" title="0">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        if idx.unique </span><span class="cov0" title="0">{
                if _, exists := idx.data[key]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate key violation for unique index")
                }</span>
                <span class="cov0" title="0">idx.data[key] = rowIDs</span>
        } else<span class="cov0" title="0"> {
                idx.data[key] = append(idx.data[key], rowIDs...)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 从哈希索引删除键值
func (idx *HashIndex) Delete(key interface{}) error <span class="cov0" title="0">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        delete(idx.data, key)
        return nil
}</span>

// Find 在哈希索引查找键值
func (idx *HashIndex) Find(key interface{}) ([]int64, bool) <span class="cov0" title="0">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        rowIDs, exists := idx.data[key]
        return rowIDs, exists
}</span>

// FindRange 哈希索引不支持范围查询
func (idx *HashIndex) FindRange(min, max interface{}) ([]int64, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("hash index does not support range queries")
}</span>

// GetIndexInfo 获取索引信息
func (idx *HashIndex) GetIndexInfo() *IndexInfo <span class="cov0" title="0">{
        return idx.info
}</span>

// ==================== 全文索引实现 ====================

// InvertedIndex 倒排索引
type InvertedIndex struct {
        tokens map[string][]int64
        mu     sync.RWMutex
}

// NewInvertedIndex 创建倒排索引
func NewInvertedIndex() *InvertedIndex <span class="cov0" title="0">{
        return &amp;InvertedIndex{
                tokens: make(map[string][]int64),
        }
}</span>

// AddDocument 添加文档到倒排索引
func (inv *InvertedIndex) AddDocument(docID int64, text string) <span class="cov0" title="0">{
        inv.mu.Lock()
        defer inv.mu.Unlock()

        // 简单分词：按空格分割
        tokens := tokenize(text)
        for _, token := range tokens </span><span class="cov0" title="0">{
                if token == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">inv.tokens[token] = append(inv.tokens[token], docID)</span>
        }
}

// Search 在倒排索引搜索
func (inv *InvertedIndex) Search(query string) []int64 <span class="cov0" title="0">{
        inv.mu.RLock()
        defer inv.mu.RUnlock()

        queryTokens := tokenize(query)
        if len(queryTokens) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 取第一个token的结果
        <span class="cov0" title="0">results := make(map[int64]bool)
        for _, docID := range inv.tokens[queryTokens[0]] </span><span class="cov0" title="0">{
                results[docID] = true
        }</span>

        // AND操作：取交集
        <span class="cov0" title="0">for _, token := range queryTokens[1:] </span><span class="cov0" title="0">{
                intersection := make(map[int64]bool)
                for _, docID := range inv.tokens[token] </span><span class="cov0" title="0">{
                        if results[docID] </span><span class="cov0" title="0">{
                                intersection[docID] = true
                        }</span>
                }
                <span class="cov0" title="0">results = intersection</span>
        }

        // 转换为切片
        <span class="cov0" title="0">resultSlice := make([]int64, 0, len(results))
        for docID := range results </span><span class="cov0" title="0">{
                resultSlice = append(resultSlice, docID)
        }</span>

        <span class="cov0" title="0">return resultSlice</span>
}

// FullTextIndex 全文索引
type FullTextIndex struct {
        info     *IndexInfo
        inverted *InvertedIndex
        mu       sync.RWMutex
}

// NewFullTextIndex 创建全文索引
func NewFullTextIndex(tableName, columnName string) *FullTextIndex <span class="cov0" title="0">{
        return &amp;FullTextIndex{
                info: &amp;IndexInfo{
                        Name:      fmt.Sprintf("idx_ft_%s_%s", tableName, columnName),
                        TableName: tableName,
                        Column:    columnName,
                        Type:      IndexTypeFullText,
                        Unique:    false,
                },
                inverted: NewInvertedIndex(),
        }
}</span>

// Insert 插入文本到全文索引
func (idx *FullTextIndex) Insert(key interface{}, rowIDs []int64) error <span class="cov0" title="0">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        // key应该是字符串类型
        text, ok := key.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("full-text index requires string key, got %T", key)
        }</span>

        <span class="cov0" title="0">for _, rowID := range rowIDs </span><span class="cov0" title="0">{
                idx.inverted.AddDocument(rowID, text)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 从全文索引删除键值
func (idx *FullTextIndex) Delete(key interface{}) error <span class="cov0" title="0">{
        // 全文索引不支持删除单个键
        // 实际实现应该维护反向映射
        return fmt.Errorf("full-text index delete not implemented")
}</span>

// Find 在全文索引查找
func (idx *FullTextIndex) Find(key interface{}) ([]int64, bool) <span class="cov0" title="0">{
        query, ok := key.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">results := idx.inverted.Search(query)
        return results, len(results) &gt; 0</span>
}

// FindRange 全文索引不支持范围查询
func (idx *FullTextIndex) FindRange(min, max interface{}) ([]int64, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("full-text index does not support range queries")
}</span>

// GetIndexInfo 获取索引信息
func (idx *FullTextIndex) GetIndexInfo() *IndexInfo <span class="cov0" title="0">{
        return idx.info
}</span>

// ==================== 辅助函数 ====================

// tokenize 分词函数
func tokenize(text string) []string <span class="cov0" title="0">{
        // 简单实现：按空格、制表符分割
        text = strings.ToLower(text)
        text = strings.ReplaceAll(text, "\t", " ")
        text = strings.ReplaceAll(text, "\n", " ")
        
        parts := strings.Split(text, " ")
        tokens := make([]string, 0, len(parts))
        
        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                if part != "" </span><span class="cov0" title="0">{
                        tokens = append(tokens, part)
                }</span>
        }
        
        <span class="cov0" title="0">return tokens</span>
}

// compareKeys 比较两个键（用于范围查询）
func compareKeys(a, b interface{}) int <span class="cov0" title="0">{
        switch va := a.(type) </span>{
        case int:<span class="cov0" title="0">
                vb := b.(int)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int64:<span class="cov0" title="0">
                vb := b.(int64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float64:<span class="cov0" title="0">
                vb := b.(float64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case string:<span class="cov0" title="0">
                vb := b.(string)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package memory

import (
        "fmt"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// IndexManager 索引管理器
type IndexManager struct {
        tables map[string]*TableIndexes
        mu     sync.RWMutex
}

// TableIndexes 单个表的索引集合
type TableIndexes struct {
        tableName string
        indexes   map[string]Index   // columnName -&gt; Index
        columnMap map[string]Index      // columnName -&gt; Index
        mu        sync.RWMutex
}

// NewIndexManager 创建索引管理器
func NewIndexManager() *IndexManager <span class="cov8" title="1">{
        return &amp;IndexManager{
                tables: make(map[string]*TableIndexes),
                mu:     sync.RWMutex{},
        }
}</span>

// CreateIndex 创建索引
func (m *IndexManager) CreateIndex(tableName, columnName string, indexType IndexType, unique bool) (Index, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        tableIdxs, ok := m.tables[tableName]
        if !ok </span><span class="cov0" title="0">{
                tableIdxs = &amp;TableIndexes{
                        tableName: tableName,
                        indexes:   make(map[string]Index),
                        columnMap: make(map[string]Index),
                        mu:        sync.RWMutex{},
                }
                m.tables[tableName] = tableIdxs
        }</span>

        <span class="cov0" title="0">tableIdxs.mu.Lock()
        defer tableIdxs.mu.Unlock()

        // 检查列是否已有索引
        if _, exists := tableIdxs.columnMap[columnName]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("index already exists for column: %s", columnName)
        }</span>

        // 根据类型创建索引
        <span class="cov0" title="0">var idx Index
        switch indexType </span>{
        case IndexTypeBTree:<span class="cov0" title="0">
                idx = NewBTreeIndex(tableName, columnName, unique)</span>
        case IndexTypeHash:<span class="cov0" title="0">
                idx = NewHashIndex(tableName, columnName, unique)</span>
        case IndexTypeFullText:<span class="cov0" title="0">
                idx = NewFullTextIndex(tableName, columnName)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported index type: %s", indexType)</span>
        }

        // 存储索引
        <span class="cov0" title="0">tableIdxs.indexes[idx.GetIndexInfo().Name] = idx
        tableIdxs.columnMap[columnName] = idx

        return idx, nil</span>
}

// GetIndex 获取指定列的索引
func (m *IndexManager) GetIndex(tableName, columnName string) (Index, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tableIdxs, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("table not found: %s", tableName)
        }</span>

        <span class="cov0" title="0">tableIdxs.mu.RLock()
        defer tableIdxs.mu.RUnlock()

        idx, exists := tableIdxs.columnMap[columnName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("index not found for column: %s", columnName)
        }</span>

        <span class="cov0" title="0">return idx, nil</span>
}

// DropIndex 删除索引
func (m *IndexManager) DropIndex(tableName, indexName string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        tableIdxs, ok := m.tables[tableName]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("table not found: %s", tableName)
        }</span>

        <span class="cov0" title="0">tableIdxs.mu.Lock()
        defer tableIdxs.mu.Unlock()

        delete(tableIdxs.indexes, indexName)

        // 从columnMap中移除
        for col, idx := range tableIdxs.columnMap </span><span class="cov0" title="0">{
                if idx.GetIndexInfo().Name == indexName </span><span class="cov0" title="0">{
                        delete(tableIdxs.columnMap, col)
                        break</span>
                }
        }

        // 重要：只删除索引元数据，不应该影响表数据
        // 确保不会删除表本身
        <span class="cov0" title="0">if _, ok := m.tables[tableName]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected: table %s was deleted", tableName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DropTableIndexes 删除表的所有索引
func (m *IndexManager) DropTableIndexes(tableName string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        delete(m.tables, tableName)
        return nil
}</span>

// RebuildIndex 重建索引
func (m *IndexManager) RebuildIndex(tableName string, schema *domain.TableInfo, rows []domain.Row) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        tableIdxs, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("table not found: %s", tableName)
        }</span>

        <span class="cov0" title="0">tableIdxs.mu.Lock()
        defer tableIdxs.mu.Unlock()

        // 清空所有索引
        for _, idx := range tableIdxs.indexes </span><span class="cov0" title="0">{
                switch idx := idx.(type) </span>{
                case *BTreeIndex:<span class="cov0" title="0">
                        // 重置B+ Tree
                        idx.mu.Lock()
                        idx.root = NewBTreeNode(true)
                        idx.height = 1
                        idx.mu.Unlock()</span>
                case *HashIndex:<span class="cov0" title="0">
                        // 重置Hash索引
                        idx.mu.Lock()
                        idx.data = make(map[interface{}][]int64)
                        idx.mu.Unlock()</span>
                case *FullTextIndex:<span class="cov0" title="0">
                        // 重置全文索引
                        idx.mu.Lock()
                        idx.inverted = NewInvertedIndex()
                        idx.mu.Unlock()</span>
                }
        }

        // 重建索引
        <span class="cov0" title="0">for i, row := range rows </span><span class="cov0" title="0">{
                rowID := int64(i + 1)
                for columnName, value := range row </span><span class="cov0" title="0">{
                        if idx, ok := tableIdxs.columnMap[columnName]; ok </span><span class="cov0" title="0">{
                                _ = idx.Insert(value, []int64{rowID})
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetTableIndexes 获取表的所有索引信息
func (m *IndexManager) GetTableIndexes(tableName string) ([]*IndexInfo, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tableIdxs, ok := m.tables[tableName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("table not found: %s", tableName)
        }</span>

        <span class="cov0" title="0">tableIdxs.mu.RLock()
        defer tableIdxs.mu.RUnlock()

        infos := make([]*IndexInfo, 0, len(tableIdxs.indexes))
        for _, idx := range tableIdxs.indexes </span><span class="cov0" title="0">{
                infos = append(infos, idx.GetIndexInfo())
        }</span>

        <span class="cov0" title="0">return infos, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package memory

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/util"
)

// TransactionIDKey context key for transaction ID
type TransactionIDKey struct{}

// GetTransactionID 从context中获取事务ID
func GetTransactionID(ctx context.Context) (int64, bool) <span class="cov8" title="1">{
        txnID, ok := ctx.Value(TransactionIDKey{}).(int64)
        return txnID, ok
}</span>

// SetTransactionID 设置事务ID到context
func SetTransactionID(ctx context.Context, txnID int64) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, TransactionIDKey{}, txnID)
}</span>

// ==================== MVCC 数据源实现 ====================

// MVCCDataSource 支持多版本并发控制的内存数据源
// 这是所有外部数据源的底层基础，所有数据源都应该映射到这里
type MVCCDataSource struct {
        config    *domain.DataSourceConfig
        connected bool
        mu        sync.RWMutex

        // 索引管理
        indexManager *IndexManager
        queryPlanner *QueryPlanner

        // MVCC 相关
        nextTxID    int64
        currentVer  int64
        snapshots   map[int64]*Snapshot
        activeTxns  map[int64]*Transaction

        // 数据存储（按版本管理）
        tables      map[string]*TableVersions

        // 临时表（会话结束时自动删除）
        tempTables  map[string]bool
}

// SupportsMVCC 实现IsMVCCable接口
func (m *MVCCDataSource) SupportsMVCC() bool <span class="cov8" title="1">{
        return true
}</span>

// TableVersions 表的多版本数据
type TableVersions struct {
        mu      sync.RWMutex
        versions map[int64]*TableData  // version -&gt; data
        latest  int64                   // 最新版本号
}

// TableData 单个版本的数据
type TableData struct {
        version   int64
        createdAt time.Time
        schema    *domain.TableInfo
        rows      []domain.Row
}

// COWTableSnapshot 写时复制的表快照
type COWTableSnapshot struct {
        tableName    string
        copied       bool               // 是否已创建修改副本
        baseData     *TableData          // 基础数据引用（未修改时）
        modifiedData *TableData         // 修改后的数据
        rowLocks     map[int64]bool     // 行级锁：跟踪哪些行被修改了
        rowCopies    map[int64]domain.Row // 行级拷贝：存储修改后的行
        deletedRows  map[int64]bool     // 行级删除：标记哪些行被删除了
        mu           sync.RWMutex
}

// Snapshot 事务快照（写时复制）
type Snapshot struct {
        txnID        int64
        startVer     int64
        createdAt    time.Time
        // 事务工作区：每张表的写时复制快照
        // 在首次修改表时才拷贝数据
        tableSnapshots map[string]*COWTableSnapshot
}

// Transaction 事务信息
type Transaction struct {
        txnID      int64
        startTime  time.Time
        readOnly   bool
}

// NewMVCCDataSource 创建MVCC内存数据源
func NewMVCCDataSource(config *domain.DataSourceConfig) *MVCCDataSource <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;domain.DataSourceConfig{
                        Type:     domain.DataSourceTypeMemory,
                        Name:     "memory",
                        Writable: true,
                }
        }</span>

        <span class="cov8" title="1">indexMgr := NewIndexManager()
        return &amp;MVCCDataSource{
                config:        config,
                connected:     false,
                indexManager:  indexMgr,
                queryPlanner:  NewQueryPlanner(indexMgr),
                nextTxID:       1,
                currentVer:    0,
                snapshots:     make(map[int64]*Snapshot),
                activeTxns:    make(map[int64]*Transaction),
                tables:        make(map[string]*TableVersions),
                tempTables:    make(map[string]bool),
        }</span>
}

// ==================== 连接管理 ====================

// Connect 连接数据源
func (m *MVCCDataSource) Connect(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connected = true
        return nil
}</span>

// Close 关闭连接
func (m *MVCCDataSource) Close(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 删除所有临时表
        for tableName := range m.tempTables </span><span class="cov0" title="0">{
                delete(m.tables, tableName)
        }</span>
        <span class="cov8" title="1">m.tempTables = make(map[string]bool)

        // 清理所有快照和事务
        m.snapshots = make(map[int64]*Snapshot)
        m.activeTxns = make(map[int64]*Transaction)
        m.connected = false
        return nil</span>
}

// BeginTransaction 实现 TransactionalDataSource 接口
func (m *MVCCDataSource) BeginTransaction(ctx context.Context, options *domain.TransactionOptions) (domain.Transaction, error) <span class="cov0" title="0">{
        readOnly := false
        if options != nil </span><span class="cov0" title="0">{
                readOnly = options.ReadOnly
        }</span>

        <span class="cov0" title="0">txnID, err := m.BeginTx(ctx, readOnly)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MVCCTransaction{
                ds:    m,
                txnID: txnID,
        }, nil</span>
}

// IsConnected 检查是否已连接
func (m *MVCCDataSource) IsConnected() bool <span class="cov8" title="1">{
        return m.connected
}</span>

// IsWritable 检查是否可写
func (m *MVCCDataSource) IsWritable() bool <span class="cov8" title="1">{
        return m.config.Writable
}</span>

// GetConfig 获取数据源配置
func (m *MVCCDataSource) GetConfig() *domain.DataSourceConfig <span class="cov8" title="1">{
        return m.config
}</span>

// ==================== 事务管理 ====================

// BeginTx 开始一个新事务（写时复制）
func (m *MVCCDataSource) BeginTx(ctx context.Context, readOnly bool) (int64, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        txnID := m.nextTxID
        m.nextTxID++

        // 创建写时复制快照结构，不拷贝数据
        tableSnapshots := make(map[string]*COWTableSnapshot)
        for tableName := range m.tables </span><span class="cov0" title="0">{
                // 只创建快照结构，引用基础数据
                tableSnapshots[tableName] = &amp;COWTableSnapshot{
                        tableName:    tableName,
                        copied:       false,
                        baseData:     nil,  // 访问时延迟加载
                        modifiedData: nil,
                }
        }</span>

        <span class="cov8" title="1">snapshot := &amp;Snapshot{
                txnID:        txnID,
                startVer:     m.currentVer,
                createdAt:    time.Now(),
                tableSnapshots: tableSnapshots,
        }

        txn := &amp;Transaction{
                txnID:     txnID,
                startTime: time.Now(),
                readOnly:  readOnly,
        }

        m.snapshots[txnID] = snapshot
        m.activeTxns[txnID] = txn

        return txnID, nil</span>
}

// CommitTx 提交事务（COW优化，支持行级COW）
func (m *MVCCDataSource) CommitTx(ctx context.Context, txnID int64) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        txn, ok := m.activeTxns[txnID]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("transaction not found: %d", txnID)
        }</span>

        <span class="cov8" title="1">snapshot, ok := m.snapshots[txnID]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction snapshot not found: %d", txnID)
        }</span>

        <span class="cov8" title="1">if txn.readOnly </span><span class="cov8" title="1">{
                // 只读事务直接结束
                delete(m.activeTxns, txnID)
                delete(m.snapshots, txnID)
                return nil
        }</span>

        // 写事务提交时，只提交已修改的表
        <span class="cov8" title="1">for tableName, cowSnapshot := range snapshot.tableSnapshots </span><span class="cov0" title="0">{
                tableVer := m.tables[tableName]
                if tableVer != nil &amp;&amp; cowSnapshot.copied </span><span class="cov0" title="0">{
                        cowSnapshot.mu.Lock()

                        // 检查是否有行级修改
                        if len(cowSnapshot.rowCopies) == 0 &amp;&amp; len(cowSnapshot.deletedRows) == 0 </span><span class="cov0" title="0">{
                                // 没有行被修改，无需创建新版本
                                cowSnapshot.mu.Unlock()
                                continue</span>
                        }

                        // 行级COW：合并基础数据和修改的行
                        <span class="cov0" title="0">tableVer.mu.Lock()
                        m.currentVer++

                        // 合并基础数据和行级修改
                        newRows := make([]domain.Row, 0, len(cowSnapshot.baseData.rows))
                        for i, row := range cowSnapshot.baseData.rows </span><span class="cov0" title="0">{
                                rowID := int64(i + 1)

                                // 检查此行是否被删除
                                if _, deleted := cowSnapshot.deletedRows[rowID]; deleted </span><span class="cov0" title="0">{
                                        continue</span> // 跳过已删除的行
                                }

                                // 检查此行是否被修改
                                <span class="cov0" title="0">if modifiedRow, ok := cowSnapshot.rowCopies[rowID]; ok </span><span class="cov0" title="0">{
                                        // 使用修改后的行
                                        newRows = append(newRows, modifiedRow)
                                }</span> else<span class="cov0" title="0"> {
                                        // 使用原始行（需要深拷贝）
                                        rowCopy := make(map[string]interface{}, len(row))
                                        for k, v := range row </span><span class="cov0" title="0">{
                                                rowCopy[k] = v
                                        }</span>
                                        <span class="cov0" title="0">newRows = append(newRows, rowCopy)</span>
                                }
                        }

                        // 处理新增的行（rowID超过基础数据行数的行）
                        <span class="cov0" title="0">baseRowsCount := len(cowSnapshot.baseData.rows)
                        for rowID, row := range cowSnapshot.rowCopies </span><span class="cov0" title="0">{
                                if rowID &gt; int64(baseRowsCount) </span><span class="cov0" title="0">{
                                        // 这是新插入的行
                                        newRows = append(newRows, row)
                                }</span>
                        }

                        // 创建新版本
                        <span class="cov0" title="0">cols := make([]domain.ColumnInfo, len(cowSnapshot.modifiedData.schema.Columns))
                        copy(cols, cowSnapshot.modifiedData.schema.Columns)

                        newVersionData := &amp;TableData{
                                version:   m.currentVer,
                                createdAt: time.Now(),
                                schema: &amp;domain.TableInfo{
                                        Name:    cowSnapshot.modifiedData.schema.Name,
                                        Schema:  cowSnapshot.modifiedData.schema.Schema,
                                        Columns: cols,
                                },
                                rows: newRows,
                        }

                        tableVer.versions[m.currentVer] = newVersionData
                        tableVer.latest = m.currentVer
                        tableVer.mu.Unlock()

                        cowSnapshot.mu.Unlock()</span>
                }
        }

        <span class="cov8" title="1">delete(m.activeTxns, txnID)
        delete(m.snapshots, txnID)

        return nil</span>
}

// RollbackTx 回滚事务
func (m *MVCCDataSource) RollbackTx(ctx context.Context, txnID int64) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.activeTxns[txnID]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("transaction not found: %d", txnID)
        }</span>

        // 写时复制下，回滚只需删除快照，无需释放数据
        <span class="cov8" title="1">delete(m.activeTxns, txnID)
        delete(m.snapshots, txnID)

        return nil</span>
}

// ensureTableCopied 确保表数据已拷贝到事务快照（写时复制）
// 采用行级COW：只创建结构，不立即拷贝所有行
func (s *COWTableSnapshot) ensureCopied(tableVer *TableVersions) error <span class="cov0" title="0">{
        if s.copied </span><span class="cov0" title="0">{
                return nil // 已创建副本
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // 再次检查，避免重复创建
        if s.copied </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 获取主版本数据
        <span class="cov0" title="0">tableVer.mu.RLock()
        baseData := tableVer.versions[tableVer.latest]
        tableVer.mu.RUnlock()

        if baseData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("table %s not found", s.tableName)
        }</span>

        // 拷贝schema
        <span class="cov0" title="0">cols := make([]domain.ColumnInfo, len(baseData.schema.Columns))
        copy(cols, baseData.schema.Columns)

        // 创建修改后的数据结构，但不立即拷贝所有行
        // 采用行级COW：只创建结构，行按需拷贝
        s.modifiedData = &amp;TableData{
                version:   baseData.version,
                createdAt: baseData.createdAt,
                schema: &amp;domain.TableInfo{
                        Name:    baseData.schema.Name,
                        Schema:  baseData.schema.Schema,
                        Columns: cols,
                },
                rows: nil, // 行数据延迟加载和拷贝
        }

        // 初始化行级跟踪结构
        s.rowLocks = make(map[int64]bool)      // 跟踪修改的行
        s.rowCopies = make(map[int64]domain.Row) // 存储修改后的行
        s.deletedRows = make(map[int64]bool) // 标记删除的行

        s.baseData = baseData
        s.copied = true

        return nil</span>
}

// getTableData 从COW快照获取表数据（行级COW）
func (s *COWTableSnapshot) getTableData(tableVer *TableVersions) *TableData <span class="cov0" title="0">{
        if !s.copied </span><span class="cov0" title="0">{
                // 未创建副本时，直接读取主版本
                tableVer.mu.RLock()
                data := tableVer.versions[tableVer.latest]
                tableVer.mu.RUnlock()
                return data
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()

        // 已创建副本，需要合并基础数据和行级修改
        if len(s.rowCopies) == 0 </span><span class="cov0" title="0">{
                // 没有行被修改，返回基础数据
                return s.baseData
        }</span>

        // 合并基础数据和修改的行
        <span class="cov0" title="0">mergedRows := make([]domain.Row, 0, len(s.baseData.rows))
        for i, row := range s.baseData.rows </span><span class="cov0" title="0">{
                rowID := int64(i + 1) // 行ID从1开始
                if modifiedRow, ok := s.rowCopies[rowID]; ok </span><span class="cov0" title="0">{
                        // 使用修改后的行
                        mergedRows = append(mergedRows, modifiedRow)
                }</span> else<span class="cov0" title="0"> {
                        // 使用原始行
                        mergedRows = append(mergedRows, row)
                }</span>
        }

        <span class="cov0" title="0">return &amp;TableData{
                version:   s.modifiedData.version,
                createdAt: s.modifiedData.createdAt,
                schema:    s.modifiedData.schema,
                rows:      mergedRows,
        }</span>
}

// ==================== 表管理 ====================

// GetTables 获取所有表（不包括临时表）
func (m *MVCCDataSource) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        if !m.connected </span><span class="cov0" title="0">{
                return nil, domain.NewErrNotConnected("memory")
        }</span>

        <span class="cov8" title="1">m.mu.RLock()
        defer m.mu.RUnlock()

        tables := make([]string, 0, len(m.tables))
        for name := range m.tables </span><span class="cov8" title="1">{
                // 排除临时表
                if !m.tempTables[name] </span><span class="cov8" title="1">{
                        tables = append(tables, name)
                }</span>
        }
        <span class="cov8" title="1">return tables, nil</span>
}

// GetAllTables 获取所有表（包括临时表）
func (m *MVCCDataSource) GetAllTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        if !m.connected </span><span class="cov0" title="0">{
                return nil, domain.NewErrNotConnected("memory")
        }</span>

        <span class="cov0" title="0">m.mu.RLock()
        defer m.mu.RUnlock()

        tables := make([]string, 0, len(m.tables))
        for name := range m.tables </span><span class="cov0" title="0">{
                tables = append(tables, name)
        }</span>
        <span class="cov0" title="0">return tables, nil</span>
}

// GetTemporaryTables 获取所有临时表
func (m *MVCCDataSource) GetTemporaryTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        if !m.connected </span><span class="cov0" title="0">{
                return nil, domain.NewErrNotConnected("memory")
        }</span>

        <span class="cov0" title="0">m.mu.RLock()
        defer m.mu.RUnlock()

        tables := make([]string, 0, len(m.tempTables))
        for name := range m.tempTables </span><span class="cov0" title="0">{
                tables = append(tables, name)
        }</span>
        <span class="cov0" title="0">return tables, nil</span>
}

// GetTableInfo 获取表信息
func (m *MVCCDataSource) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                return nil, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">tableVer.mu.RLock()
        defer tableVer.mu.RUnlock()

        // 获取最新版本的数据
        latest := tableVer.versions[tableVer.latest]
        if latest == nil </span><span class="cov0" title="0">{
                return nil, domain.NewErrTableNotFound(tableName)
        }</span>

        // 深拷贝表信息
        <span class="cov8" title="1">cols := make([]domain.ColumnInfo, len(latest.schema.Columns))
        copy(cols, latest.schema.Columns)

        return &amp;domain.TableInfo{
                Name:    latest.schema.Name,
                Schema:  latest.schema.Schema,
                Columns: cols,
        }, nil</span>
}

// CreateTable 创建表
func (m *MVCCDataSource) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.tables[tableInfo.Name]; ok </span><span class="cov8" title="1">{
                return fmt.Errorf("table %s already exists", tableInfo.Name)
        }</span>

        // 深拷贝表信息
        <span class="cov8" title="1">cols := make([]domain.ColumnInfo, len(tableInfo.Columns))
        copy(cols, tableInfo.Columns)

        // 创建新版本
        m.currentVer++
        versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema: &amp;domain.TableInfo{
                        Name:       tableInfo.Name,
                        Schema:     tableInfo.Schema,
                        Columns:    cols,
                        Temporary:  tableInfo.Temporary,
                },
                rows: []domain.Row{},
        }

        m.tables[tableInfo.Name] = &amp;TableVersions{
                versions: map[int64]*TableData{
                        m.currentVer: versionData,
                },
                latest: m.currentVer,
        }

        // 如果是临时表，添加到临时表列表
        if tableInfo.Temporary </span><span class="cov0" title="0">{
                m.tempTables[tableInfo.Name] = true
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DropTable 删除表
func (m *MVCCDataSource) DropTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.tables[tableName]; !ok </span><span class="cov8" title="1">{
                return domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">delete(m.tables, tableName)
        // 删除索引
        _ = m.indexManager.DropTableIndexes(tableName)
        return nil</span>
}

// TruncateTable 清空表
func (m *MVCCDataSource) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov0" title="0">{
                return domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">tableVer.mu.Lock()
        defer tableVer.mu.Unlock()

        // 创建新版本（空数据）
        m.currentVer++
        versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema:    tableVer.versions[tableVer.latest].schema,
                rows:      []domain.Row{},
        }

        tableVer.versions[m.currentVer] = versionData
        tableVer.latest = m.currentVer

        return nil</span>
}

// CreateIndex 创建索引
func (m *MVCCDataSource) CreateIndex(tableName, columnName, indexType string, unique bool) error <span class="cov0" title="0">{
        // 转换索引类型
        var idxType IndexType
        switch indexType </span>{
        case "btree":<span class="cov0" title="0">
                idxType = IndexTypeBTree</span>
        case "hash":<span class="cov0" title="0">
                idxType = IndexTypeHash</span>
        case "fulltext":<span class="cov0" title="0">
                idxType = IndexTypeFullText</span>
        default:<span class="cov0" title="0">
                idxType = IndexTypeBTree</span> // 默认
        }

        // 创建索引
        <span class="cov0" title="0">_, err := m.indexManager.CreateIndex(tableName, columnName, idxType, unique)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create index failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DropIndex 删除索引
func (m *MVCCDataSource) DropIndex(tableName, indexName string) error <span class="cov0" title="0">{
        err := m.indexManager.DropIndex(tableName, indexName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("drop index failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ==================== 数据查询 ====================

// Query 查询数据
func (m *MVCCDataSource) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        m.mu.RLock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                m.mu.RUnlock()
                return nil, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">txnID, hasTxn := GetTransactionID(ctx)
        var tableData *TableData

        if hasTxn </span><span class="cov0" title="0">{
                // 在事务中，从COW快照读取数据
                snapshot, ok := m.snapshots[txnID]
                if ok </span><span class="cov0" title="0">{
                        cowSnapshot, ok := snapshot.tableSnapshots[tableName]
                        if ok </span><span class="cov0" title="0">{
                                tableData = cowSnapshot.getTableData(tableVer)
                                m.mu.RUnlock()
                        }</span> else<span class="cov0" title="0"> {
                                m.mu.RUnlock()
                                tableVer.mu.RLock()
                                tableData = tableVer.versions[tableVer.latest]
                                tableVer.mu.RUnlock()
                        }</span>
                } else<span class="cov0" title="0"> {
                        m.mu.RUnlock()
                        tableVer.mu.RLock()
                        tableData = tableVer.versions[tableVer.latest]
                        tableVer.mu.RUnlock()
                }</span>
        } else<span class="cov8" title="1"> {
                // 非事务查询，从最新版本读取
                m.mu.RUnlock()
                tableVer.mu.RLock()
                tableData = tableVer.versions[tableVer.latest]
                tableVer.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">if tableData == nil </span><span class="cov0" title="0">{
                return nil, domain.NewErrTableNotFound(tableName)
        }</span>

        // 使用查询优化器优化查询
        <span class="cov8" title="1">var queryResult *domain.QueryResult
        var err error

        if options != nil &amp;&amp; len(options.Filters) &gt; 0 </span><span class="cov8" title="1">{
                // 有过滤条件，使用查询优化器
                plan, planErr := m.queryPlanner.PlanQuery(tableName, options.Filters, options)
                if planErr != nil </span><span class="cov0" title="0">{
                        // 优化失败，使用全表扫描
                        pagedRows := util.ApplyQueryOperations(tableData.rows, options, &amp;tableData.schema.Columns)
                        queryResult = &amp;domain.QueryResult{
                                Columns: tableData.schema.Columns,
                                Rows:    pagedRows,
                                Total:   int64(len(pagedRows)),
                        }
                }</span> else<span class="cov8" title="1"> {
                        // 执行优化后的查询计划
                        queryResult, err = m.queryPlanner.ExecutePlan(plan, tableData)
                                if err != nil </span><span class="cov0" title="0">{
                                        // 执行失败，使用全表扫描
                                        pagedRows := util.ApplyQueryOperations(tableData.rows, options, &amp;tableData.schema.Columns)
                                        queryResult = &amp;domain.QueryResult{
                                                Columns: tableData.schema.Columns,
                                                Rows:    pagedRows,
                                                Total:   int64(len(pagedRows)),
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        // 应用排序和分页
                                        if options != nil </span><span class="cov8" title="1">{
                                                if options.OrderBy != "" </span><span class="cov0" title="0">{
                                                        queryResult.Rows = util.ApplyOrder(queryResult.Rows, options)
                                                }</span>
                                                <span class="cov8" title="1">if options.Limit &gt; 0 || options.Offset &gt; 0 </span><span class="cov0" title="0">{
                                                        queryResult.Rows = util.ApplyPagination(queryResult.Rows, int(options.Limit), int(options.Offset))
                                                }</span>
                                        }
                                        <span class="cov8" title="1">queryResult.Total = int64(len(queryResult.Rows))</span>
                                }
                        }
        } else<span class="cov8" title="1"> {
                // 无过滤条件，使用全表扫描
                pagedRows := util.ApplyQueryOperations(tableData.rows, options, &amp;tableData.schema.Columns)
                queryResult = &amp;domain.QueryResult{
                        Columns: tableData.schema.Columns,
                        Rows:    pagedRows,
                        Total:   int64(len(pagedRows)),
                }
        }</span>

        <span class="cov8" title="1">return queryResult, nil</span>
}

// ==================== 数据修改 ====================

// Insert 插入数据
func (m *MVCCDataSource) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !m.IsWritable() </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly(string(m.config.Type), "insert")
        }</span>

        <span class="cov8" title="1">txnID, hasTxn := GetTransactionID(ctx)

        // 先获取全局锁
        m.mu.Lock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                m.mu.Unlock()
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">var sourceData *TableData
        if hasTxn </span><span class="cov0" title="0">{
                // 在事务中，使用COW快照
                snapshot, ok := m.snapshots[txnID]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, fmt.Errorf("transaction not found: %d", txnID)
                }</span>

                <span class="cov0" title="0">cowSnapshot, ok := snapshot.tableSnapshots[tableName]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, domain.NewErrTableNotFound(tableName)
                }</span>

                // 确保数据已拷贝（写时复制，行级COW）
                <span class="cov0" title="0">if err := cowSnapshot.ensureCopied(tableVer); err != nil </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, err
                }</span>

                <span class="cov0" title="0">m.mu.Unlock()

                // 行级COW：不直接拷贝整个表，只记录新插入的行
                cowSnapshot.mu.Lock()

                // 获取基础数据的行数
                baseRowsCount := int64(len(cowSnapshot.baseData.rows))
                inserted := int64(0)

                for _, row := range rows </span><span class="cov0" title="0">{
                        // 每个新行使用递增的rowID（从基础数据行数+1开始）
                        rowID := baseRowsCount + inserted + 1
                        cowSnapshot.rowLocks[rowID] = true

                        // 深拷贝行数据
                        rowCopy := make(map[string]interface{}, len(row))
                        for k, v := range row </span><span class="cov0" title="0">{
                                rowCopy[k] = v
                        }</span>
                        <span class="cov0" title="0">cowSnapshot.rowCopies[rowID] = rowCopy

                        inserted++</span>
                }

                <span class="cov0" title="0">cowSnapshot.mu.Unlock()
                return inserted, nil</span>
        }

        // 非事务模式：在持有全局锁时，获取表版本锁
        // 锁顺序：先全局锁，后表级锁（避免死锁）
        <span class="cov8" title="1">tableVer.mu.Lock()
        
        // 现在可以安全地释放全局锁，因为已经持有表锁
        m.mu.Unlock()
        defer tableVer.mu.Unlock()

        sourceData = tableVer.versions[tableVer.latest]
        if sourceData == nil </span><span class="cov0" title="0">{
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        // 非事务插入，创建新版本
        <span class="cov8" title="1">m.currentVer++
        newRows := make([]domain.Row, len(sourceData.rows)+len(rows))
        copy(newRows, sourceData.rows)
        copy(newRows[len(sourceData.rows):], rows)

        versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema:    sourceData.schema,
                rows:      newRows,
        }

        tableVer.versions[m.currentVer] = versionData
        tableVer.latest = m.currentVer

        return int64(len(rows)), nil</span>
}

// Update 更新数据
func (m *MVCCDataSource) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !m.IsWritable() </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly(string(m.config.Type), "update")
        }</span>

        <span class="cov8" title="1">txnID, hasTxn := GetTransactionID(ctx)

        // 先获取全局锁
        m.mu.Lock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                m.mu.Unlock()
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">var sourceData *TableData
        if hasTxn </span><span class="cov0" title="0">{
                // 在事务中，使用COW快照
                snapshot, ok := m.snapshots[txnID]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, fmt.Errorf("transaction not found: %d", txnID)
                }</span>

                <span class="cov0" title="0">cowSnapshot, ok := snapshot.tableSnapshots[tableName]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, domain.NewErrTableNotFound(tableName)
                }</span>

                // 确保数据已拷贝（写时复制，行级COW）
                <span class="cov0" title="0">if err := cowSnapshot.ensureCopied(tableVer); err != nil </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, err
                }</span>

                <span class="cov0" title="0">m.mu.Unlock()

                // 行级COW：遍历基础数据，对匹配的行进行拷贝和修改
                cowSnapshot.mu.Lock()
                defer cowSnapshot.mu.Unlock()

                updated := int64(0)
                for i, row := range cowSnapshot.baseData.rows </span><span class="cov0" title="0">{
                        rowID := int64(i + 1) // 行ID从1开始
                        if util.MatchesFilters(row, filters) </span><span class="cov0" title="0">{
                                // 行匹配过滤条件，需要进行修改
                                if _, alreadyModified := cowSnapshot.rowLocks[rowID]; !alreadyModified </span><span class="cov0" title="0">{
                                        // 第一次修改此行，创建深拷贝
                                        rowCopy := make(map[string]interface{}, len(row))
                                        for k, v := range row </span><span class="cov0" title="0">{
                                                rowCopy[k] = v
                                        }</span>
                                        // 应用更新
                                        <span class="cov0" title="0">for k, v := range updates </span><span class="cov0" title="0">{
                                                rowCopy[k] = v
                                        }</span>
                                        // 存储修改后的行
                                        <span class="cov0" title="0">cowSnapshot.rowCopies[rowID] = rowCopy
                                        cowSnapshot.rowLocks[rowID] = true</span>
                                } else<span class="cov0" title="0"> {
                                        // 行已经修改过，直接更新已有副本
                                        if existingRow, ok := cowSnapshot.rowCopies[rowID]; ok </span><span class="cov0" title="0">{
                                                for k, v := range updates </span><span class="cov0" title="0">{
                                                        existingRow[k] = v
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">updated++</span>
                        }
                }
                <span class="cov0" title="0">return updated, nil</span>
        }

        // 非事务模式：锁顺序：先全局锁，后表级锁
        <span class="cov8" title="1">tableVer.mu.Lock()
        m.mu.Unlock()
        defer tableVer.mu.Unlock()

        sourceData = tableVer.versions[tableVer.latest]
        if sourceData == nil </span><span class="cov0" title="0">{
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        // 非事务更新，创建新版本
        <span class="cov8" title="1">m.currentVer++
        newRows := make([]domain.Row, len(sourceData.rows))
        copy(newRows, sourceData.rows)

        updated := int64(0)
        for i, row := range newRows </span><span class="cov8" title="1">{
                if util.MatchesFilters(row, filters) </span><span class="cov8" title="1">{
                        for k, v := range updates </span><span class="cov8" title="1">{
                                newRows[i][k] = v
                        }</span>
                        <span class="cov8" title="1">updated++</span>
                }
        }

        <span class="cov8" title="1">versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema:    sourceData.schema,
                rows:      newRows,
        }

        tableVer.versions[m.currentVer] = versionData
        tableVer.latest = m.currentVer

        return updated, nil</span>
}

// Delete 删除数据
func (m *MVCCDataSource) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !m.IsWritable() </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly(string(m.config.Type), "delete")
        }</span>

        <span class="cov8" title="1">txnID, hasTxn := GetTransactionID(ctx)

        // 先获取全局锁
        m.mu.Lock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                m.mu.Unlock()
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">var sourceData *TableData
        if hasTxn </span><span class="cov0" title="0">{
                // 在事务中，使用COW快照
                snapshot, ok := m.snapshots[txnID]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, fmt.Errorf("transaction not found: %d", txnID)
                }</span>

                <span class="cov0" title="0">cowSnapshot, ok := snapshot.tableSnapshots[tableName]
                if !ok </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, domain.NewErrTableNotFound(tableName)
                }</span>

                // 确保数据已拷贝（写时复制，行级COW）
                <span class="cov0" title="0">if err := cowSnapshot.ensureCopied(tableVer); err != nil </span><span class="cov0" title="0">{
                        m.mu.Unlock()
                        return 0, err
                }</span>

                <span class="cov0" title="0">m.mu.Unlock()

                // 行级COW：标记要删除的行，不立即修改数据
                cowSnapshot.mu.Lock()
                defer cowSnapshot.mu.Unlock()

                deleted := int64(0)
                for i, row := range cowSnapshot.baseData.rows </span><span class="cov0" title="0">{
                        rowID := int64(i + 1) // 行ID从1开始

                        // 检查行是否匹配删除条件
                        if util.MatchesFilters(row, filters) </span><span class="cov0" title="0">{
                                // 如果此行已经被修改过，需要从rowCopies中移除
                                if _, alreadyModified := cowSnapshot.rowLocks[rowID]; alreadyModified </span><span class="cov0" title="0">{
                                        delete(cowSnapshot.rowCopies, rowID)
                                }</span>
                                // 标记为已删除
                                <span class="cov0" title="0">cowSnapshot.deletedRows[rowID] = true
                                delete(cowSnapshot.rowLocks, rowID)
                                deleted++</span>
                        }
                }
                <span class="cov0" title="0">return deleted, nil</span>
        }

        // 非事务模式：锁顺序：先全局锁，后表级锁
        <span class="cov8" title="1">tableVer.mu.Lock()
        m.mu.Unlock()
        defer tableVer.mu.Unlock()

        sourceData = tableVer.versions[tableVer.latest]
        if sourceData == nil </span><span class="cov0" title="0">{
                return 0, domain.NewErrTableNotFound(tableName)
        }</span>

        // 非事务删除，创建新版本
        <span class="cov8" title="1">m.currentVer++
        newRows := make([]domain.Row, 0, len(sourceData.rows))

        deleted := int64(0)
        for _, row := range sourceData.rows </span><span class="cov8" title="1">{
                if !util.MatchesFilters(row, filters) </span><span class="cov8" title="1">{
                        newRows = append(newRows, row)
                }</span> else<span class="cov8" title="1"> {
                        deleted++
                }</span>
        }

        <span class="cov8" title="1">versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema:    sourceData.schema,
                rows:      newRows,
        }

        tableVer.versions[m.currentVer] = versionData
        tableVer.latest = m.currentVer

        return deleted, nil</span>
}

// Execute 执行自定义SQL语句
func (m *MVCCDataSource) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        // 内存数据源不支持SQL执行
        return nil, domain.NewErrUnsupportedOperation(string(m.config.Type), "execute SQL")
}</span>

// ==================== 适配器接口 ====================

// LoadTable 加载表数据到内存（供外部数据源适配器使用）
func (m *MVCCDataSource) LoadTable(tableName string, schema *domain.TableInfo, rows []domain.Row) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 创建新版本
        m.currentVer++

        // 深拷贝schema
        cols := make([]domain.ColumnInfo, len(schema.Columns))
        copy(cols, schema.Columns)

        versionData := &amp;TableData{
                version:   m.currentVer,
                createdAt: time.Now(),
                schema: &amp;domain.TableInfo{
                        Name:    schema.Name,
                        Schema:  schema.Schema,
                        Columns: cols,
                },
                rows: rows,
        }

        if existing, ok := m.tables[tableName]; ok </span><span class="cov8" title="1">{
                existing.mu.Lock()
                existing.versions[m.currentVer] = versionData
                existing.latest = m.currentVer
                existing.mu.Unlock()
        }</span> else<span class="cov8" title="1"> {
                m.tables[tableName] = &amp;TableVersions{
                        versions: map[int64]*TableData{
                                m.currentVer: versionData,
                        },
                        latest: m.currentVer,
                }
        }</span>

        // 重建索引
        <span class="cov8" title="1">_ = m.indexManager.RebuildIndex(tableName, versionData.schema, rows)

        return nil</span>
}

// GetLatestTableData 获取最新表数据（供外部数据源适配器写回使用）
func (m *MVCCDataSource) GetLatestTableData(tableName string) (*domain.TableInfo, []domain.Row, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tableVer, ok := m.tables[tableName]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">tableVer.mu.RLock()
        defer tableVer.mu.RUnlock()

        latest := tableVer.versions[tableVer.latest]
        if latest == nil </span><span class="cov0" title="0">{
                return nil, nil, domain.NewErrTableNotFound(tableName)
        }</span>

        <span class="cov8" title="1">return latest.schema, latest.rows, nil</span>
}

// GetCurrentVersion 获取当前版本号
func (m *MVCCDataSource) GetCurrentVersion() int64 <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.currentVer
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package memory

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// MVCCTransaction wraps existing transaction methods to implement Transaction interface
type MVCCTransaction struct {
        ds    *MVCCDataSource
        txnID int64
}

func (t *MVCCTransaction) Commit(ctx context.Context) error <span class="cov0" title="0">{
        return t.ds.CommitTx(ctx, t.txnID)
}</span>

func (t *MVCCTransaction) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        return t.ds.RollbackTx(ctx, t.txnID)
}</span>

func (t *MVCCTransaction) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Temporary implementation: return empty result
        return &amp;domain.QueryResult{
                Columns: []domain.ColumnInfo{},
                Rows:    []domain.Row{},
                Total:   0,
        }, nil
}</span>

func (t *MVCCTransaction) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return t.ds.Query(ctx, tableName, options)
}</span>

func (t *MVCCTransaction) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov0" title="0">{
        return t.ds.Insert(ctx, tableName, rows, options)
}</span>

func (t *MVCCTransaction) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov0" title="0">{
        return t.ds.Update(ctx, tableName, filters, updates, options)
}</span>

func (t *MVCCTransaction) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov0" title="0">{
        return t.ds.Delete(ctx, tableName, filters, options)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package memory

import (
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/util"
)

// ScanMethod 扫描方法
type ScanMethod string

const (
        ScanMethodFull  ScanMethod = "full"  // 全表扫描
        ScanMethodIndex ScanMethod = "index" // 索引扫描
        ScanMethodRange ScanMethod = "range" // 范围扫描
)

// QueryPlan 查询计划
type QueryPlan struct {
        TableName string
        Filters   []domain.Filter
        Options   *domain.QueryOptions
        Method    ScanMethod
        Index     *IndexInfo
}

// QueryPlanner 查询优化器
type QueryPlanner struct {
        indexManager *IndexManager
}

// NewQueryPlanner 创建查询优化器
func NewQueryPlanner(indexManager *IndexManager) *QueryPlanner <span class="cov8" title="1">{
        return &amp;QueryPlanner{
                indexManager: indexManager,
        }
}</span>

// PlanQuery 优化查询计划
func (p *QueryPlanner) PlanQuery(tableName string, filters []domain.Filter, options *domain.QueryOptions) (*QueryPlan, error) <span class="cov8" title="1">{
        plan := &amp;QueryPlan{
                TableName: tableName,
                Filters:   filters,
                Options:   options,
                Method:    ScanMethodFull,
                Index:     nil,
        }

        // 检查是否可以使用索引（等值查询）
        if len(filters) == 1 &amp;&amp; filters[0].Operator == "=" </span><span class="cov8" title="1">{
                index, err := p.indexManager.GetIndex(tableName, filters[0].Field)
                if err == nil &amp;&amp; index != nil </span><span class="cov0" title="0">{
                        // 使用索引
                        indexInfo := index.GetIndexInfo()
                        if indexInfo.Type == IndexTypeBTree || indexInfo.Type == IndexTypeHash </span><span class="cov0" title="0">{
                                plan.Method = ScanMethodIndex
                                plan.Index = indexInfo
                                return plan, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return plan, nil</span>
}

// ExecutePlan 执行查询计划
func (p *QueryPlanner) ExecutePlan(plan *QueryPlan, tableData *TableData) (*domain.QueryResult, error) <span class="cov8" title="1">{
        switch plan.Method </span>{
        case ScanMethodFull:<span class="cov8" title="1">
                // 全表扫描
                return p.fullScan(tableData, plan)</span>
        case ScanMethodIndex:<span class="cov0" title="0">
                // 索引查询
                return p.indexScan(tableData, plan)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown scan method: %s", plan.Method)</span>
        }
}

// fullScan 全表扫描
func (p *QueryPlanner) fullScan(tableData *TableData, plan *QueryPlan) (*domain.QueryResult, error) <span class="cov8" title="1">{
        // 使用现有的过滤逻辑
        filteredRows := make([]domain.Row, 0)
        for _, row := range tableData.rows </span><span class="cov8" title="1">{
                matches := true
                for _, filter := range plan.Filters </span><span class="cov8" title="1">{
                        // 使用MatchFilter进行正确的值比较
                        if !util.MatchFilter(row, filter) </span><span class="cov8" title="1">{
                                matches = false
                                break</span>
                        }
                }

                <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                        filteredRows = append(filteredRows, row)
                }</span>
        }

        <span class="cov8" title="1">return &amp;domain.QueryResult{
                Columns: tableData.schema.Columns,
                Rows:    filteredRows,
                Total:   int64(len(filteredRows)),
        }, nil</span>
}

// indexScan 索引查询
func (p *QueryPlanner) indexScan(tableData *TableData, plan *QueryPlan) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(plan.Filters) == 0 </span><span class="cov0" title="0">{
                return p.fullScan(tableData, plan)
        }</span>

        // 获取索引
        <span class="cov0" title="0">index, err := p.indexManager.GetIndex(plan.TableName, plan.Filters[0].Field)
        if err != nil || index == nil </span><span class="cov0" title="0">{
                return p.fullScan(tableData, plan)
        }</span>

        // 执行点查询
        <span class="cov0" title="0">rowIDs, found := index.Find(plan.Filters[0].Value)
        if !found || len(rowIDs) == 0 </span><span class="cov0" title="0">{
                return &amp;domain.QueryResult{
                        Columns: tableData.schema.Columns,
                        Rows:    []domain.Row{},
                        Total:   0,
                }, nil
        }</span>

        // 根据rowID获取行数据
        <span class="cov0" title="0">filteredRows := make([]domain.Row, 0, len(rowIDs))
        for _, rowID := range rowIDs </span><span class="cov0" title="0">{
                if int(rowID) &lt;= len(tableData.rows) </span><span class="cov0" title="0">{
                        filteredRows = append(filteredRows, tableData.rows[rowID-1])
                }</span>
        }

        // 应用其他过滤条件
        <span class="cov0" title="0">for _, filter := range plan.Filters[1:] </span><span class="cov0" title="0">{
                newFiltered := make([]domain.Row, 0)
                for _, row := range filteredRows </span><span class="cov0" title="0">{
                        matches := true
                        _, exists := row[filter.Field]
                        if !exists </span><span class="cov0" title="0">{
                                matches = false
                        }</span>
                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                newFiltered = append(newFiltered, row)
                        }</span>
                }
                <span class="cov0" title="0">filteredRows = newFiltered</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: tableData.schema.Columns,
                Rows:    filteredRows,
                Total:   int64(len(filteredRows)),
        }, nil</span>
}

// rangeScan 范围查询
func (p *QueryPlanner) rangeScan(tableData *TableData, plan *QueryPlan) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 暂不实现，简化为全表扫描
        return p.fullScan(tableData, plan)
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package parquet

import (
        "context"
        "fmt"
        "os"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
)

// ParquetAdapter Parquet文件数据源适配器
// 继承 MVCCDataSource，只负责Parquet格式的加载和写回
// 注意: 这是一个简化实现，实际使用时应该使用 Apache Arrow/Parquet 库
type ParquetAdapter struct {
        *memory.MVCCDataSource
        filePath  string
        tableName string
        writable  bool
}

// NewParquetAdapter 创建Parquet数据源适配器
func NewParquetAdapter(config *domain.DataSourceConfig, filePath string) *ParquetAdapter <span class="cov8" title="1">{
        tableName := "parquet_data"
        writable := false // Parquet默认只读

        // 从配置中读取选项
        if config.Options != nil </span><span class="cov8" title="1">{
                if t, ok := config.Options["table_name"]; ok </span><span class="cov8" title="1">{
                        if str, ok := t.(string); ok &amp;&amp; str != "" </span><span class="cov8" title="1">{
                                tableName = str
                        }</span>
                }
                <span class="cov8" title="1">if w, ok := config.Options["writable"]; ok </span><span class="cov8" title="1">{
                        if b, ok := w.(bool); ok </span><span class="cov8" title="1">{
                                writable = b
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;ParquetAdapter{
                MVCCDataSource: memory.NewMVCCDataSource(config),
                filePath:       filePath,
                tableName:      tableName,
                writable:       writable,
        }</span>
}

// Connect 连接数据源 - 加载Parquet文件到内存
func (a *ParquetAdapter) Connect(ctx context.Context) error <span class="cov8" title="1">{
        // 检查文件是否存在
        if _, err := os.Stat(a.filePath); err != nil </span><span class="cov8" title="1">{
                return domain.NewErrNotConnected("parquet")
        }</span>

        // 简化实现：返回固定列结构和数据
        // TODO: 实际应该使用 Apache Arrow 库读取Parquet元数据
        <span class="cov8" title="1">columns := []domain.ColumnInfo{
                {Name: "id", Type: "int64", Nullable: false, Primary: true},
                {Name: "value", Type: "string", Nullable: true},
        }

        // 简化实现：返回固定测试数据
        // TODO: 实际应该读取Parquet文件
        rows := []domain.Row{
                {"id": int64(1), "value": "parquet_data_1"},
                {"id": int64(2), "value": "parquet_data_2"},
                {"id": int64(3), "value": "parquet_data_3"},
        }

        // 创建表信息
        tableInfo := &amp;domain.TableInfo{
                Name:    a.tableName,
                Schema:  "default",
                Columns: columns,
        }

        // 加载到MVCC内存源
        if err := a.LoadTable(a.tableName, tableInfo, rows); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load Parquet data: %w", err)
        }</span>

        // 连接MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Connect(ctx)</span>
}

// Close 关闭连接 - 可选写回Parquet文件
func (a *ParquetAdapter) Close(ctx context.Context) error <span class="cov8" title="1">{
        // 如果是可写模式，需要写回Parquet文件
        if a.writable </span><span class="cov8" title="1">{
                if err := a.writeBack(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write back Parquet file: %w", err)
                }</span>
        }

        // 关闭MVCC数据源
        <span class="cov8" title="1">return a.MVCCDataSource.Close(ctx)</span>
}

// GetConfig 获取数据源配置
func (a *ParquetAdapter) GetConfig() *domain.DataSourceConfig <span class="cov8" title="1">{
        return a.MVCCDataSource.GetConfig()
}</span>

// GetTables 获取所有表（MVCCDataSource提供）
func (a *ParquetAdapter) GetTables(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTables(ctx)
}</span>

// GetTableInfo 获取表信息（MVCCDataSource提供）
func (a *ParquetAdapter) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTableInfo(ctx, tableName)
}</span>

// Query 查询数据（MVCCDataSource提供）
func (a *ParquetAdapter) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.Query(ctx, tableName, options)
}</span>

// Insert 插入数据（MVCCDataSource提供）
func (a *ParquetAdapter) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("parquet", "insert")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新数据（MVCCDataSource提供）
func (a *ParquetAdapter) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("parquet", "update")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除数据（MVCCDataSource提供）
func (a *ParquetAdapter) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("parquet", "delete")
        }</span>
        <span class="cov0" title="0">return a.MVCCDataSource.Delete(ctx, tableName, filters, options)</span>
}

// CreateTable 创建表（Parquet不支持）
func (a *ParquetAdapter) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("parquet", "create table")
}</span>

// DropTable 删除表（Parquet不支持）
func (a *ParquetAdapter) DropTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("parquet", "drop table")
}</span>

// TruncateTable 清空表（Parquet不支持）
func (a *ParquetAdapter) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        return domain.NewErrReadOnly("parquet", "truncate table")
}</span>

// Execute 执行SQL（Parquet不支持）
func (a *ParquetAdapter) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return nil, domain.NewErrUnsupportedOperation("parquet", "execute SQL")
}</span>

// ==================== 私有方法 ====================

// writeBack 写回Parquet文件
// 注意: 简化实现，实际应该使用 Apache Arrow 库
func (a *ParquetAdapter) writeBack() error <span class="cov8" title="1">{
        // 获取最新数据
        schema, rows, err := a.GetLatestTableData(a.tableName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: 实际应该使用 Apache Arrow 库写入Parquet文件
        // 简化实现：这里只是一个占位符
        <span class="cov8" title="1">_ = schema
        _ = rows
        _ = a.filePath

        // 实际实现应该：
        // 1. 创建 Arrow Schema
        // 2. 创建 Arrow RecordBatch
        // 3. 使用 Arrow Parquet Writer 写入文件

        return nil</span>
}

// IsConnected 检查是否已连接（MVCCDataSource提供）
func (a *ParquetAdapter) IsConnected() bool <span class="cov8" title="1">{
        return a.MVCCDataSource.IsConnected()
}</span>

// IsWritable 检查是否可写
func (a *ParquetAdapter) IsWritable() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// SupportsWrite 实现IsWritableSource接口
func (a *ParquetAdapter) SupportsWrite() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// detectType 检测值的类型（私有方法，供测试使用）
func (a *ParquetAdapter) detectType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return "bool"</span>
        case float64:<span class="cov8" title="1">
                // 检查是否是整数
                if v == float64(int64(v)) </span><span class="cov8" title="1">{
                        return "int64"
                }</span>
                <span class="cov8" title="1">return "float64"</span>
        case string:<span class="cov8" title="1">
                return "string"</span>
        case nil:<span class="cov8" title="1">
                return "string"</span>
        case []interface{}, map[string]interface{}:<span class="cov8" title="1">
                return "string"</span>
        default:<span class="cov8" title="1">
                return "string"</span>
        }
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package parquet

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ParquetFactory Parquet 数据源工厂
type ParquetFactory struct{}

// NewParquetFactory 创建 Parquet 数据源工厂
func NewParquetFactory() *ParquetFactory <span class="cov8" title="1">{
        return &amp;ParquetFactory{}
}</span>

// GetType 实现DataSourceFactory接口
func (f *ParquetFactory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return domain.DataSourceTypeParquet
}</span>

// Create 实现DataSourceFactory接口
func (f *ParquetFactory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        // 使用ParquetAdapter（继承MVCCDataSource）
        return NewParquetAdapter(config, config.Name), nil
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package resource

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/csv"
        "github.com/kasuganosora/sqlexec/pkg/resource/excel"
        "github.com/kasuganosora/sqlexec/pkg/resource/json"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
        "github.com/kasuganosora/sqlexec/pkg/resource/parquet"
        "github.com/kasuganosora/sqlexec/pkg/resource/slice"
)

// init 注册所有数据源工厂
func init() <span class="cov0" title="0">{
        registry := application.GetRegistry()

        // 注册基础数据源工厂
        registry.Register(memory.NewMemoryFactory())

        // 注册文件数据源工厂
        registry.Register(csv.NewCSVFactory())
        registry.Register(json.NewJSONFactory())
        registry.Register(excel.NewExcelFactory())
        registry.Register(parquet.NewParquetFactory())

        // 注册内存数据适配器工厂
        registry.Register(slice.NewFactory())
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package slice

import (
        "context"
        "fmt"
        "reflect"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/memory"
)

// SliceAdapter 将 []map[string]any 或 []struct 转换为内存数据源
// 适用于将程序内嵌的数据结构提供 SQL 查询和处理能力
type SliceAdapter struct {
        *memory.MVCCDataSource

        mu              sync.RWMutex
        originalData    interface{} // 原始数据 []map[string]any 或 []struct
        tableName       string      // 表名
        databaseName    string      // 数据库名
        writable        bool        // 是否可写
        mvccSupported   bool        // 是否支持 MVCC
        isPointer       bool        // 原始数据是否为指针（用于SyncToOriginal）
        isMapSlice      bool        // 是否为 map slice
        mapSliceType    reflect.Type // map slice 的类型信息
        structFields    []reflect.StructField // 结构体字段信息
}

// NewSliceAdapter 创建一个新的 slice adapter
// data: 原始数据，可以是 []map[string]any 或 []struct
// tableName: 表名
// databaseName: 数据库名
// writable: 是否可写，默认为 true（非指针参数会自动设为 false）
// mvccSupported: 是否支持 MVCC，默认为 true
// 注意：
//   - 如果需要在写入时修改原始数据，data 必须是指针类型
//   - 如果 data 不是指针，会自动设置为不可写模式
func NewSliceAdapter(data interface{}, tableName string, databaseName string, writable, mvccSupported bool) (*SliceAdapter, error) <span class="cov8" title="1">{
        if data == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data cannot be nil")
        }</span>

        <span class="cov8" title="1">val := reflect.ValueOf(data)
        originalRef := data
        isPointer := false
        
        if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if val.IsNil() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("data pointer is nil")
                }</span>
                <span class="cov8" title="1">val = val.Elem()
                isPointer = true</span>
        }

        <span class="cov8" title="1">if val.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data must be a slice, got %T", data)
        }</span>

        // 如果不是指针，自动设置为不可写（因为无法修改原始数据）
        <span class="cov8" title="1">if !isPointer </span><span class="cov8" title="1">{
                writable = false
        }</span>

        <span class="cov8" title="1">adapter := &amp;SliceAdapter{
                originalData:  originalRef,
                tableName:     tableName,
                databaseName:  databaseName,
                writable:      writable,
                mvccSupported: mvccSupported,
                isPointer:    isPointer, // 记录是否为指针
        }

        // 检查是 map slice 还是 struct slice
        if val.Len() &gt; 0 </span><span class="cov8" title="1">{
                elem := val.Index(0).Interface()
                adapter.isMapSlice = isMapStringAny(elem)

                        if !adapter.isMapSlice </span><span class="cov8" title="1">{
                                // 获取结构体字段信息
                                adapter.structFields = getStructFields(val.Type().Elem())
                        }</span> else<span class="cov8" title="1"> {
                                // 记录 map slice 的类型（使用指针指向的类型）
                                adapter.mapSliceType = val.Type()
                        }</span>
        } else<span class="cov8" title="1"> {
                // 空切片，尝试从类型推断
                elemType := val.Type().Elem()
                adapter.isMapSlice = isMapStringAnyType(elemType)
                if !adapter.isMapSlice &amp;&amp; elemType.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        adapter.structFields = getStructFields(elemType)
                }</span> else<span class="cov8" title="1"> {
                        adapter.mapSliceType = val.Type()
                }</span>
        }

        // 创建 MVCCDataSource
        <span class="cov8" title="1">config := &amp;domain.DataSourceConfig{
                Writable: writable,
        }
        adapter.MVCCDataSource = memory.NewMVCCDataSource(config)

        // 转换并加载数据
        if err := adapter.loadData(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load data: %w", err)
        }</span>

        <span class="cov8" title="1">return adapter, nil</span>
}

// loadData 从原始数据加载数据到 MVCCDataSource
func (a *SliceAdapter) loadData() error <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        val := reflect.ValueOf(a.originalData)
        if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                val = val.Elem()
        }</span>

        <span class="cov8" title="1">if val.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return fmt.Errorf("data must be a slice, got %v", val.Kind())
        }</span>

        // 获取所有行数据
        <span class="cov8" title="1">var rows []domain.Row
        var schema *domain.TableInfo

        if a.isMapSlice </span><span class="cov8" title="1">{
                // 处理 []map[string]any
                schema, rows = a.convertMapSlice(val)
        }</span> else<span class="cov8" title="1"> {
                // 处理 []struct
                schema, rows = a.convertStructSlice(val)
        }</span>

        // 加载到 MVCCDataSource
        <span class="cov8" title="1">if err := a.LoadTable(a.tableName, schema, rows); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load table: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// convertMapSlice 将 []map[string]any 转换为 TableInfo 和 []Row
func (a *SliceAdapter) convertMapSlice(sliceValue reflect.Value) (*domain.TableInfo, []domain.Row) <span class="cov8" title="1">{
        if sliceValue.Len() == 0 </span><span class="cov8" title="1">{
                // 空切片，创建默认 schema
                return &amp;domain.TableInfo{
                        Name:    a.tableName,
                        Columns: []domain.ColumnInfo{},
                }, []domain.Row{}
        }</span>

        // 收集所有列
        <span class="cov8" title="1">columnSet := make(map[string]bool)
        columns := []domain.ColumnInfo{}
        var rows []domain.Row

        // 第一次遍历：收集所有列
        for i := 0; i &lt; sliceValue.Len(); i++ </span><span class="cov8" title="1">{
                elem := sliceValue.Index(i)
                if elem.Kind() == reflect.Map </span><span class="cov8" title="1">{
                        for _, key := range elem.MapKeys() </span><span class="cov8" title="1">{
                                keyStr := key.String()
                                if !columnSet[keyStr] </span><span class="cov8" title="1">{
                                        columnSet[keyStr] = true
                                // 推断列类型
                                val := elem.MapIndex(key).Interface()
                                colType := inferColumnType(val)
                                        columns = append(columns, domain.ColumnInfo{
                                                Name:     keyStr,
                                                Type:     colType,
                                                Nullable: true,
                                        })
                                }</span>
                        }
                }
        }

        // 第二次遍历：构建行数据
        <span class="cov8" title="1">for i := 0; i &lt; sliceValue.Len(); i++ </span><span class="cov8" title="1">{
                elem := sliceValue.Index(i)
                if elem.Kind() == reflect.Map </span><span class="cov8" title="1">{
                        row := make(domain.Row, len(columns))
                        for _, col := range columns </span><span class="cov8" title="1">{
                                val := elem.MapIndex(reflect.ValueOf(col.Name))
                                if val.IsValid() </span><span class="cov8" title="1">{
                                        row[col.Name] = val.Interface()
                                }</span> else<span class="cov0" title="0"> {
                                        row[col.Name] = nil
                                }</span>
                        }
                        <span class="cov8" title="1">rows = append(rows, row)</span>
                }
        }

        <span class="cov8" title="1">return &amp;domain.TableInfo{
                Name:    a.tableName,
                Columns: columns,
        }, rows</span>
}

// convertStructSlice 将 []struct 转换为 TableInfo 和 []Row
func (a *SliceAdapter) convertStructSlice(sliceValue reflect.Value) (*domain.TableInfo, []domain.Row) <span class="cov8" title="1">{
        // 构建列信息
        columns := []domain.ColumnInfo{}
        for _, field := range a.structFields </span><span class="cov8" title="1">{
                colType := getFieldType(field.Type)
                columns = append(columns, domain.ColumnInfo{
                        Name:     field.Name,
                        Type:     colType,
                        Nullable: isFieldNullable(field.Type),
                })
        }</span>

        // 构建行数据
        <span class="cov8" title="1">var rows []domain.Row
        for i := 0; i &lt; sliceValue.Len(); i++ </span><span class="cov8" title="1">{
                elem := sliceValue.Index(i)
                row := make(domain.Row, len(a.structFields))
                for _, field := range a.structFields </span><span class="cov8" title="1">{
                        fieldVal := elem.FieldByName(field.Name)
                        if fieldVal.IsValid() </span><span class="cov8" title="1">{
                                row[field.Name] = fieldVal.Interface()
                        }</span> else<span class="cov0" title="0"> {
                                row[field.Name] = nil
                        }</span>
                }
                <span class="cov8" title="1">rows = append(rows, row)</span>
        }

        <span class="cov8" title="1">return &amp;domain.TableInfo{
                Name:    a.tableName,
                Columns: columns,
        }, rows</span>
}

// isMapStringAny 检查是否为 map[string]any
func isMapStringAny(v interface{}) bool <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">t := reflect.TypeOf(v)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">return t.Kind() == reflect.Map &amp;&amp; t.Key().Kind() == reflect.String</span>
}

// isMapStringAnyType 检查类型是否为 map[string]any
func isMapStringAnyType(t reflect.Type) bool <span class="cov8" title="1">{
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">return t.Kind() == reflect.Map &amp;&amp; t.Key().Kind() == reflect.String</span>
}

// getStructFields 获取结构体的所有可导出字段
func getStructFields(t reflect.Type) []reflect.StructField <span class="cov8" title="1">{
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var fields []reflect.StructField
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                if field.PkgPath == "" </span><span class="cov8" title="1">{ // 可导出字段
                        fields = append(fields, field)
                }</span>
        }
        <span class="cov8" title="1">return fields</span>
}

// inferColumnTypes 推断列类型
func inferColumnType(value interface{}) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return "any"
        }</span>

        <span class="cov8" title="1">switch value.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return "int64"</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return "int64"</span>
        case float32, float64:<span class="cov0" title="0">
                return "float64"</span>
        case bool:<span class="cov0" title="0">
                return "bool"</span>
        case string:<span class="cov8" title="1">
                return "string"</span>
        default:<span class="cov0" title="0">
                return "any"</span>
        }
}

// getFieldType 获取字段类型
func getFieldType(t reflect.Type) string <span class="cov8" title="1">{
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">switch t.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return "int64"</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return "int64"</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return "float64"</span>
        case reflect.Bool:<span class="cov0" title="0">
                return "bool"</span>
        case reflect.String:<span class="cov8" title="1">
                return "string"</span>
        case reflect.Interface:<span class="cov0" title="0">
                return "any"</span>
        default:<span class="cov0" title="0">
                return "string"</span>
        }
}

// isFieldNullable 检查字段是否可空
func isFieldNullable(t reflect.Type) bool <span class="cov8" title="1">{
        return t.Kind() == reflect.Ptr
}</span>

// SyncToOriginal 将 MVCCDataSource 中的变更同步回原始数据
// 仅当原始数据是 []map[string]any 时有效
// 注意：原始数据必须是指针类型才能修改
func (a *SliceAdapter) SyncToOriginal(ctx context.Context) error <span class="cov8" title="1">{
        if !a.writable </span><span class="cov0" title="0">{
                return domain.NewErrReadOnly("slice", "sync to original")
        }</span>

        <span class="cov8" title="1">if !a.isMapSlice </span><span class="cov8" title="1">{
                return fmt.Errorf("sync to original only supported for []map[string]any, not []struct")
        }</span>

        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()

        // 获取当前表数据
        _, rows, err := a.GetLatestTableData(a.tableName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get table data: %w", err)
        }</span>

        // 获取原始 slice 的 reflect.Value（必须是指针）
        <span class="cov8" title="1">val := reflect.ValueOf(a.originalData)
        if val.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("original data must be a pointer to enable sync")
        }</span>
        
        <span class="cov8" title="1">sliceVal := val.Elem()
        if sliceVal.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return fmt.Errorf("original data is not a slice")
        }</span>

        <span class="cov8" title="1">if !sliceVal.CanSet() </span><span class="cov0" title="0">{
                return fmt.Errorf("original data is not settable")
        }</span>

        // 创建新的 slice
        <span class="cov8" title="1">newSlice := reflect.MakeSlice(sliceVal.Type(), len(rows), len(rows))
        for i, row := range rows </span><span class="cov8" title="1">{
                rowMap := make(map[string]interface{})
                for colName, v := range row </span><span class="cov8" title="1">{
                        rowMap[colName] = v
                }</span>
                <span class="cov8" title="1">newSlice.Index(i).Set(reflect.ValueOf(rowMap))</span>
        }

        // 更新原始数据
        <span class="cov8" title="1">sliceVal.Set(newSlice)

        return nil</span>
}

// GetDatabaseName 获取数据库名
func (a *SliceAdapter) GetDatabaseName() string <span class="cov8" title="1">{
        return a.databaseName
}</span>

// GetTableName 获取表名
func (a *SliceAdapter) GetTableName() string <span class="cov8" title="1">{
        return a.tableName
}</span>

// IsWritable 是否可写
func (a *SliceAdapter) IsWritable() bool <span class="cov8" title="1">{
        return a.writable
}</span>

// SupportsMVCC 是否支持 MVCC
func (a *SliceAdapter) SupportsMVCC() bool <span class="cov8" title="1">{
        return a.writable &amp;&amp; a.mvccSupported
}</span>

// SupportsWrite 是否支持写入
func (a *SliceAdapter) SupportsWrite() bool <span class="cov0" title="0">{
        return a.writable
}</span>

// Connect 连接数据源
func (a *SliceAdapter) Connect(ctx context.Context) error <span class="cov8" title="1">{
        return a.MVCCDataSource.Connect(ctx)
}</span>

// Close 关闭数据源
func (a *SliceAdapter) Close(ctx context.Context) error <span class="cov0" title="0">{
        return a.MVCCDataSource.Close(ctx)
}</span>

// IsConnected 是否已连接
func (a *SliceAdapter) IsConnected() bool <span class="cov0" title="0">{
        return a.MVCCDataSource.IsConnected()
}</span>

// GetTables 获取所有表名
func (a *SliceAdapter) GetTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        return a.MVCCDataSource.GetTables(ctx)
}</span>

// GetTableInfo 获取表信息
func (a *SliceAdapter) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.GetTableInfo(ctx, tableName)
}</span>

// Query 执行查询
func (a *SliceAdapter) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.Query(ctx, tableName, options)
}</span>

// Insert 插入数据
func (a *SliceAdapter) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("slice", "insert")
        }</span>
        // 不在insert后同步，只在commit时同步
        <span class="cov8" title="1">return a.MVCCDataSource.Insert(ctx, tableName, rows, options)</span>
}

// Update 更新数据
func (a *SliceAdapter) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("slice", "update")
        }</span>
        // 不在update后同步，只在commit时同步
        <span class="cov8" title="1">return a.MVCCDataSource.Update(ctx, tableName, filters, updates, options)</span>
}

// Delete 删除数据
func (a *SliceAdapter) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return 0, domain.NewErrReadOnly("slice", "delete")
        }</span>
        // 不在delete后同步，只在commit时同步
        <span class="cov8" title="1">return a.MVCCDataSource.Delete(ctx, tableName, filters, options)</span>
}

// TruncateTable 清空表
func (a *SliceAdapter) TruncateTable(ctx context.Context, tableName string) error <span class="cov8" title="1">{
        if !a.writable </span><span class="cov8" title="1">{
                return domain.NewErrReadOnly("slice", "truncate table")
        }</span>
        <span class="cov8" title="1">return a.MVCCDataSource.TruncateTable(ctx, tableName)</span>
}

// LoadTable 加载表数据
func (a *SliceAdapter) LoadTable(tableName string, schema *domain.TableInfo, rows []domain.Row) error <span class="cov8" title="1">{
        return a.MVCCDataSource.LoadTable(tableName, schema, rows)
}</span>

// GetVersion 获取版本号
func (a *SliceAdapter) GetVersion() int64 <span class="cov0" title="0">{
        return a.MVCCDataSource.GetCurrentVersion()
}</span>

// BeginTx 开始事务
func (a *SliceAdapter) BeginTx(ctx context.Context, readOnly bool) (int64, error) <span class="cov8" title="1">{
        return a.MVCCDataSource.BeginTx(ctx, readOnly)
}</span>

// CommitTx 提交事务
func (a *SliceAdapter) CommitTx(ctx context.Context, txnID int64) error <span class="cov8" title="1">{
        // 先提交MVCC事务
        err := a.MVCCDataSource.CommitTx(ctx, txnID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 只有commit成功后，才同步回原始数据
        <span class="cov8" title="1">if a.isMapSlice &amp;&amp; a.isPointer </span><span class="cov8" title="1">{
                _ = a.SyncToOriginal(ctx)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// RollbackTx 回滚事务
func (a *SliceAdapter) RollbackTx(ctx context.Context, txnID int64) error <span class="cov8" title="1">{
        return a.MVCCDataSource.RollbackTx(ctx, txnID)
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package slice

import (
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Factory 数据源工厂
type Factory struct{}

// NewFactory 创建新的工厂
func NewFactory() *Factory <span class="cov8" title="1">{
        return &amp;Factory{}
}</span>

// Create 创建数据源
func (f *Factory) Create(config *domain.DataSourceConfig) (domain.DataSource, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        // 从配置中获取数据
        <span class="cov8" title="1">data, ok := config.Options["data"]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing 'data' option in config")
        }</span>

        // 获取表名
        <span class="cov8" title="1">tableName, ok := config.Options["table_name"].(string)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing or invalid 'table_name' option in config")
        }</span>

        // 获取数据库名
        <span class="cov8" title="1">databaseName, ok := config.Options["database_name"].(string)
        if !ok </span><span class="cov0" title="0">{
                databaseName = "default" // 默认数据库名
        }</span>

        // 获取是否可写
        <span class="cov8" title="1">writable := true
        if val, ok := config.Options["writable"].(bool); ok </span><span class="cov8" title="1">{
                writable = val
        }</span> else<span class="cov0" title="0"> if config.Writable </span><span class="cov0" title="0">{
                writable = config.Writable
        }</span>

        // 获取是否支持 MVCC
        <span class="cov8" title="1">mvccSupported := true
        if val, ok := config.Options["mvcc_supported"].(bool); ok </span><span class="cov8" title="1">{
                mvccSupported = val
        }</span>

        // 创建 adapter
        <span class="cov8" title="1">return NewSliceAdapter(data, tableName, databaseName, writable, mvccSupported)</span>
}

// GetType 获取数据源类型
func (f *Factory) GetType() domain.DataSourceType <span class="cov8" title="1">{
        return "slice"
}</span>

// Description 工厂描述
func (f *Factory) Description() string <span class="cov8" title="1">{
        return "Slice data source for []map[string]any or []struct"
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package util

import (
        "fmt"
        "reflect"
        "strconv"
)

// CompareEqual 比较两个值是否相等
func CompareEqual(a, b interface{}) bool <span class="cov8" title="1">{
        if a == nil || b == nil </span><span class="cov8" title="1">{
                return a == b
        }</span>

        // 尝试数值比较
        <span class="cov8" title="1">if cmp, ok := CompareNumeric(a, b); ok </span><span class="cov8" title="1">{
                return cmp == 0
        }</span>

        // 尝试字符串比较
        <span class="cov8" title="1">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        return aStr == bStr</span>
}

// CompareNumeric 数值比较，返回 -1 (a&lt;b), 0 (a==b), 1 (a&gt;b) 和成功标志
func CompareNumeric(a, b interface{}) (int, bool) <span class="cov8" title="1">{
        aFloat, okA := ConvertToFloat64(a)
        bFloat, okB := ConvertToFloat64(b)
        if !okA || !okB </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        <span class="cov8" title="1">if aFloat &lt; bFloat </span><span class="cov8" title="1">{
                return -1, true
        }</span> else<span class="cov8" title="1"> if aFloat &gt; bFloat </span><span class="cov8" title="1">{
                return 1, true
        }</span>
        <span class="cov8" title="1">return 0, true</span>
}

// CompareGreater 比较a是否大于b
func CompareGreater(a, b interface{}) bool <span class="cov8" title="1">{
        // 尝试数值比较
        if cmp, ok := CompareNumeric(a, b); ok </span><span class="cov8" title="1">{
                return cmp &gt; 0
        }</span>
        // 降级到字符串比较
        <span class="cov8" title="1">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        return aStr &gt; bStr</span>
}

// CompareLike 模糊匹配（支持 * 和 % 通配符）
func CompareLike(a, b interface{}) bool <span class="cov8" title="1">{
        aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)

        // 简化实现：只支持 * 通配符
        pattern := ""
        for _, ch := range bStr </span><span class="cov8" title="1">{
                if ch == '*' || ch == '%' </span><span class="cov8" title="1">{
                        pattern += ".*"
                }</span> else<span class="cov8" title="1"> if ch == '_' </span><span class="cov0" title="0">{
                        pattern += "."
                }</span> else<span class="cov8" title="1"> {
                        pattern += string(ch)
                }</span>
        }

        // 使用 contains 进行简化匹配
        <span class="cov8" title="1">return Contains(aStr, bStr)</span>
}

// CompareIn 检查a是否在b的值列表中
func CompareIn(a, b interface{}) bool <span class="cov8" title="1">{
        values, ok := b.([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if CompareEqual(a, v) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CompareBetween 检查值是否在范围内
func CompareBetween(a, b interface{}) bool <span class="cov8" title="1">{
        // b 应该是一个包含两个元素的数组 [min, max]
        slice, ok := b.([]interface{})
        if !ok || len(slice) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">min := slice[0]
        max := slice[1]

        // 对于字符串，使用字符串比较
        aStr := fmt.Sprintf("%v", a)
        minStr := fmt.Sprintf("%v", min)
        maxStr := fmt.Sprintf("%v", max)

        // 对于数值，使用数值比较
        if cmp, ok := CompareNumeric(a, min); ok &amp;&amp; cmp &gt;= 0 </span><span class="cov8" title="1">{
                if cmpMax, okMax := CompareNumeric(a, max); okMax &amp;&amp; cmpMax &lt;= 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // 降级到字符串比较：min &lt;= a &lt;= max
        <span class="cov8" title="1">return (aStr &gt;= minStr) &amp;&amp; (aStr &lt;= maxStr)</span>
}

// CompareValues 比较两个值（用于索引排序）
func CompareValues(a, b interface{}) int <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if a == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                return 1
        }</span>

        // 尝试数值比较
        <span class="cov8" title="1">aFloat, aOk := ConvertToFloat64(a)
        bFloat, bOk := ConvertToFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov8" title="1">{
                if aFloat &lt; bFloat </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aFloat &gt; bFloat </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // 字符串比较
        <span class="cov8" title="1">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov8" title="1">{
                return -1
        }</span> else<span class="cov8" title="1"> if aStr &gt; bStr </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// ConvertToFloat64 将值转换为 float64 进行数值比较
func ConvertToFloat64(v interface{}) (float64, bool) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(val), true</span>
        case int8:<span class="cov8" title="1">
                return float64(val), true</span>
        case int16:<span class="cov8" title="1">
                return float64(val), true</span>
        case int32:<span class="cov8" title="1">
                return float64(val), true</span>
        case int64:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint8:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint16:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint32:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint64:<span class="cov8" title="1">
                return float64(val), true</span>
        case float32:<span class="cov8" title="1">
                return float64(val), true</span>
        case float64:<span class="cov8" title="1">
                return val, true</span>
        case string:<span class="cov8" title="1">
                f, err := strconv.ParseFloat(val, 64)
                return f, err == nil</span>
        default:<span class="cov8" title="1">
                // 尝试通过反射获取数值
                rv := reflect.ValueOf(v)
                switch rv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        return float64(rv.Int()), true</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        return float64(rv.Uint()), true</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        return rv.Float(), true</span>
                }
                <span class="cov8" title="1">return 0, false</span>
        }
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package util

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ApplyFilters 应用过滤器（通用实现）
func ApplyFilters(rows []domain.Row, options *domain.QueryOptions) []domain.Row <span class="cov8" title="1">{
        if options == nil || len(options.Filters) == 0 </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">result := []domain.Row{}
        for _, row := range rows </span><span class="cov8" title="1">{
                if MatchesFilters(row, options.Filters) </span><span class="cov8" title="1">{
                        result = append(result, row)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// MatchesFilters 检查行是否匹配过滤器列表
func MatchesFilters(row domain.Row, filters []domain.Filter) bool <span class="cov8" title="1">{
        // 如果没有过滤器，所有行都匹配
        if len(filters) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // 检查第一个过滤器
        <span class="cov8" title="1">filter := filters[0]

        // 如果有逻辑操作符
        if filter.LogicOp == "OR" || filter.LogicOp == "or" </span><span class="cov8" title="1">{
                // OR 操作：行的任何子过滤器匹配即可
                return MatchesAnySubFilter(row, filter.SubFilters)
        }</span>

        // 如果有 AND 逻辑操作符
        <span class="cov8" title="1">if filter.LogicOp == "AND" || filter.LogicOp == "and" </span><span class="cov8" title="1">{
                // AND 操作：行的所有子过滤器都必须匹配
                return MatchesAllSubFilters(row, filter.SubFilters)
        }</span>

        // 默认（AND 逻辑）：所有过滤器都必须匹配
        <span class="cov8" title="1">for _, f := range filters </span><span class="cov8" title="1">{
                if !MatchFilter(row, f) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// MatchesAnySubFilter 检查行是否匹配任意子过滤器（OR 逻辑）
func MatchesAnySubFilter(row domain.Row, subFilters []domain.Filter) bool <span class="cov8" title="1">{
        // 如果没有子过滤器，返回 true
        if len(subFilters) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        // 检查是否有子过滤器匹配
        <span class="cov8" title="1">for _, subFilter := range subFilters </span><span class="cov8" title="1">{
                if MatchFilter(row, subFilter) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// MatchesAllSubFilters 检查行是否匹配所有子过滤器（AND 逻辑）
func MatchesAllSubFilters(row domain.Row, subFilters []domain.Filter) bool <span class="cov8" title="1">{
        // 如果没有子过滤器，返回 true
        if len(subFilters) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        // 检查是否所有子过滤器都匹配
        <span class="cov8" title="1">for _, subFilter := range subFilters </span><span class="cov8" title="1">{
                if !MatchFilter(row, subFilter) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// MatchFilter 匹配单个过滤器
func MatchFilter(row domain.Row, filter domain.Filter) bool <span class="cov8" title="1">{
        // 处理逻辑运算符（AND/OR）
        if filter.LogicOp == "OR" || filter.LogicOp == "or" </span><span class="cov0" title="0">{
                return MatchesAnySubFilter(row, filter.SubFilters)
        }</span>
        <span class="cov8" title="1">if filter.LogicOp == "AND" || filter.LogicOp == "and" </span><span class="cov0" title="0">{
                return MatchesAllSubFilters(row, filter.SubFilters)
        }</span>

        // 处理普通字段比较
        <span class="cov8" title="1">value, exists := row[filter.Field]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch filter.Operator </span>{
        case "=":<span class="cov8" title="1">
                return CompareEqual(value, filter.Value)</span>
        case "!=":<span class="cov8" title="1">
                return !CompareEqual(value, filter.Value)</span>
        case "&gt;":<span class="cov8" title="1">
                return CompareGreater(value, filter.Value)</span>
        case "&lt;":<span class="cov8" title="1">
                return !CompareGreater(value, filter.Value) &amp;&amp; !CompareEqual(value, filter.Value)</span>
        case "&gt;=":<span class="cov8" title="1">
                return CompareGreater(value, filter.Value) || CompareEqual(value, filter.Value)</span>
        case "&lt;=":<span class="cov8" title="1">
                return !CompareGreater(value, filter.Value)</span>
        case "LIKE":<span class="cov8" title="1">
                return CompareLike(value, filter.Value)</span>
        case "NOT LIKE":<span class="cov0" title="0">
                return !CompareLike(value, filter.Value)</span>
        case "IN":<span class="cov8" title="1">
                return CompareIn(value, filter.Value)</span>
        case "NOT IN":<span class="cov0" title="0">
                return !CompareIn(value, filter.Value)</span>
        case "BETWEEN":<span class="cov8" title="1">
                return CompareBetween(value, filter.Value)</span>
        case "NOT BETWEEN":<span class="cov0" title="0">
                return !CompareBetween(value, filter.Value)</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package util

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "sort"
)

// ApplyOrder 应用排序
func ApplyOrder(rows []domain.Row, options *domain.QueryOptions) []domain.Row <span class="cov8" title="1">{
        if options == nil || options.OrderBy == "" </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">result := make([]domain.Row, len(rows))
        copy(result, rows)

        // 获取排序列
        column := options.OrderBy

        // 获取排序方向
        order := options.Order
        if order == "" </span><span class="cov8" title="1">{
                order = "ASC"
        }</span>

        // 排序
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                valI, existsI := result[i][column]
                valJ, existsJ := result[j][column]

                if !existsI &amp;&amp; !existsJ </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if !existsI </span><span class="cov0" title="0">{
                        return order != "ASC"
                }</span>
                <span class="cov8" title="1">if !existsJ </span><span class="cov0" title="0">{
                        return order == "ASC"
                }</span>

                <span class="cov8" title="1">cmp := CompareValues(valI, valJ)
                if order == "DESC" </span><span class="cov8" title="1">{
                        return cmp &gt; 0
                }</span>
                <span class="cov8" title="1">return cmp &lt; 0</span>
        })

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package util

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ApplyPagination 应用分页（通用实现）

// ApplyPagination 应用分页（通用实现）
func ApplyPagination(rows []domain.Row, offset, limit int) []domain.Row <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">start := offset
        if start &lt; 0 </span><span class="cov8" title="1">{
                start = 0
        }</span>
        <span class="cov8" title="1">if start &gt;= len(rows) </span><span class="cov8" title="1">{
                return []domain.Row{}
        }</span>

        <span class="cov8" title="1">end := start + limit
        if end &gt; len(rows) </span><span class="cov8" title="1">{
                end = len(rows)
        }</span>

        <span class="cov8" title="1">result := make([]domain.Row, 0, limit)
        for i := start; i &lt; end; i++ </span><span class="cov8" title="1">{
                result = append(result, rows[i])
        }</span>
        <span class="cov8" title="1">return result</span>
}

// PruneRows 裁剪行，只保留指定的列
func PruneRows(rows []domain.Row, columns []string) []domain.Row <span class="cov8" title="1">{
        if len(columns) == 0 </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">result := make([]domain.Row, len(rows))
        for i, row := range rows </span><span class="cov8" title="1">{
                pruned := make(domain.Row)
                for _, col := range columns </span><span class="cov8" title="1">{
                        if val, ok := row[col]; ok </span><span class="cov8" title="1">{
                                pruned[col] = val
                        }</span>
                }
                <span class="cov8" title="1">result[i] = pruned</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ApplyQueryOperations 应用查询操作（过滤器、排序、分页）
func ApplyQueryOperations(rows []domain.Row, options *domain.QueryOptions, columns *[]domain.ColumnInfo) []domain.Row <span class="cov8" title="1">{
        // 应用过滤器
        filteredRows := ApplyFilters(rows, options)

        // 应用排序
        sortedRows := ApplyOrder(filteredRows, options)

        // 应用分页
        pagedRows := ApplyPagination(sortedRows, options.Offset, options.Limit)

        // 如果需要列裁剪
        if options != nil &amp;&amp; len(options.SelectColumns) &gt; 0 &amp;&amp; columns != nil </span><span class="cov0" title="0">{
                pagedRows = PruneRows(pagedRows, options.SelectColumns)
        }</span>

        <span class="cov8" title="1">return pagedRows</span>
}

// GetNeededColumns 获取需要读取的列（通用方法）
func GetNeededColumns(options *domain.QueryOptions) []string <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">needed := make(map[string]bool)
        for _, filter := range options.Filters </span><span class="cov8" title="1">{
                needed[filter.Field] = true
        }</span>

        <span class="cov8" title="1">if options.OrderBy != "" </span><span class="cov8" title="1">{
                needed[options.OrderBy] = true
        }</span>

        <span class="cov8" title="1">if len(options.SelectColumns) &gt; 0 </span><span class="cov8" title="1">{
                for _, col := range options.SelectColumns </span><span class="cov8" title="1">{
                        needed[col] = true
                }</span>
        }

        <span class="cov8" title="1">if len(needed) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make([]string, 0, len(needed))
        for col := range needed </span><span class="cov8" title="1">{
                result = append(result, col)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package util

import "strings"

// StartsWith 检查字符串是否以指定前缀开头
func StartsWith(s, prefix string) bool <span class="cov8" title="1">{
        if len(s) &lt; len(prefix) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s[:len(prefix)] == prefix</span>
}

// EndsWith 检查字符串是否以指定后缀结尾
func EndsWith(s, suffix string) bool <span class="cov8" title="1">{
        if len(s) &lt; len(suffix) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s[len(s)-len(suffix):] == suffix</span>
}

// ContainsSimple 简单字符串包含检查
func ContainsSimple(s, substr string) bool <span class="cov8" title="1">{
        return FindSubstring(s, substr) != -1
}</span>

// FindSubstring 查找子串位置
func FindSubstring(s, substr string) int <span class="cov8" title="1">{
        if len(substr) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(s) &lt; len(substr) </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Contains 字符串包含检查（支持通配符）
func Contains(s, substr string) bool <span class="cov8" title="1">{
        // 简化实现：将 % 替换为 *
        substr = ReplaceAll(substr, "%", "*")

        if substr == "*" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(substr) &gt;= 2 &amp;&amp; substr[0] == '*' &amp;&amp; substr[len(substr)-1] == '*' </span><span class="cov8" title="1">{
                pattern := substr[1 : len(substr)-1]
                return ContainsSimple(s, pattern)
        }</span>

        <span class="cov8" title="1">if len(substr) &gt;= 1 &amp;&amp; substr[0] == '*' </span><span class="cov8" title="1">{
                pattern := substr[1:]
                return EndsWith(s, pattern)
        }</span>

        <span class="cov8" title="1">if len(substr) &gt;= 1 &amp;&amp; substr[len(substr)-1] == '*' </span><span class="cov8" title="1">{
                pattern := substr[:len(substr)-1]
                return StartsWith(s, pattern)
        }</span>

        <span class="cov8" title="1">return s == substr</span>
}

// ReplaceAll 替换字符串中所有出现的子串
func ReplaceAll(s, old, new string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(s, old, new)
}</span>

// ContainsTable 检查SQL是否包含表名
func ContainsTable(query, tableName string) bool <span class="cov8" title="1">{
        // 简化实现：检查表名是否在查询中
        return len(query) &gt; 0 &amp;&amp; len(tableName) &gt; 0 &amp;&amp;
                (query == tableName || ContainsWord(query, tableName))
}</span>

// ContainsWord 检查单词是否在字符串中（作为独立单词）
func ContainsWord(str, word string) bool <span class="cov8" title="1">{
        if len(str) == 0 || len(word) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // 简化实现：查找是否包含空格+word或word+空格，或在开头/结尾
        <span class="cov8" title="1">wordLower := strings.ToLower(word)
        strLower := strings.ToLower(str)

        // 检查各种可能的位置
        patterns := []string{
                " " + wordLower + " ",
                " " + wordLower + ",",
                " " + wordLower + ";",
                " " + wordLower + ")",
                "(" + wordLower + " ",
                "," + wordLower + " ",
                " " + wordLower + "\n",
                "\n" + wordLower + " ",
        }

        // 检查开头
        if strings.HasPrefix(strLower, wordLower+" ") ||
                strings.HasPrefix(strLower, wordLower+",") ||
                strings.HasPrefix(strLower, wordLower+"(") </span><span class="cov8" title="1">{
                return true
        }</span>

        // 检查结尾
        <span class="cov8" title="1">if strings.HasSuffix(strLower, " "+wordLower) ||
                strings.HasSuffix(strLower, ","+wordLower) ||
                strings.HasSuffix(strLower, ")"+wordLower) </span><span class="cov8" title="1">{
                return true
        }</span>

        // 检查中间
        <span class="cov8" title="1">for _, pattern := range patterns </span><span class="cov8" title="1">{
                if strings.Contains(strLower, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// JoinWith 用指定分隔符连接字符串数组
func JoinWith(strs []string, sep string) string <span class="cov8" title="1">{
        if len(strs) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.Join(strs, sep)</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package security

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// AuditLevel 审计级别
type AuditLevel int

const (
        AuditLevelInfo AuditLevel = iota
        AuditLevelWarning
        AuditLevelError
        AuditLevelCritical
)

// AuditEventType 审计事件类型
type AuditEventType string

const (
        EventTypeLogin      AuditEventType = "login"
        EventTypeLogout     AuditEventType = "logout"
        EventTypeQuery      AuditEventType = "query"
        EventTypeInsert     AuditEventType = "insert"
        EventTypeUpdate     AuditEventType = "update"
        EventTypeDelete     AuditEventType = "delete"
        EventTypeDDL        AuditEventType = "ddl"
        EventTypePermission AuditEventType = "permission"
        EventTypeInjection  AuditEventType = "injection"
        EventTypeError      AuditEventType = "error"
)

// AuditEvent 审计事件
type AuditEvent struct {
        ID        string                 `json:"id"`
        Timestamp time.Time              `json:"timestamp"`
        Level     AuditLevel             `json:"level"`
        EventType AuditEventType         `json:"event_type"`
        User      string                 `json:"user"`
        Database  string                 `json:"database"`
        Table     string                 `json:"table"`
        Query     string                 `json:"query"`
        Message   string                 `json:"message"`
        Metadata  map[string]interface{} `json:"metadata"`
        Success   bool                   `json:"success"`
        Duration  int64                  `json:"duration"` // 毫秒
}

// AuditLogEntry 审计日志条目
type AuditLogEntry struct {
        Event *AuditEvent
        Error error
}

// AuditLogger 审计日志记录器
type AuditLogger struct {
        entries chan *AuditLogEntry
        bufLock sync.RWMutex
        buffer  []*AuditEvent
        size    int
        maxSize int
        index   int
}

// NewAuditLogger 创建审计日志记录器
func NewAuditLogger(size int) *AuditLogger <span class="cov0" title="0">{
        return &amp;AuditLogger{
                entries: make(chan *AuditLogEntry, 1000),
                buffer:  make([]*AuditEvent, size),
                size:    size,
                maxSize: size,
        }
}</span>

// Log 记录审计事件
func (al *AuditLogger) Log(event *AuditEvent) <span class="cov0" title="0">{
        entry := &amp;AuditLogEntry{
                Event: event,
        }

        // 存储到缓冲区
        al.bufLock.Lock()
        al.buffer[al.index] = event
        al.index = (al.index + 1) % al.size
        al.bufLock.Unlock()

        // 发送到通道（异步处理）
        select </span>{
        case al.entries &lt;- entry:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // 通道满，丢弃
        }
}

// LogQuery 记录查询
func (al *AuditLogger) LogQuery(user, database, query string, duration int64, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelInfo,
                EventType: EventTypeQuery,
                User:      user,
                Database:  database,
                Query:     query,
                Success:   success,
                Duration:  duration,
        }

        al.Log(event)
}</span>

// LogInsert 记录插入操作
func (al *AuditLogger) LogInsert(user, database, table string, query string, duration int64, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelInfo,
                EventType: EventTypeInsert,
                User:      user,
                Database:  database,
                Table:     table,
                Query:     query,
                Success:   success,
                Duration:  duration,
        }

        al.Log(event)
}</span>

// LogUpdate 记录更新操作
func (al *AuditLogger) LogUpdate(user, database, table string, query string, duration int64, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelInfo,
                EventType: EventTypeUpdate,
                User:      user,
                Database:  database,
                Table:     table,
                Query:     query,
                Success:   success,
                Duration:  duration,
        }

        al.Log(event)
}</span>

// LogDelete 记录删除操作
func (al *AuditLogger) LogDelete(user, database, table string, query string, duration int64, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelWarning,
                EventType: EventTypeDelete,
                User:      user,
                Database:  database,
                Table:     table,
                Query:     query,
                Success:   success,
                Duration:  duration,
        }

        al.Log(event)
}</span>

// LogDDL 记录DDL操作
func (al *AuditLogger) LogDDL(user, database, query string, duration int64, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelWarning,
                EventType: EventTypeDDL,
                User:      user,
                Database:  database,
                Query:     query,
                Success:   success,
                Duration:  duration,
        }

        al.Log(event)
}</span>

// LogLogin 记录登录
func (al *AuditLogger) LogLogin(user, ip string, success bool) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelInfo,
                EventType: EventTypeLogin,
                User:      user,
                Message:   fmt.Sprintf("Login from %s", ip),
                Success:   success,
                Metadata: map[string]interface{}{
                        "ip": ip,
                },
        }

        al.Log(event)
}</span>

// LogLogout 记录登出
func (al *AuditLogger) LogLogout(user string) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelInfo,
                EventType: EventTypeLogout,
                User:      user,
                Message:   "User logged out",
                Success:   true,
        }

        al.Log(event)
}</span>

// LogPermission 记录权限变更
func (al *AuditLogger) LogPermission(user, action string, metadata map[string]interface{}) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelWarning,
                EventType: EventTypePermission,
                User:      user,
                Message:   fmt.Sprintf("Permission %s", action),
                Success:   true,
                Metadata:  metadata,
        }

        al.Log(event)
}</span>

// LogInjection 记录SQL注入尝试
func (al *AuditLogger) LogInjection(user, ip, query string) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelCritical,
                EventType: EventTypeInjection,
                User:      user,
                Query:     query,
                Message:   "SQL injection attempt detected",
                Success:   false,
                Metadata: map[string]interface{}{
                        "ip": ip,
                },
        }

        al.Log(event)
}</span>

// LogError 记录错误
func (al *AuditLogger) LogError(user, database, message string, err error) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Timestamp: time.Now(),
                Level:     AuditLevelError,
                EventType: EventTypeError,
                User:      user,
                Database:  database,
                Message:   message,
                Success:   false,
                Metadata: map[string]interface{}{
                        "error": err.Error(),
                },
        }

        al.Log(event)
}</span>

// GetEvents 获取事件
func (al *AuditLogger) GetEvents(offset, limit int) []*AuditEvent <span class="cov0" title="0">{
        al.bufLock.Lock()
        defer al.bufLock.Unlock()

        events := make([]*AuditEvent, 0, limit)

        // 计算起始位置
        start := al.index - offset - limit
        if start &lt; 0 </span><span class="cov0" title="0">{
                start += al.size
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                pos := (start + i) % al.size
                event := al.buffer[pos]
                if event == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events</span>
}

// GetEventsByUser 获取用户的事件
func (al *AuditLogger) GetEventsByUser(user string) []*AuditEvent <span class="cov0" title="0">{
        al.bufLock.RLock()
        defer al.bufLock.RUnlock()

        events := make([]*AuditEvent, 0)
        for _, event := range al.buffer </span><span class="cov0" title="0">{
                if event != nil &amp;&amp; event.User == user </span><span class="cov0" title="0">{
                        events = append(events, event)
                }</span>
        }

        <span class="cov0" title="0">return events</span>
}

// GetEventsByType 获取指定类型的事件
func (al *AuditLogger) GetEventsByType(eventType AuditEventType) []*AuditEvent <span class="cov0" title="0">{
        al.bufLock.RLock()
        defer al.bufLock.RUnlock()

        events := make([]*AuditEvent, 0)
        for _, event := range al.buffer </span><span class="cov0" title="0">{
                if event != nil &amp;&amp; event.EventType == eventType </span><span class="cov0" title="0">{
                        events = append(events, event)
                }</span>
        }

        <span class="cov0" title="0">return events</span>
}

// GetEventsByLevel 获取指定级别的事件
func (al *AuditLogger) GetEventsByLevel(level AuditLevel) []*AuditEvent <span class="cov0" title="0">{
        al.bufLock.RLock()
        defer al.bufLock.RUnlock()

        events := make([]*AuditEvent, 0)
        for _, event := range al.buffer </span><span class="cov0" title="0">{
                if event != nil &amp;&amp; event.Level == level </span><span class="cov0" title="0">{
                        events = append(events, event)
                }</span>
        }

        <span class="cov0" title="0">return events</span>
}

// GetEventsByTimeRange 获取时间范围内的事件
func (al *AuditLogger) GetEventsByTimeRange(start, end time.Time) []*AuditEvent <span class="cov0" title="0">{
        al.bufLock.RLock()
        defer al.bufLock.RUnlock()

        events := make([]*AuditEvent, 0)
        for _, event := range al.buffer </span><span class="cov0" title="0">{
                if event != nil &amp;&amp; event.Timestamp.After(start) &amp;&amp; event.Timestamp.Before(end) </span><span class="cov0" title="0">{
                        events = append(events, event)
                }</span>
        }

        <span class="cov0" title="0">return events</span>
}

// Export 导出审计日志
func (al *AuditLogger) Export() (string, error) <span class="cov0" title="0">{
        events := al.GetEvents(0, al.size)
        data, err := json.MarshalIndent(events, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(data), nil</span>
}

// generateEventID 生成事件ID
func generateEventID() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package security

import (
        "errors"
        "sync"
        "time"
)

// Permission 权限类型
type Permission int

const (
        PermissionNone Permission = iota
        PermissionRead
        PermissionWrite
        PermissionDelete
        PermissionCreate
        PermissionDrop
        PermissionAlter
        PermissionGrant
        PermissionAll = 0xFF
)

// Role 角色类型
type Role string

const (
        RoleAdmin      Role = "admin"
        RoleModerator  Role = "moderator"
        RoleUser       Role = "user"
        RoleReadOnly   Role = "readonly"
        RoleGuest      Role = "guest"
)

// User 用户
type User struct {
        Username    string
        PasswordHash string
        Roles       []Role
        Permissions map[string]Permission // table -&gt; permission
        CreatedAt   time.Time
        UpdatedAt   time.Time
        IsActive    bool
}

// AuthorizationManager 授权管理器
type AuthorizationManager struct {
        users  map[string]*User
        roles  map[Role][]Permission
        rwLock sync.RWMutex
}

// NewAuthorizationManager 创建授权管理器
func NewAuthorizationManager() *AuthorizationManager <span class="cov8" title="1">{
        am := &amp;AuthorizationManager{
                users:  make(map[string]*User),
                roles:  make(map[Role][]Permission),
        }

        // 初始化默认角色权限
        am.initDefaultRoles()

        return am
}</span>

// initDefaultRoles 初始化默认角色权限
func (am *AuthorizationManager) initDefaultRoles() <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        // 管理员：所有权限
        am.roles[RoleAdmin] = []Permission{PermissionAll}

        // 版主：读写删除权限
        am.roles[RoleModerator] = []Permission{
                PermissionRead,
                PermissionWrite,
                PermissionDelete,
        }

        // 普通用户：读写权限
        am.roles[RoleUser] = []Permission{
                PermissionRead,
                PermissionWrite,
        }

        // 只读用户：只读权限
        am.roles[RoleReadOnly] = []Permission{
                PermissionRead,
        }

        // 访客：无权限
        am.roles[RoleGuest] = []Permission{
                PermissionNone,
        }
}</span>

// CreateUser 创建用户
func (am *AuthorizationManager) CreateUser(username, passwordHash string, roles []Role) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        if username == "" </span><span class="cov8" title="1">{
                return errors.New("username cannot be empty")
        }</span>

        <span class="cov8" title="1">if _, exists := am.users[username]; exists </span><span class="cov8" title="1">{
                return errors.New("user already exists")
        }</span>

        <span class="cov8" title="1">am.users[username] = &amp;User{
                Username:    username,
                PasswordHash: passwordHash,
                Roles:       roles,
                Permissions: make(map[string]Permission),
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                IsActive:    true,
        }

        return nil</span>
}

// GetUser 获取用户
func (am *AuthorizationManager) GetUser(username string) (*User, error) <span class="cov8" title="1">{
        am.rwLock.RLock()
        defer am.rwLock.RUnlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("user not found")
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// DeleteUser 删除用户
func (am *AuthorizationManager) DeleteUser(username string) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        if _, exists := am.users[username]; !exists </span><span class="cov8" title="1">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">delete(am.users, username)
        return nil</span>
}

// HasPermission 检查用户是否有指定权限
func (am *AuthorizationManager) HasPermission(username string, permission Permission, table string) bool <span class="cov8" title="1">{
        am.rwLock.RLock()
        defer am.rwLock.RUnlock()

        user, exists := am.users[username]
        if !exists || !user.IsActive </span><span class="cov8" title="1">{
                return false
        }</span>

        // 检查表级别权限
        <span class="cov8" title="1">if table != "" </span><span class="cov8" title="1">{
                if tablePerm, ok := user.Permissions[table]; ok </span><span class="cov8" title="1">{
                        return (tablePerm &amp; permission) != 0
                }</span>
        }

        // 检查角色权限
        <span class="cov8" title="1">for _, role := range user.Roles </span><span class="cov8" title="1">{
                if rolePerms, ok := am.roles[role]; ok </span><span class="cov8" title="1">{
                        for _, perm := range rolePerms </span><span class="cov8" title="1">{
                                if perm == PermissionAll || perm == permission </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return false</span>
}

// GrantPermission 授予权限
func (am *AuthorizationManager) GrantPermission(username string, permission Permission, table string) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov8" title="1">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">if table == "" </span><span class="cov8" title="1">{
                return errors.New("table cannot be empty")
        }</span>

        <span class="cov8" title="1">if user.Permissions == nil </span><span class="cov0" title="0">{
                user.Permissions = make(map[string]Permission)
        }</span>

        <span class="cov8" title="1">currentPerm := user.Permissions[table]
        user.Permissions[table] = currentPerm | permission
        user.UpdatedAt = time.Now()

        return nil</span>
}

// RevokePermission 撤销权限
func (am *AuthorizationManager) RevokePermission(username string, permission Permission, table string) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">if table == "" </span><span class="cov0" title="0">{
                return errors.New("table cannot be empty")
        }</span>

        <span class="cov8" title="1">currentPerm := user.Permissions[table]
        user.Permissions[table] = currentPerm &amp;^ permission
        user.UpdatedAt = time.Now()

        return nil</span>
}

// AssignRole 分配角色
func (am *AuthorizationManager) AssignRole(username string, role Role) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">for _, r := range user.Roles </span><span class="cov8" title="1">{
                if r == role </span><span class="cov8" title="1">{
                        return errors.New("user already has this role")
                }</span>
        }

        <span class="cov8" title="1">user.Roles = append(user.Roles, role)
        user.UpdatedAt = time.Now()

        return nil</span>
}

// RemoveRole 移除角色
func (am *AuthorizationManager) RemoveRole(username string, role Role) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">for i, r := range user.Roles </span><span class="cov8" title="1">{
                if r == role </span><span class="cov8" title="1">{
                        user.Roles = append(user.Roles[:i], user.Roles[i+1:]...)
                        user.UpdatedAt = time.Now()
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return errors.New("role not found for user")</span>
}

// ActivateUser 激活用户
func (am *AuthorizationManager) ActivateUser(username string) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">user.IsActive = true
        user.UpdatedAt = time.Now()

        return nil</span>
}

// DeactivateUser 停用用户
func (am *AuthorizationManager) DeactivateUser(username string) error <span class="cov8" title="1">{
        am.rwLock.Lock()
        defer am.rwLock.Unlock()

        user, exists := am.users[username]
        if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">user.IsActive = false
        user.UpdatedAt = time.Now()

        return nil</span>
}

// ListUsers 列出所有用户
func (am *AuthorizationManager) ListUsers() []string <span class="cov8" title="1">{
        am.rwLock.RLock()
        defer am.rwLock.RUnlock()

        users := make([]string, 0, len(am.users))
        for username := range am.users </span><span class="cov8" title="1">{
                users = append(users, username)
        }</span>
        <span class="cov8" title="1">return users</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package security

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
)

// Encryptor 加密器
type Encryptor struct {
        key []byte
}

// NewEncryptor 创建加密器
func NewEncryptor(password string) (*Encryptor, error) <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return nil, errors.New("password must be at least 8 characters")
        }</span>

        // 使用SHA256生成32字节的密钥
        <span class="cov8" title="1">hash := sha256.Sum256([]byte(password))
        key := hash[:]

        return &amp;Encryptor{
                key: key,
        }, nil</span>
}

// Encrypt 加密数据
func (e *Encryptor) Encrypt(plaintext string) (string, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 使用GCM模式
        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 加密
        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// Decrypt 解密数据
func (e *Encryptor) Decrypt(ciphertext string) (string, error) <span class="cov8" title="1">{
        // Base64解码
        data, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov8" title="1">{
                return "", errors.New("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, ciphertextBytes := data[:nonceSize], data[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertextBytes, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(plaintext), nil</span>
}

// EncryptField 加密字段值
func (e *Encryptor) EncryptField(fieldName, value string) (string, error) <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return e.Encrypt(value)</span>
}

// DecryptField 解密字段值
func (e *Encryptor) DecryptField(fieldName, encryptedValue string) (string, error) <span class="cov8" title="1">{
        if encryptedValue == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return e.Decrypt(encryptedValue)</span>
}

// HashPassword 哈希密码
func HashPassword(password string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(password))
        return fmt.Sprintf("%x", hash)
}</span>

// VerifyPassword 验证密码
func VerifyPassword(password, hash string) bool <span class="cov8" title="1">{
        return HashPassword(password) == hash
}</span>

// SensitiveFieldsManager 敏感字段管理器
type SensitiveFieldsManager struct {
        encryptor        *Encryptor
        sensitiveFields  map[string]bool // table.field -&gt; true
}

// NewSensitiveFieldsManager 创建敏感字段管理器
func NewSensitiveFieldsManager(password string, fields []string) (*SensitiveFieldsManager, error) <span class="cov8" title="1">{
        encryptor, err := NewEncryptor(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">manager := &amp;SensitiveFieldsManager{
                encryptor:       encryptor,
                sensitiveFields: make(map[string]bool),
        }

        for _, field := range fields </span><span class="cov8" title="1">{
                manager.sensitiveFields[field] = true
        }</span>

        <span class="cov8" title="1">return manager, nil</span>
}

// AddSensitiveField 添加敏感字段
func (m *SensitiveFieldsManager) AddSensitiveField(table, field string) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s.%s", table, field)
        m.sensitiveFields[key] = true
}</span>

// RemoveSensitiveField 移除敏感字段
func (m *SensitiveFieldsManager) RemoveSensitiveField(table, field string) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s.%s", table, field)
        delete(m.sensitiveFields, key)
}</span>

// IsSensitive 检查字段是否敏感
func (m *SensitiveFieldsManager) IsSensitive(table, field string) bool <span class="cov8" title="1">{
        key := fmt.Sprintf("%s.%s", table, field)
        return m.sensitiveFields[key]
}</span>

// EncryptFieldIfSensitive 如果字段敏感则加密
func (m *SensitiveFieldsManager) EncryptFieldIfSensitive(table, field, value string) (string, error) <span class="cov8" title="1">{
        if !m.IsSensitive(table, field) </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">return m.encryptor.EncryptField(field, value)</span>
}

// DecryptFieldIfSensitive 如果字段敏感则解密
func (m *SensitiveFieldsManager) DecryptFieldIfSensitive(table, field, value string) (string, error) <span class="cov8" title="1">{
        if !m.IsSensitive(table, field) </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">return m.encryptor.DecryptField(field, value)</span>
}

// EncryptRecord 加密记录中的敏感字段
func (m *SensitiveFieldsManager) EncryptRecord(table string, record map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for field, value := range record </span><span class="cov8" title="1">{
                strValue, ok := value.(string)
                if !ok </span><span class="cov8" title="1">{
                        result[field] = value
                        continue</span>
                }

                <span class="cov8" title="1">encrypted, err := m.EncryptFieldIfSensitive(table, field, strValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result[field] = encrypted</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// DecryptRecord 解密记录中的敏感字段
func (m *SensitiveFieldsManager) DecryptRecord(table string, record map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for field, value := range record </span><span class="cov8" title="1">{
                strValue, ok := value.(string)
                if !ok </span><span class="cov8" title="1">{
                        result[field] = value
                        continue</span>
                }

                <span class="cov8" title="1">decrypted, err := m.DecryptFieldIfSensitive(table, field, strValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result[field] = decrypted</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package security

import (
        "regexp"
        "strings"
        "unicode"
)

// SQLInjectionDetector SQL注入检测器
type SQLInjectionDetector struct {
        patterns []*regexp.Regexp
}

// NewSQLInjectionDetector 创建SQL注入检测器
func NewSQLInjectionDetector() *SQLInjectionDetector <span class="cov8" title="1">{
        patterns := []*regexp.Regexp{
                // 检测UNION注入（检测 UNION SELECT 模式）
                regexp.MustCompile(`(?i)\bunion\s+(all\s+)?select\b`),
                // 检测OR注入（检测数字比较，如 1 OR 1=1）
                regexp.MustCompile(`(?i)\s+or\s+["']?\d+["']?\s*(=|&lt;|&gt;)\s*["']?\d+["']?`),
                // 检测AND注入（检测数字比较，如 1 AND 1=1）
                regexp.MustCompile(`(?i)\s+and\s+["']?\d+["']?\s*(=|&lt;|&gt;)\s*["']?\d+["']?`),
                // 检测注释注入（末尾的注释或注释后的其他语句）
                regexp.MustCompile(`(?i)(--[^a-zA-Z0-9]|/\*[^*]*\*/)`),
                // 检测堆叠查询（分号后有SQL关键字）
                regexp.MustCompile(`;\s*(select|insert|update|delete|drop|alter|create|exec|execute|waitfor)\b`),
                // 检测EXEC注入
                regexp.MustCompile(`(?i)\bexec(ute)?\s*\(?(\s*(xp_\w+|sp_\w+))`),
                // 检测XP_开头的存储过程（常见于SQL Server注入）
                regexp.MustCompile(`(?i)\bxp_\w+\b`),
                // 检测十六进制编码（十六进制字符串，至少3个字符）
                regexp.MustCompile(`(?i)0x[0-9a-f]{3,}`),
        }

        return &amp;SQLInjectionDetector{
                patterns: patterns,
        }
}

// Detect 检测SQL注入
func (d *SQLInjectionDetector) Detect(sql string) *InjectionResult {
        </span>result := &amp;InjectionResult{
                IsDetected: false,
                Details:    []InjectionDetail{},
        }

        // 检查是否是参数化查询（占位符）
        if d.isParameterizedQuery(sql) {
                return result
        }

</span>        // 检查引号是否成对出现
        if d.hasUnmatchedQuot</span><span class="cov8" title="1">es(sql) {
                result.IsDetected = true
                result.Details = append(result.</span><span class="cov8" title="1">Details, InjectionDetail{
                        Pattern:  "unmatched_quotes",
                        Position: 0,
                        Length:   len(sql),
                        Fragment: sql,
                })
                return result
        }
</span>
        for _, pattern := range d.patterns {
                matches := pattern.FindAllStringIndex(sql, -1)
        <span class="cov8" title="1">        if len(match</span>es) &gt; 0 {
                        result.IsDetected = true
                        for _, match := range matches {
                                // 验证匹配是否在合法的上下文中
                                if d.isSuspiciousPattern(sql, match[0], match[1]) {
                                        result.Details = append(result.Details, InjectionDetail{
                                                Pattern:  pattern</span><span class="cov8" title="1">.String(),
                                                Position: match[0],
                </span>                                Length:   match[1] - match[0],
                                                Fragment: sql[match[0]:match[1]],
                                        })
        <span class="cov8" title="1">                        }
                        }
</span>                }
        }

        return result
}

// isParameterizedQuery 检查是否是参数化查询
func (d *SQLInjectionDetector) isPara</span><span class="cov8" title="1">meterizedQuery(sql string) bool {
        // 检查是否包含参数占位符
        h</span>asPlaceholder := regexp.MustCompile(`\?|@p\d+|:\d+`).MatchString(sql)
        <span class="cov8" title="1">if hasPlaceho</span>lder {
                return true
        }
        return false
}

// hasUnmatchedQuotes 检查是否有未匹配的引号
func (d *SQLInjectionDete</span><span class="cov8" title="1">ctor) hasUnmatchedQuotes(sql string) bool {
        singleQuoteCount := strings.Count(sql, "'")
        doubleQuoteCount := strings.Count(sql, `"`)
</span>        
        //</span> 引号数量为奇数表示未匹配
        if singleQuoteCount%2 != 0 || doubleQuoteCount%2 != 0 {
        <span class="cov8" title="1">        return true
</span>        }
        return false
}

// isSuspiciousPattern 检查模式是否出现在可疑的上下文中
func (d *SQLInjectionDetector) isSuspiciousPattern(sql string, start, end int) bool {
        </span>// 如果模式出现在VALUES或SET子句中，可能是合法的
        lowerSQL := strings.ToLower(sql)
        before := strings.LastIndex(lowerSQL[:start], "values(")
        beforeSet := strings.LastIndex(lowerSQL[:start], "set ")
        
</span>        if before &gt; start-50 &amp;&amp; before != -1 {
                </span>return false
        }
        if beforeSet &gt; start-50 &amp;&amp; beforeSet != -1 {
        <span class="cov8" title="1">        return false
</span>        }
</span>        
        //</span> 检查模式后面是否有可疑的内容
        if end &lt; len(sql)-5 {
                nextPart := strings.ToLower(sql[end:end+5])
                // 如果后面跟着数字比较（=1或!=1），可能是注入
        <span class="cov8" title="1">        if strings.Contains(nextPart,</span> "=1") || strings.Contains(nextPart, "= '1'") {
                        return true
                }
        }
        
        return true
}

// DetectAndSanitize 检测并清理SQL注入
func (d *SQLInjectionDetector) DetectAndSanitize(sql string) (*InjectionResult, string) {
        result := d.Detect(sql)
        if !result.IsDetected {
                return result, sql
        }

        // 清理SQL字符串
        sanitized := d.sanitizeSQL(sql)
        return result, sanitized
}

</span>// sanitizeSQL 清理SQL注入
fu</span>nc (d *SQLInjectionDetector) sanitizeSQL(sql string) string {
        // 移除危险字符
        <span class="cov8" title="1">dangerousChars := []st</span><span class="cov8" title="1">ring{"'", "\"", ";", "--", "/*", "*/", "xp_"}
        result := sql
        f</span>or _, char := range dangerousChars {
        <span class="cov8" title="1">        result = strings.Repl</span><span class="cov8" title="1">aceAll(result, char, "")
        }
        r</span>eturn result
}<span class="cov8" title="1">
</span>
//</span> SanitizeInput 清理用户输入
f<span class="cov8" title="1">unc (d *SQLI</span>njectionDetector) SanitizeInput(input string) string {
        // 移除所有非字母数字和基本标点的字符
        var result strings.Builder
        for _, r := range input {
                if unicode.IsLetter(r) || unicode.IsDigit(r) ||
                        r == '_' || r == '-' || r == '.' || r == '@' {
                        result.WriteRune(r)
                }
        }
        return result.String()
}

// ValidateString 验证字符串是否安全
func (d *SQLInjectionDetector) ValidateString(str string) bool {
        result := d.Detect(str)
        return !result.IsDetected
}

// ValidateParameter 验证参数是否安全
func (d *SQLInjectionDetector) ValidateParameter(name, value string) bool {
        if name == "" {
                return false
        }

        // 检查参数名是否只包含字母数字和下划线
        for _, r := range name {
                if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) &amp;&amp; r != '_' {
                        return false
                }
        }

        // 检查参数值是否包含注入
        return d.ValidateString(value)
}

// InjectionResult 注入检测结果
type InjectionResult struct {
        IsDetected bool
        Details    []InjectionDetail
}

// InjectionDetail 注入详细信息
type InjectionDetail struct {
        Pattern  string
        Position int
        Length   int
        Fragment string
}

// GetSeverity 获取注入严重程度
func (r *InjectionResult) GetSeverity() string {
        if !r.IsDetected {
                return "none"
        }

        if len(r.Details) &gt; 5 {
                return "critical"
        }
        if len(r.Details) &gt; 2 {
                return "high"
        }
        if len(r.Details) &gt; 1 {
                return "medium"
        }
        return "low"
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package pkg

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "net"
        "strings"
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/config"
        "github.com/kasuganosora/sqlexec/pkg/monitor"
        "github.com/kasuganosora/sqlexec/pkg/mvcc"
        "github.com/kasuganosora/sqlexec/pkg/optimizer"
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/pool"
        "github.com/kasuganosora/sqlexec/server/protocol"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/session"
)

// 定义 context key
type contextKey string

const (
        // 连接状态相关的 key
        keyHandshakeDone contextKey = "handshake_done"
        keySession       contextKey = "session"
)

// 设置握手完成状态
func withHandshakeDone(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, keyHandshakeDone, true)
}</span>

// 检查握手是否完成
func isHandshakeDone(ctx context.Context) bool <span class="cov0" title="0">{
        done, _ := ctx.Value(keyHandshakeDone).(bool)
        return done
}</span>

// 设置会话到 context
func withSession(ctx context.Context, sess *session.Session) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, keySession, sess)
}</span>

// 从 context 获取会话
func getSession(ctx context.Context) *session.Session <span class="cov0" title="0">{
        sess, _ := ctx.Value(keySession).(*session.Session)
        return sess
}</span>

// Server MySQL 服务器
type Server struct {
        sessionMgr        *session.SessionMgr
        dataSourceMgr     *application.DataSourceManager
        defaultDataSource domain.DataSource
        mu                sync.RWMutex
        parser            *parser.Parser
        handler           *parser.HandlerChain
        optimizedExecutor *optimizer.OptimizedExecutor
        useOptimizer      bool

        // 池系统
        goroutinePool *pool.GoroutinePool
        objectPool    *pool.ObjectPool

        // 监控系统
        metricsCollector *monitor.MetricsCollector
        cacheManager     *monitor.CacheManager
        
        // MVCC管理器
        mvccManager *mvcc.Manager
}

// NewServer 创建新的服务器实例
func NewServer(cfg *config.Config) *Server <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        // 初始化会话配置
        <span class="cov0" title="0">session.InitSessionConfig(&amp;cfg.Session)

        // 创建解析器
        p := parser.NewParser()

        // 创建处理器链
        chain := parser.NewHandlerChain()
        chain.RegisterHandler("SELECT", parser.NewQueryHandler())
        chain.RegisterHandler("INSERT", parser.NewDMLHandler())
        chain.RegisterHandler("UPDATE", parser.NewDMLHandler())
        chain.RegisterHandler("DELETE", parser.NewDMLHandler())
        chain.RegisterHandler("REPLACE", parser.NewDMLHandler())
        chain.RegisterHandler("CREATE_TABLE", parser.NewDDLHandler())
        chain.RegisterHandler("DROP_TABLE", parser.NewDDLHandler())
        chain.RegisterHandler("CREATE_DATABASE", parser.NewDDLHandler())
        chain.RegisterHandler("DROP_DATABASE", parser.NewDDLHandler())
        chain.RegisterHandler("ALTER_TABLE", parser.NewDDLHandler())
        chain.RegisterHandler("TRUNCATE_TABLE", parser.NewDDLHandler())
        chain.RegisterHandler("SET", parser.NewSetHandler())
        chain.RegisterHandler("SHOW", parser.NewShowHandler())
        chain.RegisterHandler("USE", parser.NewUseHandler())
        chain.SetDefaultHandler(parser.NewDefaultHandler())

        // 创建池系统
        goroutinePool := pool.NewGoroutinePool(cfg.Pool.GoroutinePool.MaxWorkers, cfg.Pool.GoroutinePool.QueueSize)

        objectPool := pool.NewObjectPool(
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return make(map[string]interface{}), nil
                }</span>,
                func(obj interface{}) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                cfg.Pool.ObjectPool.MaxSize,
        )

        // 创建监控系统
        <span class="cov0" title="0">metricsCollector := monitor.NewMetricsCollector()
        cacheManager := monitor.NewCacheManager(
                cfg.Cache.QueryCache.MaxSize,
                cfg.Cache.ResultCache.MaxSize,
                cfg.Cache.SchemaCache.MaxSize,
        )

        // 创建MVCC管理器
        mvccManager := mvcc.NewManagerFromConfig(cfg)

        server := &amp;Server{
                sessionMgr:       session.NewSessionMgr(context.Background(), session.NewMemoryDriver()),
                dataSourceMgr:    application.GetDefaultManager(),
                parser:           p,
                handler:          chain,
                useOptimizer:     cfg.Optimizer.Enabled,
                goroutinePool:    goroutinePool,
                objectPool:       objectPool,
                metricsCollector: metricsCollector,
                cacheManager:     cacheManager,
                mvccManager:     mvccManager,
        }

        return server</span>
}

// SetDataSource 设置默认数据源
func (s *Server) SetDataSource(ds domain.DataSource) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !ds.IsConnected() </span><span class="cov0" title="0">{
                if err := ds.Connect(context.Background()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to connect data source: %w", err)
                }</span>
        }

        <span class="cov0" title="0">s.defaultDataSource = ds

        // 初始化优化执行器
        s.optimizedExecutor = optimizer.NewOptimizedExecutor(ds, s.useOptimizer)

        return nil</span>
}

// GetDataSource 获取默认数据源
func (s *Server) GetDataSource() domain.DataSource <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.defaultDataSource
}</span>

// SetUseOptimizer 设置是否使用优化器
func (s *Server) SetUseOptimizer(use bool) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.useOptimizer = use
        if s.optimizedExecutor != nil </span><span class="cov0" title="0">{
                s.optimizedExecutor.SetUseOptimizer(use)
        }</span>
}

// GetUseOptimizer 获取是否使用优化器
func (s *Server) GetUseOptimizer() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.useOptimizer
}</span>

// SetDataSourceManager 设置数据源管理器
func (s *Server) SetDataSourceManager(mgr *application.DataSourceManager) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.dataSourceMgr = mgr
}</span>

// GetDataSourceManager 获取数据源管理器
func (s *Server) GetDataSourceManager() *application.DataSourceManager <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.dataSourceMgr
}</span>

// HandleConn 用于处理MYSQL的链接
func (s *Server) HandleConn(ctx context.Context, conn net.Conn) (err error) <span class="cov0" title="0">{
        // 设置连接超时
        if tcpConn, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcpConn.SetKeepAlive(true)
                tcpConn.SetKeepAlivePeriod(config.DefaultConfig().Server.KeepAlivePeriod)
        }</span>

        // 获取客户端地址
        <span class="cov0" title="0">remoteAddr := conn.RemoteAddr().String()
        addr, port := parseRemoteAddr(remoteAddr)
        log.Printf("新连接来自: %s:%s", addr, port)

        // 获取或创建会话
        sess, err := s.sessionMgr.GetOrCreateSession(ctx, addr, port)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("创建会话失败: %v", err)
                return fmt.Errorf("创建会话失败: %w", err)
        }</span>
        <span class="cov0" title="0">sess.ResetSequenceID()
        ctx = withSession(ctx, sess)

        // 检查是否已经完成握手
        if !isHandshakeDone(ctx) </span><span class="cov0" title="0">{
                // 发送握手包
                handshake := protocol.NewHandshakePacket()
                handshake.ThreadID = sess.ThreadID
                log.Printf("准备发送握手包: ProtocolVersion=%d, ServerVersion=%s, ConnectionID=%d, AuthPluginName=%s",
                        handshake.ProtocolVersion,
                        handshake.ServerVersion,
                        handshake.ThreadID,
                        handshake.AuthPluginName)

                data, err := handshake.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("序列化握手包失败: %v", err)
                        return fmt.Errorf("序列化握手包失败: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := conn.Write(data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("发送握手包失败: %v", err)
                        return fmt.Errorf("发送握手包失败: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("已发送握手包")

                // 读取客户端的认证包
                log.Printf("等待客户端认证包...")
                authPacket, err := protocol.ReadPacket(conn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("读取认证包失败: %v", err)
                        return fmt.Errorf("读取认证包失败: %w", err)
                }</span>

                // 打印认证包信息
                <span class="cov0" title="0">log.Printf("收到认证包: 长度=%d, SequenceID=%d", authPacket.PayloadLength, authPacket.SequenceID)
                if len(authPacket.Payload) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("认证包命令类型: %d", authPacket.Payload[0])
                }</span>

                // 解析认证响应
                <span class="cov0" title="0">handshakeResponse := &amp;protocol.HandshakeResponse{}
                if err := handshakeResponse.Unmarshal(conn, uint32(handshake.CapabilityFlags1)|uint32(handshake.CapabilityFlags2)&lt;&lt;16); err != nil </span><span class="cov0" title="0">{
                        log.Printf("解析认证响应失败: %v", err)
                        return fmt.Errorf("解析认证响应失败: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("用户: %s, 数据库: %s, 字符集: %d", handshakeResponse.User, handshakeResponse.Database, handshakeResponse.CharacterSet)

                // 设置用户名
                sess.SetUser(handshakeResponse.User)

                // 发送 OK 包表示认证成功
                log.Printf("发送认证成功包...")
                if err := protocol.SendOK(conn, sess.GetNextSequenceID()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("发送认证成功包失败: %v", err)
                        return fmt.Errorf("发送认证成功包失败: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("已发送认证成功包")

                // 标记握手完成
                ctx = withHandshakeDone(ctx)</span>
        }

        // 处理后续的命令包
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                log.Printf("等待命令包...")
                packet, err := protocol.ReadPacket(conn)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                log.Printf("客户端断开连接")
                                return nil
                        }</span>
                        <span class="cov0" title="0">log.Printf("读取命令包失败: %v", err)
                        protocol.SendError(conn, err)
                        return fmt.Errorf("读取命令包失败: %w", err)</span>
                }

                // 打印封包信息用于调试
                <span class="cov0" title="0">log.Printf("收到命令包: 长度=%d, SequenceID=%d", packet.PayloadLength, packet.SequenceID)

                // 更新会话序列号
                sess.SequenceID = packet.SequenceID

                // 解析封包的类型
                packetType := packet.GetCommandType()
                commandName := protocol.GetCommandName(packetType)
                log.Printf("收到命令: %s (0x%02x)", commandName, packetType)

                // 重置会话序列号(新命令开始)
                sess.ResetSequenceID()

                var handleErr error
                switch packetType </span>{
                case protocol.COM_QUIT:<span class="cov0" title="0">
                        log.Printf("收到退出命令")
                        return nil</span>
                case protocol.COM_QUERY:<span class="cov0" title="0">
                        handleErr = s.handleQuery(ctx, conn, packet)</span>
                case protocol.COM_INIT_DB:<span class="cov0" title="0">
                        handleErr = s.handleInitDB(ctx, conn, packet)</span>
                case protocol.COM_PING:<span class="cov0" title="0">
                        handleErr = s.handlePing(ctx, conn)</span>
                case protocol.COM_STMT_PREPARE:<span class="cov0" title="0">
                        handleErr = s.handleStmtPrepare(ctx, conn, packet)</span>
                case protocol.COM_STMT_EXECUTE:<span class="cov0" title="0">
                        handleErr = s.handleStmtExecute(ctx, conn, packet)</span>
                case protocol.COM_STMT_CLOSE:<span class="cov0" title="0">
                        handleErr = s.handleStmtClose(ctx, conn, packet)</span>
                case protocol.COM_FIELD_LIST:<span class="cov0" title="0">
                        handleErr = s.handleFieldList(ctx, conn, packet)</span>
                case protocol.COM_SET_OPTION:<span class="cov0" title="0">
                        handleErr = s.handleSetOption(ctx, conn, packet)</span>
                case protocol.COM_REFRESH:<span class="cov0" title="0">
                        handleErr = s.handleRefresh(ctx, conn, packet)</span>
                case protocol.COM_STATISTICS:<span class="cov0" title="0">
                        handleErr = s.handleStatistics(ctx, conn)</span>
                case protocol.COM_PROCESS_INFO:<span class="cov0" title="0">
                        handleErr = s.handleProcessInfo(ctx, conn)</span>
                case protocol.COM_PROCESS_KILL:<span class="cov0" title="0">
                        handleErr = s.handleProcessKill(ctx, conn, packet)</span>
                case protocol.COM_DEBUG:<span class="cov0" title="0">
                        handleErr = s.handleDebug(ctx, conn)</span>
                case protocol.COM_SHUTDOWN:<span class="cov0" title="0">
                        handleErr = s.handleShutdown(ctx, conn)</span>
                default:<span class="cov0" title="0">
                        log.Printf("不支持的命令类型: %s (0x%02x)", commandName, packetType)
                        protocol.SendError(conn, fmt.Errorf("不支持的命令类型: %d", packetType))</span>
                }

                <span class="cov0" title="0">if handleErr != nil </span><span class="cov0" title="0">{
                        log.Printf("处理命令 %s 失败: %v", commandName, handleErr)
                        return handleErr
                }</span>
        }
}

// parseRemoteAddr 解析远程地址
func parseRemoteAddr(addr string) (string, string) <span class="cov0" title="0">{
        parts := strings.Split(addr, ":")
        if len(parts) == 2 </span><span class="cov0" title="0">{
                return parts[0], parts[1]
        }</span>
        <span class="cov0" title="0">return addr, ""</span>
}

func (s *Server) handleQuery(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        query := string(packet.Payload[1:])
        log.Printf("处理查询: %s", query)

        sess := getSession(ctx)

        // 使用 TiDB parser 解析 SQL 语句
        stmtNode, err := s.parser.ParseOneStmtText(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("解析 SQL 失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("SQL 解析错误: %w", err))
        }</span>

        // 使用处理器链处理 SQL 语句
        <span class="cov0" title="0">result, err := s.handler.Handle(stmtNode)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("处理 SQL 失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("SQL 处理错误: %w", err))
        }</span>

        // 根据结果类型返回不同的响应
        <span class="cov0" title="0">switch r := result.(type) </span>{
        case *parser.QueryResult:<span class="cov0" title="0">
                // SELECT 查询 - 使用QueryBuilder执行
                log.Printf("SELECT 查询结果，涉及表: %v, 列: %v", r.Tables, r.Columns)
                return s.handleSelectQuery(ctx, conn, sess, query)</span>
        case *parser.DMLResult:<span class="cov0" title="0">
                // INSERT/UPDATE/DELETE - 使用QueryBuilder执行
                log.Printf("DML 操作，类型: %s, 涉及表: %v", r.Type, r.Tables)
                return s.handleDMLQuery(ctx, conn, sess, query, r.Type)</span>
        case *parser.DDLResult:<span class="cov0" title="0">
                // CREATE/DROP/ALTER - 使用QueryBuilder执行
                log.Printf("DDL 操作，类型: %s, 涉及表: %v", r.Type, r.Tables)
                return s.handleDDLQuery(ctx, conn, sess, query, r.Type)</span>
        case *parser.SetResult:<span class="cov0" title="0">
                // SET 命令
                log.Printf("设置变量完成: %d 个变量", r.Count)
                // 保存变量到 session
                for name, value := range r.Vars </span><span class="cov0" title="0">{
                        sess.SetVariable(name, value)
                }</span>
                <span class="cov0" title="0">return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
        case *parser.ShowResult:<span class="cov0" title="0">
                // SHOW 命令
                if r.ShowTp == "SHOW_VARIABLES" </span><span class="cov0" title="0">{
                        return s.sendVariablesResultSet(ctx, conn, sess)
                }</span>
                <span class="cov0" title="0">log.Printf("SHOW 命令完成: %s", r.ShowTp)
                return s.sendResultSet(ctx, conn, sess)</span>
        case *parser.UseResult:<span class="cov0" title="0">
                // USE 命令
                sess.Set("current_database", r.Database)
                log.Printf("切换到数据库: %s", r.Database)
                return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
        case *parser.DefaultResult:<span class="cov0" title="0">
                // 默认处理
                log.Printf("默认处理完成: %s", r.Type)
                return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
        default:<span class="cov0" title="0">
                // 未知结果
                log.Printf("未知结果类型: %T", result)
                return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
        }
}

func (s *Server) handleInitDB(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        dbName := string(packet.Payload[1:])
        sess := getSession(ctx)

        log.Printf("切换数据库: %s", dbName)
        sess.Set("current_database", dbName)

        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

func (s *Server) handlePing(ctx context.Context, conn net.Conn) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 PING")
        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// handleStmtPrepare 处理 COM_STMT_PREPARE 命令
func (s *Server) handleStmtPrepare(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)

        // 解析 COM_STMT_PREPARE 包
        stmtPreparePacket := &amp;protocol.ComStmtPreparePacket{}
        if err := stmtPreparePacket.Unmarshal(bytes.NewReader(packet.RawBytes())); err != nil </span><span class="cov0" title="0">{
                log.Printf("解析 COM_STMT_PREPARE 包失败: %v", err)
                protocol.SendError(conn, err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("处理 COM_STMT_PREPARE: query='%s'", stmtPreparePacket.Query)

        // 生成语句ID
        stmtID := sess.ThreadID // 简化：使用thread ID

        // 分析SQL语句，提取参数和列信息
        paramCount := countParams(stmtPreparePacket.Query)
        columnCount := analyzeColumns(stmtPreparePacket.Query)

        // 创建 Prepare 响应包
        response := &amp;protocol.StmtPrepareResponsePacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                StatementID:  stmtID,
                ColumnCount:  columnCount,
                ParamCount:   paramCount,
                Reserved:     0,
                WarningCount: 0,
                Params:       make([]protocol.FieldMeta, paramCount),
                Columns:      make([]protocol.FieldMeta, columnCount),
        }

        // 填充参数元数据
        for i := uint16(0); i &lt; paramCount; i++ </span><span class="cov0" title="0">{
                response.Params[i] = protocol.FieldMeta{
                        Catalog:                   "def",
                        Schema:                    "",
                        Table:                     "",
                        OrgTable:                  "",
                        Name:                      "?",
                        OrgName:                   "",
                        LengthOfFixedLengthFields: 12,
                        CharacterSet:              33,
                        ColumnLength:              255,
                        Type:                      protocol.MYSQL_TYPE_VAR_STRING,
                        Flags:                     0,
                        Decimals:                  0,
                        Reserved:                  "\x00\x00",
                }
        }</span>

        // 填充列元数据
        <span class="cov0" title="0">columnNames := getColumns(stmtPreparePacket.Query)
        for i := uint16(0); i &lt; columnCount &amp;&amp; i &lt; uint16(len(columnNames)); i++ </span><span class="cov0" title="0">{
                response.Columns[i] = protocol.FieldMeta{
                        Catalog:                   "def",
                        Schema:                    "test",
                        Table:                     "table",
                        OrgTable:                  "table",
                        Name:                      columnNames[i],
                        OrgName:                   columnNames[i],
                        LengthOfFixedLengthFields: 12,
                        CharacterSet:              33,
                        ColumnLength:              255,
                        Type:                      protocol.MYSQL_TYPE_VAR_STRING,
                        Flags:                     protocol.NOT_NULL_FLAG,
                        Decimals:                  0,
                        Reserved:                  "\x00\x00",
                }
        }</span>

        // 发送响应
        <span class="cov0" title="0">data, err := response.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("序列化 COM_STMT_PREPARE 响应失败: %v", err)
                protocol.SendError(conn, err)
                return err
        }</span>

        <span class="cov0" title="0">if _, err := conn.Write(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("发送 COM_STMT_PREPARE 响应失败: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("已发送 COM_STMT_PREPARE 响应: statement_id=%d, params=%d, columns=%d",
                response.StatementID, response.ParamCount, response.ColumnCount)

        // 保存预处理语句到会话
        sess.Set(fmt.Sprintf("stmt_%d", stmtID), stmtPreparePacket.Query)

        return nil</span>
}

// handleStmtExecute 处理 COM_STMT_EXECUTE 命令
func (s *Server) handleStmtExecute(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)

        // 解析 COM_STMT_EXECUTE 包
        stmtExecutePacket := &amp;protocol.ComStmtExecutePacket{}
        if err := stmtExecutePacket.Unmarshal(bytes.NewReader(packet.RawBytes())); err != nil </span><span class="cov0" title="0">{
                log.Printf("解析 COM_STMT_EXECUTE 包失败: %v", err)
                protocol.SendError(conn, err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("处理 COM_STMT_EXECUTE: statement_id=%d, params=%v",
                stmtExecutePacket.StatementID, stmtExecutePacket.ParamValues)

        // 获取预处理语句的查询
        queryKey := fmt.Sprintf("stmt_%d", stmtExecutePacket.StatementID)
        query, _ := sess.Get(queryKey)
        if query == nil </span><span class="cov0" title="0">{
                log.Printf("预处理语句不存在: statement_id=%d", stmtExecutePacket.StatementID)
                protocol.SendError(conn, fmt.Errorf("预处理语句不存在"))
                return fmt.Errorf("预处理语句不存在")
        }</span>

        // 分析列
        <span class="cov0" title="0">columnCount := analyzeColumns(query.(string))

        // 发送列数包
        columnCountData := []byte{
                0x01, 0x00, 0x00, // 列数 = 1
                sess.GetNextSequenceID(),
        }
        if _, err := conn.Write(columnCountData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送列元数据包
        <span class="cov0" title="0">columnNames := getColumns(query.(string))
        for i := 0; i &lt; int(columnCount) &amp;&amp; i &lt; len(columnNames); i++ </span><span class="cov0" title="0">{
                fieldMeta := protocol.FieldMetaPacket{
                        Packet: protocol.Packet{
                                SequenceID: sess.GetNextSequenceID(),
                        },
                        FieldMeta: protocol.FieldMeta{
                                Catalog:                   "def",
                                Schema:                    "test",
                                Table:                     "table",
                                OrgTable:                  "table",
                                Name:                      columnNames[i],
                                OrgName:                   columnNames[i],
                                LengthOfFixedLengthFields: 12,
                                CharacterSet:              33,
                                ColumnLength:              255,
                                Type:                      protocol.MYSQL_TYPE_VAR_STRING,
                                Flags:                     protocol.NOT_NULL_FLAG,
                                Decimals:                  0,
                                Reserved:                  "\x00\x00",
                        },
                }
                fieldMetaData, err := fieldMeta.MarshalDefault()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("序列化列元数据失败: %v", err)
                        protocol.SendError(conn, err)
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := conn.Write(fieldMetaData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 发送列结束包
        <span class="cov0" title="0">eofPacket := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        eofData, err := eofPacket.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(eofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送数据行（简化：发送一行示例数据）
        <span class="cov0" title="0">rowData := protocol.RowDataPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                RowData: []string{"1"},
        }
        rowDataBytes, err := rowData.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(rowDataBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送结束包
        <span class="cov0" title="0">finalEof := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        finalEofData, err := finalEof.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(finalEofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("已发送 COM_STMT_EXECUTE 响应: statement_id=%d", stmtExecutePacket.StatementID)
        return nil</span>
}

// handleStmtClose 处理 COM_STMT_CLOSE 命令
func (s *Server) handleStmtClose(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)

        // 解析 COM_STMT_CLOSE 包
        stmtClosePacket := &amp;protocol.ComStmtClosePacket{}
        if err := stmtClosePacket.Unmarshal(bytes.NewReader(packet.RawBytes())); err != nil </span><span class="cov0" title="0">{
                log.Printf("解析 COM_STMT_CLOSE 包失败: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("处理 COM_STMT_CLOSE: statement_id=%d", stmtClosePacket.StatementID)

        // 释放预处理语句资源
        queryKey := fmt.Sprintf("stmt_%d", stmtClosePacket.StatementID)
        sess.Delete(queryKey)

        // COM_STMT_CLOSE 不需要发送响应
        log.Printf("已关闭预处理语句: statement_id=%d", stmtClosePacket.StatementID)
        return nil</span>
}

// handleFieldList 处理 COM_FIELD_LIST 命令
func (s *Server) handleFieldList(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_FIELD_LIST")

        // 发送结束包
        eofPacket := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        eofData, err := eofPacket.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = conn.Write(eofData)
        return err</span>
}

// handleSetOption 处理 COM_SET_OPTION 命令
func (s *Server) handleSetOption(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_SET_OPTION")

        // 返回OK包
        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// handleRefresh 处理 COM_REFRESH 命令
func (s *Server) handleRefresh(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_REFRESH")

        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// handleStatistics 处理 COM_STATISTICS 命令
func (s *Server) handleStatistics(ctx context.Context, conn net.Conn) error <span class="cov0" title="0">{
        log.Printf("处理 COM_STATISTICS")

        stats := "Uptime: 3600  Threads: 1  Questions: 10  Slow queries: 0  Opens: 5  Flush tables: 1  Open tables: 4  Queries per second avg: 0.003"

        // 发送统计信息
        if _, err := conn.Write([]byte(stats)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleProcessInfo 处理 COM_PROCESS_INFO 命令
func (s *Server) handleProcessInfo(ctx context.Context, conn net.Conn) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_PROCESS_INFO")

        // 返回空结果集
        return s.sendResultSet(ctx, conn, sess)
}</span>

// handleProcessKill 处理 COM_PROCESS_KILL 命令
func (s *Server) handleProcessKill(ctx context.Context, conn net.Conn, packet *protocol.Packet) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_PROCESS_KILL")

        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// handleDebug 处理 COM_DEBUG 命令
func (s *Server) handleDebug(ctx context.Context, conn net.Conn) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_DEBUG")

        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// handleShutdown 处理 COM_SHUTDOWN 命令
func (s *Server) handleShutdown(ctx context.Context, conn net.Conn) error <span class="cov0" title="0">{
        sess := getSession(ctx)
        log.Printf("处理 COM_SHUTDOWN")

        return protocol.SendOK(conn, sess.GetNextSequenceID())
}</span>

// sendResultSet 发送结果集
func (s *Server) sendResultSet(ctx context.Context, conn net.Conn, sess *session.Session) error <span class="cov0" title="0">{
        // 发送列数
        columnCountPacket := &amp;protocol.ColumnCountPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                ColumnCount: 1,
        }
        columnCountData, err := columnCountPacket.MarshalDefault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(columnCountData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送列定义
        <span class="cov0" title="0">fieldMeta := protocol.FieldMetaPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                FieldMeta: protocol.FieldMeta{
                        Catalog:                   "def",
                        Schema:                    "test",
                        Table:                     "test_table",
                        OrgTable:                  "test_table",
                        Name:                      "id",
                        OrgName:                   "id",
                        LengthOfFixedLengthFields: 12,
                        CharacterSet:              33,
                        ColumnLength:              11,
                        Type:                      protocol.MYSQL_TYPE_LONG,
                        Flags:                     protocol.NOT_NULL_FLAG | protocol.PRI_KEY_FLAG,
                        Decimals:                  0,
                        Reserved:                  "\x00\x00",
                },
        }
        fieldMetaData, err := fieldMeta.MarshalDefault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(fieldMetaData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送列结束包
        <span class="cov0" title="0">eofPacket := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        eofData, err := eofPacket.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(eofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送数据行
        <span class="cov0" title="0">rowData := protocol.RowDataPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                RowData: []string{"1"},
        }
        rowDataBytes, err := rowData.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(rowDataBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送结果集结束包
        <span class="cov0" title="0">finalEof := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        finalEofData, err := finalEof.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(finalEofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendVariablesResultSet 发送 SHOW VARIABLES 结果集
func (s *Server) sendVariablesResultSet(ctx context.Context, conn net.Conn, sess *session.Session) error <span class="cov0" title="0">{
        log.Printf("发送 SHOW VARIABLES 结果集")

        // 获取所有会话变量
        userVariables, err := sess.GetAllVariables()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("获取会话变量失败: %v", err)
        }</span>

        // 默认的系统变量
        <span class="cov0" title="0">variables := map[string]string{
                "version":            "8.0.0",
                "version_comment":    "MySQL Proxy",
                "port":               "3306",
                "socket":             "/tmp/mysql.sock",
                "datadir":            "/var/lib/mysql/",
                "basedir":            "/usr/",
                "tmpdir":             "/tmp",
                "slave_skip_errors":  "OFF",
                "autocommit":         "ON",
                "max_allowed_packet": "67108864",
        }

        // 合并用户设置的变量
        for name, value := range userVariables </span><span class="cov0" title="0">{
                variables[name] = fmt.Sprintf("%v", value)
        }</span>

        // 发送列数（两列：Variable_name, Value）
        <span class="cov0" title="0">columnCountPacket := &amp;protocol.ColumnCountPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                ColumnCount: 2,
        }
        columnCountData, err := columnCountPacket.MarshalDefault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(columnCountData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送列定义
        <span class="cov0" title="0">columns := []struct {
                name string
                meta protocol.FieldMeta
        }{
                {
                        name: "Variable_name",
                        meta: protocol.FieldMeta{
                                Catalog:                   "def",
                                Schema:                    "information_schema",
                                Table:                     "SESSION_VARIABLES",
                                OrgTable:                  "SESSION_VARIABLES",
                                Name:                      "VARIABLE_NAME",
                                OrgName:                   "VARIABLE_NAME",
                                LengthOfFixedLengthFields: 12,
                                CharacterSet:              33,
                                ColumnLength:              64,
                                Type:                      protocol.MYSQL_TYPE_VAR_STRING,
                                Flags:                     protocol.NOT_NULL_FLAG,
                                Decimals:                  0,
                                Reserved:                  "\x00\x00",
                        },
                },
                {
                        name: "Value",
                        meta: protocol.FieldMeta{
                                Catalog:                   "def",
                                Schema:                    "information_schema",
                                Table:                     "SESSION_VARIABLES",
                                OrgTable:                  "SESSION_VARIABLES",
                                Name:                      "VARIABLE_VALUE",
                                OrgName:                   "VARIABLE_VALUE",
                                LengthOfFixedLengthFields: 12,
                                CharacterSet:              33,
                                ColumnLength:              1024,
                                Type:                      protocol.MYSQL_TYPE_VAR_STRING,
                                Flags:                     0,
                                Decimals:                  0,
                                Reserved:                  "\x00\x00",
                        },
                },
        }

        for _, col := range columns </span><span class="cov0" title="0">{
                fieldMeta := protocol.FieldMetaPacket{
                        Packet: protocol.Packet{
                                SequenceID: sess.GetNextSequenceID(),
                        },
                        FieldMeta: col.meta,
                }
                fieldMetaData, err := fieldMeta.MarshalDefault()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := conn.Write(fieldMetaData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 发送列结束包
        <span class="cov0" title="0">eofPacket := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        eofData, err := eofPacket.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(eofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送数据行
        <span class="cov0" title="0">for name, value := range variables </span><span class="cov0" title="0">{
                rowData := protocol.RowDataPacket{
                        Packet: protocol.Packet{
                                SequenceID: sess.GetNextSequenceID(),
                        },
                        RowData: []string{name, value},
                }
                rowDataBytes, err := rowData.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := conn.Write(rowDataBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 发送结果集结束包
        <span class="cov0" title="0">finalEof := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        finalEofData, err := finalEof.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(finalEofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleSelectQuery 处理SELECT查询 - 使用OptimizedExecutor执行查询
func (s *Server) handleSelectQuery(ctx context.Context, conn net.Conn, sess *session.Session, query string) error <span class="cov0" title="0">{
        // 开始监控查询
        startTime := time.Now()
        s.metricsCollector.StartQuery()
        defer s.metricsCollector.EndQuery()

        // 检查缓存（使用查询缓存）
        queryCache := s.cacheManager.GetQueryCache()
        if cachedResult, found := queryCache.Get(query); found </span><span class="cov0" title="0">{
                log.Printf("查询命中缓存: %s", query)
                result := cachedResult.(*domain.QueryResult)

                // 记录缓存命中
                s.metricsCollector.RecordQuery(time.Since(startTime), true, "")
                return s.sendQueryResult(ctx, conn, sess, result)
        }</span>

        // 获取数据源
        <span class="cov0" title="0">ds := s.GetDataSource()
        if ds == nil </span><span class="cov0" title="0">{
                log.Printf("未设置数据源，返回默认结果")
                return s.sendResultSet(ctx, conn, sess)
        }</span>

        // 解析SQL
        <span class="cov0" title="0">adapter := parser.NewSQLAdapter()
        parseResult, err := adapter.Parse(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %v", err)
                s.metricsCollector.RecordError("SQL_PARSE_ERROR")
                return protocol.SendError(conn, fmt.Errorf("SQL解析错误: %w", err))
        }</span>

        <span class="cov0" title="0">if !parseResult.Success </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %s", parseResult.Error)
                s.metricsCollector.RecordError("SQL_PARSE_ERROR")
                return protocol.SendError(conn, fmt.Errorf("SQL解析失败: %s", parseResult.Error))
        }</span>

        <span class="cov0" title="0">var result *domain.QueryResult

        // 如果启用了优化器，使用 OptimizedExecutor
        if s.useOptimizer </span><span class="cov0" title="0">{
                s.mu.Lock()
                if s.optimizedExecutor == nil </span><span class="cov0" title="0">{
                        s.optimizedExecutor = optimizer.NewOptimizedExecutor(ds, true)
                }</span>
                <span class="cov0" title="0">executor := s.optimizedExecutor
                s.mu.Unlock()

                // 使用goroutine池执行查询
                errCh := make(chan error, 1)
                resultCh := make(chan *domain.QueryResult, 1)

                err = s.goroutinePool.Submit(func() </span><span class="cov0" title="0">{
                        r, e := executor.ExecuteSelect(ctx, parseResult.Statement.Select)
                        resultCh &lt;- r
                        errCh &lt;- e
                }</span>)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Printf("提交查询任务失败: %v", err)
                        s.metricsCollector.RecordError("POOL_SUBMIT_ERROR")
                        // 降级到传统路径
                        builder := parser.NewQueryBuilder(ds)
                        result, err = builder.BuildAndExecute(ctx, query)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("执行查询失败: %v", err)
                                s.metricsCollector.RecordError("QUERY_EXECUTION_ERROR")
                                return protocol.SendError(conn, fmt.Errorf("查询执行错误: %w", err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 等待查询完成
                        result = &lt;-resultCh
                        err = &lt;-errCh
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("优化执行查询失败: %v", err)
                                s.metricsCollector.RecordError("OPTIMIZER_ERROR")
                                // 降级到传统路径
                                builder := parser.NewQueryBuilder(ds)
                                result, err = builder.BuildAndExecute(ctx, query)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("执行查询失败: %v", err)
                                        s.metricsCollector.RecordError("QUERY_EXECUTION_ERROR")
                                        return protocol.SendError(conn, fmt.Errorf("查询执行错误: %w", err))
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // 使用传统的 QueryBuilder 路径
                builder := parser.NewQueryBuilder(ds)
                result, err = builder.BuildAndExecute(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("执行查询失败: %v", err)
                        s.metricsCollector.RecordError("QUERY_EXECUTION_ERROR")
                        return protocol.SendError(conn, fmt.Errorf("查询执行错误: %w", err))
                }</span>
        }

        // 缓存查询结果（仅缓存成功的结果）
        <span class="cov0" title="0">if result != nil &amp;&amp; len(result.Rows) &gt; 0 </span><span class="cov0" title="0">{
                queryCache.Set(query, result, 5*time.Minute) // 缓存5分钟
        }</span>

        // 记录成功查询
        <span class="cov0" title="0">s.metricsCollector.RecordQuery(time.Since(startTime), true, "")

        // 发送查询结果
        return s.sendQueryResult(ctx, conn, sess, result)</span>
}

// handleDMLQuery 处理DML查询 - 使用OptimizedExecutor执行
func (s *Server) handleDMLQuery(ctx context.Context, conn net.Conn, sess *session.Session, query string, stmtType string) error <span class="cov0" title="0">{
        // 获取数据源
        ds := s.GetDataSource()
        if ds == nil </span><span class="cov0" title="0">{
                log.Printf("未设置数据源，返回OK")
                return protocol.SendOK(conn, sess.GetNextSequenceID())
        }</span>

        // 解析SQL
        <span class="cov0" title="0">adapter := parser.NewSQLAdapter()
        parseResult, err := adapter.Parse(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("SQL解析错误: %w", err))
        }</span>

        <span class="cov0" title="0">if !parseResult.Success </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %s", parseResult.Error)
                return protocol.SendError(conn, fmt.Errorf("SQL解析失败: %s", parseResult.Error))
        }</span>

        // 使用 OptimizedExecutor 执行 DML 操作
        <span class="cov0" title="0">s.mu.Lock()
        if s.optimizedExecutor == nil </span><span class="cov0" title="0">{
                s.optimizedExecutor = optimizer.NewOptimizedExecutor(ds, false)
        }</span>
        <span class="cov0" title="0">executor := s.optimizedExecutor
        s.mu.Unlock()

        var dmlResult *domain.QueryResult
        switch parseResult.Statement.Type </span>{
        case parser.SQLTypeInsert:<span class="cov0" title="0">
                dmlResult, err = executor.ExecuteInsert(ctx, parseResult.Statement.Insert)</span>
        case parser.SQLTypeUpdate:<span class="cov0" title="0">
                dmlResult, err = executor.ExecuteUpdate(ctx, parseResult.Statement.Update)</span>
        case parser.SQLTypeDelete:<span class="cov0" title="0">
                dmlResult, err = executor.ExecuteDelete(ctx, parseResult.Statement.Delete)</span>
        default:<span class="cov0" title="0">
                // 降级到传统路径
                builder := parser.NewQueryBuilder(ds)
                dmlResult, err = builder.BuildAndExecute(ctx, query)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("执行DML操作失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("DML执行错误: %w", err))
        }</span>

        <span class="cov0" title="0">log.Printf("%s 操作完成，影响行数: %d", stmtType, dmlResult.Total)
        return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
}

// handleDDLQuery 处理DDL查询 - 使用OptimizedExecutor执行
func (s *Server) handleDDLQuery(ctx context.Context, conn net.Conn, sess *session.Session, query string, stmtType string) error <span class="cov0" title="0">{
        // 获取数据源
        ds := s.GetDataSource()
        if ds == nil </span><span class="cov0" title="0">{
                log.Printf("未设置数据源，返回OK")
                return protocol.SendOK(conn, sess.GetNextSequenceID())
        }</span>

        // 解析SQL
        <span class="cov0" title="0">adapter := parser.NewSQLAdapter()
        parseResult, err := adapter.Parse(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("SQL解析错误: %w", err))
        }</span>

        <span class="cov0" title="0">if !parseResult.Success </span><span class="cov0" title="0">{
                log.Printf("解析SQL失败: %s", parseResult.Error)
                return protocol.SendError(conn, fmt.Errorf("SQL解析失败: %s", parseResult.Error))
        }</span>

        // 使用 OptimizedExecutor 执行 DDL 操作
        <span class="cov0" title="0">s.mu.Lock()
        if s.optimizedExecutor == nil </span><span class="cov0" title="0">{
                s.optimizedExecutor = optimizer.NewOptimizedExecutor(ds, false)
        }</span>
        <span class="cov0" title="0">executor := s.optimizedExecutor
        s.mu.Unlock()

        switch parseResult.Statement.Type </span>{
        case parser.SQLTypeCreate:<span class="cov0" title="0">
                _, err = executor.ExecuteCreate(ctx, parseResult.Statement.Create)</span>
        case parser.SQLTypeDrop:<span class="cov0" title="0">
                _, err = executor.ExecuteDrop(ctx, parseResult.Statement.Drop)</span>
        case parser.SQLTypeAlter:<span class="cov0" title="0">
                _, err = executor.ExecuteAlter(ctx, parseResult.Statement.Alter)</span>
        default:<span class="cov0" title="0">
                // 降级到传统路径
                builder := parser.NewQueryBuilder(ds)
                _, err = builder.BuildAndExecute(ctx, query)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("执行DDL操作失败: %v", err)
                return protocol.SendError(conn, fmt.Errorf("DDL执行错误: %w", err))
        }</span>

        <span class="cov0" title="0">log.Printf("%s 操作完成", stmtType)
        return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
}

// sendQueryResult 发送查询结果集
func (s *Server) sendQueryResult(ctx context.Context, conn net.Conn, sess *session.Session, result *domain.QueryResult) error <span class="cov0" title="0">{
        var err error

        // 发送列数
        columnCountPacket := &amp;protocol.ColumnCountPacket{
                Packet: protocol.Packet{
                        SequenceID: sess.GetNextSequenceID(),
                },
                ColumnCount: uint64(len(result.Columns)),
        }
        columnCountData, err := columnCountPacket.MarshalDefault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(columnCountData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送列定义
        <span class="cov0" title="0">for _, col := range result.Columns </span><span class="cov0" title="0">{
                fieldMeta := protocol.FieldMetaPacket{
                        Packet: protocol.Packet{
                                SequenceID: sess.GetNextSequenceID(),
                        },
                        FieldMeta: protocol.FieldMeta{
                                Catalog:                   "def",
                                Schema:                    "",
                                Table:                     "",
                                OrgTable:                  "",
                                Name:                      col.Name,
                                OrgName:                   col.Name,
                                LengthOfFixedLengthFields: 12,
                                CharacterSet:              33,
                                ColumnLength:              255,
                                Type:                      s.getMySQLType(col.Type),
                                Flags:                     s.getColumnFlags(col),
                                Decimals:                  0,
                                Reserved:                  "\x00\x00",
                        },
                }
                fieldMetaData, err := fieldMeta.MarshalDefault()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := conn.Write(fieldMetaData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 发送列结束包
        <span class="cov0" title="0">eofPacket := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        eofData, err := eofPacket.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(eofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 发送数据行
        <span class="cov0" title="0">for _, row := range result.Rows </span><span class="cov0" title="0">{
                rowData := protocol.RowDataPacket{
                        Packet: protocol.Packet{
                                SequenceID: sess.GetNextSequenceID(),
                        },
                        RowData: make([]string, len(result.Columns)),
                }

                for i, col := range result.Columns </span><span class="cov0" title="0">{
                        val := row[col.Name]
                        rowData.RowData[i] = s.formatValue(val)
                }</span>

                <span class="cov0" title="0">rowDataBytes, err := rowData.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := conn.Write(rowDataBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 发送结果集结束包
        <span class="cov0" title="0">finalEof := protocol.CreateEofPacketWithStatus(sess.GetNextSequenceID(), true, false)
        finalEofData, err := finalEof.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(finalEofData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getMySQLType 获取MySQL类型
func (s *Server) getMySQLType(typeStr string) byte <span class="cov0" title="0">{
        typeStr = strings.ToLower(typeStr)
        switch </span>{
        case typeStr == "int", typeStr == "integer":<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_LONG</span>
        case typeStr == "bigint":<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_LONGLONG</span>
        case typeStr == "float", typeStr == "double":<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_DOUBLE</span>
        case typeStr == "string", typeStr == "varchar", typeStr == "text":<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_VAR_STRING</span>
        case typeStr == "bool", typeStr == "boolean":<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_TINY</span>
        default:<span class="cov0" title="0">
                return protocol.MYSQL_TYPE_VAR_STRING</span>
        }
}

// getColumnFlags 获取列标志
func (s *Server) getColumnFlags(col domain.ColumnInfo) uint16 <span class="cov0" title="0">{
        var flags uint16
        if col.Primary </span><span class="cov0" title="0">{
                flags |= protocol.PRI_KEY_FLAG
        }</span>
        <span class="cov0" title="0">if !col.Nullable </span><span class="cov0" title="0">{
                flags |= protocol.NOT_NULL_FLAG
        }</span>
        <span class="cov0" title="0">return flags</span>
}

// formatValue 格式化值
func (s *Server) formatValue(val interface{}) string <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return "NULL"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v", val)</span>
}

// countParams 统计SQL中的参数数量
func countParams(query string) uint16 <span class="cov0" title="0">{
        count := uint16(0)
        for _, ch := range query </span><span class="cov0" title="0">{
                if ch == '?' </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// analyzeColumns 分析SQL返回的列数
func analyzeColumns(query string) uint16 <span class="cov0" title="0">{
        queryUpper := strings.ToUpper(query)

        if strings.Contains(queryUpper, "SELECT") </span><span class="cov0" title="0">{
                // 简化：假设SELECT返回1列
                return 1
        }</span>

        <span class="cov0" title="0">if strings.Contains(queryUpper, "SHOW") </span><span class="cov0" title="0">{
                return 2
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// getColumns 获取SQL返回的列名
func getColumns(query string) []string <span class="cov0" title="0">{
        queryUpper := strings.ToUpper(query)

        if strings.Contains(queryUpper, "SELECT") </span><span class="cov0" title="0">{
                return []string{"id"}
        }</span>

        <span class="cov0" title="0">if strings.Contains(queryUpper, "SHOW") </span><span class="cov0" title="0">{
                return []string{"Variable_name", "Value"}
        }</span>

        <span class="cov0" title="0">return []string{}</span>
}

// handleSetCommand 处理 SET 命令
func (s *Server) handleSetCommand(ctx context.Context, conn net.Conn, sess *session.Session, query string) error <span class="cov0" title="0">{
        log.Printf("处理 SET 命令: %s", query)

        // 去除 SET 关键词和首尾空格
        cmd := strings.TrimSpace(query[3:])

        // 处理 SET NAMES charset
        if strings.HasPrefix(strings.ToUpper(cmd), "NAMES") </span><span class="cov0" title="0">{
                charset := strings.TrimSpace(cmd[5:])
                // 去除可能的 COLLATE 子句
                if idx := strings.Index(charset, "COLLATE"); idx &gt; 0 </span><span class="cov0" title="0">{
                        charset = strings.TrimSpace(charset[:idx])
                }</span>
                <span class="cov0" title="0">if err := sess.SetVariable("names", charset); err != nil </span><span class="cov0" title="0">{
                        log.Printf("设置字符集失败: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">log.Printf("设置字符集: %s", charset)
                return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
        }

        // 处理 SET @@variable = value 或 SET @variable = value
        // 支持多个变量设置: SET var1=val1, var2=val2
        <span class="cov0" title="0">assignments := strings.Split(cmd, ",")

        for _, assign := range assignments </span><span class="cov0" title="0">{
                assign = strings.TrimSpace(assign)

                // 解析变量名和值
                var varName, varValue string

                // 查找等号位置
                eqIdx := strings.Index(assign, "=")
                if eqIdx == -1 </span><span class="cov0" title="0">{
                        // 尝试查找 := 赋值
                        eqIdx = strings.Index(assign, ":=")
                }</span>

                <span class="cov0" title="0">if eqIdx == -1 </span><span class="cov0" title="0">{
                        log.Printf("无法解析 SET 命令: %s", assign)
                        continue</span>
                }

                <span class="cov0" title="0">varName = strings.TrimSpace(assign[:eqIdx])
                varValue = strings.TrimSpace(assign[eqIdx+1:])

                // 去除值两端的引号
                if (strings.HasPrefix(varValue, "'") &amp;&amp; strings.HasSuffix(varValue, "'")) ||
                        (strings.HasPrefix(varValue, "\"") &amp;&amp; strings.HasSuffix(varValue, "\"")) </span><span class="cov0" title="0">{
                        varValue = varValue[1 : len(varValue)-1]
                }</span>

                // 处理变量名前缀
                <span class="cov0" title="0">varName = strings.TrimSpace(varName)

                // 移除 @@global. 或 @@session. 前缀
                varName = strings.TrimPrefix(varName, "@@global.")
                varName = strings.TrimPrefix(varName, "@@session.")
                varName = strings.TrimPrefix(varName, "@@local.")
                varName = strings.TrimPrefix(varName, "@@")

                // 移除 @ 前缀（用户变量）
                varName = strings.TrimPrefix(varName, "@")

                // 转换为小写（不区分大小写）
                varName = strings.ToLower(varName)

                // 保存到会话
                if err := sess.SetVariable(varName, varValue); err != nil </span><span class="cov0" title="0">{
                        log.Printf("设置变量 %s 失败: %v", varName, err)
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("设置会话变量: %s = %s", varName, varValue)</span>
        }

        <span class="cov0" title="0">return protocol.SendOK(conn, sess.GetNextSequenceID())</span>
}

// Start 启动服务器
func (s *Server) Start(ctx context.Context, listener net.Listener) error <span class="cov0" title="0">{
        log.Println("正在启动服务器...")

        // 监听连接
        log.Printf("开始监听端口: %v", listener.Addr())

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        conn, err := listener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("接受连接失败: %v", err)
                                continue</span>
                        }

                        // 使用goroutine池处理连接
                        <span class="cov0" title="0">s.goroutinePool.Submit(func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("关闭连接失败: %v", err)
                                        }</span>
                                }()

                                <span class="cov0" title="0">if err := s.HandleConn(ctx, conn); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("处理连接失败: %v", err)
                                }</span>
                        })
                }
        }()

        <span class="cov0" title="0">log.Println("服务器启动成功")
        return nil</span>
}

// Close 关闭服务器并释放资源
func (s *Server) Close() error <span class="cov0" title="0">{
        log.Println("正在关闭服务器并释放资源...")

        var errs []error

        // 关闭goroutine池
        if s.goroutinePool != nil </span><span class="cov0" title="0">{
                if err := s.goroutinePool.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("关闭goroutine池失败: %v", err)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("goroutine池已关闭")
                }</span>
        }

        // 关闭对象池
        <span class="cov0" title="0">if s.objectPool != nil </span><span class="cov0" title="0">{
                if err := s.objectPool.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("关闭对象池失败: %v", err)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("对象池已关闭")
                }</span>
        }

        // 获取监控指标快照（用于日志）
        <span class="cov0" title="0">if s.metricsCollector != nil </span><span class="cov0" title="0">{
                snapshot := s.metricsCollector.GetSnapshot()
                log.Printf("查询统计: 总计=%d, 成功=%d, 失败=%d, 成功率=%.2f%%",
                        snapshot.QueryCount,
                        snapshot.QuerySuccess,
                        snapshot.QueryError,
                        snapshot.SuccessRate,
                )
                log.Printf("性能统计: 平均耗时=%v",
                        snapshot.AvgDuration,
                )

                // 获取缓存统计
                if s.cacheManager != nil </span><span class="cov0" title="0">{
                        allCacheStats := s.cacheManager.GetStats()
                        queryCacheStats := allCacheStats["query"]
                        if queryCacheStats != nil </span><span class="cov0" title="0">{
                                log.Printf("缓存统计: 命中率=%.2f%%, 缓存大小=%d, 命中=%d, 未命中=%d",
                                        queryCacheStats.HitRate,
                                        queryCacheStats.Size,
                                        queryCacheStats.Hits,
                                        queryCacheStats.Misses,
                                )
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("关闭服务器时发生 %d 个错误", len(errs))
        }</span>

        <span class="cov0" title="0">log.Println("服务器已关闭")
        return nil</span>
}

// GetMetricsCollector 获取监控指标收集器
func (s *Server) GetMetricsCollector() *monitor.MetricsCollector <span class="cov0" title="0">{
        return s.metricsCollector
}</span>

// GetCacheManager 获取缓存管理器
func (s *Server) GetCacheManager() *monitor.CacheManager <span class="cov0" title="0">{
        return s.cacheManager
}</span>

// GetGoroutinePoolStats 获取goroutine池统计信息
func (s *Server) GetGoroutinePoolStats() pool.PoolStats <span class="cov0" title="0">{
        if s.goroutinePool == nil </span><span class="cov0" title="0">{
                return pool.PoolStats{}
        }</span>
        <span class="cov0" title="0">return s.goroutinePool.Stats()</span>
}

// GetObjectPoolStats 获取对象池统计信息
func (s *Server) GetObjectPoolStats() pool.PoolStats <span class="cov0" title="0">{
        if s.objectPool == nil </span><span class="cov0" title="0">{
                return pool.PoolStats{}
        }</span>
        <span class="cov0" title="0">return s.objectPool.Stats()</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package virtual

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// VirtualDataSource implements the DataSource interface for virtual tables
// It acts as a read-only data source that delegates queries to virtual tables
type VirtualDataSource struct {
        provider VirtualTableProvider
}

// NewVirtualDataSource creates a new VirtualDataSource with the given provider
func NewVirtualDataSource(provider VirtualTableProvider) *VirtualDataSource <span class="cov0" title="0">{
        return &amp;VirtualDataSource{
                provider: provider,
        }
}</span>

// Connect is a no-op for virtual data source (always connected)
func (v *VirtualDataSource) Connect(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Close is a no-op for virtual data source
func (v *VirtualDataSource) Close(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// IsConnected always returns true for virtual data source
func (v *VirtualDataSource) IsConnected() bool <span class="cov0" title="0">{
        return true
}</span>

// IsWritable returns false - virtual data source is read-only
func (v *VirtualDataSource) IsWritable() bool <span class="cov0" title="0">{
        return false
}</span>

// GetConfig returns a minimal data source config for virtual data source
func (v *VirtualDataSource) GetConfig() *domain.DataSourceConfig <span class="cov0" title="0">{
        return &amp;domain.DataSourceConfig{
                Type:   "virtual",
                Name:   "information_schema",
        }
}</span>

// GetTables returns all virtual table names
func (v *VirtualDataSource) GetTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        return v.provider.ListVirtualTables(), nil
}</span>

// GetTableInfo returns the schema information for a virtual table
func (v *VirtualDataSource) GetTableInfo(ctx context.Context, tableName string) (*domain.TableInfo, error) <span class="cov0" title="0">{
        vt, err := v.provider.GetVirtualTable(tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;domain.TableInfo{
                Name:    tableName,
                Schema:  "information_schema",
                Columns: vt.GetSchema(),
        }, nil</span>
}

// Query executes a query against a virtual table
func (v *VirtualDataSource) Query(ctx context.Context, tableName string, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        vt, err := v.provider.GetVirtualTable(tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Delegate query to the virtual table
        <span class="cov0" title="0">return vt.Query(ctx, options.Filters, options)</span>
}

// Insert is not supported - virtual data source is read-only
func (v *VirtualDataSource) Insert(ctx context.Context, tableName string, rows []domain.Row, options *domain.InsertOptions) (int64, error) <span class="cov0" title="0">{
        return 0, fmt.Errorf("information_schema is read-only: INSERT operation not supported")
}</span>

// Update is not supported - virtual data source is read-only
func (v *VirtualDataSource) Update(ctx context.Context, tableName string, filters []domain.Filter, updates domain.Row, options *domain.UpdateOptions) (int64, error) <span class="cov0" title="0">{
        return 0, fmt.Errorf("information_schema is read-only: UPDATE operation not supported")
}</span>

// Delete is not supported - virtual data source is read-only
func (v *VirtualDataSource) Delete(ctx context.Context, tableName string, filters []domain.Filter, options *domain.DeleteOptions) (int64, error) <span class="cov0" title="0">{
        return 0, fmt.Errorf("information_schema is read-only: DELETE operation not supported")
}</span>

// CreateTable is not supported - virtual data source is read-only
func (v *VirtualDataSource) CreateTable(ctx context.Context, tableInfo *domain.TableInfo) error <span class="cov0" title="0">{
        return fmt.Errorf("information_schema is read-only: CREATE TABLE operation not supported")
}</span>

// DropTable is not supported - virtual data source is read-only
func (v *VirtualDataSource) DropTable(ctx context.Context, tableName string) error <span class="cov0" title="0">{
        return fmt.Errorf("information_schema is read-only: DROP TABLE operation not supported")
}</span>

// TruncateTable is not supported - virtual data source is read-only
func (v *VirtualDataSource) TruncateTable(ctx context.Context, tableName string) error <span class="cov0" title="0">{
        return fmt.Errorf("information_schema is read-only: TRUNCATE operation not supported")
}</span>

// Execute is not supported - virtual data source is read-only
func (v *VirtualDataSource) Execute(ctx context.Context, sql string) (*domain.QueryResult, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("information_schema is read-only: EXECUTE operation not supported")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
