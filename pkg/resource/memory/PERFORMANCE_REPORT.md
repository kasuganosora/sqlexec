# 内存数据源性能测试报告

## 测试环境
- **CPU**: Intel(R) Core(TM) i7-7800X @ 3.50GHz
- **架构**: linux/amd64
- **测试时间**: 2026-01-25

## 测试结果汇总

### 1. 查询所有数据 (Benchmark_Query_All)

| 数据量 | 每次操作耗时 | 内存分配 | 分配次数 |
|--------|-------------|---------|---------|
| 10K    | 164.7 ns/op | 64 B/op | 1 allocs/op |
| 50K    | 103.6 ns/op | 64 B/op | 1 allocs/op |
| 100K   | 97.15 ns/op  | 64 B/op | 1 allocs/op |
| 500K   | 90.16 ns/op  | 64 B/op | 1 allocs/op |
| 1M     | 104.7 ns/op  | 64 B/op | 1 allocs/op |
| 5M     | 129.9 ns/op  | 64 B/op | 1 allocs/op |

**分析**:
- 查询所有数据性能非常稳定，基本不受数据量影响
- 内存分配极少（仅64字节），几乎无内存压力
- **结论**: 无明显性能瓶颈

### 2. 带过滤条件的查询 (Benchmark_Query_WithFilter)

| 数据量 | 每次操作耗时    | 内存分配      | 分配次数 |
|--------|----------------|---------------|---------|
| 10K    | 929.6 μs/op    | 105.7 KB/op   | 16 allocs/op |
| 50K    | 4.649 ms/op    | 572.6 KB/op   | 21 allocs/op |
| 100K   | 8.872 ms/op    | 1.302 MB/op   | 24 allocs/op |
| 500K   | 46.46 ms/op    | 7.208 MB/op   | 31 allocs/op |
| 1M     | 93.28 ms/op    | 14.43 MB/op   | 34 allocs/op |
| 5M     | 451.04 ms/op   | 70.52 MB/op   | 41 allocs/op |

**分析**:
- **主要瓶颈**: 过滤操作耗时与数据量呈线性增长
- 5M行数据需要451ms，内存分配高达70MB
- 过滤后需要创建新的结果行，导致大量内存分配
- **结论**: 存在明显性能瓶颈，需要优化过滤逻辑

### 3. 分页查询 (Benchmark_Query_WithLimit)

| 数据量 | 每次操作耗时 | 内存分配 | 分配次数 |
|--------|-------------|---------|---------|
| 10K    | 659.9 ns/op | 960 B/op | 2 allocs/op |
| 50K    | 485.0 ns/op | 960 B/op | 2 allocs/op |
| 100K   | 517.8 ns/op | 960 B/op | 2 allocs/op |
| 500K   | 662.8 ns/op | 960 B/op | 2 allocs/op |
| 1M     | 729.0 ns/op | 960 B/op | 2 allocs/op |
| 5M     | 1581 ns/op  | 960 B/op | 2 allocs/op |

**分析**:
- 性能优秀，基本不受数据量影响
- 内存分配恒定（仅960字节）
- **结论**: 无明显性能瓶颈

### 4. 更新操作 (Benchmark_Update)

| 数据量 | 每次操作耗时  | 内存分配     | 分配次数 |
|--------|--------------|--------------|---------|
| 10K    | 479.7 μs/op  | 82.06 KB/op  | 3 allocs/op |
| 50K    | 4.556 ms/op  | 401.6 KB/op  | 3 allocs/op |
| 100K   | 9.807 ms/op  | 802.96 KB/op | 3 allocs/op |
| 500K   | 49.80 ms/op  | 4.006 MB/op  | 3 allocs/op |
| 1M     | 90.61 ms/op  | 8.004 MB/op  | 3 allocs/op |
| 5M     | 458.17 ms/op | 40.00 MB/op  | 3 allocs/op |

**分析**:
- 更新操作需要拷贝整个数据集（MVCC机制）
- 5M行数据需要458ms，内存分配40MB
- **结论**: MVCC机制导致的数据拷贝是主要瓶颈

### 5. 事务提交 (Benchmark_Transaction_Commit)

| 数据量 | 每次操作耗时 | 内存分配        | 分配次数     |
|--------|-------------|-----------------|-------------|
| 10K    | 6.307 ms/op  | 3.607 MB/op     | 20013 allocs/op |
| 50K    | 28.24 ms/op  | 18.01 MB/op     | 100013 allocs/op |
| 100K   | 55.48 ms/op  | 36.01 MB/op     | 200013 allocs/op |
| 500K   | 332.45 ms/op | 180.02 MB/op    | 1000013 allocs/op |
| 1M     | 627.29 ms/op | 360.01 MB/op    | 2000014 allocs/op |
| 5M     | 4.571 s/op   | 1.800 GB/op     | 10000015 allocs/op |

**分析**:
- **严重瓶颈**: 事务提交需要深拷贝所有表数据到快照
- 5M行数据需要4.57秒，内存分配高达1.8GB
- 每行需要约360字节分配，包含整个表的深拷贝
- **结论**: 事务机制的深拷贝是最大性能瓶颈

### 6. 事务回滚 (Benchmark_BeginTx_RollbackTx)

| 数据量 | 每次操作耗时 | 内存分配        | 分配次数     |
|--------|-------------|-----------------|-------------|
| 10K    | 4.917 ms/op  | 3.525 MB/op     | 20011 allocs/op |
| 50K    | 26.05 ms/op  | 17.60 MB/op     | 100011 allocs/op |
| 100K   | 57.40 ms/op  | 35.21 MB/op     | 200011 allocs/op |
| 500K   | 285.47 ms/op | 176.01 MB/op    | 1000012 allocs/op |
| 1M     | 535.34 ms/op | 352.01 MB/op    | 2000013 allocs/op |
| 5M     | 4.378 s/op   | 1.760 GB/op     | 10000015 allocs/op |

**分析**:
- 事务开始时就深拷贝所有数据
- 回滚只是删除快照，不涉及拷贝
- **结论**: BeginTx的深拷贝是主要瓶颈

## 性能瓶颈分析

### 关键瓶颈排序（按严重程度）

1. **事务深拷贝** (最严重)
   - 影响: BeginTx, CommitTx
   - 原因: TiDB风格的完整数据拷贝
   - 影响: 5M数据需要4.5秒，1.8GB内存

2. **过滤查询** (严重)
   - 影响: Query with filters
   - 原因: 需要遍历所有行，创建新结果
   - 影响: 5M数据需要451ms，70MB内存

3. **更新操作** (中等)
   - 影响: Update
   - 原因: MVCC需要创建新版本
   - 影响: 5M数据需要458ms，40MB内存

### 根本原因

1. **TiDB风格的MVCC实现过于激进**
   - 当前实现：每次事务都拷贝所有表的所有数据
   - 问题: 即使只修改1行，也需要拷贝全部数据

2. **无索引机制**
   - 过滤查询需要全表扫描
   - 时间复杂度O(n)

3. **内存分配频繁**
   - 每次深拷贝都分配大量内存
   - 无对象池复用

## 优化建议

### 优化策略1: 写时复制 (Copy-on-Write)

**实现思路**:
- 不在BeginTx时拷贝所有数据
- 只在首次修改表时，才拷贝该表的快照
- 使用atomic指针实现COW

**预期收益**:
- 只读事务: 接近零开销
- 少量修改的事务: 性能提升90%以上

### 优化策略2: 按表粒度的快照

**实现思路**:
- BeginTx时只创建快照结构，不拷贝数据
- 访问表时，检查是否已修改
- 未修改的表直接读主版本

**预期收益**:
- 内存使用减少90%
- BeginTx速度提升95%

### 优化策略3: 行级COW (Row-level Copy-on-Write)

**实现思路**:
- 使用引用计数标记行
- 修改时只拷贝受影响的行
- 未修改的行共享原始数据

**预期收益**:
- Update操作性能提升80%
- 内存分配减少80%

### 优化策略4: 添加索引支持

**实现思路**:
- 实现B-Tree或Hash索引
- 常用过滤字段自动建索引
- 查询优先使用索引

**预期收益**:
- 等值查询性能提升99%
- 范围查询性能提升90%

### 优化策略5: 对象池 (Object Pool)

**实现思路**:
- 复用Row对象
- 减少内存分配
- 使用sync.Pool

**预期收益**:
- GC压力减少70%
- 内存分配次数减少50%

## 优化实施计划

### 第一阶段: 写时复制 (高优先级)

1. 修改Snapshot结构，使用指针引用
2. 在首次修改时才拷贝数据
3. 测试事务隔离性

**预期效果**:
- BeginTx耗时: 4.5s -> 50ms (90%↓)
- CommitTx耗时: 4.5s -> 100ms (98%↓)
- 内存分配: 1.8GB -> 18MB (99%↓)

### 第二阶段: 索引支持 (中优先级)

1. 实现基础索引结构
2. 自动为常用字段建索引
3. 查询优化器使用索引

**预期效果**:
- 过滤查询: 451ms -> 5ms (99%↓)
- 等值查询: 451ms -> 1ms (99.8%↓)

### 第三阶段: 对象池 (低优先级)

1. 引入sync.Pool复用Row
2. 减少内存分配
3. 优化GC

**预期效果**:
- 内存分配次数: 50%↓
- GC停顿时间: 70%↓

## 基准数据总结

| 场景 | 10K耗时 | 1M耗时 | 5M耗时 | 状态 |
|------|---------|--------|--------|------|
| 查询全部 | 0.16μs | 0.10μs | 0.13μs | ✅ 优秀 |
| 分页查询 | 0.66μs | 0.73μs | 1.58μs | ✅ 优秀 |
| 过滤查询 | 0.93ms | 93.3ms | 451ms | ⚠️ 需优化 |
| 更新操作 | 0.48ms | 90.6ms | 458ms | ⚠️ 需优化 |
| 事务提交 | 6.3ms | 627ms | 4.57s | 🔴 严重 |
| 事务回滚 | 4.9ms | 535ms | 4.38s | 🔴 严重 |

## 下一步行动

1. **立即实施**: 写时复制优化（第一阶段）
2. **短期计划**: 索引支持（第二阶段）
3. **长期优化**: 对象池和查询优化器

优化完成后，将重新运行基准测试对比性能提升。
