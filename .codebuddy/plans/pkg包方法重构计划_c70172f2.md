---
name: pkg包方法重构计划
overview: 将pkg子包中的重复方法下沉到pkg/utils包，消除代码重复，提高可维护性。包括类型转换函数、过滤匹配逻辑等核心工具函数的统一。
todos:
  - id: create-utils-package
    content: 创建 pkg/utils 包目录结构
    status: completed
  - id: implement-converter
    content: 实现 converter.go 类型转换函数
    status: completed
    dependencies:
      - create-utils-package
  - id: implement-filter
    content: 实现 filter.go 过滤匹配函数
    status: completed
    dependencies:
      - create-utils-package
  - id: implement-compare
    content: 实现 compare.go 比较函数
    status: completed
    dependencies:
      - create-utils-package
      - implement-converter
  - id: update-json-builtin
    content: 更新 json/builtin 包使用 utils 函数
    status: completed
    dependencies:
      - implement-converter
      - implement-filter
      - implement-compare
  - id: update-optimizer-parser
    content: 更新 optimizer/parser 包使用 utils 函数
    status: completed
    dependencies:
      - implement-converter
      - implement-filter
      - implement-compare
  - id: update-information-schema
    content: 更新 information_schema 包使用 utils 过滤函数
    status: completed
    dependencies:
      - implement-filter
  - id: run-tests
    content: 运行所有 pkg 包测试验证重构
    status: completed
    dependencies:
      - update-json-builtin
      - update-optimizer-parser
      - update-information-schema
---

## 用户需求

分析 pkg 包并重构，将各个子包中重复或相似的方法下沉到 pkg/utils 包中，消除代码重复，提高代码可维护性。

## 主要发现的重复方法

### 1. 类型转换函数（跨包重复）

- **toString**: `pkg/json/array.go` (L185) 和 `pkg/builtin/string_functions.go` (L319)
- **toInt64**: `pkg/builtin/string_functions.go` (L331) 和 `pkg/builtin/init.go` (L56)
- **toFloat64**: `pkg/builtin/math_functions.go` (L320), `pkg/builtin/init.go` (L38) 和 `pkg/optimizer/utils.go` (L11)

### 2. information_schema 包内部重复（99%相似）

- **matchesFilter**: `pkg/information_schema/tables.go` (L238) 和 `pkg/information_schema/columns.go` (L194)
- **applyFilters**: `pkg/information_schema/tables.go` (L217) 和 `pkg/information_schema/columns.go` (L173)
- **matchesLike**: `pkg/information_schema/tables.go` (L266) 和 `pkg/information_schema/columns.go` (L222)

### 3. 历史已知的重复

- **compareValues**: `pkg/optimizer/utils.go` 和 `pkg/parser/view_check_option.go`

## 技术栈

- **语言**: Go 1.x
- **项目结构**: 单体仓库，pkg 下有多个子包

## 重构策略

### 1. 类型转换函数提取

**合并后的函数设计**:

- `ToString(interface{}) string`: 支持所有基础类型（int系列、uint系列、float系列、bool、string、[]byte）
- `ToInt64(interface{}) (int64, error)`: 支持数值类型转换
- `ToFloat64(interface{}) (float64, error)`: 支持所有数值类型转换，包括字符串解析

### 2. 过滤匹配函数提取

**设计为通用函数**，不绑定到特定类型：

- `MatchesFilter(row domain.Row, filter domain.Filter) (bool, error)`
- `ApplyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error)`
- `MatchesLike(value, pattern string) bool`

### 3. 比较函数提取

保留 `CompareValues(a, b interface{}, operator string) (bool, error)` 并增强：

- 支持更多操作符类型
- 统一数值和字符串比较逻辑

## 实现步骤

### Phase 1: 创建 pkg/utils 包

1. 创建 `d:/code/db/pkg/utils/` 目录
2. 创建 `converter.go`: 类型转换函数
3. 创建 `filter.go`: 过滤匹配函数
4. 创建 `compare.go`: 比较函数
5. 创建 `utils_test.go`: 单元测试

### Phase 2: 更新调用方

6. 更新 `pkg/json/array.go`: 使用 utils.ToString
7. 更新 `pkg/builtin/string_functions.go`: 使用 utils.ToString 和 utils.ToInt64
8. 更新 `pkg/builtin/math_functions.go`: 使用 utils.ToFloat64
9. 更新 `pkg/builtin/init.go`: 移除重复的 ToFloat64/ToInt64，保留为 utils 包的导出包装
10. 更新 `pkg/optimizer/utils.go`: 移除 compareValues，使用 utils.CompareValues
11. 更新 `pkg/parser/view_check_option.go`: 移除 compareValues，使用 utils.CompareValues
12. 更新 `pkg/information_schema/tables.go`: 使用 utils 包的过滤函数
13. 更新 `pkg/information_schema/columns.go`: 使用 utils 包的过滤函数
14. 更新 `pkg/information_schema/views.go`: 如有需要，使用 utils 函数

### Phase 3: 测试验证

15. 运行所有包测试: `go test ./pkg/...`
16. 验证没有破坏现有功能
17. 确保代码编译通过

## 目录结构

```
pkg/
├── utils/                      # [NEW] 新增通用工具包
│   ├── converter.go            # [NEW] 类型转换函数
│   ├── filter.go               # [NEW] 过滤匹配函数
│   ├── compare.go              # [NEW] 比较函数
│   └── utils_test.go          # [NEW] 单元测试
├── json/                      # [MODIFY] 使用 utils.ToString
├── builtin/                   # [MODIFY] 使用 utils 包
│   ├── string_functions.go      # [MODIFY] 使用 utils.ToString/ToInt64
│   ├── math_functions.go       # [MODIFY] 使用 utils.ToFloat64
│   └── init.go              # [MODIFY] 简化为 utils 包装
├── optimizer/                 # [MODIFY] 使用 utils.CompareValues
│   └── utils.go             # [MODIFY] 移除 compareValues
├── parser/                   # [MODIFY] 使用 utils.CompareValues
│   └── view_check_option.go  # [MODIFY] 移除 compareValues
└── information_schema/         # [MODIFY] 使用 utils 包的过滤函数
    ├── tables.go             # [MODIFY] 使用 utils 函数
    └── columns.go           # [MODIFY] 使用 utils 函数
```

## 关键代码结构

### converter.go

```
package utils

import "fmt"

// ToString converts any value to string
func ToString(v interface{}) string {
	switch val := v.(type) {
	case string:
		return val
	case []byte:
		return string(val)
	case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
		return fmt.Sprintf("%d", val)
	case float32, float64:
		return fmt.Sprintf("%f", val)
	case bool:
		return fmt.Sprintf("%t", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}

// ToInt64 converts a value to int64
func ToInt64(arg interface{}) (int64, error) {
	switch v := arg.(type) {
	case int:
		return int64(v), nil
	case int8:
		return int64(v), nil
	case int16:
		return int64(v), nil
	case int32:
		return int64(v), nil
	case int64:
		return v, nil
	case uint, uint8, uint16, uint32, uint64:
		return int64(v), nil
	case float64:
		return int64(v), nil
	case float32:
		return int64(v), nil
	default:
		return 0, fmt.Errorf("cannot convert %T to int64", arg)
	}
}

// ToFloat64 converts a value to float64
func ToFloat64(arg interface{}) (float64, error) {
	switch v := arg.(type) {
	case float64:
		return v, nil
	case float32:
		return float64(v), nil
	case int, int8, int16, int32, int64:
		return float64(v), nil
	case uint, uint8, uint16, uint32, uint64:
		return float64(v), nil
	case string:
		// Try parsing string to float64
		var f float64
		_, err := fmt.Sscanf(v, "%f", &f)
		if err == nil {
			return f, nil
		}
		return 0, fmt.Errorf("cannot convert %T to float64", arg)
	default:
		return 0, fmt.Errorf("cannot convert %T to float64", arg)
	}
}
```

### filter.go

```
package utils

import (
	"fmt"
	"strings"
	
	"github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ApplyFilters applies filters to result rows
func ApplyFilters(rows []domain.Row, filters []domain.Filter) ([]domain.Row, error) {
	for _, filter := range filters {
		var filteredRows []domain.Row
		
		for _, row := range rows {
			matches, err := MatchesFilter(row, filter)
			if err != nil {
				return nil, err
			}
			if matches {
				filteredRows = append(filteredRows, row)
			}
		}
		
		rows = filteredRows
	}
	
	return rows, nil
}

// MatchesFilter checks if a row matches a filter
func MatchesFilter(row domain.Row, filter domain.Filter) (bool, error) {
	value, exists := row[filter.Field]
	if !exists {
		return false, nil
	}

	// Convert value to string for comparison
	var strValue string
	if value == nil {
		strValue = ""
	} else {
		strValue = fmt.Sprintf("%v", value)
	}

	// Apply operator
	switch filter.Operator {
	case "=":
		return strValue == fmt.Sprintf("%v", filter.Value), nil
	case "!=":
		return strValue != fmt.Sprintf("%v", filter.Value), nil
	case "like", "LIKE":
		return MatchesLike(strValue, fmt.Sprintf("%v", filter.Value)), nil
	default:
		return false, fmt.Errorf("unsupported filter operator: %s", filter.Operator)
	}
}

// MatchesLike implements simple LIKE pattern matching
func MatchesLike(value, pattern string) bool {
	// Simple implementation - can be enhanced for full LIKE support
	if pattern == "%" {
		return true
	}
	if pattern == value {
		return true
	}
	if len(pattern) > 0 && pattern[0] == '%' && len(pattern) > 1 {
		suffix := pattern[1:]
		return len(value) >= len(suffix) && value[len(value)-len(suffix):] == suffix
	}
	if len(pattern) > 0 && pattern[len(pattern)-1] == '%' && len(pattern) > 1 {
		prefix := pattern[:len(pattern)-1]
		return len(value) >= len(prefix) && value[:len(prefix)] == prefix
	}
	return false
}
```

### compare.go

```
package utils

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

// CompareValues compares two values with given operator
// Returns true if comparison matches, false otherwise
func CompareValues(a, b interface{}, operator string) (bool, error) {
	// Normalize operator
	op := strings.ToUpper(operator)
	
	// Handle nil values
	if a == nil || b == nil {
		switch op {
		case "=", "EQ":
			return a == nil && b == nil, nil
		case "!=", "NEQ":
			return !(a == nil && b == nil), nil
		default:
			return false, nil
		}
	}

	// Try numeric comparison
	aNum, aOk := ToFloat64(a)
	bNum, bOk := ToFloat64(b)
	
	if aOk && bOk {
		switch op {
		case "=", "EQ":
			return aNum == bNum, nil
		case "!=", "NEQ":
			return aNum != bNum, nil
		case ">", "GT":
			return aNum > bNum, nil
		case "<", "LT":
			return aNum < bNum, nil
		case ">=", "GE":
			return aNum >= bNum, nil
		case "<=", "LE":
			return aNum <= bNum, nil
		default:
			return false, fmt.Errorf("unsupported operator: %s", operator)
		}
	}

	// String comparison
	aStr, aOk := a.(string)
	bStr, bOk := b.(string)
	
	if aOk && bOk {
		switch op {
		case "=", "EQ":
			return aStr == bStr, nil
		case "!=", "NEQ":
			return aStr != bStr, nil
		case ">", "GT":
			return aStr > bStr, nil
		case "<", "LT":
			return aStr < bStr, nil
		case ">=", "GE":
			return aStr >= bStr, nil
		case "<=", "LE":
			return aStr <= bStr, nil
		case "LIKE":
			return MatchesLike(aStr, bStr), nil
		default:
			return false, fmt.Errorf("unsupported operator: %s", operator)
		}
	}

	return false, fmt.Errorf("cannot compare %T with %T", a, b)
}
```