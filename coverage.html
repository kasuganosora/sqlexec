
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>optimizer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kasuganosora/sqlexec/pkg/optimizer/cardinality.go (0.0%)</option>
				
				<option value="file1">github.com/kasuganosora/sqlexec/pkg/optimizer/cost/adaptive_model.go (89.5%)</option>
				
				<option value="file2">github.com/kasuganosora/sqlexec/pkg/optimizer/cost/hardware_profile.go (100.0%)</option>
				
				<option value="file3">github.com/kasuganosora/sqlexec/pkg/optimizer/enhanced_optimizer.go (47.0%)</option>
				
				<option value="file4">github.com/kasuganosora/sqlexec/pkg/optimizer/enhanced_predicate_pushdown.go (37.2%)</option>
				
				<option value="file5">github.com/kasuganosora/sqlexec/pkg/optimizer/expression_evaluator.go (16.7%)</option>
				
				<option value="file6">github.com/kasuganosora/sqlexec/pkg/optimizer/filterable_util.go (100.0%)</option>
				
				<option value="file7">github.com/kasuganosora/sqlexec/pkg/optimizer/index/selector.go (90.1%)</option>
				
				<option value="file8">github.com/kasuganosora/sqlexec/pkg/optimizer/join/bushy_tree.go (100.0%)</option>
				
				<option value="file9">github.com/kasuganosora/sqlexec/pkg/optimizer/join/dp_reorder.go (83.9%)</option>
				
				<option value="file10">github.com/kasuganosora/sqlexec/pkg/optimizer/join/graph.go (0.0%)</option>
				
				<option value="file11">github.com/kasuganosora/sqlexec/pkg/optimizer/join_elimination.go (3.6%)</option>
				
				<option value="file12">github.com/kasuganosora/sqlexec/pkg/optimizer/join_reorder.go (9.3%)</option>
				
				<option value="file13">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_aggregate.go (72.4%)</option>
				
				<option value="file14">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_datasource.go (68.8%)</option>
				
				<option value="file15">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_join.go (0.0%)</option>
				
				<option value="file16">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_limit.go (77.8%)</option>
				
				<option value="file17">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_projection.go (77.3%)</option>
				
				<option value="file18">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_scan_accessors.go (0.0%)</option>
				
				<option value="file19">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_selection.go (76.9%)</option>
				
				<option value="file20">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_sort.go (88.2%)</option>
				
				<option value="file21">github.com/kasuganosora/sqlexec/pkg/optimizer/logical_union.go (0.0%)</option>
				
				<option value="file22">github.com/kasuganosora/sqlexec/pkg/optimizer/merge_join.go (0.0%)</option>
				
				<option value="file23">github.com/kasuganosora/sqlexec/pkg/optimizer/optimized_executor.go (20.7%)</option>
				
				<option value="file24">github.com/kasuganosora/sqlexec/pkg/optimizer/optimizer.go (55.1%)</option>
				
				<option value="file25">github.com/kasuganosora/sqlexec/pkg/optimizer/or_to_union.go (23.3%)</option>
				
				<option value="file26">github.com/kasuganosora/sqlexec/pkg/optimizer/parallel/join_executor.go (36.2%)</option>
				
				<option value="file27">github.com/kasuganosora/sqlexec/pkg/optimizer/parallel/scanner.go (0.0%)</option>
				
				<option value="file28">github.com/kasuganosora/sqlexec/pkg/optimizer/parallel/worker_pool.go (11.7%)</option>
				
				<option value="file29">github.com/kasuganosora/sqlexec/pkg/optimizer/performance.go (0.0%)</option>
				
				<option value="file30">github.com/kasuganosora/sqlexec/pkg/optimizer/physical_scan.go (38.9%)</option>
				
				<option value="file31">github.com/kasuganosora/sqlexec/pkg/optimizer/physical_sort.go (0.0%)</option>
				
				<option value="file32">github.com/kasuganosora/sqlexec/pkg/optimizer/procedure_executor.go (0.0%)</option>
				
				<option value="file33">github.com/kasuganosora/sqlexec/pkg/optimizer/rules.go (58.4%)</option>
				
				<option value="file34">github.com/kasuganosora/sqlexec/pkg/optimizer/semi_join_rewrite.go (16.5%)</option>
				
				<option value="file35">github.com/kasuganosora/sqlexec/pkg/optimizer/statistics/cache.go (82.5%)</option>
				
				<option value="file36">github.com/kasuganosora/sqlexec/pkg/optimizer/statistics/collector.go (96.0%)</option>
				
				<option value="file37">github.com/kasuganosora/sqlexec/pkg/optimizer/statistics/estimator.go (79.4%)</option>
				
				<option value="file38">github.com/kasuganosora/sqlexec/pkg/optimizer/statistics/histogram.go (88.8%)</option>
				
				<option value="file39">github.com/kasuganosora/sqlexec/pkg/optimizer/statistics/utils.go (35.7%)</option>
				
				<option value="file40">github.com/kasuganosora/sqlexec/pkg/optimizer/types.go (96.6%)</option>
				
				<option value="file41">github.com/kasuganosora/sqlexec/pkg/optimizer/utils.go (40.0%)</option>
				
				<option value="file42">github.com/kasuganosora/sqlexec/pkg/optimizer/view_executor.go (0.0%)</option>
				
				<option value="file43">github.com/kasuganosora/sqlexec/pkg/optimizer/view_rewrite.go (0.0%)</option>
				
				<option value="file44">github.com/kasuganosora/sqlexec/pkg/optimizer/window_operator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package optimizer

import (
        "context"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// TableStatistics 表统计信息
type TableStatistics struct {
        Name       string
        RowCount   int64
        ColumnStats map[string]*ColumnStatistics
}

// ColumnStatistics 列统计信息
type ColumnStatistics struct {
        Name          string
        DataType       string
        DistinctCount  int64  // NDV (Number of Distinct Values)
        NullCount      int64
        MinValue       interface{}
        MaxValue       interface{}
        NullFraction   float64
        AvgWidth      float64 // 平均字符串长度
}

// CardinalityEstimator 基数估算器接口
type CardinalityEstimator interface {
        // EstimateTableScan 估算表扫描的基数
        EstimateTableScan(tableName string) int64

        // EstimateFilter 估算过滤后的基数
        EstimateFilter(table string, filters []domain.Filter) int64

        // EstimateJoin 估算JOIN的输出行数
        EstimateJoin(left, right LogicalPlan, joinType JoinType) int64

        // EstimateDistinct 估算DISTINCT后的行数
        EstimateDistinct(table string, columns []string) int64

        // UpdateStatistics 更新表的统计信息
        UpdateStatistics(tableName string, stats *TableStatistics)
}

// SimpleCardinalityEstimator 简化的基数估算器
type SimpleCardinalityEstimator struct {
        stats map[string]*TableStatistics
}

// NewSimpleCardinalityEstimator 创建简化基数估算器
func NewSimpleCardinalityEstimator() *SimpleCardinalityEstimator <span class="cov0" title="0">{
        return &amp;SimpleCardinalityEstimator{
                stats: make(map[string]*TableStatistics),
        }
}</span>

// UpdateStatistics 更新统计信息
func (e *SimpleCardinalityEstimator) UpdateStatistics(tableName string, stats *TableStatistics) <span class="cov0" title="0">{
        e.stats[tableName] = stats
}</span>

// EstimateTableScan 估算表扫描基数
func (e *SimpleCardinalityEstimator) EstimateTableScan(tableName string) int64 <span class="cov0" title="0">{
        if stats, exists := e.stats[tableName]; exists </span><span class="cov0" title="0">{
                return stats.RowCount
        }</span>
        // 默认估计：假设1000行
        <span class="cov0" title="0">return 1000</span>
}

// EstimateFilter 估算过滤后的基数
func (e *SimpleCardinalityEstimator) EstimateFilter(table string, filters []domain.Filter) int64 <span class="cov0" title="0">{
        baseRowCount := e.EstimateTableScan(table)
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return baseRowCount
        }</span>

        // 计算每个过滤器的选择率
        <span class="cov0" title="0">totalSelectivity := 1.0
        for _, filter := range filters </span><span class="cov0" title="0">{
                sel := e.estimateFilterSelectivity(table, filter)
                if filter.LogicOp == "AND" </span><span class="cov0" title="0">{
                        // AND: 选择率相乘
                        totalSelectivity *= sel
                }</span> else<span class="cov0" title="0"> if filter.LogicOp == "OR" </span><span class="cov0" title="0">{
                        // OR: 处理OR子过滤器
                        // 简化：使用平均选择率
                        orSelectivity := 0.0
                        for i := range filter.SubFilters </span><span class="cov0" title="0">{
                                orSel := e.estimateFilterSelectivity(table, filter.SubFilters[i])
                                orSelectivity += orSel
                        }</span>
                        <span class="cov0" title="0">if len(filter.SubFilters) &gt; 0 </span><span class="cov0" title="0">{
                                totalSelectivity *= (orSelectivity / float64(len(filter.SubFilters)))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 单个条件
                        totalSelectivity *= sel
                }</span>
        }

        <span class="cov0" title="0">result := float64(baseRowCount) * totalSelectivity
        // 确保至少返回1行
        if result &lt; 1 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return int64(result)</span>
}

// estimateFilterSelectivity 估算单个过滤器的选择率
func (e *SimpleCardinalityEstimator) estimateFilterSelectivity(table string, filter domain.Filter) float64 <span class="cov0" title="0">{
        // 处理逻辑组合
        if filter.LogicOp == "AND" || filter.LogicOp == "OR" </span><span class="cov0" title="0">{
                return e.estimateLogicSelectivity(table, filter)
        }</span>

        <span class="cov0" title="0">stats, exists := e.stats[table]
        if !exists </span><span class="cov0" title="0">{
                // 没有统计信息时使用默认选择率
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        <span class="cov0" title="0">colStats, colExists := stats.ColumnStats[filter.Field]
        if !colExists </span><span class="cov0" title="0">{
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=", "!=":<span class="cov0" title="0">
                // 等值查询：选择率 = 1/NDV
                if colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        return 1.0 / float64(colStats.DistinctCount)
                }</span>
                <span class="cov0" title="0">return 0.1</span>

        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov0" title="0">
                // 范围查询
                return e.estimateRangeSelectivity(filter.Operator, filter.Value, colStats)</span>

        case "IN":<span class="cov0" title="0">
                // IN操作：假设平均每IN列表有10个值
                if valList, ok := filter.Value.([]interface{}); ok &amp;&amp; len(valList) &gt; 0 </span><span class="cov0" title="0">{
                        return float64(len(valList)) / float64(colStats.DistinctCount)
                }</span>
                <span class="cov0" title="0">return 0.1</span>

        case "BETWEEN":<span class="cov0" title="0">
                // BETWEEN操作
                if vals, ok := filter.Value.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov0" title="0">{
                        return e.estimateRangeSelectivity("&gt;=", vals[0], colStats) *
                                e.estimateRangeSelectivity("&lt;=", vals[1], colStats)
                }</span>
                <span class="cov0" title="0">return 0.3</span>

        case "LIKE":<span class="cov0" title="0">
                // LIKE操作：保守估计0.1-0.5
                return 0.25</span>

        default:<span class="cov0" title="0">
                return e.getDefaultSelectivity(filter.Operator)</span>
        }
}

// estimateLogicSelectivity 估算逻辑组合的选择率
func (e *SimpleCardinalityEstimator) estimateLogicSelectivity(table string, filter domain.Filter) float64 <span class="cov0" title="0">{
        if len(filter.SubFilters) == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">switch filter.LogicOp </span>{
        case "AND":<span class="cov0" title="0">
                // AND: 选择率相乘
                sel := 1.0
                for _, subFilter := range filter.SubFilters </span><span class="cov0" title="0">{
                        sel *= e.estimateFilterSelectivity(table, subFilter)
                }</span>
                <span class="cov0" title="0">return sel</span>

        case "OR":<span class="cov0" title="0">
                // OR: 选择率 = 1 - (1-s1)*(1-s2)*...*(1-sn)
                // 简化：使用包含关系
                sel := 0.0
                for _, subFilter := range filter.SubFilters </span><span class="cov0" title="0">{
                        subSel := e.estimateFilterSelectivity(table, subFilter)
                        sel += subSel
                }</span>
                // 避免超过1.0
                <span class="cov0" title="0">if sel &gt; 0.95 </span><span class="cov0" title="0">{
                        sel = 0.95
                }</span>
                <span class="cov0" title="0">return sel</span>

        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

// estimateRangeSelectivity 估算范围查询的选择率
func (e *SimpleCardinalityEstimator) estimateRangeSelectivity(operator string, value interface{}, colStats *ColumnStatistics) float64 <span class="cov0" title="0">{
        minVal := colStats.MinValue
        maxVal := colStats.MaxValue

        if minVal == nil || maxVal == nil </span><span class="cov0" title="0">{
                return 0.1
        }</span>

        <span class="cov0" title="0">minFloat, _ := toFloat64(minVal)
        maxFloat, _ := toFloat64(maxVal)
        valFloat, _ := toFloat64(value)

        if minFloat == maxFloat </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">rangeSize := maxFloat - minFloat
        if rangeSize == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "&gt;":<span class="cov0" title="0">
                // value &gt; min: (max - value) / (max - min)
                if valFloat &lt;= minFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (maxFloat - valFloat) / rangeSize</span>

        case "&gt;=":<span class="cov0" title="0">
                // value &gt;= min: (max - value) / (max - min)
                if valFloat &lt; minFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (maxFloat - valFloat + 0.0001) / rangeSize</span>

        case "&lt;":<span class="cov0" title="0">
                // value &lt; max: (value - min) / (max - min)
                if valFloat &gt;= maxFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (valFloat - minFloat) / rangeSize</span>

        case "&lt;=":<span class="cov0" title="0">
                // value &lt;= max: (value - min) / (max - min)
                if valFloat &gt; maxFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">return (valFloat - minFloat + 0.0001) / rangeSize</span>

        default:<span class="cov0" title="0">
                return 0.5</span>
        }
}

// getDefaultSelectivity 获取默认选择率
func (e *SimpleCardinalityEstimator) getDefaultSelectivity(operator string) float64 <span class="cov0" title="0">{
        switch operator </span>{
        case "=", "!=":<span class="cov0" title="0">
                return 0.1</span> // 等值查询：10%
        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov0" title="0">
                return 0.3</span> // 范围查询：30%
        case "IN":<span class="cov0" title="0">
                return 0.2</span> // IN查询：20%
        case "BETWEEN":<span class="cov0" title="0">
                return 0.3</span> // BETWEEN查询：30%
        case "LIKE":<span class="cov0" title="0">
                return 0.25</span> // LIKE查询：25%
        default:<span class="cov0" title="0">
                return 0.5</span> // 默认：50%
        }
}

// EstimateJoin 估算JOIN的基数
func (e *SimpleCardinalityEstimator) EstimateJoin(left, right LogicalPlan, joinType JoinType) int64 <span class="cov0" title="0">{
        // 获取左右表的基数
        leftCount := e.estimateRowCount(left)
        rightCount := e.estimateRowCount(right)

        if leftCount == 0 || rightCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 根据JOIN类型估算
        <span class="cov0" title="0">switch joinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN: 假设每个左表行匹配右表的1/N个行
                // 简化估计: min(left, right)
                return min(leftCount, rightCount)</span>

        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN: 输出 = 左表行数
                return leftCount</span>

        case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN: 输出 = 右表行数
                return rightCount</span>

        case FullOuterJoin:<span class="cov0" title="0">
                // FULL JOIN: 输出 ≈ left + right - matches
                return leftCount + rightCount/2</span>

        default:<span class="cov0" title="0">
                return min(leftCount, rightCount)</span>
        }
}

// estimateRowCount 估算逻辑计划的行数
func (e *SimpleCardinalityEstimator) estimateRowCount(plan LogicalPlan) int64 <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return e.EstimateTableScan(dataSource.TableName)
        }</span>

        <span class="cov0" title="0">if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                if len(selection.children) &gt; 0 </span><span class="cov0" title="0">{
                        tableName := getTableName(selection.children[0])
                        conditions := selection.Conditions()
                        // 转换表达式到过滤器
                        filters := make([]domain.Filter, len(conditions))
                        for i, cond := range conditions </span><span class="cov0" title="0">{
                                filters[i] = domain.Filter{
                                        Field:    expressionToString(cond),
                                        Operator:  "=",
                                        Value:     cond.Value,
                                }
                        }</span>
                        <span class="cov0" title="0">return e.EstimateFilter(tableName, filters)</span>
                }
        }

        // 其他算子：返回子节点的行数
        <span class="cov0" title="0">children := plan.Children()
        if len(children) &gt; 0 </span><span class="cov0" title="0">{
                return e.estimateRowCount(children[0])
        }</span>

        <span class="cov0" title="0">return 1000</span> // 默认值
}

// getTableName 获取逻辑计划的表名
func getTableName(plan LogicalPlan) string <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return dataSource.TableName
        }</span>
        <span class="cov0" title="0">children := plan.Children()
        if len(children) &gt; 0 </span><span class="cov0" title="0">{
                return getTableName(children[0])
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// EstimateDistinct 估算DISTINCT后的行数
func (e *SimpleCardinalityEstimator) EstimateDistinct(table string, columns []string) int64 <span class="cov0" title="0">{
        stats, exists := e.stats[table]
        if !exists </span><span class="cov0" title="0">{
                return e.EstimateTableScan(table) / 2
        }</span>

        <span class="cov0" title="0">if len(columns) == 0 </span><span class="cov0" title="0">{
                return stats.RowCount
        }</span>

        // 简化：取最小NDV
        <span class="cov0" title="0">minNDV := int64(math.MaxInt64)
        for _, col := range columns </span><span class="cov0" title="0">{
                if colStats, ok := stats.ColumnStats[col]; ok &amp;&amp; colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        if colStats.DistinctCount &lt; minNDV </span><span class="cov0" title="0">{
                                minNDV = colStats.DistinctCount
                        }</span>
                }
        }

        <span class="cov0" title="0">if minNDV == math.MaxInt64 </span><span class="cov0" title="0">{
                return stats.RowCount / 2
        }</span>

        <span class="cov0" title="0">return minNDV</span>
}

// CollectStatistics 从数据源收集统计信息（简化版）
func CollectStatistics(dataSource domain.DataSource, tableName string) (*TableStatistics, error) <span class="cov0" title="0">{
        // 执行查询获取所有数据
        result, err := dataSource.Query(context.Background(), tableName, &amp;domain.QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := &amp;TableStatistics{
                Name:       tableName,
                RowCount:   result.Total,
                ColumnStats: make(map[string]*ColumnStatistics),
        }

        // 为每列收集统计信息
        for _, colInfo := range result.Columns </span><span class="cov0" title="0">{
                stats.ColumnStats[colInfo.Name] = collectColumnStatistics(result.Rows, colInfo.Name, colInfo.Type)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// collectColumnStatistics 收集列的统计信息
func collectColumnStatistics(rows []domain.Row, columnName, columnType string) *ColumnStatistics <span class="cov0" title="0">{
        stats := &amp;ColumnStatistics{
                Name:    columnName,
                DataType: columnType,
        }

        // 收集值
        values := make([]interface{}, 0, len(rows))
        distinctValues := make(map[interface{}]bool)
        nullCount := int64(0)
        totalWidth := 0.0

        for _, row := range rows </span><span class="cov0" title="0">{
                val := row[columnName]
                values = append(values, val)

                if val == nil </span><span class="cov0" title="0">{
                        nullCount++
                        continue</span>
                }

                <span class="cov0" title="0">distinctValues[val] = true

                // 对于字符串类型，计算平均宽度
                if s, ok := val.(string); ok </span><span class="cov0" title="0">{
                        totalWidth += float64(len(s))
                }</span>
        }

        // 计算统计信息
        <span class="cov0" title="0">stats.NullCount = nullCount
        stats.NullFraction = float64(nullCount) / float64(len(rows))
        stats.DistinctCount = int64(len(distinctValues))

        // 计算Min和Max
        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                stats.MinValue = values[0]
                stats.MaxValue = values[0]

                for _, val := range values </span><span class="cov0" title="0">{
                        if val != nil </span><span class="cov0" title="0">{
                                if compareValues(val, stats.MinValue) &lt; 0 </span><span class="cov0" title="0">{
                                        stats.MinValue = val
                                }</span>
                                <span class="cov0" title="0">if compareValues(val, stats.MaxValue) &gt; 0 </span><span class="cov0" title="0">{
                                        stats.MaxValue = val
                                }</span>
                        }
                }

                // 计算平均宽度
                <span class="cov0" title="0">if len(values)-int(nullCount) &gt; 0 </span><span class="cov0" title="0">{
                        stats.AvgWidth = totalWidth / float64(len(values)-int(nullCount))
                }</span>
        }

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cost

import (
        "fmt"
        "math"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// JoinType JOIN类型（独立定义以避免循环导入）
type JoinType int

const (
        InnerJoin JoinType = iota
        LeftOuterJoin
        RightOuterJoin
        FullOuterJoin
)

// SimpleCardinalityEstimator 简单的基数估算器（默认实现）
type SimpleCardinalityEstimator struct{}

func (s *SimpleCardinalityEstimator) EstimateTableScan(tableName string) int64 <span class="cov7" title="6">{
        return 10000 // 默认值
}</span>

func (s *SimpleCardinalityEstimator) EstimateFilter(tableName string, filters []domain.Filter) int64 <span class="cov3" title="2">{
        return 1000 // 默认值
}</span>

// CardinalityEstimator 基数估算器接口（cost 包内部接口）
type CardinalityEstimator interface {
        EstimateTableScan(tableName string) int64
        EstimateFilter(tableName string, filters []domain.Filter) int64
}

// AdaptiveCostModel 自适应成本模型
// 基于硬件配置、统计信息动态调整成本估算
type AdaptiveCostModel struct {
        hardware     *HardwareProfile
        factors      *AdaptiveCostFactor
        estimator    CardinalityEstimator
        cacheHitInfo *CacheHitInfo
}

// CacheHitInfo 缓存命中信息（用于动态调整）
type CacheHitInfo struct {
        TableHitRates map[string]float64 // 表级缓存命中率
        LastUpdate    time.Time
}

// NewAdaptiveCostModel 创建自适应成本模型
func NewAdaptiveCostModel(estimator CardinalityEstimator) *AdaptiveCostModel <span class="cov10" title="13">{
        hardware := DetectHardwareProfile()

        return &amp;AdaptiveCostModel{
                hardware:     hardware,
                factors:      hardware.CalculateCostFactors(),
                estimator:    estimator,
                cacheHitInfo: &amp;CacheHitInfo{
                        TableHitRates: make(map[string]float64),
                        LastUpdate:    time.Now(),
                },
        }
}</span>

// NewEnhancedCostModel 创建增强成本模型（别名）
func NewEnhancedCostModel(hardware *HardwareProfile) *AdaptiveCostModel <span class="cov3" title="2">{
        if hardware == nil </span><span class="cov1" title="1">{
                hardware = DetectHardwareProfile()
        }</span>

        <span class="cov3" title="2">estimator := &amp;SimpleCardinalityEstimator{}

        return &amp;AdaptiveCostModel{
                hardware:     hardware,
                factors:      hardware.CalculateCostFactors(),
                estimator:    estimator,
                cacheHitInfo: &amp;CacheHitInfo{
                        TableHitRates: make(map[string]float64),
                        LastUpdate:    time.Now(),
                },
        }</span>
}

// ScanCost 计算扫描成本（增强版）
func (acm *AdaptiveCostModel) ScanCost(tableName string, rowCount int64, useIndex bool) float64 <span class="cov9" title="10">{
        if rowCount &lt;= 0 </span><span class="cov3" title="2">{
                return 0
        }</span>

        // 基础IO成本
        <span class="cov8" title="8">baseCost := float64(rowCount) * acm.factors.IOFactor

        // 使用索引时，调整成本
        if useIndex </span><span class="cov5" title="4">{
                // 索引扫描成本 = 索引高度 + 叶子节点访问
                indexHeight := acm.estimateIndexHeight(tableName)
                leafAccess := float64(rowCount) * acm.factors.IOFactor * 0.1
                
                // 索引通常比全表扫描快10倍
                indexCost := (float64(indexHeight) * acm.factors.CPUFactor) + leafAccess
                return math.Min(baseCost, indexCost * 0.1)
        }</span>

        // 考虑缓存命中率
        <span class="cov5" title="4">cacheHitRate := acm.getTableCacheHitRate(tableName)
        if cacheHitRate &gt; 0 </span><span class="cov5" title="4">{
                // 缓存命中时，成本大幅降低
                cachedCost := baseCost * (1.0 - cacheHitRate)
                return math.Min(baseCost, cachedCost)
        }</span>

        <span class="cov0" title="0">return baseCost</span>
}

// FilterCost 计算过滤成本（增强版）
func (acm *AdaptiveCostModel) FilterCost(inputRows int64, selectivity float64, filters []domain.Filter) float64 <span class="cov6" title="5">{
        outputRows := float64(inputRows) * selectivity

        // CPU比较成本
        comparisonCost := outputRows * acm.factors.CPUFactor

        // 内存成本：过滤需要加载行到内存
        memoryCost := float64(inputRows) * acm.factors.MemoryFactor * 0.01

        // 如果使用了索引，降低成本
        for _, filter := range filters </span><span class="cov4" title="3">{
                if acm.canUseIndex(filter.Field) </span><span class="cov4" title="3">{
                        // 索引过滤成本更低
                        comparisonCost *= 0.3
                }</span>
        }

        <span class="cov6" title="5">return comparisonCost + memoryCost</span>
}

// JoinCost 计算连接成本（增强版）
func (acm *AdaptiveCostModel) JoinCost(left interface{}, right interface{}, joinType JoinType, conditions []*parser.Expression) float64 <span class="cov6" title="5">{
        leftRows := acm.estimatePlanRowCount(left)
        rightRows := acm.estimatePlanRowCount(right)

        if leftRows == 0 || rightRows == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov6" title="5">switch joinType </span>{
        case InnerJoin:<span class="cov1" title="1">
                // Hash Join成本
                buildCost := acm.buildHashTableCost(leftRows)
                probeCost := acm.probeHashTableCost(leftRows, rightRows, conditions)
                return buildCost + probeCost</span>

        case LeftOuterJoin:<span class="cov1" title="1">
                // Left Outer Join
                buildCost := acm.buildHashTableCost(leftRows)
                probeCost := acm.probeHashTableCost(leftRows, rightRows, conditions)
                materializeCost := float64(leftRows) * acm.factors.MemoryFactor * 0.01
                return buildCost + probeCost + materializeCost</span>

        case RightOuterJoin:<span class="cov1" title="1">
                // Right Outer Join
                buildCost := acm.buildHashTableCost(rightRows)
                probeCost := acm.probeHashTableCost(rightRows, leftRows, conditions)
                materializeCost := float64(rightRows) * acm.factors.MemoryFactor * 0.01
                return buildCost + probeCost + materializeCost</span>

        case FullOuterJoin:<span class="cov1" title="1">
                // Full Outer Join
                leftBuild := acm.buildHashTableCost(leftRows)
                rightBuild := acm.buildHashTableCost(rightRows)
                probeCost1 := acm.probeHashTableCost(leftRows, rightRows, conditions)
                probeCost2 := acm.probeHashTableCost(rightRows, leftRows, conditions)
                return leftBuild + rightBuild + probeCost1 + probeCost2</span>

        default:<span class="cov1" title="1">
                // 默认使用Hash Join
                return acm.buildHashTableCost(int64(math.Min(float64(leftRows), float64(rightRows)))) +
                        acm.probeHashTableCost(leftRows, rightRows, conditions)</span>
        }
}

// ScanCostForJoinModel 用于join.CostModel接口的扫描成本计算
func (acm *AdaptiveCostModel) ScanCostForJoinModel(tableName string, rowCount int64, useIndex bool) float64 <span class="cov3" title="2">{
        return acm.ScanCost(tableName, rowCount, useIndex)
}</span>

// AggregateCost 计算聚合成本（增强版）
func (acm *AdaptiveCostModel) AggregateCost(inputRows int64, groupByCols int, aggFuncs int) float64 <span class="cov5" title="4">{
        // 分组成本：每行 * 分组列数 * CPU因子
        groupingCost := float64(inputRows) * float64(groupByCols) * acm.factors.CPUFactor

        // 聚合函数成本
        aggregationCost := float64(inputRows) * float64(aggFuncs) * acm.factors.CPUFactor

        // 内存成本：哈希表构建
        hashTableCost := float64(inputRows) * acm.factors.MemoryFactor * 0.05

        // 排序成本（如果有ORDER BY）
        sortingCost := acm.estimateSortingCost(inputRows, groupByCols)

        return groupingCost + aggregationCost + hashTableCost + sortingCost
}</span>

// ProjectCost 计算投影成本（增强版）
func (acm *AdaptiveCostModel) ProjectCost(inputRows int64, projCols int) float64 <span class="cov5" title="4">{
        // 基础投影成本
        baseCost := float64(inputRows) * float64(projCols) * acm.factors.CPUFactor

        // 如果投影包含表达式计算，增加额外成本
        expressionCost := float64(projCols) * acm.factors.CPUFactor * 0.5

        // 内存成本
        memoryCost := float64(inputRows) * float64(projCols) * acm.factors.MemoryFactor * 0.001

        return baseCost + expressionCost + memoryCost
}</span>

// SortCost 计算排序成本
func (acm *AdaptiveCostModel) SortCost(inputRows int64) float64 <span class="cov5" title="4">{
        // 快速排序成本：n * log(n)
        if inputRows &lt;= 1 </span><span class="cov3" title="2">{
                return 0
        }</span>
        <span class="cov3" title="2">return float64(inputRows) * math.Log2(float64(inputRows)) * acm.factors.CPUFactor</span>
}

// estimateIndexHeight 估算索引高度
func (acm *AdaptiveCostModel) estimateIndexHeight(tableName string) int <span class="cov5" title="4">{
        // 基于B+树索引，高度 ≈ log2(行数)
        rowCount := acm.estimator.EstimateTableScan(tableName)
        if rowCount &lt;= 0 </span><span class="cov0" title="0">{
                return 3
        }</span>
        
        <span class="cov5" title="4">height := math.Ceil(math.Log2(float64(rowCount)))
        return int(math.Max(2, height))</span>
}

// buildHashTableCost 计算哈希表构建成本
func (acm *AdaptiveCostModel) buildHashTableCost(rows int64) float64 <span class="cov7" title="6">{
        // 构建哈希表 = 计算哈希 + 插入哈希
        hashCost := float64(rows) * acm.factors.CPUFactor * 2.0
        memoryCost := float64(rows) * acm.factors.MemoryFactor * 0.01
        return hashCost + memoryCost
}</span>

// probeHashTableCost 计算哈希探测成本
func (acm *AdaptiveCostModel) probeHashTableCost(buildRows, probeRows int64, conditions []*parser.Expression) float64 <span class="cov7" title="6">{
        // 探测成本 = 探测行数 * 条件数 * CPU因子
        probeCost := float64(probeRows) * float64(len(conditions)+1) * acm.factors.CPUFactor
        
        // 内存成本：加载探测表
        memoryCost := float64(probeRows) * acm.factors.MemoryFactor * 0.001

        return probeCost + memoryCost
}</span>

// estimateSortingCost 估算排序成本
func (acm *AdaptiveCostModel) estimateSortingCost(rows int64, sortCols int) float64 <span class="cov5" title="4">{
        if rows &lt;= 1 </span><span class="cov1" title="1">{
                return 0
        }</span>
        
        // 外部排序成本：n * log(n) * (列数/10)
        <span class="cov4" title="3">logCost := math.Log2(float64(rows))
        return float64(rows) * logCost * float64(sortCols) * acm.factors.CPUFactor</span>
}

// estimatePlanRowCount 估算计划的行数
func (acm *AdaptiveCostModel) estimatePlanRowCount(plan interface{}) int64 <span class="cov9" title="10">{
        // 简化实现，直接估算
        return 10000
}</span>

// estimatePlanRowCountWithType 带类型断言的估算（如果需要）
func (acm *AdaptiveCostModel) estimatePlanRowCountWithType(plan interface{}) int64 <span class="cov0" title="0">{
        if ds, ok := plan.(interface{ GetTableName() string }); ok </span><span class="cov0" title="0">{
                if method := ds.GetTableName; method != nil </span><span class="cov0" title="0">{
                        return acm.estimator.EstimateTableScan(method())
                }</span>
        }

        <span class="cov0" title="0">if sel, ok := plan.(interface{ Children() []interface{} }); ok &amp;&amp; len(sel.Children()) &gt; 0 </span><span class="cov0" title="0">{
                // 简化：直接返回估算值
                return acm.estimator.EstimateTableScan("unknown")
        }</span>

        // 默认
        <span class="cov0" title="0">return 10000</span>
}

// canUseIndex 检查是否可以使用索引
func (acm *AdaptiveCostModel) canUseIndex(fieldName string) bool <span class="cov4" title="3">{
        // 简化：假设所有列都有索引
        // 实际应该从IndexManager检查
        return true
}</span>

// getTableCacheHitRate 获取表的缓存命中率
func (acm *AdaptiveCostModel) getTableCacheHitRate(tableName string) float64 <span class="cov8" title="8">{
        if rate, exists := acm.cacheHitInfo.TableHitRates[tableName]; exists </span><span class="cov5" title="4">{
                return rate
        }</span>
        <span class="cov5" title="4">return acm.hardware.EstimateCacheHitRate()</span>
}

// UpdateCacheHitInfo 更新缓存命中信息
func (acm *AdaptiveCostModel) UpdateCacheHitInfo(tableName string, hitRate float64) <span class="cov5" title="4">{
        acm.cacheHitInfo.TableHitRates[tableName] = hitRate
        acm.cacheHitInfo.LastUpdate = time.Now()
}</span>

// GetHardwareProfile 获取硬件配置
func (acm *AdaptiveCostModel) GetHardwareProfile() *HardwareProfile <span class="cov1" title="1">{
        return acm.hardware
}</span>

// GetCostFactors 获取成本因子
func (acm *AdaptiveCostModel) GetCostFactors() *AdaptiveCostFactor <span class="cov1" title="1">{
        return acm.factors
}</span>

// Explain 返回成本模型的说明
func (acm *AdaptiveCostModel) Explain() string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "AdaptiveCostModel:\n"+
                        "  IO Factor: %.4f\n"+
                        "  CPU Factor: %.4f\n"+
                        "  Memory Factor: %.4f\n"+
                        "  Network Factor: %.4f\n"+
                        "  Cache Hit Rate: %.2f%%",
                acm.factors.IOFactor,
                acm.factors.CPUFactor,
                acm.factors.MemoryFactor,
                acm.factors.NetworkFactor,
                acm.hardware.EstimateCacheHitRate()*100,
        )
}</span>

// getTableName 获取表的名称（简化版）
func getTableName(plan interface{}) string <span class="cov0" title="0">{
        // 简化实现
        return "unknown_table"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cost

import (
        "fmt"
        "os"
        "runtime"
        "time"
)

// HardwareProfile 硬件配置文件
// 基于实际硬件动态调整成本因子
type HardwareProfile struct {
        // CPU相关
        CPUCores        int     // CPU核心数
        CPUFrequency   float64 // CPU频率（GHz）
        CPUSpeed       float64 // CPU速度（相对值，基准1.0）
        
        // 内存相关
        TotalMemory    int64   // 总内存（MB）
        AvailableMemory int64   // 可用内存（MB）
        MemorySpeed    float64 // 内存速度（相对值，基准1.0）
        
        // 磁盘相关
        DiskType       string   // 磁盘类型: "SSD", "HDD", "NVMe"
        DiskIO        float64  // 磁盘IO速度（MB/s）
        DiskSeekTime  float64  // 磁盘寻道时间（ms）
        
        // 网络相关
        NetworkBandwidth float64 // 网络带宽（Mbps）
        NetworkLatency  float64 // 网络延迟（ms）
        
        // 系统相关
        OS            string    // 操作系统
        Architecture   string    // 架构: "amd64", "arm64"
        RuntimeVersion string    // Go运行时版本
        
        // 测量信息
        MeasuredAt     time.Time // 测量时间
        CacheHitRate  float64   // 平均缓存命中率
        IsCloudEnv    bool      // 是否云环境
}

// DetectHardwareProfile 自动检测硬件配置
func DetectHardwareProfile() *HardwareProfile <span class="cov7" title="20">{
        profile := &amp;HardwareProfile{
                MeasuredAt:    time.Now(),
                OS:            runtime.GOOS,
                Architecture:   runtime.GOARCH,
                RuntimeVersion: runtime.Version(),
                IsCloudEnv:    detectCloudEnvironment(),
        }
        
        // 检测CPU信息
        profile.CPUCores = runtime.NumCPU()
        profile.CPUFrequency = estimateCPUFrequency()
        profile.CPUSpeed = normalizeCPUSpeed(profile.CPUCores, profile.CPUFrequency)
        
        // 检测内存信息
        profile.TotalMemory = getSystemMemory()
        profile.AvailableMemory = getAvailableMemory()
        profile.MemorySpeed = 1.0 // 默认，可以通过sysfs或WMIC获取
        
        // 检测磁盘信息
        profile.DiskType = detectDiskType()
        profile.DiskIO = estimateDiskIO(profile.DiskType)
        profile.DiskSeekTime = estimateDiskSeekTime(profile.DiskType)
        
        // 默认网络配置
        profile.NetworkBandwidth = 1000.0 // 1 Gbps
        profile.NetworkLatency = 1.0     // 1ms
        
        // 默认缓存命中率
        profile.CacheHitRate = 0.8 // 80%命中率
        
        return profile
}</span>

// detectCloudEnvironment 检测是否在云环境中运行
func detectCloudEnvironment() bool <span class="cov7" title="22">{
        // 简化检测：检查环境变量或特定文件路径
        // AWS, GCP, Azure等都有特定标识
        envVars := []string{"AWS_REGION", "GOOGLE_CLOUD_PROJECT", "AZURE_RESOURCE_GROUP"}
        for _, env := range envVars </span><span class="cov10" title="64">{
                if os.Getenv(env) != "" </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov7" title="21">return false</span>
}

// estimateCPUFrequency 估算CPU频率（简化）
func estimateCPUFrequency() float64 <span class="cov7" title="21">{
        // Linux: 可以从 /proc/cpuinfo 读取
        // Windows: 可以通过 WMI 获取
        // 简化：使用典型值
        return 2.4 // 典型的2.4GHz
}</span>

// normalizeCPUSpeed 标准化CPU速度
func normalizeCPUSpeed(cores int, frequency float64) float64 <span class="cov8" title="26">{
        // 基准: 4核 @ 2.4GHz = 1.0
        benchmarkCores := 4
        benchmarkFreq := 2.4
        
        capacity := float64(cores) * frequency
        benchmarkCapacity := float64(benchmarkCores) * benchmarkFreq
        
        return capacity / benchmarkCapacity
}</span>

// getSystemMemory 获取系统总内存（MB）
func getSystemMemory() int64 <span class="cov7" title="21">{
        // Linux: 从 /proc/meminfo
        // Windows: 通过 GlobalMemoryStatusEx
        // macOS: 通过 sysctl hw.memsize
        // 简化：使用runtime限制
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        // 返回系统内存（这里简化处理）
        // 实际应该调用系统API
        return 8192 // 默认8GB
}</span>

// getAvailableMemory 获取可用内存（MB）
func getAvailableMemory() int64 <span class="cov7" title="21">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        // 简化：返回堆内存的估算值
        // 实际应该从系统获取
        return 4096 // 默认4GB可用
}</span>

// detectDiskType 检测磁盘类型
func detectDiskType() string <span class="cov7" title="21">{
        // 简化：默认SSD
        // 实际应该检测挂载点或磁盘信息
        return "SSD"
}</span>

// estimateDiskIO 估算磁盘IO速度（MB/s）
func estimateDiskIO(diskType string) float64 <span class="cov7" title="24">{
        switch diskType </span>{
        case "NVMe":<span class="cov1" title="1">
                return 3500.0</span> // ~3.5 GB/s
        case "SSD":<span class="cov7" title="21">
                return 500.0</span>  // ~500 MB/s
        case "HDD":<span class="cov1" title="1">
                return 100.0</span>  // ~100 MB/s
        default:<span class="cov1" title="1">
                return 500.0</span>  // 默认SSD
        }
}

// estimateDiskSeekTime 估算磁盘寻道时间（ms）
func estimateDiskSeekTime(diskType string) float64 <span class="cov7" title="24">{
        switch diskType </span>{
        case "NVMe":<span class="cov1" title="1">
                return 0.01</span> // 几乎没有寻道
        case "SSD":<span class="cov7" title="21">
                return 0.1</span>  // ~0.1ms
        case "HDD":<span class="cov1" title="1">
                return 5.0</span>   // ~5ms
        default:<span class="cov1" title="1">
                return 0.1</span>
        }
}

// AdaptiveCostFactor 自适应成本因子
// 基于硬件配置动态调整
type AdaptiveCostFactor struct {
        IOFactor      float64 // IO成本因子
        CPUFactor     float64 // CPU成本因子
        MemoryFactor  float64 // 内存成本因子
        NetworkFactor float64 // 网络成本因子
}

// CalculateCostFactors 计算自适应成本因子
func (hp *HardwareProfile) CalculateCostFactors() *AdaptiveCostFactor <span class="cov7" title="21">{
        factor := &amp;AdaptiveCostFactor{}
        
        // IO因子：基于磁盘速度
        // 基准: SSD @ 500MB/s = 0.1
        baseDiskIO := 500.0
        factor.IOFactor = 0.1 * (baseDiskIO / hp.DiskIO)
        
        // CPU因子：基于核心数和频率
        // 基准: 4核 @ 2.4GHz = 0.01
        factor.CPUFactor = 0.01 / hp.CPUSpeed
        
        // 内存因子：基于内存速度
        // 基准: 1.0 = 0.001
        factor.MemoryFactor = 0.001 * hp.MemorySpeed
        
        // 网络因子：基于带宽
        // 基准: 1Gbps = 0.01
        baseBandwidth := 1000.0
        factor.NetworkFactor = 0.01 * (baseBandwidth / hp.NetworkBandwidth)
        
        // 云环境调整
        if hp.IsCloudEnv </span><span class="cov1" title="1">{
                // 云环境网络延迟通常更高
                factor.NetworkFactor *= 1.5
        }</span>
        
        <span class="cov7" title="21">return factor</span>
}

// EstimateCacheHitRate 估算缓存命中率（基于历史）
func (hp *HardwareProfile) EstimateCacheHitRate() float64 <span class="cov4" title="6">{
        // 简化：使用配置值
        // 实际应该基于查询历史统计
        return hp.CacheHitRate
}</span>

// String 返回硬件配置的字符串表示
func (hp *HardwareProfile) String() string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "CPU: %d cores @ %.2fGHz, Memory: %dMB, Disk: %s @ %.2fMB/s",
                hp.CPUCores, hp.CPUFrequency, hp.AvailableMemory, hp.DiskType, hp.DiskIO,
        )
}</span>

// Explain 返回详细的硬件配置说明
func (hp *HardwareProfile) Explain() string <span class="cov1" title="1">{
        explanation := fmt.Sprintf("=== Hardware Profile ===\n")
        explanation += fmt.Sprintf("CPU:         %d cores @ %.2fGHz (Speed: %.2fx)\n", 
                hp.CPUCores, hp.CPUFrequency, hp.CPUSpeed)
        explanation += fmt.Sprintf("Memory:      %d / %d MB (Speed: %.2fx)\n",
                hp.AvailableMemory, hp.TotalMemory, hp.MemorySpeed)
        explanation += fmt.Sprintf("Disk:        %s @ %.2f MB/s (Seek: %.2fms)\n",
                hp.DiskType, hp.DiskIO, hp.DiskSeekTime)
        explanation += fmt.Sprintf("Network:     %.2f Mbps @ %.2fms latency (Factor: %.4fx)\n",
                hp.NetworkBandwidth, hp.NetworkLatency, 0.01*1000.0/hp.NetworkBandwidth)
        explanation += fmt.Sprintf("Environment:  %s, OS: %s, Arch: %s\n",
                map[bool]string{true: "Cloud", false: "Local"}[hp.IsCloudEnv], hp.OS, hp.Architecture)
        explanation += fmt.Sprintf("Cost Factors: IO=%.4f, CPU=%.4f, Mem=%.4f\n",
                hp.CalculateCostFactors().IOFactor,
                hp.CalculateCostFactors().CPUFactor,
                hp.CalculateCostFactors().MemoryFactor)
        
        return explanation
}</span>

// UpdateCacheHitRate 更新缓存命中率
func (hp *HardwareProfile) UpdateCacheHitRate(rate float64) <span class="cov4" title="5">{
        hp.CacheHitRate = rate
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/optimizer/cost"
        "github.com/kasuganosora/sqlexec/pkg/optimizer/index"
        "github.com/kasuganosora/sqlexec/pkg/optimizer/join"
        "github.com/kasuganosora/sqlexec/pkg/optimizer/statistics"
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// EnhancedOptimizer 增强的优化器
// 集成所有新的优化模块
type EnhancedOptimizer struct {
        baseOptimizer    *Optimizer
        costModel       *cost.AdaptiveCostModel
        indexSelector   *index.IndexSelector
        dpJoinReorder   *join.DPJoinReorder
        bushyTree      *join.BushyJoinTreeBuilder
        statsCache      *statistics.AutoRefreshStatisticsCache
        parallelism     int
        estimator       CardinalityEstimator
}

// NewEnhancedOptimizer 创建增强的优化器
func NewEnhancedOptimizer(dataSource domain.DataSource, parallelism int) *EnhancedOptimizer <span class="cov6" title="16">{
        // 创建基础优化器
        baseOptimizer := NewOptimizer(dataSource)

        // 创建统计信息缓存
        autoRefreshStatsCache := statistics.NewAutoRefreshStatisticsCache(
                statistics.NewSamplingCollector(dataSource, 0.02), // 2%采样
                dataSource,
                time.Hour*24, // 24小时TTL
        )

        // 创建基础的统计缓存
        statsCache := statistics.NewStatisticsCache(time.Hour * 24)

        // 创建基数估算器
        estimator := statistics.NewEnhancedCardinalityEstimator(statsCache)

        // 创建成本模型（使用适配器）
        costModel := cost.NewAdaptiveCostModel(&amp;cardinalityEstimatorAdapter{estimator: estimator})

        // 创建索引选择器
        indexSelector := index.NewIndexSelector(estimator)

        // 创建成本模型适配器以匹配 join.CostModel 接口
        costModelAdapter := &amp;joinCostModelAdapter{costModel: costModel}

        // 创建DP JOIN重排序器
        dpJoinReorder := join.NewDPJoinReorder(costModelAdapter, &amp;joinCardinalityAdapter{estimator: estimator}, 10) // 最多10个表

        // 创建Bushy Join Tree构建器（使用原始的 costModel）
        bushyTree := join.NewBushyJoinTreeBuilder(costModel, &amp;joinCardinalityAdapter{estimator: estimator}, 3) // Bushiness=3

        // 创建优化器适配器
        optimizerEstimatorAdapter := &amp;optimizerCardinalityAdapter{estimator: estimator}

        return &amp;EnhancedOptimizer{
                baseOptimizer:    baseOptimizer,
                costModel:       costModel,
                indexSelector:   indexSelector,
                dpJoinReorder:   dpJoinReorder,
                bushyTree:      bushyTree,
                statsCache:      autoRefreshStatsCache, // 修改为 autoRefreshStatsCache
                parallelism:     parallelism,
                estimator:       optimizerEstimatorAdapter, // 添加estimator
        }
}</span>

// cardinalityEstimatorAdapter 将 optimizer.CardinalityEstimator 适配为 cost.CardinalityEstimator
type cardinalityEstimatorAdapter struct {
        estimator statistics.CardinalityEstimator
}

func (a *cardinalityEstimatorAdapter) EstimateTableScan(tableName string) int64 <span class="cov0" title="0">{
        return a.estimator.EstimateTableScan(tableName)
}</span>

func (a *cardinalityEstimatorAdapter) EstimateFilter(tableName string, filters []domain.Filter) int64 <span class="cov0" title="0">{
        return a.estimator.EstimateFilter(tableName, filters)
}</span>

// joinCostModelAdapter 将 cost.AdaptiveCostModel 适配为 join.CostModel
type joinCostModelAdapter struct {
        costModel *cost.AdaptiveCostModel
}

func (a *joinCostModelAdapter) ScanCost(tableName string, rowCount int64, useIndex bool) float64 <span class="cov0" title="0">{
        return a.costModel.ScanCost(tableName, rowCount, useIndex)
}</span>

func (a *joinCostModelAdapter) JoinCost(left, right join.LogicalPlan, joinType join.JoinType, conditions []*parser.Expression) float64 <span class="cov0" title="0">{
        return a.costModel.JoinCost(left, right, cost.JoinType(joinType), conditions)
}</span>

// joinCardinalityAdapter 将 statistics.CardinalityEstimator 适配为 join.CardinalityEstimator
type joinCardinalityAdapter struct {
        estimator statistics.CardinalityEstimator
}

func (a *joinCardinalityAdapter) EstimateTableScan(tableName string) int64 <span class="cov0" title="0">{
        return a.estimator.EstimateTableScan(tableName)
}</span>

// optimizerCardinalityAdapter 将 statistics.CardinalityEstimator 适配为 optimizer.CardinalityEstimator
type optimizerCardinalityAdapter struct {
        estimator statistics.CardinalityEstimator
}

func (a *optimizerCardinalityAdapter) EstimateTableScan(tableName string) int64 <span class="cov0" title="0">{
        return a.estimator.EstimateTableScan(tableName)
}</span>

func (a *optimizerCardinalityAdapter) EstimateFilter(table string, filters []domain.Filter) int64 <span class="cov0" title="0">{
        return a.estimator.EstimateFilter(table, filters)
}</span>

func (a *optimizerCardinalityAdapter) EstimateJoin(left, right LogicalPlan, joinType JoinType) int64 <span class="cov0" title="0">{
        // 简化实现：使用默认估算
        return 10000
}</span>

func (a *optimizerCardinalityAdapter) EstimateDistinct(table string, columns []string) int64 <span class="cov0" title="0">{
        // 简化实现：使用默认估算
        return 5000
}</span>

func (a *optimizerCardinalityAdapter) UpdateStatistics(tableName string, stats *TableStatistics) {<span class="cov0" title="0">
        // 简化实现：不需要更新
}</span>

// costModelAdapter 将 cost.AdaptiveCostModel 适配为 optimizer.CostModel
type costModelAdapter struct {
        costModel *cost.AdaptiveCostModel
}

func (a *costModelAdapter) ScanCost(tableName string, rowCount int64) float64 <span class="cov0" title="0">{
        return a.costModel.ScanCost(tableName, rowCount, false)
}</span>

func (a *costModelAdapter) FilterCost(inputRows int64, selectivity float64) float64 <span class="cov0" title="0">{
        return a.costModel.FilterCost(inputRows, selectivity, []domain.Filter{})
}</span>

func (a *costModelAdapter) JoinCost(leftRows, rightRows int64, joinType JoinType) float64 <span class="cov0" title="0">{
        // 简化实现：转换为 cost.JoinType
        costJoinType := cost.InnerJoin
        switch joinType </span>{
        case LeftOuterJoin:<span class="cov0" title="0">
                costJoinType = cost.LeftOuterJoin</span>
        case RightOuterJoin:<span class="cov0" title="0">
                costJoinType = cost.RightOuterJoin</span>
        case FullOuterJoin:<span class="cov0" title="0">
                costJoinType = cost.FullOuterJoin</span>
        }
        <span class="cov0" title="0">return a.costModel.JoinCost(leftRows, rightRows, costJoinType, []*parser.Expression{})</span>
}

func (a *costModelAdapter) AggregateCost(inputRows int64, groupByCols int) float64 <span class="cov0" title="0">{
        // cost.AdaptiveCostModel 需要3个参数，这里简化处理
        return a.costModel.AggregateCost(inputRows, groupByCols, 1)
}</span>

func (a *costModelAdapter) ProjectCost(inputRows int64, projCols int) float64 <span class="cov0" title="0">{
        return a.costModel.ProjectCost(inputRows, projCols)
}</span>



// Optimize 优化查询（增强版）
func (eo *EnhancedOptimizer) Optimize(ctx context.Context, stmt *parser.SQLStatement) (PhysicalPlan, error) <span class="cov7" title="20">{
        fmt.Println("=== Enhanced Optimizer Started ===")
        
        // 1. 转换为逻辑计划
        logicalPlan, err := eo.baseOptimizer.convertToLogicalPlan(stmt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("convert to logical plan failed: %w", err)
        }</span>
        <span class="cov7" title="19">fmt.Printf("  [ENHANCED] Logical Plan: %s\n", logicalPlan.Explain())

        // 2. 创建增强的优化上下文
        optCtx := &amp;OptimizationContext{
                DataSource:   eo.baseOptimizer.dataSource,
                TableInfo:    make(map[string]*domain.TableInfo),
                Stats:       make(map[string]*Statistics),
                CostModel:   NewDefaultCostModel(),
        }

        // 3. 应用增强的优化规则
        optimizedPlan, err := eo.applyEnhancedRules(ctx, logicalPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apply enhanced rules failed: %w", err)
        }</span>
        <span class="cov7" title="19">fmt.Printf("  [ENHANCED] Optimized Plan: %s\n", optimizedPlan.Explain())

        // 4. 转换为物理计划（增强版）
        physicalPlan, err := eo.convertToPhysicalPlanEnhanced(ctx, optimizedPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("convert to physical plan failed: %w", err)
        }</span>
        <span class="cov7" title="19">fmt.Printf("  [ENHANCED] Physical Plan: %s\n", ExplainPlan(physicalPlan))

        return physicalPlan, nil</span>
}

// applyEnhancedRules 应用增强的优化规则
func (eo *EnhancedOptimizer) applyEnhancedRules(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov7" title="19">{
        // 应用新的规则
        enhancedRules := []OptimizationRule{
                // 1. 增强的谓词下推
                NewEnhancedPredicatePushdownRule(eo.estimator),

                // 2. OR转UNION规则
                NewORToUnionRule(),

                // 3. DP JOIN重排序
                &amp;DPJoinReorderAdapter{
                        dpReorder: eo.dpJoinReorder,
                },

                // 4. Bushy Join Tree构建
                &amp;BushyTreeAdapter{
                        bushyTree: eo.bushyTree,
                },

                // 5. 索引选择
                &amp;IndexSelectionAdapter{
                        indexSelector: eo.indexSelector,
                        costModel:    eo.costModel,
                },
        }

        // 应用规则
        ruleSet := RuleSet(enhancedRules)

        fmt.Println("  [ENHANCED] Applying enhanced optimization rules...")
        optimizedPlan, err := ruleSet.Apply(ctx, plan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="19">return optimizedPlan, nil</span>
}

// convertToPhysicalPlanEnhanced 转换为物理计划（增强版）
func (eo *EnhancedOptimizer) convertToPhysicalPlanEnhanced(ctx context.Context, logicalPlan LogicalPlan, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov9" title="52">{
        switch p := logicalPlan.(type) </span>{
        case *LogicalDataSource:<span class="cov7" title="19">
                return eo.convertDataSourceEnhanced(ctx, p)</span>
        case *LogicalSelection:<span class="cov4" title="6">
                return eo.convertSelectionEnhanced(ctx, p, optCtx)</span>
        case *LogicalProjection:<span class="cov7" title="19">
                return eo.convertProjectionEnhanced(ctx, p, optCtx)</span>
        case *LogicalLimit:<span class="cov3" title="4">
                return eo.convertLimitEnhanced(ctx, p, optCtx)</span>
        case *LogicalSort:<span class="cov2" title="2">
                return eo.convertSortEnhanced(ctx, p, optCtx)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                return eo.convertJoinEnhanced(ctx, p, optCtx)</span>
        case *LogicalAggregate:<span class="cov2" title="2">
                return eo.convertAggregateEnhanced(ctx, p, optCtx)</span>
        case *LogicalUnion:<span class="cov0" title="0">
                return eo.convertUnionEnhanced(ctx, p, optCtx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported logical plan type: %T", p)</span>
        }
}

// convertDataSourceEnhanced 转换数据源（增强版）
func (eo *EnhancedOptimizer) convertDataSourceEnhanced(ctx context.Context, p *LogicalDataSource) (PhysicalPlan, error) <span class="cov7" title="19">{
        tableName := p.TableName
        
        // 应用索引选择
        requiredCols := make([]string, 0)
        for _, col := range p.Columns </span><span class="cov9" title="77">{
                requiredCols = append(requiredCols, col.Name)
        }</span>
        
        // 从谓词条件中提取过滤器
        <span class="cov7" title="19">filters := convertPredicatesToFilters(p.GetPushedDownPredicates())
        
        // 选择最佳索引
        indexSelection := eo.indexSelector.SelectBestIndex(tableName, filters, requiredCols)
        fmt.Printf("  [ENHANCED] Index Selection: %s\n", indexSelection.String())
        
        // 使用索引或全表扫描
        useIndex := indexSelection.SelectedIndex != nil
        scan := NewPhysicalTableScan(
                tableName,
                p.TableInfo,
                eo.baseOptimizer.dataSource,
                filters,
                &amp;LimitInfo{
                        Limit:  0,
                        Offset: 0,
                },
        )

        // 更新成本
        scanCost := eo.costModel.ScanCost(tableName, 10000, useIndex) // 使用默认估算
        scan.cost = scanCost

        return scan, nil</span>
}

// convertSelectionEnhanced 转换选择（增强版）
func (eo *EnhancedOptimizer) convertSelectionEnhanced(ctx context.Context, p *LogicalSelection, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov4" title="6">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selection has no child")
        }</span>

        // 转换子节点
        <span class="cov4" title="6">child, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换条件为过滤器
        <span class="cov4" title="6">filters := convertPredicatesToFilters(p.GetConditions())

        // 计算成本
        _ = optCtx.CostModel.FilterCost(int64(10000), 0.1) // 使用默认估算

        return NewPhysicalSelection(p.GetConditions(), filters, child, eo.baseOptimizer.dataSource), nil</span>
}

// convertProjectionEnhanced 转换投影（增强版）
func (eo *EnhancedOptimizer) convertProjectionEnhanced(ctx context.Context, p *LogicalProjection, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov7" title="19">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("projection has no child")
        }</span>

        <span class="cov7" title="19">child, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换投影
        <span class="cov7" title="19">projExprs := p.GetExprs()
        aliases := p.GetAliases()

        // 计算成本
        projCols := len(projExprs)
        _ = optCtx.CostModel.ProjectCost(int64(10000), projCols) // 使用默认估算

        return NewPhysicalProjection(projExprs, aliases, child), nil</span>
}

// convertLimitEnhanced 转换限制（增强版）
func (eo *EnhancedOptimizer) convertLimitEnhanced(ctx context.Context, p *LogicalLimit, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov3" title="4">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("limit has no child")
        }</span>

        <span class="cov3" title="4">child, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">limit := p.GetLimit()
        offset := p.GetOffset()

        // 计算成本
        _ = optCtx.CostModel.FilterCost(int64(10000), 0.0001) // 极低成本

        return NewPhysicalLimit(limit, offset, child), nil</span>
}

// convertSortEnhanced 转换排序（增强版）
func (eo *EnhancedOptimizer) convertSortEnhanced(ctx context.Context, p *LogicalSort, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov2" title="2">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sort has no child")
        }</span>

        <span class="cov2" title="2">child, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 排序逻辑需要单独实现
        // 这里简化：直接返回子节点
        <span class="cov2" title="2">return child, nil</span>
}

// convertJoinEnhanced 转换JOIN（增强版）
func (eo *EnhancedOptimizer) convertJoinEnhanced(ctx context.Context, p *LogicalJoin, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov0" title="0">{
        if len(p.Children()) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("join must have exactly 2 children")
        }</span>

        // 转换左右子节点
        <span class="cov0" title="0">left, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">right, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[1], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 计算JOIN成本
        <span class="cov0" title="0">_ = eo.costModel.JoinCost(10000, 10000, cost.JoinType(p.GetJoinType()), convertJoinConditionsToExpressions(p.GetJoinConditions()))

        fmt.Println("  [ENHANCED] Using original JOIN plan")
        return NewPhysicalHashJoin(p.GetJoinType(), left, right, p.GetJoinConditions()), nil</span>
}

// convertJoinConditionsToExpressions 转换JOIN条件
func convertJoinConditionsToExpressions(conditions []*JoinCondition) []*parser.Expression <span class="cov0" title="0">{
        if conditions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]*parser.Expression, 0, len(conditions))
        for _, cond := range conditions </span><span class="cov0" title="0">{
                result = append(result, &amp;parser.Expression{
                        Type:     parser.ExprTypeOperator,
                        Operator: cond.Operator,
                        Left:     cond.Left,
                        Right:    cond.Right,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

// convertAggregateEnhanced 转换聚合（增强版）
func (eo *EnhancedOptimizer) convertAggregateEnhanced(ctx context.Context, p *LogicalAggregate, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov2" title="2">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aggregate has no child")
        }</span>

        <span class="cov2" title="2">child, err := eo.convertToPhysicalPlanEnhanced(ctx, p.Children()[0], optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换聚合
        <span class="cov2" title="2">groupByCols := p.GetGroupByCols()
        aggFuncs := p.GetAggFuncs()

        // 计算成本
        _ = eo.costModel.AggregateCost(int64(10000), len(groupByCols), len(aggFuncs))

        return NewPhysicalHashAggregate(aggFuncs, groupByCols, child), nil</span>
}

// convertUnionEnhanced 转换UNION（增强版）
func (eo *EnhancedOptimizer) convertUnionEnhanced(ctx context.Context, p *LogicalUnion, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov0" title="0">{
        if len(p.Children()) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("union has no child")
        }</span>


        // 转换所有子节点
        <span class="cov0" title="0">children := make([]PhysicalPlan, 0, len(p.Children()))
        for _, child := range p.Children() </span><span class="cov0" title="0">{
                converted, err := eo.convertToPhysicalPlanEnhanced(ctx, child, optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">children = append(children, converted)</span>
        }

        // 合并结果（简化）：返回第一个子节点
        // 实际应该实现真正的UNION ALL
        <span class="cov0" title="0">return children[0], nil</span>
}

// Adapters for interface compliance

// DPJoinReorderAdapter DP JOIN重排序适配器
type DPJoinReorderAdapter struct {
        dpReorder *join.DPJoinReorder
}

func (a *DPJoinReorderAdapter) Name() string <span class="cov0" title="0">{
        return "DPJoinReorder"
}</span>

func (a *DPJoinReorderAdapter) Match(plan LogicalPlan) bool <span class="cov9" title="52">{
        _, ok := plan.(*LogicalJoin)
        return ok
}</span>

func (a *DPJoinReorderAdapter) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        join, ok := plan.(*LogicalJoin)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov0" title="0">fmt.Println("  [DP REORDER] 开始DP JOIN重排序优化")

        // 适配器：将 optimizer.LogicalPlan 转换为 join.LogicalPlan
        joinPlan := a.convertToJoinPlan(plan)

        // 调用 join 包的 DP 重排序算法
        reorderedPlan, err := a.dpReorder.Reorder(ctx, joinPlan)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  [DP REORDER] 重排序失败: %v，使用原计划\n", err)
                return join, nil
        }</span>

        // 如果重排序后的计划为空或与原计划相同，返回原计划
        <span class="cov0" title="0">if reorderedPlan == nil </span><span class="cov0" title="0">{
                fmt.Println("  [DP REORDER] 未找到更优的JOIN顺序")
                return join, nil
        }</span>

        <span class="cov0" title="0">fmt.Println("  [DP REORDER] DP JOIN重排序成功")

        // 适配器：将 join.LogicalPlan 转换回 optimizer.LogicalPlan
        // 注意：这里简化实现，实际需要完整的类型转换
        return a.convertFromJoinPlan(reorderedPlan), nil</span>
}

// convertToJoinPlan 将 optimizer.LogicalPlan 转换为 join.LogicalPlan
// 这是一个适配器方法，用于桥接两个包之间的类型差异
func (a *DPJoinReorderAdapter) convertToJoinPlan(plan LogicalPlan) join.LogicalPlan <span class="cov0" title="0">{
        // 简化实现：创建一个适配器包装
        // 完整实现需要递归转换所有节点类型

        // 对于当前实现，join.LogicalPlan 只需要 Children() 和 Explain() 方法
        return &amp;joinPlanAdapter{plan: plan}
}</span>

// convertFromJoinPlan 将 join.LogicalPlan 转换回 optimizer.LogicalPlan
func (a *DPJoinReorderAdapter) convertFromJoinPlan(plan join.LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        // 简化实现：如果 plan 是 joinPlanAdapter，解包返回原始计划
        if adapter, ok := plan.(*joinPlanAdapter); ok </span><span class="cov0" title="0">{
                return adapter.plan
        }</span>

        // 否则返回原计划（因为 DP 重排序可能返回空）
        <span class="cov0" title="0">return nil</span>
}

// joinPlanAdapter 将 optimizer.LogicalPlan 适配为 join.LogicalPlan
type joinPlanAdapter struct {
        plan LogicalPlan
}

func (a *joinPlanAdapter) Children() []join.LogicalPlan <span class="cov0" title="0">{
        if a.plan == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">children := a.plan.Children()
        result := make([]join.LogicalPlan, len(children))
        for i, child := range children </span><span class="cov0" title="0">{
                result[i] = &amp;joinPlanAdapter{plan: child}
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (a *joinPlanAdapter) Explain() string <span class="cov0" title="0">{
        if a.plan == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov0" title="0">return a.plan.Explain()</span>
}

// BushyTreeAdapter Bushy Tree适配器
type BushyTreeAdapter struct {
        bushyTree *join.BushyJoinTreeBuilder
}

func (a *BushyTreeAdapter) Name() string <span class="cov0" title="0">{
        return "BushyTreeBuilder"
}</span>

func (a *BushyTreeAdapter) Match(plan LogicalPlan) bool <span class="cov9" title="52">{
        // 匹配任何包含JOIN的计划
        return a.containsJoin(plan)
}</span>

func (a *BushyTreeAdapter) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 简化：不执行Bushy Tree构建，直接返回原计划
        // 已实现：调用 join 包中的 Bushy Tree 构建器
        // 当前 Bushy Tree 构建器返回 nil，表示保持线性树
        // 如果需要真正启用 Bushy Tree，需要在 bushy_tree.go 中实现完整逻辑

        fmt.Println("  [BUSHY TREE] 开始 Bushy JOIN Tree 构建优化")

        // 检查是否有足够的表进行 Bushy Tree 构建
        tables := a.collectTables(plan)
        if len(tables) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Printf("  [BUSHY TREE] 表数量 %d &lt; 3，使用线性树\n", len(tables))
                return plan, nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("  [BUSHY TREE] 检测到 %d 个表，考虑 Bushy Tree\n", len(tables))

        // 调用 Bushy Tree 构建器
        tableNames := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                tableNames = append(tableNames, table)
        }</span>

        // 调用构建器（注意：当前实现返回 nil）
        <span class="cov0" title="0">bushyTree := a.bushyTree.BuildBushyTree(tableNames, nil)

        if bushyTree == nil </span><span class="cov0" title="0">{
                fmt.Println("  [BUSHY TREE] Bushy Tree 构建器返回 nil，保持原线性树")
                return plan, nil
        }</span>

        <span class="cov0" title="0">fmt.Println("  [BUSHY TREE] Bushy Tree 构建成功")

        // 转换为 optimizer.LogicalPlan
        return a.convertBushyTreeToPlan(bushyTree), nil</span>
}

// collectTables 收集逻辑计划中涉及的所有表
func (a *BushyTreeAdapter) collectTables(plan LogicalPlan) map[string]bool <span class="cov0" title="0">{
        tables := make(map[string]bool)
        a.collectTablesRecursive(plan, tables)
        return tables
}</span>

// collectTablesRecursive 递归收集表名
func (a *BushyTreeAdapter) collectTablesRecursive(plan LogicalPlan, tables map[string]bool) <span class="cov0" title="0">{
        if plan == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                tables[dataSource.TableName] = true
                return
        }</span>

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                a.collectTablesRecursive(child, tables)
        }</span>
}

// convertBushyTreeToPlan 将 Bushy Tree 转换为逻辑计划
func (a *BushyTreeAdapter) convertBushyTreeToPlan(bushyTree interface{}) LogicalPlan <span class="cov0" title="0">{
        // 简化实现：返回 nil，实际需要解析 bushyTree 结构
        // bushyTree 是 interface{} 类型，实际应该是某种树结构

        fmt.Println("  [BUSHY TREE] Bushy Tree 转换功能（框架实现）")

        return nil
}</span>

func (a *BushyTreeAdapter) containsJoin(plan LogicalPlan) bool <span class="cov9" title="52">{
        if _, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov9" title="52">if _, ok := plan.(*LogicalUnion); ok </span><span class="cov0" title="0">{
                for _, child := range plan.Children() </span><span class="cov0" title="0">{
                        if a.containsJoin(child) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov9" title="52">return false</span>
}

// IndexSelectionAdapter 索引选择适配器
type IndexSelectionAdapter struct {
        indexSelector *index.IndexSelector
        costModel    *cost.AdaptiveCostModel
}

func (a *IndexSelectionAdapter) Name() string <span class="cov7" title="19">{
        return "IndexSelection"
}</span>

func (a *IndexSelectionAdapter) Match(plan LogicalPlan) bool <span class="cov9" title="52">{
        _, ok := plan.(*LogicalDataSource)
        return ok
}</span>

func (a *IndexSelectionAdapter) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov7" title="19">{
        dataSource, ok := plan.(*LogicalDataSource)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov7" title="19">tableName := dataSource.TableName

        // 从谓词条件中提取过滤器
        filters := convertPredicatesToFilters(dataSource.GetPushedDownPredicates())

        // 应用索引选择
        requiredCols := make([]string, 0)
        for _, col := range dataSource.Columns </span><span class="cov9" title="77">{
                requiredCols = append(requiredCols, col.Name)
        }</span>
        <span class="cov7" title="19">indexSelection := a.indexSelector.SelectBestIndex(tableName, filters, requiredCols)

        if indexSelection.SelectedIndex != nil </span><span class="cov0" title="0">{
                // 输出日志
                fmt.Printf("  [INDEX SELECT] Selected index: %s for table %s\n",
                        indexSelection.SelectedIndex.Name, tableName)
        }</span>

        <span class="cov7" title="19">return plan, nil</span>
}

// Helper functions

func convertPredicatesToFilters(conditions []*parser.Expression) []domain.Filter <span class="cov8" title="44">{
        filters := make([]domain.Filter, 0, len(conditions))
        for _, cond := range conditions </span><span class="cov6" title="18">{
                if cond != nil </span><span class="cov6" title="18">{
                        filters = append(filters, domain.Filter{
                                Field:    expressionToString(cond),
                                Operator:  "=/",
                                Value:     cond.Value,
                        })
                }</span>
        }
        <span class="cov8" title="44">return filters</span>
}



func convertAggFuncs(aggItems []*AggregationItem) []*AggregationItem <span class="cov0" title="0">{
        funcs := make([]*AggregationItem, len(aggItems))
        for i, item := range aggItems </span><span class="cov0" title="0">{
                funcs[i] = &amp;AggregationItem{
                        Type:  item.Type,
                        Alias: item.Type.String(),
                }
        }</span>
        <span class="cov0" title="0">return funcs</span>
}

// SetParallelism 设置并行度
func (eo *EnhancedOptimizer) SetParallelism(parallelism int) <span class="cov0" title="0">{
        eo.parallelism = parallelism
}</span>

// GetParallelism 获取并行度
func (eo *EnhancedOptimizer) GetParallelism() int <span class="cov3" title="4">{
        return eo.parallelism
}</span>

// GetStatisticsCache 获取统计信息缓存
func (eo *EnhancedOptimizer) GetStatisticsCache() *statistics.AutoRefreshStatisticsCache <span class="cov0" title="0">{
        return eo.statsCache
}</span>

// Explain 解释增强优化器
func (eo *EnhancedOptimizer) Explain() string <span class="cov1" title="1">{
        factors := eo.costModel.GetCostFactors()
        costModelStr := fmt.Sprintf(
                "AdaptiveCostModel(IO=%.4f, CPU=%.4f, Mem=%.4f, Net=%.4f)",
                factors.IOFactor, factors.CPUFactor, factors.MemoryFactor, factors.NetworkFactor,
        )

        return fmt.Sprintf(
                "=== Enhanced Optimizer ===\n"+
                        "  Parallelism: %d\n"+
                        "  Cost Model: %s\n"+
                        "  Index Selector: %s\n"+
                        "  DP Join Reorder: %s\n"+
                        "  Bushy Tree Builder: %s\n"+
                        "  Stats Cache: TTL=%v",
                eo.parallelism,
                costModelStr,
                eo.indexSelector.Explain("", nil, nil),
                eo.dpJoinReorder.Explain(nil),
                eo.bushyTree.Explain(),
                eo.statsCache.Stats().TTL,
        )
}</span>

// expressionToString 将表达式转换为字符串
func expressionToString(expr *parser.Expression) string <span class="cov10" title="78">{
        if expr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov10" title="78">if expr.Type == parser.ExprTypeColumn </span><span class="cov7" title="24">{
                return expr.Column
        }</span>

        <span class="cov9" title="54">if expr.Type == parser.ExprTypeValue </span><span class="cov7" title="24">{
                return fmt.Sprintf("%v", expr.Value)
        }</span>

        <span class="cov8" title="30">if expr.Type == parser.ExprTypeOperator </span><span class="cov8" title="30">{
                left := expressionToString(expr.Left)
                right := expressionToString(expr.Right)
                if left != "" &amp;&amp; right != "" </span><span class="cov8" title="30">{
                        return fmt.Sprintf("%s %s %s", left, expr.Operator, right)
                }</span>
                <span class="cov0" title="0">if left != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s %s", expr.Operator, left)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", expr.Value)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// EnhancedPredicatePushdownRule 增强的谓词下推规则
// 支持跨JOIN谓词下推、OR条件处理
type EnhancedPredicatePushdownRule struct {
        cardinalityEstimator CardinalityEstimator
}

// NewEnhancedPredicatePushdownRule 创建增强谓词下推规则
func NewEnhancedPredicatePushdownRule(estimator CardinalityEstimator) *EnhancedPredicatePushdownRule <span class="cov7" title="19">{
        return &amp;EnhancedPredicatePushdownRule{
                cardinalityEstimator: estimator,
        }
}</span>

// Name 返回规则名称
func (r *EnhancedPredicatePushdownRule) Name() string <span class="cov4" title="6">{
        return "EnhancedPredicatePushdown"
}</span>

// Match 检查规则是否匹配
func (r *EnhancedPredicatePushdownRule) Match(plan LogicalPlan) bool <span class="cov9" title="52">{
        _, ok := plan.(*LogicalSelection)
        return ok
}</span>

// Apply 应用规则
func (r *EnhancedPredicatePushdownRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov4" title="6">{
        selection, ok := plan.(*LogicalSelection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov4" title="6">if len(selection.Children()) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov4" title="6">child := selection.Children()[0]

        // 1. 尝试下推到DataSource
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov4" title="6">{
                pushedDown := r.tryPushDownToDataSource(selection, dataSource)
                if pushedDown </span><span class="cov4" title="6">{
                        fmt.Println("  [PUSHDOWN] Predicates pushed down to DataSource")
                        // 如果所有条件都已下推，返回DataSource
                        if len(selection.Conditions()) == 0 </span><span class="cov0" title="0">{
                                return dataSource, nil
                        }</span>
                }
        }

        // 2. 尝试跨JOIN下推
        <span class="cov4" title="6">if join, ok := child.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                pushedDown := r.tryPushDownAcrossJoin(selection, join)
                if pushedDown </span><span class="cov0" title="0">{
                        fmt.Println("  [PUSHDOWN] Predicates pushed down across JOIN")
                }</span>
        }

        // 3. 处理OR条件，转换为UNION
        <span class="cov4" title="6">if orPlan := r.tryConvertORToUnion(selection); orPlan != nil </span><span class="cov0" title="0">{
                fmt.Println("  [PUSHDOWN] Converted OR to UNION")
                return orPlan, nil
        }</span>

        // 4. 合并相邻Selection
        <span class="cov4" title="6">merged := r.mergeAdjacentSelections(selection)
        if merged != selection </span><span class="cov0" title="0">{
                return merged, nil
        }</span>

        <span class="cov4" title="6">return plan, nil</span>
}

// tryPushDownToDataSource 尝试下推到DataSource
func (r *EnhancedPredicatePushdownRule) tryPushDownToDataSource(selection *LogicalSelection, dataSource *LogicalDataSource) bool <span class="cov4" title="6">{
        conditions := selection.Conditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 分析哪些条件可以下推
        <span class="cov4" title="6">pushableConditions := make([]*parser.Expression, 0)
        remainingConditions := make([]*parser.Expression, 0)

        for _, cond := range conditions </span><span class="cov4" title="6">{
                if r.canPushDownToDataSource(cond, dataSource) </span><span class="cov4" title="6">{
                        pushableConditions = append(pushableConditions, cond)
                }</span> else<span class="cov0" title="0"> {
                        remainingConditions = append(remainingConditions, cond)
                }</span>
        }

        // 如果所有条件都可以下推，更新DataSource
        <span class="cov4" title="6">if len(remainingConditions) == 0 </span><span class="cov4" title="6">{
                // 将条件标记到DataSource
                for _, cond := range pushableConditions </span><span class="cov4" title="6">{
                        dataSource.PushDownPredicates([]*parser.Expression{cond})
                }</span>
                <span class="cov4" title="6">return true</span>
        }

        // 部分下推：创建新的Selection
        <span class="cov0" title="0">if len(pushableConditions) &gt; 0 </span><span class="cov0" title="0">{
                for _, cond := range pushableConditions </span><span class="cov0" title="0">{
                        dataSource.PushDownPredicates([]*parser.Expression{cond})
                }</span>
        }

        <span class="cov0" title="0">return len(pushableConditions) &gt; 0</span>
}

// canPushDownToDataSource 检查条件是否可以下推到DataSource
func (r *EnhancedPredicatePushdownRule) canPushDownToDataSource(cond *parser.Expression, dataSource *LogicalDataSource) bool <span class="cov4" title="6">{
        // 简化：检查条件引用的列是否在DataSource中
        schema := dataSource.Schema()
        if len(schema) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查所有引用的列
        <span class="cov4" title="6">cols := r.extractColumnsFromExpression(cond)
        for _, col := range cols </span><span class="cov4" title="6">{
                // 检查列是否在DataSource的schema中
                for _, schemaCol := range schema </span><span class="cov7" title="18">{
                        if col == schemaCol.Name </span><span class="cov4" title="6">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// tryPushDownAcrossJoin 尝试跨JOIN下推谓词
func (r *EnhancedPredicatePushdownRule) tryPushDownAcrossJoin(selection *LogicalSelection, join *LogicalJoin) bool <span class="cov0" title="0">{
        conditions := selection.Conditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 分析JOIN条件，确定哪些表参与
        <span class="cov0" title="0">joinTables := r.extractTablesFromJoin(join)
        joinConditions := r.extractJoinConditions(join)

        // 分类条件
        leftPushable := make([]*parser.Expression, 0)
        rightPushable := make([]*parser.Expression, 0)
        bothPushable := make([]*parser.Expression, 0)
        remaining := make([]*parser.Expression, 0)

        for _, cond := range conditions </span><span class="cov0" title="0">{
                // 确定条件引用的表
                condTables := r.extractTablesFromCondition(cond)

                // 检查是否可以下推
                pushDecision := r.analyzePushability(cond, condTables, joinTables, joinConditions)
                
                switch pushDecision </span>{
                case PushLeft:<span class="cov0" title="0">
                        leftPushable = append(leftPushable, cond)</span>
                case PushRight:<span class="cov0" title="0">
                        rightPushable = append(rightPushable, cond)</span>
                case PushBoth:<span class="cov0" title="0">
                        bothPushable = append(bothPushable, cond)</span>
                default:<span class="cov0" title="0">
                        remaining = append(remaining, cond)</span>
                }
        }

        // 应用下推
        <span class="cov0" title="0">children := join.Children()
        if len(children) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">leftChild := children[0]
        rightChild := children[1]
        pushed := false

        // 为左子节点创建或更新Selection
        if len(leftPushable) &gt; 0 </span><span class="cov0" title="0">{
                leftSelection := r.createOrMergeSelection(leftChild, leftPushable)
                join.SetChildren(leftSelection, rightChild)
                pushed = true
        }</span>

        // 为右子节点创建或更新Selection
        <span class="cov0" title="0">if len(rightPushable) &gt; 0 </span><span class="cov0" title="0">{
                children = join.Children()
                leftChild = children[0]
                rightChild = children[1]
                
                rightSelection := r.createOrMergeSelection(rightChild, rightPushable)
                join.SetChildren(leftChild, rightSelection)
                pushed = true
        }</span>

        <span class="cov0" title="0">return pushed</span>
}

// createOrMergeSelection 创建或合并Selection节点
func (r *EnhancedPredicatePushdownRule) createOrMergeSelection(child LogicalPlan, conditions []*parser.Expression) LogicalPlan <span class="cov0" title="0">{
        if existingSelection, ok := child.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                // 合并条件
                mergedConditions := append(existingSelection.Conditions(), conditions...)
                return NewLogicalSelection(mergedConditions, existingSelection.Children()[0])
        }</span>
        // 创建新的Selection
        <span class="cov0" title="0">return NewLogicalSelection(conditions, child)</span>
}

// tryConvertORToUnion 尝试将OR条件转换为UNION
func (r *EnhancedPredicatePushdownRule) tryConvertORToUnion(selection *LogicalSelection) LogicalPlan <span class="cov4" title="6">{
        conditions := selection.Conditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 查找OR条件
        <span class="cov4" title="6">orConditions := r.findORConditions(conditions)
        if len(orConditions) == 0 </span><span class="cov4" title="6">{
                return nil
        }</span>

        // 转换OR为UNION
        <span class="cov0" title="0">child := selection.Children()[0]
        unionPlans := make([]LogicalPlan, 0, len(orConditions))

        for _, orCond := range orConditions </span><span class="cov0" title="0">{
                // 为OR的每个分支创建Selection
                unionPlans = append(unionPlans, NewLogicalSelection([]*parser.Expression{orCond}, child))
        }</span>

        // 创建UNION节点
        <span class="cov0" title="0">return NewLogicalUnion(unionPlans)</span>
}

// mergeAdjacentSelections 合并相邻的Selection节点
func (r *EnhancedPredicatePushdownRule) mergeAdjacentSelections(selection *LogicalSelection) LogicalPlan <span class="cov4" title="6">{
        child := selection.Children()[0]
        if child == nil </span><span class="cov0" title="0">{
                return selection
        }</span>

        // 检查子节点是否也是Selection
        <span class="cov4" title="6">if childSelection, ok := child.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                // 合并两个Selection的条件
                mergedConditions := append(selection.Conditions(), childSelection.Conditions()...)
                return NewLogicalSelection(mergedConditions, childSelection.Children()[0])
        }</span>

        <span class="cov4" title="6">return selection</span>
}

// PushDecision 下推决策
type PushDecision int

const (
        PushNone PushDecision = iota
        PushLeft
        PushRight
        PushBoth
)

// extractColumnsFromExpression 从表达式提取列名
func (r *EnhancedPredicatePushdownRule) extractColumnsFromExpression(expr *parser.Expression) []string <span class="cov4" title="6">{
        cols := make(map[string]bool)
        r.collectColumns(expr, cols)

        result := make([]string, 0, len(cols))
        for col := range cols </span><span class="cov5" title="8">{
                result = append(result, col)
        }</span>
        <span class="cov4" title="6">return result</span>
}

// collectColumns 递归收集表达式中的列
func (r *EnhancedPredicatePushdownRule) collectColumns(expr *parser.Expression, cols map[string]bool) <span class="cov10" title="58">{
        if expr == nil </span><span class="cov8" title="32">{
                return
        }</span>

        <span class="cov8" title="26">if expr.Column != "" </span><span class="cov5" title="8">{
                cols[expr.Column] = true
        }</span>

        <span class="cov8" title="26">r.collectColumns(expr.Left, cols)
        r.collectColumns(expr.Right, cols)

        // 处理函数参数
        for _, arg := range expr.Args </span><span class="cov0" title="0">{
                if arg.Column != "" </span><span class="cov0" title="0">{
                        cols[arg.Column] = true
                }</span>
        }
}

// extractTablesFromJoin 从JOIN节点提取表名
func (r *EnhancedPredicatePushdownRule) extractTablesFromJoin(join *LogicalJoin) []string <span class="cov0" title="0">{
        tables := make(map[string]bool)
        r.collectTablesFromPlan(join, tables)

        result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// collectTablesFromPlan 从计划收集表名
func (r *EnhancedPredicatePushdownRule) collectTablesFromPlan(plan LogicalPlan, tables map[string]bool) <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                tables[dataSource.TableName] = true
                return
        }</span>

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                r.collectTablesFromPlan(child, tables)
        }</span>
}

// extractTablesFromCondition 从条件提取表名
func (r *EnhancedPredicatePushdownRule) extractTablesFromCondition(expr *parser.Expression) []string <span class="cov0" title="0">{
        tables := make(map[string]bool)
        r.collectColumns(expr, tables) // 简化：假设列名和表名一致

        result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// extractJoinConditions 提取JOIN条件
func (r *EnhancedPredicatePushdownRule) extractJoinConditions(join *LogicalJoin) []*parser.Expression <span class="cov0" title="0">{
        // 将JoinCondition转换为Expression
        joinConds := join.GetJoinConditions()
        result := make([]*parser.Expression, 0, len(joinConds))

        for _, jc := range joinConds </span><span class="cov0" title="0">{
                // 将JoinCondition (Left, Right, Operator) 转换为Expression
                result = append(result, &amp;parser.Expression{
                        Type:     parser.ExprTypeOperator,
                        Operator: jc.Operator,
                        Left:     jc.Left,
                        Right:    jc.Right,
                })
        }</span>

        <span class="cov0" title="0">return result</span>
}

// analyzePushability 分析条件是否可以下推
func (r *EnhancedPredicatePushdownRule) analyzePushability(
        cond *parser.Expression,
        condTables []string,
        joinTables []string,
        joinConditions []*parser.Expression,
) PushDecision <span class="cov0" title="0">{
        // 检查条件是否只引用左表
        if r.referencesOnlyTables(cond, joinTables[:1]) </span><span class="cov0" title="0">{
                return PushLeft
        }</span>

        // 检查条件是否只引用右表
        <span class="cov0" title="0">if len(joinTables) &gt; 1 &amp;&amp; r.referencesOnlyTables(cond, joinTables[1:]) </span><span class="cov0" title="0">{
                return PushRight
        }</span>

        // 检查条件是否是等值连接且引用所有表
        <span class="cov0" title="0">if r.isEquijoinCondition(cond, joinConditions) </span><span class="cov0" title="0">{
                return PushBoth
        }</span>

        // 否则无法下推
        <span class="cov0" title="0">return PushNone</span>
}

// referencesOnlyTables 检查表达式是否只引用指定的表
func (r *EnhancedPredicatePushdownRule) referencesOnlyTables(expr *parser.Expression, tables []string) bool <span class="cov0" title="0">{
        if len(tables) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">exprTables := r.extractTablesFromCondition(expr)
        
        // 检查exprTables是否是tables的子集
        tablesMap := make(map[string]bool)
        for _, t := range tables </span><span class="cov0" title="0">{
                tablesMap[t] = true
        }</span>

        <span class="cov0" title="0">for _, et := range exprTables </span><span class="cov0" title="0">{
                if !tablesMap[et] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// isEquijoinCondition 检查是否是等值连接条件
func (r *EnhancedPredicatePushdownRule) isEquijoinCondition(expr *parser.Expression, joinConditions []*parser.Expression) bool <span class="cov0" title="0">{
        if expr == nil || len(joinConditions) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 简化：检查是否是单列等值连接
        // 实际应该更复杂的分析
        <span class="cov0" title="0">return expr.Operator == "=" &amp;&amp; expr.Column != ""</span>
}

// findORConditions 查找OR条件
func (r *EnhancedPredicatePushdownRule) findORConditions(conditions []*parser.Expression) []*parser.Expression <span class="cov4" title="6">{
        orConds := []*parser.Expression{}
        for _, cond := range conditions </span><span class="cov4" title="6">{
                if r.isORExpression(cond) </span><span class="cov0" title="0">{
                        orConds = append(orConds, cond)
                }</span>
        }
        <span class="cov4" title="6">return orConds</span>
}

// isORExpression 判断是否是OR表达式
func (r *EnhancedPredicatePushdownRule) isORExpression(expr *parser.Expression) bool <span class="cov10" title="58">{
        if expr == nil </span><span class="cov8" title="32">{
                return false
        }</span>

        // 检查顶层运算符是否是OR
        <span class="cov8" title="26">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "or" </span><span class="cov0" title="0">{
                return true
        }</span>

        // 递归检查子表达式
        <span class="cov8" title="26">if r.isORExpression(expr.Left) || r.isORExpression(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="26">return false</span>
}

// Explain 解释规则应用
func (r *EnhancedPredicatePushdownRule) Explain(result LogicalPlan) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "EnhancedPredicatePushdown: Applied, result type: %T",
                result,
        )
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package optimizer

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/builtin"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// ExpressionEvaluator 表达式求值器
type ExpressionEvaluator struct {
        functionAPI *builtin.FunctionAPI
}

// NewExpressionEvaluator 创建表达式求值器
func NewExpressionEvaluator(fnAPI *builtin.FunctionAPI) *ExpressionEvaluator <span class="cov1" title="1">{
        return &amp;ExpressionEvaluator{
                functionAPI: fnAPI,
        }
}</span>

// NewExpressionEvaluatorWithoutAPI 创建不依赖函数API的表达式求值器
// 用于不需要调用函数的场景（如常量折叠）
func NewExpressionEvaluatorWithoutAPI() *ExpressionEvaluator <span class="cov10" title="150">{
        return &amp;ExpressionEvaluator{
                functionAPI: nil,
        }
}</span>

// Evaluate 计算表达式的值
func (e *ExpressionEvaluator) Evaluate(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov5" title="10">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov5" title="10">switch expr.Type </span>{
        case parser.ExprTypeColumn:<span class="cov0" title="0">
                // 列引用
                if val, exists := row[expr.Column]; exists </span><span class="cov0" title="0">{
                        return val, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("column not found: %s", expr.Column)</span>

        case parser.ExprTypeValue:<span class="cov4" title="6">
                // 字面量值
                return expr.Value, nil</span>

        case parser.ExprTypeOperator:<span class="cov2" title="3">
                // 运算符表达式
                return e.evaluateOperator(expr, row)</span>

        case parser.ExprTypeFunction:<span class="cov1" title="1">
                // 函数调用
                return e.evaluateFunction(expr, row)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported expression type: %v", expr.Type)</span>
        }
}

// evaluateOperator 计算运算符表达式
func (e *ExpressionEvaluator) evaluateOperator(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov2" title="3">{
        if expr.Operator == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operator is empty")
        }</span>

        // 处理逻辑运算符
        <span class="cov2" title="3">if strings.EqualFold(expr.Operator, "and") || strings.EqualFold(expr.Operator, "or") </span><span class="cov0" title="0">{
                return e.evaluateLogicalOp(expr, row)
        }</span>

        // 处理一元运算符
        <span class="cov2" title="3">if expr.Right == nil </span><span class="cov0" title="0">{
                return e.evaluateUnaryOp(expr, row)
        }</span>

        // 处理二元运算符
        <span class="cov2" title="3">if expr.Left == nil || expr.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid operator expression: missing operand")
        }</span>

        <span class="cov2" title="3">left, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left operand evaluation failed: %w", err)
        }</span>

        <span class="cov2" title="3">right, err := e.Evaluate(expr.Right, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right operand evaluation failed: %w", err)
        }</span>

        // 根据运算符类型计算
        <span class="cov2" title="3">switch strings.ToLower(expr.Operator) </span>{
        case "=":<span class="cov0" title="0">
                return e.compareValues(left, right) == 0, nil</span>
        case "!=", "&lt;&gt;":<span class="cov0" title="0">
                return e.compareValues(left, right) != 0, nil</span>
        case "&gt;":<span class="cov0" title="0">
                return e.compareValues(left, right) &gt; 0, nil</span>
        case "&gt;=":<span class="cov0" title="0">
                return e.compareValues(left, right) &gt;= 0, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return e.compareValues(left, right) &lt; 0, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return e.compareValues(left, right) &lt;= 0, nil</span>
        case "+", "plus":<span class="cov1" title="1">
                return e.addValues(left, right)</span>
        case "-", "minus":<span class="cov0" title="0">
                return e.subValues(left, right)</span>
        case "*", "mul":<span class="cov1" title="1">
                return e.mulValues(left, right)</span>
        case "/", "div":<span class="cov1" title="1">
                return e.divValues(left, right)</span>
        case "like":<span class="cov0" title="0">
                return e.likeValues(left, right), nil</span>
        case "not like":<span class="cov0" title="0">
                return !e.likeValues(left, right), nil</span>
        case "in":<span class="cov0" title="0">
                return e.inValues(left, right), nil</span>
        case "not in":<span class="cov0" title="0">
                return !e.inValues(left, right), nil</span>
        case "between":<span class="cov0" title="0">
                if vals, ok := right.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov0" title="0">{
                        return e.betweenValues(left, vals[0], vals[1]), nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported operator: %s", expr.Operator)</span>
        }
}

// evaluateLogicalOp 计算逻辑运算符
func (e *ExpressionEvaluator) evaluateLogicalOp(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Left == nil || expr.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid logical operator expression")
        }</span>

        <span class="cov0" title="0">left, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 短路求值
        <span class="cov0" title="0">if strings.EqualFold(expr.Operator, "and") </span><span class="cov0" title="0">{
                if !e.isTrue(left) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">right, err := e.Evaluate(expr.Right, row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return e.isTrue(right), nil</span>
        }

        // OR
        <span class="cov0" title="0">if e.isTrue(left) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">right, err := e.Evaluate(expr.Right, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return e.isTrue(right), nil</span>
}

// evaluateUnaryOp 计算一元运算符
func (e *ExpressionEvaluator) evaluateUnaryOp(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov0" title="0">{
        if expr.Left == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid unary operator expression: missing operand")
        }</span>

        <span class="cov0" title="0">operand, err := e.Evaluate(expr.Left, row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch strings.ToLower(expr.Operator) </span>{
        case "-":<span class="cov0" title="0">
                // 负号
                if num, ok := toFloat64(operand); ok </span><span class="cov0" title="0">{
                        return -num, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot apply unary minus to non-numeric value")</span>
        case "+":<span class="cov0" title="0">
                // 正号
                return operand, nil</span>
        case "not":<span class="cov0" title="0">
                // 逻辑非
                return !e.isTrue(operand), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported unary operator: %s", expr.Operator)</span>
        }
}

// evaluateFunction 计算函数调用（支持自定义函数）
func (e *ExpressionEvaluator) evaluateFunction(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov1" title="1">{
        if expr.Function == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function name is empty")
        }</span>

        // 转换为小写以支持大小写不敏感的函数名
        <span class="cov1" title="1">funcName := strings.ToLower(expr.Function)

        // 优先从FunctionAPI获取函数（包括内置和用户函数）
        if e.functionAPI == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function API not initialized")
        }</span>

        <span class="cov1" title="1">info, err := e.functionAPI.GetFunction(funcName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function not found: %s", expr.Function)
        }</span>

        // 计算参数（带类型检查）
        <span class="cov1" title="1">args := make([]interface{}, 0, len(expr.Args))
        for i, argExpr := range expr.Args </span><span class="cov0" title="0">{
                argValue, err := e.Evaluate(&amp;argExpr, row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument %d evaluation failed for function %s: %w", i, expr.Function, err)
                }</span>

                // 类型检查和自动转换
                <span class="cov0" title="0">convertedValue, err := e.convertToExpectedType(argValue, info.Parameters, i)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument %d type conversion failed for function %s: %w", i, expr.Function, err)
                }</span>
                <span class="cov0" title="0">args = append(args, convertedValue)</span>
        }

        // 调用函数处理函数
        <span class="cov1" title="1">result, err := info.Handler(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s execution failed: %w", expr.Function, err)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// convertToExpectedType 将值转换为期望的类型
func (e *ExpressionEvaluator) convertToExpectedType(value interface{}, params []builtin.FunctionParam, argIndex int) (interface{}, error) <span class="cov0" title="0">{
        if argIndex &gt;= len(params) </span><span class="cov0" title="0">{
                return value, nil // 参数数量不匹配，返回原值
        }</span>

        <span class="cov0" title="0">expectedType := params[argIndex].Type

        // 如果期望类型为空或值为nil，直接返回
        if expectedType == "" || value == nil </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // 类型转换映射
        <span class="cov0" title="0">switch expectedType </span>{
        case "int", "integer":<span class="cov0" title="0">
                return e.toInt(value)</span>
        case "bigint", "long":<span class="cov0" title="0">
                return e.toInt64(value)</span>
        case "decimal", "numeric", "number":<span class="cov0" title="0">
                return e.toFloat64(value)</span>
        case "varchar", "char", "text", "string":<span class="cov0" title="0">
                return e.toString(value)</span>
        default:<span class="cov0" title="0">
                return value, nil</span> // 未知类型，返回原值
        }
}

// exists 检查值是否存在（替代 ! 运算符）
func (e *ExpressionEvaluator) exists(v interface{}) bool <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch v.(type) </span>{
        case string:<span class="cov0" title="0">
                return len(v.(string)) &gt; 0</span>
        case []interface{}:<span class="cov0" title="0">
                return len(v.([]interface{})) &gt; 0</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return len(v.(map[string]interface{})) &gt; 0</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// toInt 转换为int
func (e *ExpressionEvaluator) toInt(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to int")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return val, nil</span>
        case int8:<span class="cov0" title="0">
                return int(val), nil</span>
        case int16:<span class="cov0" title="0">
                return int(val), nil</span>
        case int32:<span class="cov0" title="0">
                return int(val), nil</span>
        case int64:<span class="cov0" title="0">
                return int(val), nil</span>
        case float32:<span class="cov0" title="0">
                return int(float64(val)), nil</span>
        case float64:<span class="cov0" title="0">
                return int(val), nil</span>
        case string:<span class="cov0" title="0">
                // 尝试解析字符串
                var result int
                _, err := fmt.Sscanf(val, "%d", &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot convert string '%s' to int: %v", val, err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to int", reflect.TypeOf(v))</span>
        }
}

// toInt64 转换为int64
func (e *ExpressionEvaluator) toInt64(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to int64")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return int64(val), nil</span>
        case int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32:<span class="cov0" title="0">
                return int64(val), nil</span>
        case float64:<span class="cov0" title="0">
                return int64(val), nil</span>
        case string:<span class="cov0" title="0">
                // 尝试解析字符串
                var result int64
                _, err := fmt.Sscanf(val, "%d", &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot convert string '%s' to int64: %v", val, err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to int64", reflect.TypeOf(v))</span>
        }
}

// toFloat64 转换为float64
func (e *ExpressionEvaluator) toFloat64(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert nil to float64")
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case int:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(val), nil</span>
        case float32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case float64:<span class="cov0" title="0">
                return val, nil</span>
        case string:<span class="cov0" title="0">
                result, err := strconv.ParseFloat(val, 64)
                if err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                // 尝试解析整数
                <span class="cov0" title="0">var intResult int64
                _, intErr := fmt.Sscanf(val, "%d", &amp;intResult)
                if intErr == nil </span><span class="cov0" title="0">{
                        return float64(intResult), nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert %T to float64", reflect.TypeOf(v))</span>
        }
}

// toString 转换为string
func (e *ExpressionEvaluator) toString(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", val), nil</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val), nil</span>
        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", val), nil</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val), nil</span>
        }
}

// compareValues 比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func (e *ExpressionEvaluator) compareValues(a, b interface{}) int <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // 尝试数值比较
        <span class="cov0" title="0">aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                if aNum &lt; bNum </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aNum &gt; bNum </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // 字符串比较
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// addValues 加法运算
func (e *ExpressionEvaluator) addValues(a, b interface{}) (interface{}, error) <span class="cov1" title="1">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov1" title="1">{
                return aNum + bNum, nil
        }</span>

        // 字符串连接
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        return aStr + bStr, nil</span>
}

// subValues 减法运算
func (e *ExpressionEvaluator) subValues(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov0" title="0">{
                return aNum - bNum, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("cannot subtract non-numeric values")</span>
}

// mulValues 乘法运算
func (e *ExpressionEvaluator) mulValues(a, b interface{}) (interface{}, error) <span class="cov1" title="1">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if aOk &amp;&amp; bOk </span><span class="cov1" title="1">{
                return aNum * bNum, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("cannot multiply non-numeric values")</span>
}

// divValues 除法运算
func (e *ExpressionEvaluator) divValues(a, b interface{}) (interface{}, error) <span class="cov1" title="1">{
        aNum, aOk := toFloat64(a)
        bNum, bOk := toFloat64(b)
        if !aOk || !bOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot divide non-numeric values")
        }</span>
        <span class="cov1" title="1">if bNum == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division by zero")
        }</span>
        <span class="cov1" title="1">return aNum / bNum, nil</span>
}

// likeValues LIKE 模式匹配
func (e *ExpressionEvaluator) likeValues(value, pattern interface{}) bool <span class="cov0" title="0">{
        valStr := fmt.Sprintf("%v", value)
        patStr := fmt.Sprintf("%v", pattern)

        // 简单的LIKE实现：支持 % 和 _ 通配符
        patternRegex := strings.ReplaceAll(patStr, "%", ".*")
        patternRegex = strings.ReplaceAll(patternRegex, "_", ".")
        patternRegex = "^" + patternRegex + "$"

        // 注意：完整的实现应该使用正则表达式包
        // 这里简化为使用strings.Contains和通配符匹配
        if !strings.Contains(patStr, "%") &amp;&amp; !strings.Contains(patStr, "_") </span><span class="cov0" title="0">{
                return valStr == patStr
        }</span>

        // 简化实现：只检查是否包含
        <span class="cov0" title="0">if strings.HasPrefix(patStr, "%") &amp;&amp; strings.HasSuffix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.Trim(patStr, "%")
                return strings.Contains(valStr, subPat)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.TrimPrefix(patStr, "%")
                return strings.HasSuffix(valStr, subPat)
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(patStr, "%") </span><span class="cov0" title="0">{
                subPat := strings.TrimSuffix(patStr, "%")
                return strings.HasPrefix(valStr, subPat)
        }</span>

        <span class="cov0" title="0">return false</span>
}

// inValues IN 操作
func (e *ExpressionEvaluator) inValues(value, values interface{}) bool <span class="cov0" title="0">{
        valList, ok := values.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, v := range valList </span><span class="cov0" title="0">{
                if e.compareValues(value, v) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// betweenValues BETWEEN 操作
func (e *ExpressionEvaluator) betweenValues(value, min, max interface{}) bool <span class="cov0" title="0">{
        return e.compareValues(value, min) &gt;= 0 &amp;&amp; e.compareValues(value, max) &lt;= 0
}</span>

// isTrue 判断值是否为真
func (e *ExpressionEvaluator) isTrue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Int() != 0</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Uint() != 0</span>
        case float32, float64:<span class="cov0" title="0">
                return reflect.ValueOf(v).Float() != 0</span>
        case string:<span class="cov0" title="0">
                return v != ""</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package optimizer

import (
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// IsFilterable 检查数据源是否支持过滤能力
//
// 该函数通过类型断言检测数据源是否实现了 FilterableDataSource 接口。
// 如果数据源支持过滤，优化器可以将过滤条件下推到数据源层面，
// 避免将所有数据加载到内存后再过滤。
//
// 参数:
//   - ds: 数据源实例
//
// 返回:
//   - true: 数据源支持过滤能力
//   - false: 数据源不支持过滤能力，需要在内存中过滤
//
// 使用示例:
//
//        if optimizer.IsFilterable(dataSource) {
//            // 将过滤器下推到数据源
//            rows, total, err := filterableDS.Filter(ctx, tableName, filter, offset, limit)
//        } else {
//            // 在内存中过滤
//            result, err := dataSource.Query(ctx, tableName, &amp;domain.QueryOptions{})
//            rows = applyFilters(result.Rows, filter)
//        }
func IsFilterable(ds domain.DataSource) bool <span class="cov10" title="3">{
        _, ok := ds.(domain.FilterableDataSource)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package index

import (
        "fmt"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/optimizer/statistics"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// IndexSelector 索引选择器
// 选择最优索引用于查询执行
type IndexSelector struct {
        estimator    statistics.CardinalityEstimator
        indexManager *IndexManager
}

// IndexManager 索引管理器
type IndexManager struct {
        indices map[string][]*Index // table_name -&gt; indices
}

// Index 索引定义
type Index struct {
        Name       string
        TableName  string
        Columns    []string
        Unique     bool
        Primary    bool
        Cardinality int64 // 基数
        IndexType  IndexType
}

// IndexType 索引类型
type IndexType int

const (
        BTreeIndex IndexType = iota
        HashIndex
        BitmapIndex
        FullTextIndex
)

// NewIndexManager 创建索引管理器
func NewIndexManager() *IndexManager <span class="cov10" title="19">{
        return &amp;IndexManager{
                indices: make(map[string][]*Index),
        }
}</span>

// NewIndexSelector 创建索引选择器
func NewIndexSelector(estimator statistics.CardinalityEstimator) *IndexSelector <span class="cov9" title="15">{
        return &amp;IndexSelector{
                estimator:    estimator,
                indexManager: NewIndexManager(),
        }
}</span>

// SelectBestIndex 选择最佳索引
func (is *IndexSelector) SelectBestIndex(tableName string, filters []domain.Filter, requiredCols []string) *IndexSelection <span class="cov5" title="5">{
        // 获取表的所有索引
        indices := is.indexManager.GetIndices(tableName)
        if len(indices) == 0 </span><span class="cov1" title="1">{
                return &amp;IndexSelection{
                        SelectedIndex: nil,
                        Reason:        "No available index",
                        Cost:          math.MaxFloat64,
                }
        }</span>

        // 评估每个索引
        <span class="cov5" title="4">bestIndex := is.evaluateIndexes(tableName, filters, requiredCols, indices)
        
        return bestIndex</span>
}

// evaluateIndexes 评估所有可用索引
func (is *IndexSelector) evaluateIndexes(tableName string, filters []domain.Filter, requiredCols []string, indices []*Index) *IndexSelection <span class="cov5" title="5">{
        var bestIndex *IndexSelection
        bestIndex = &amp;IndexSelection{
                Cost: math.MaxFloat64,
        }

        for _, idx := range indices </span><span class="cov6" title="7">{
                evaluation := is.evaluateIndex(tableName, filters, requiredCols, idx)
                
                if evaluation.Cost &lt; bestIndex.Cost </span><span class="cov5" title="5">{
                        bestIndex = evaluation
                }</span>
        }

        <span class="cov5" title="5">return bestIndex</span>
}

// evaluateIndex 评估单个索引
func (is *IndexSelector) evaluateIndex(tableName string, filters []domain.Filter, requiredCols []string, idx *Index) *IndexSelection <span class="cov7" title="8">{
        // 1. 检查索引是否可用
        if !is.isIndexUsable(tableName, filters, idx) </span><span class="cov4" title="3">{
                return &amp;IndexSelection{
                        SelectedIndex: nil,
                        Reason:        "Index not usable for given filters",
                        Cost:          math.MaxFloat64,
                }
        }</span>

        // 2. 计算索引扫描成本
        <span class="cov5" title="5">scanCost := is.estimateIndexScanCost(tableName, filters, idx)

        // 3. 检查索引覆盖性
        isCovering := is.isCoveringIndex(requiredCols, idx)
        
        // 4. 计算总成本
        totalCost := scanCost
        if !isCovering </span><span class="cov1" title="1">{
                // 非覆盖索引需要回表查询
                totalCost += is.estimateTableLookupCost(tableName)
        }</span>

        // 5. 生成选择理由
        <span class="cov5" title="5">reason := is.generateSelectionReason(idx, filters, isCovering, scanCost)

        return &amp;IndexSelection{
                SelectedIndex: idx,
                IsCovering:     isCovering,
                EstimatedRows:    is.estimateIndexRows(tableName, filters, idx),
                Cost:            totalCost,
                Reason:           reason,
        }</span>
}

// isIndexUsable 检查索引是否可用
func (is *IndexSelector) isIndexUsable(tableName string, filters []domain.Filter, idx *Index) bool <span class="cov8" title="11">{
        // 至少有一个过滤条件匹配索引的前导列
        for _, filter := range filters </span><span class="cov8" title="10">{
                for i, col := range idx.Columns </span><span class="cov8" title="10">{
                        if filter.Field == col </span><span class="cov6" title="6">{
                                // 找到匹配的列，检查是否是前导列
                                if i == 0 </span><span class="cov6" title="6">{
                                        return true // 前导列匹配
                                }</span>
                                // 简化：如果不是前导列，也可以使用（实际应该更严格）
                                <span class="cov0" title="0">return true</span>
                        }
                }
        }

        <span class="cov5" title="5">return len(filters) == 0</span>
}

// estimateIndexScanCost 估算索引扫描成本
func (is *IndexSelector) estimateIndexScanCost(tableName string, filters []domain.Filter, idx *Index) float64 <span class="cov6" title="6">{
        // 获取基估计
        stats, err := is.estimator.GetStatistics(tableName)
        if err != nil </span><span class="cov0" title="0">{
                // 使用默认估算
                return 100.0
        }</span>

        // 估算选择性
        <span class="cov6" title="6">selectivity := is.estimateIndexSelectivity(filters, idx, stats)
        estimatedRows := float64(stats.RowCount) * selectivity

        // 索引扫描成本 = 索引高度 + 叶子节点访问
        indexHeight := is.estimateIndexHeight(idx, stats)
        leafAccess := estimatedRows * 0.01 // IO成本

        scanCost := float64(indexHeight) + leafAccess

        return scanCost</span>
}

// estimateIndexRows 估算索引扫描的行数
func (is *IndexSelector) estimateIndexRows(tableName string, filters []domain.Filter, idx *Index) float64 <span class="cov6" title="6">{
        stats, err := is.estimator.GetStatistics(tableName)
        if err != nil </span><span class="cov0" title="0">{
                return 100.0
        }</span>

        <span class="cov6" title="6">selectivity := is.estimateIndexSelectivity(filters, idx, stats)
        return float64(stats.RowCount) * selectivity</span>
}

// estimateIndexSelectivity 估算索引的选择性
func (is *IndexSelector) estimateIndexSelectivity(filters []domain.Filter, idx *Index, stats *statistics.TableStatistics) float64 <span class="cov8" title="12">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // 使用直方图估算选择性
        <span class="cov8" title="12">totalSelectivity := 1.0
        for _, filter := range filters </span><span class="cov8" title="12">{
                // 检查过滤条件是否在索引的列上
                colInIndex := false
                for _, col := range idx.Columns </span><span class="cov8" title="12">{
                        if filter.Field == col </span><span class="cov8" title="12">{
                                colInIndex = true
                                break</span>
                        }
                }

                <span class="cov8" title="12">if colInIndex </span><span class="cov8" title="12">{
                        // 使用列的直方图
                        if histogram, exists := stats.Histograms[filter.Field]; exists </span><span class="cov0" title="0">{
                                sel := histogram.EstimateSelectivity(filter)
                                totalSelectivity *= sel
                        }</span> else<span class="cov8" title="12"> if colStats, exists := stats.ColumnStats[filter.Field]; exists </span><span class="cov8" title="12">{
                                // 回退到NDV
                                sel := 1.0 / float64(colStats.DistinctCount)
                                totalSelectivity *= sel
                        }</span>
                }
        }

        <span class="cov8" title="12">return totalSelectivity</span>
}

// isCoveringIndex 检查是否是覆盖索引
func (is *IndexSelector) isCoveringIndex(requiredCols []string, idx *Index) bool <span class="cov7" title="9">{
        if len(requiredCols) == 0 </span><span class="cov1" title="1">{
                return false
        }</span>

        // 检查所有需要的列是否都在索引中
        <span class="cov7" title="8">coveredCount := 0
        for _, reqCol := range requiredCols </span><span class="cov9" title="14">{
                for _, idxCol := range idx.Columns </span><span class="cov9" title="18">{
                        if reqCol == idxCol </span><span class="cov8" title="10">{
                                coveredCount++
                                break</span>
                        }
                }
        }

        // 覆盖索引包含所有需要的列
        <span class="cov7" title="8">return coveredCount == len(requiredCols)</span>
}

// estimateTableLookupCost 估算表查找成本
func (is *IndexSelector) estimateTableLookupCost(tableName string) float64 <span class="cov1" title="1">{
        // 随机表查找：通常需要10-20次IO
        return 15.0
}</span>

// estimateIndexHeight 估算索引高度
func (is *IndexSelector) estimateIndexHeight(idx *Index, stats *statistics.TableStatistics) int <span class="cov8" title="10">{
        if idx.Cardinality &gt; 0 </span><span class="cov7" title="9">{
                // 基于B+树的高度 ≈ log2(基数)
                height := math.Ceil(math.Log2(float64(idx.Cardinality)))
                return int(math.Max(2, height))
        }</span>

        // 使用表的NDV
        <span class="cov1" title="1">for _, col := range idx.Columns </span><span class="cov0" title="0">{
                if colStats, exists := stats.ColumnStats[col]; exists &amp;&amp; colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        height := math.Ceil(math.Log2(float64(colStats.DistinctCount)))
                        return int(math.Max(2, height))
                }</span>
        }

        <span class="cov1" title="1">return 3</span> // 默认高度
}

// generateSelectionReason 生成索引选择理由
func (is *IndexSelector) generateSelectionReason(idx *Index, filters []domain.Filter, isCovering bool, scanCost float64) string <span class="cov6" title="7">{
        reason := fmt.Sprintf("Selected index '%s'", idx.Name)
        
        if isCovering </span><span class="cov5" title="5">{
                reason += " (covering index)"
        }</span>

        <span class="cov6" title="7">reason += fmt.Sprintf(" with estimated cost %.2f", scanCost)
        
        if len(filters) &gt; 0 </span><span class="cov6" title="7">{
                reason += fmt.Sprintf(" for %d filter condition(s)", len(filters))
        }</span>

        <span class="cov6" title="7">return reason</span>
}

// AddIndex 添加索引定义
func (im *IndexManager) AddIndex(index *Index) <span class="cov8" title="10">{
        if im.indices == nil </span><span class="cov0" title="0">{
                im.indices = make(map[string][]*Index)
        }</span>
        <span class="cov8" title="10">im.indices[index.TableName] = append(im.indices[index.TableName], index)</span>
}

// GetIndices 获取表的所有索引
func (im *IndexManager) GetIndices(tableName string) []*Index <span class="cov8" title="10">{
        if im.indices == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="10">if indices, exists := im.indices[tableName]; exists </span><span class="cov6" title="7">{
                return indices
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// FindIndexByName 根据名称查找索引
func (im *IndexManager) FindIndexByName(tableName, indexName string) *Index <span class="cov4" title="3">{
        indices := im.GetIndices(tableName)
        for _, idx := range indices </span><span class="cov3" title="2">{
                if idx.Name == indexName </span><span class="cov1" title="1">{
                        return idx
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// IndexSelection 索引选择结果
type IndexSelection struct {
        SelectedIndex  *Index
        IsCovering    bool
        EstimatedRows float64
        Cost           float64
        Reason         string
}

// String 返回选择的字符串表示
func (is *IndexSelection) String() string <span class="cov4" title="3">{
        if is.SelectedIndex == nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("NoIndexSelected(cost=%.2f, reason=%s)", is.Cost, is.Reason)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("IndexSelected(%s, covering=%v, cost=%.2f, reason=%s)",
                is.SelectedIndex.Name, is.IsCovering, is.Cost, is.Reason)</span>
}

// Explain 返回详细的索引选择说明
func (is *IndexSelector) Explain(tableName string, filters []domain.Filter, requiredCols []string) string <span class="cov1" title="1">{
        selection := is.SelectBestIndex(tableName, filters, requiredCols)
        
        explanation := fmt.Sprintf("=== Index Selection for '%s' ===\n", tableName)
        explanation += fmt.Sprintf("Required Columns: %v\n", requiredCols)
        explanation += fmt.Sprintf("Filters: %d\n\n", len(filters))
        
        for i, filter := range filters </span><span class="cov1" title="1">{
                explanation += fmt.Sprintf("  Filter %d: %s %s %v\n", i+1, filter.Field, filter.Operator, filter.Value)
        }</span>
        
        <span class="cov1" title="1">explanation += fmt.Sprintf("\nSelected: %s\n", selection.String())
        explanation += fmt.Sprintf("Estimated Rows: %.0f\n", selection.EstimatedRows)
        
        return explanation</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package join

import (
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/optimizer/cost"
)

// BushyJoinTreeBuilder Bushy Join Tree构建器
// 支持非线性（bushy）的JOIN树，提升多表JOIN性能
type BushyJoinTreeBuilder struct {
        costModel   *cost.AdaptiveCostModel
        estimator   interface{} // 使用 interface{} 避免循环导入
        maxBushiness int       // 最大Bushiness参数
}

// NewBushyJoinTreeBuilder 创建Bushy JOIN Tree构建器
func NewBushyJoinTreeBuilder(costModel *cost.AdaptiveCostModel, estimator interface{}, maxBushiness int) *BushyJoinTreeBuilder <span class="cov10" title="21">{
        return &amp;BushyJoinTreeBuilder{
                costModel:   costModel,
                estimator:   estimator,
                maxBushiness: maxBushiness,
        }
}</span>

// BuildBushyTree 构建Bushy JOIN Tree
func (bjtb *BushyJoinTreeBuilder) BuildBushyTree(tables []string, joinNodes interface{}) interface{} <span class="cov9" title="19">{
        n := len(tables)
        if n &lt; 3 </span><span class="cov5" title="5">{
                // 少于3个表，线性树就是最优的
                return nil
        }</span>

        <span class="cov8" title="14">fmt.Printf("  [BUSHY TREE] Building bushy tree for %d tables (maxBushiness=%d)\n", n, bjtb.maxBushiness)

        // 简化实现：暂时返回nil
        // 完整的Bushy Tree实现比较复杂，需要：
        // 1. 使用动态规划枚举所有JOIN顺序
        // 2. 考虑非线性（bushy）的连接方式
        // 3. 基于成本模型选择最优方案

        return nil</span>
}

// Explain 解释Bushy Tree构建器
func (bjtb *BushyJoinTreeBuilder) Explain() string <span class="cov6" title="6">{
        return fmt.Sprintf(
                "BushyJoinTreeBuilder(maxBushiness=%d)",
                bjtb.maxBushiness,
        )
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package join

import (
        "context"
        "fmt"
        "math"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalPlan 逻辑计划接口（避免循环依赖）
type LogicalPlan interface {
        Children() []LogicalPlan
        Explain() string
}

// JoinType JOIN类型
type JoinType int

const (
        InnerJoin JoinType = iota
        LeftOuterJoin
        RightOuterJoin
        FullOuterJoin
)

// CostModel 成本模型接口
type CostModel interface {
        ScanCost(tableName string, rowCount int64, useIndex bool) float64
        JoinCost(left, right LogicalPlan, joinType JoinType, conditions []*parser.Expression) float64
}

// CardinalityEstimator 基数估算器接口
type CardinalityEstimator interface {
        EstimateTableScan(tableName string) int64
}

// DPJoinReorder DP算法JOIN重排序器
// 使用动态规划算法寻找最优JOIN顺序
type DPJoinReorder struct {
        costModel   CostModel
        estimator   CardinalityEstimator
        maxTables    int // 最大表数量限制
        cache        *ReorderCache
}

// ReorderCache 重排序缓存
type ReorderCache struct {
        mu    sync.RWMutex
        cache  map[string]*ReorderResult
}

// ReorderResult 重排序结果
type ReorderResult struct {
        Order        []string
        Cost         float64
        JoinTreeType string // "left-deep", "right-deep", "bushy"
        Plan         LogicalPlan
}

// NewDPJoinReorder 创建DP JOIN重排序器
func NewDPJoinReorder(costModel CostModel, estimator CardinalityEstimator, maxTables int) *DPJoinReorder <span class="cov8" title="18">{
        return &amp;DPJoinReorder{
                costModel:   costModel,
                estimator:   estimator,
                maxTables:    maxTables,
                cache:        NewReorderCache(1000), // 最多缓存1000个结果
        }
}</span>

// Reorder JOIN重排序（入口函数）
func (dpr *DPJoinReorder) Reorder(ctx context.Context, plan LogicalPlan) (LogicalPlan, error) <span class="cov3" title="3">{
        // 收集所有JOIN节点和涉及的表
        joinNodes, tables := dpr.collectJoinNodes(plan)
        if len(tables) &lt; 2 </span><span class="cov3" title="3">{
                return plan, nil // 不需要重排序
        }</span>

        <span class="cov0" title="0">if len(tables) &gt; dpr.maxTables </span><span class="cov0" title="0">{
                // 超过限制，使用贪心算法
                plan := dpr.greedyReorder(tables, joinNodes)
                return plan, nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("  [JOIN REORDER] Reordering %d tables\n", len(tables))

        // 使用DP算法找最优顺序
        result := dpr.dpSearch(tables, joinNodes)

        if result.Plan != nil </span><span class="cov0" title="0">{
                fmt.Printf("  [JOIN REORDER] Found optimal order: %v, cost=%.2f\n", result.Order, result.Cost)
                return result.Plan, nil
        }</span>

        // DP未找到解，使用贪心算法
        <span class="cov0" title="0">plan = dpr.greedyReorder(tables, joinNodes)
        return plan, nil</span>
}

// collectJoinNodes 收集所有JOIN节点和表名
func (dpr *DPJoinReorder) collectJoinNodes(plan LogicalPlan) ([]LogicalPlan, []string) <span class="cov4" title="4">{
        joinNodes := []LogicalPlan{}
        tables := map[string]bool{}

        dpr.collectJoinsRecursive(plan, &amp;joinNodes, tables)

        tableList := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov4" title="4">{
                tableList = append(tableList, table)
        }</span>

        <span class="cov4" title="4">return joinNodes, tableList</span>
}

// collectJoinsRecursive 递归收集JOIN节点
func (dpr *DPJoinReorder) collectJoinsRecursive(plan LogicalPlan, joinNodes *[]LogicalPlan, tables map[string]bool) <span class="cov8" title="17">{
        // 检查是否是JOIN节点（简化：检查节点类型或名称）
        if plan != nil &amp;&amp; len(plan.Children()) == 2 </span><span class="cov2" title="2">{
                // 假设这是JOIN节点
                *joinNodes = append(*joinNodes, plan)
                
                // 递归处理子节点
                for _, child := range plan.Children() </span><span class="cov4" title="4">{
                        dpr.collectJoinsRecursive(child, joinNodes, tables)
                }</span>
                <span class="cov2" title="2">return</span>
        }

        // 非JOIN节点，尝试提取表名
        // 简化：假设所有非JOIN节点都是数据源
        <span class="cov8" title="15">if plan != nil </span><span class="cov7" title="14">{
                // 这里简化处理，实际应该通过接口获取表名
                tables["unknown_table"] = true
        }</span>

        // 递归处理子节点
        <span class="cov8" title="15">if plan != nil </span><span class="cov7" title="14">{
                for _, child := range plan.Children() </span><span class="cov5" title="6">{
                        dpr.collectJoinsRecursive(child, joinNodes, tables)
                }</span>
        }
}

// dpSearch 使用动态规划搜索最优JOIN顺序
func (dpr *DPJoinReorder) dpSearch(tables []string, joinNodes []LogicalPlan) *ReorderResult <span class="cov2" title="2">{
        // 检查缓存
        cacheKey := dpr.generateCacheKey(tables)
        if cached := dpr.cache.Get(cacheKey); cached != nil </span><span class="cov0" title="0">{
                fmt.Printf("  [JOIN REORDER] Cache hit for key: %s\n", cacheKey)
                return cached
        }</span>

        <span class="cov2" title="2">n := len(tables)
        if n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // DP状态：dp[S][i] 表示使用表集合S的最优顺序
        <span class="cov2" title="2">dp := make(map[string]*DPState)
        
        // 初始化：单个表
        for _, table := range tables </span><span class="cov4" title="4">{
                key := table
                cost := dpr.estimateSingleTableCost(table)
                dp[key] = &amp;DPState{
                        Order: []string{table},
                        Cost:  cost,
                        Left:  "",
                        Right: "",
                }
        }</span>

        // 递归求解更大的表集合
        <span class="cov2" title="2">bestResult := dpr.solveDP(tables, dp, joinNodes)

        // 缓存结果
        dpr.cache.Set(cacheKey, bestResult)

        return bestResult</span>
}

// solveDP 递归求解DP问题
func (dpr *DPJoinReorder) solveDP(tables []string, dp map[string]*DPState, joinNodes []LogicalPlan) *ReorderResult <span class="cov4" title="4">{
        n := len(tables)
        if n == 1 </span><span class="cov1" title="1">{
                // 单个表，直接返回
                key := tables[0]
                if state, exists := dp[key]; exists </span><span class="cov1" title="1">{
                        return &amp;ReorderResult{
                                Order: state.Order,
                                Cost:  state.Cost,
                                Plan:  dpr.buildPlanFromOrder(state.Order, joinNodes),
                        }
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // 枚举所有表分割：S = A ∪ B, A ∩ B = ∅
        <span class="cov3" title="3">bestCost := math.MaxFloat64
        var bestOrder []string

        for i := 0; i &lt; n; i++ </span><span class="cov5" title="6">{
                // 生成所有2^n - 2个非空真子集（简化实现）
                for mask := 1; mask &lt; (1 &lt;&lt; uint(n)); mask++ </span><span class="cov8" title="18">{
                        if mask == 0 || mask == (1&lt;&lt;uint(n))-1 </span><span class="cov5" title="6">{
                                continue</span> // 跳过空集和全集
                        }

                        <span class="cov7" title="12">leftSet := []string{}
                        rightSet := []string{}
                        
                        for j := 0; j &lt; n; j++ </span><span class="cov9" title="24">{
                                if (mask &amp; (1 &lt;&lt; uint(j))) != 0 </span><span class="cov7" title="12">{
                                        leftSet = append(leftSet, tables[j])
                                }</span> else<span class="cov7" title="12"> {
                                        rightSet = append(rightSet, tables[j])
                                }</span>
                        }

                        <span class="cov7" title="12">if len(leftSet) == 0 || len(rightSet) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 递归求解左右子集
                        <span class="cov7" title="12">leftKey := dpr.generateCacheKey(leftSet)
                        rightKey := dpr.generateCacheKey(rightSet)

                        leftState := dp[leftKey]
                        rightState := dp[rightKey]

                        if leftState == nil || rightState == nil </span><span class="cov7" title="12">{
                                continue</span>
                        }

                        // 计算JOIN成本
                        <span class="cov0" title="0">joinCost := dpr.estimateJoinCost(leftSet, rightSet, joinNodes)

                        // 总成本 = 左边成本 + 右边成本 + JOIN成本
                        totalCost := leftState.Cost + rightState.Cost + joinCost

                        if totalCost &lt; bestCost </span><span class="cov0" title="0">{
                                bestCost = totalCost
                                bestOrder = append(leftState.Order, rightState.Order...)
                        }</span>
                }
        }

        <span class="cov3" title="3">if len(bestOrder) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;ReorderResult{
                        Order:        bestOrder,
                        Cost:         bestCost,
                        JoinTreeType: "bushy",
                        Plan:         dpr.buildPlanFromOrder(bestOrder, joinNodes),
                }
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// greedyReorder 贪心算法重排序（回退方案）
func (dpr *DPJoinReorder) greedyReorder(tables []string, joinNodes []LogicalPlan) LogicalPlan <span class="cov1" title="1">{
        if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">remainingTables := make([]string, len(tables))
        copy(remainingTables, tables)

        remainingCosts := make(map[string]float64)
        for _, table := range remainingTables </span><span class="cov3" title="3">{
                remainingCosts[table] = dpr.estimateSingleTableCost(table)
        }</span>

        <span class="cov1" title="1">order := []string{}
        totalCost := 0.0

        for len(remainingTables) &gt; 0 </span><span class="cov3" title="3">{
                // 选择最优表加入顺序
                bestTable := ""
                bestJoinCost := math.MaxFloat64

                // 尝试每个剩余表
                for _, table := range remainingTables </span><span class="cov5" title="6">{
                        // 计算将table加入当前顺序的成本
                        joinCost := dpr.estimateGreedyJoinCost(order, table, remainingCosts[table], joinNodes)
                        
                        if joinCost &lt; bestJoinCost </span><span class="cov3" title="3">{
                                bestJoinCost = joinCost
                                bestTable = table
                        }</span>
                }

                <span class="cov3" title="3">if bestTable == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                // 添加到顺序
                <span class="cov3" title="3">order = append(order, bestTable)
                totalCost += bestJoinCost + remainingCosts[bestTable]
                
                // 从剩余表中移除
                for i, t := range remainingTables </span><span class="cov3" title="3">{
                        if t == bestTable </span><span class="cov3" title="3">{
                                remainingTables = append(remainingTables[:i], remainingTables[i+1:]...)
                                break</span>
                        }
                }
        }

        <span class="cov1" title="1">fmt.Printf("  [JOIN REORDER] Greedy order: %v, cost=%.2f\n", order, totalCost)

        return dpr.buildPlanFromOrder(order, joinNodes)</span>
}

// estimateSingleTableCost 估算单个表的扫描成本
func (dpr *DPJoinReorder) estimateSingleTableCost(table string) float64 <span class="cov6" title="8">{
        return dpr.costModel.ScanCost(table, 10000, false) // 简化：使用默认行数
}</span>

// estimateJoinCost 估算JOIN成本
func (dpr *DPJoinReorder) estimateJoinCost(leftSet, rightSet []string, joinNodes []LogicalPlan) float64 <span class="cov2" title="2">{
        if len(leftSet) == 0 || len(rightSet) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        // 简化：假设等值连接，使用平均基数
        <span class="cov1" title="1">leftCard := 0.0
        rightCard := 0.0

        for _, table := range leftSet </span><span class="cov1" title="1">{
                leftCard += float64(dpr.estimator.EstimateTableScan(table))
        }</span>

        <span class="cov1" title="1">for _, table := range rightSet </span><span class="cov1" title="1">{
                rightCard += float64(dpr.estimator.EstimateTableScan(table))
        }</span>

        // 估算JOIN选择性（简化：假设10%）
        <span class="cov1" title="1">selectivity := 0.1
        joinCost := leftCard * rightCard * selectivity

        return joinCost</span>
}

// estimateGreedyJoinCost 估算贪心JOIN成本
func (dpr *DPJoinReorder) estimateGreedyJoinCost(currentOrder []string, newTable string, tableCost float64, joinNodes []LogicalPlan) float64 <span class="cov6" title="7">{
        if len(currentOrder) == 0 </span><span class="cov3" title="3">{
                return tableCost
        }</span>

        <span class="cov4" title="4">lastTable := currentOrder[len(currentOrder)-1]
        
        // 估算连接lastTable和newTable的成本
        leftCard := float64(dpr.estimator.EstimateTableScan(lastTable))
        rightCard := float64(dpr.estimator.EstimateTableScan(newTable))
        
        // 简化的JOIN成本估算
        joinCost := leftCard * rightCard * 0.1

        return joinCost</span>
}

// buildPlanFromOrder 根据表顺序构建JOIN树
func (dpr *DPJoinReorder) buildPlanFromOrder(order []string, joinNodes []LogicalPlan) LogicalPlan <span class="cov5" title="5">{
        if len(order) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // 简化：返回第一个数据源
        <span class="cov4" title="4">return dpr.buildDataSource(order[0])</span>
}

// buildDataSource 构建数据源节点
func (dpr *DPJoinReorder) buildDataSource(tableName string) LogicalPlan <span class="cov5" title="5">{
        // 简化：返回nil，实际应该创建数据源对象
        return nil
}</span>

// generateCacheKey 生成缓存键
func (dpr *DPJoinReorder) generateCacheKey(tables []string) string <span class="cov9" title="29">{
        if len(tables) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        <span class="cov9" title="28">key := ""
        for _, table := range tables </span><span class="cov10" title="32">{
                key += table + "|"
        }</span>
        <span class="cov9" title="28">return key</span>
}

// DPState DP状态
type DPState struct {
        Order []string
        Cost  float64
        Left  string
        Right string
}

// NewReorderCache 创建重排序缓存
func NewReorderCache(size int) *ReorderCache <span class="cov9" title="23">{
        return &amp;ReorderCache{
                cache: make(map[string]*ReorderResult),
        }
}</span>

// Get 获取缓存的排序结果
func (rc *ReorderCache) Get(key string) *ReorderResult <span class="cov8" title="17">{
        rc.mu.RLock()
        defer rc.mu.RUnlock()

        return rc.cache[key]
}</span>

// Set 设置缓存的排序结果
func (rc *ReorderCache) Set(key string, result *ReorderResult) <span class="cov8" title="16">{
        rc.mu.Lock()
        defer rc.mu.Unlock()

        rc.cache[key] = result
}</span>

// Clear 清空缓存
func (rc *ReorderCache) Clear() <span class="cov1" title="1">{
        rc.mu.Lock()
        defer rc.mu.Unlock()

        rc.cache = make(map[string]*ReorderResult)
}</span>

// Explain 解释重排序结果
func (dpr *DPJoinReorder) Explain(result *ReorderResult) string <span class="cov1" title="1">{
        if result == nil </span><span class="cov0" title="0">{
                return "No reorder result"
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf(
                "=== JOIN Reorder Result ===\n"+
                "Order: %v\n"+
                "Cost: %.2f\n"+
                "Tree Type: %s\n",
                result.Order, result.Cost, result.JoinTreeType,
        )</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package join

import (
        "fmt"
)

// JoinGraph JOIN关系图
// 用于表示表之间的连接关系，辅助JOIN重排序
type JoinGraph struct {
        nodes      map[string]*JoinNode      // table_name -&gt; node
        edges      []*JoinEdge              // 所有边
        edgeCount  int                      // 边数
}

// JoinNode JOIN图节点
type JoinNode struct {
        Name       string            // 表名
        Degree     int                // 度数（连接的边数）
        Edges      []*JoinEdge        // 连接的边
        Cardinality int64              // 表基数（可选）
}

// JoinEdge JOIN图边
type JoinEdge struct {
        From      string                // 起始表
        To        string                // 目标表
        JoinType  string                // 连接类型
        Cardinality float64             // 估算的基数
}

// NewJoinGraph 创建JOIN图
func NewJoinGraph() *JoinGraph <span class="cov0" title="0">{
        return &amp;JoinGraph{
                nodes:     make(map[string]*JoinNode),
                edges:     []*JoinEdge{},
                edgeCount: 0,
        }
}</span>

// AddNode 添加节点
func (jg *JoinGraph) AddNode(name string, cardinality int64) <span class="cov0" title="0">{
        if _, exists := jg.nodes[name]; !exists </span><span class="cov0" title="0">{
                jg.nodes[name] = &amp;JoinNode{
                        Name:       name,
                        Degree:     0,
                        Edges:      []*JoinEdge{},
                        Cardinality: cardinality,
                }
        }</span>
}

// AddEdge 添加边（连接关系）
func (jg *JoinGraph) AddEdge(from, to, joinType string, cardinality float64) <span class="cov0" title="0">{
        // 添加边
        edge := &amp;JoinEdge{
                From:      from,
                To:        to,
                JoinType:  joinType,
                Cardinality: cardinality,
        }
        jg.edges = append(jg.edges, edge)
        jg.edgeCount++

        // 更新节点度数
        if fromNode, exists := jg.nodes[from]; exists </span><span class="cov0" title="0">{
                fromNode.Degree++
                fromNode.Edges = append(fromNode.Edges, edge)
        }</span>

        <span class="cov0" title="0">if toNode, exists := jg.nodes[to]; exists </span><span class="cov0" title="0">{
                toNode.Degree++
        }</span>
}

// GetNode 获取节点
func (jg *JoinGraph) GetNode(name string) *JoinNode <span class="cov0" title="0">{
        return jg.nodes[name]
}</span>

// GetNeighbors 获取节点的邻居
func (jg *JoinGraph) GetNeighbors(name string) []string <span class="cov0" title="0">{
        node := jg.GetNode(name)
        if node == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">neighbors := make([]string, 0, len(node.Edges))
        for _, edge := range node.Edges </span><span class="cov0" title="0">{
                if edge.From == name </span><span class="cov0" title="0">{
                        neighbors = append(neighbors, edge.To)
                }</span>
        }

        <span class="cov0" title="0">return neighbors</span>
}

// GetConnectedComponents 获取连通分量
func (jg *JoinGraph) GetConnectedComponents() [][]string <span class="cov0" title="0">{
        visited := make(map[string]bool)
        components := [][]string{}

        for name := range jg.nodes </span><span class="cov0" title="0">{
                if !visited[name] </span><span class="cov0" title="0">{
                        component := jg.bfs(name, visited)
                        if len(component) &gt; 0 </span><span class="cov0" title="0">{
                                components = append(components, component)
                        }</span>
                }
        }

        <span class="cov0" title="0">return components</span>
}

// BFS 广度优先搜索
func (jg *JoinGraph) bfs(start string, visited map[string]bool) []string <span class="cov0" title="0">{
        queue := []string{start}
        visited[start] = true
        component := []string{}

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]
                component = append(component, current)

                // 遍历邻居
                for _, neighbor := range jg.GetNeighbors(current) </span><span class="cov0" title="0">{
                        if !visited[neighbor] </span><span class="cov0" title="0">{
                                visited[neighbor] = true
                                queue = append(queue, neighbor)
                        }</span>
                }
        }

        <span class="cov0" title="0">return component</span>
}

// FindMinSpanningTree 查找最小生成树（Kruskal算法）
func (jg *JoinGraph) FindMinSpanningTree() []*JoinEdge <span class="cov0" title="0">{
        // 按基数排序边
        sortedEdges := make([]*JoinEdge, len(jg.edges))
        copy(sortedEdges, jg.edges)

        // 简化的冒泡排序（实际应该使用更高效的算法）
        for i := 0; i &lt; len(sortedEdges)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(sortedEdges); j++ </span><span class="cov0" title="0">{
                        if sortedEdges[i].Cardinality &gt; sortedEdges[j].Cardinality </span><span class="cov0" title="0">{
                                sortedEdges[i], sortedEdges[j] = sortedEdges[j], sortedEdges[i]
                        }</span>
                }
        }

        // Kruskal算法
        <span class="cov0" title="0">parent := make(map[string]string)
        for name := range jg.nodes </span><span class="cov0" title="0">{
                parent[name] = name
        }</span>

        <span class="cov0" title="0">mst := []*JoinEdge{}
        for _, edge := range sortedEdges </span><span class="cov0" title="0">{
                // 检查是否形成环
                rootFrom := jg.findParent(edge.From, parent)
                rootTo := jg.findParent(edge.To, parent)

                if rootFrom != rootTo </span><span class="cov0" title="0">{
                        mst = append(mst, edge)
                        parent[rootFrom] = rootTo
                }</span>

                // 如果MST包含所有节点，停止
                <span class="cov0" title="0">if len(mst) == len(jg.nodes)-1 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return mst</span>
}

// findParent 查找根节点（用于并查集）
func (jg *JoinGraph) findParent(name string, parent map[string]string) string <span class="cov0" title="0">{
        for parent[name] != name </span><span class="cov0" title="0">{
                name = parent[name]
        }</span>
        <span class="cov0" title="0">return name</span>
}

// GetDegreeSequence 获取度数序列（用于判断是否是星型图）
func (jg *JoinGraph) GetDegreeSequence() []int <span class="cov0" title="0">{
        degrees := make([]int, 0, len(jg.nodes))
        for _, node := range jg.nodes </span><span class="cov0" title="0">{
                degrees = append(degrees, node.Degree)
        }</span>
        <span class="cov0" title="0">return degrees</span>
}

// IsStarGraph 判断是否是星型图（一个中心节点连接所有其他节点）
func (jg *JoinGraph) IsStarGraph() bool <span class="cov0" title="0">{
        if len(jg.nodes) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 找度数最大的节点
        <span class="cov0" title="0">maxDegree := 0
        centerNodes := []string{}
        for _, node := range jg.nodes </span><span class="cov0" title="0">{
                if node.Degree &gt; maxDegree </span><span class="cov0" title="0">{
                        maxDegree = node.Degree
                        centerNodes = []string{node.Name}
                }</span> else<span class="cov0" title="0"> if node.Degree == maxDegree </span><span class="cov0" title="0">{
                        centerNodes = append(centerNodes, node.Name)
                }</span>
        }

        // 检查是否所有其他节点都连接到中心节点
        <span class="cov0" title="0">if len(centerNodes) == 1 </span><span class="cov0" title="0">{
                center := centerNodes[0]
                neighbors := jg.GetNeighbors(center)
                
                // 检查度数是否等于节点数-1
                if len(neighbors) == len(jg.nodes)-1 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// EstimateJoinCardinality 估算JOIN的基数（基于图）
func (jg *JoinGraph) EstimateJoinCardinality(from, to string) float64 <span class="cov0" title="0">{
        fromNode := jg.GetNode(from)
        toNode := jg.GetNode(to)

        if fromNode == nil || toNode == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 查找连接这两个节点的边
        <span class="cov0" title="0">for _, edge := range fromNode.Edges </span><span class="cov0" title="0">{
                if edge.To == to </span><span class="cov0" title="0">{
                        return edge.Cardinality
                }</span>
        }

        // 没有找到边，使用节点基数估算
        <span class="cov0" title="0">return float64(fromNode.Cardinality * toNode.Cardinality)</span>
}

// GetStats 获取图的统计信息
func (jg *JoinGraph) GetStats() GraphStats <span class="cov0" title="0">{
        stats := GraphStats{
                NodeCount:    len(jg.nodes),
                EdgeCount:    jg.edgeCount,
                IsConnected:   jg.isConnected(),
                IsStar:       jg.IsStarGraph(),
        }

        if len(jg.nodes) &gt; 0 </span><span class="cov0" title="0">{
                stats.MaxDegree = jg.getMaxDegree()
                stats.MinDegree = jg.getMinDegree()
                stats.AvgDegree = float64(jg.edgeCount * 2) / float64(len(jg.nodes))
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// isConnected 检查图是否连通
func (jg *JoinGraph) isConnected() bool <span class="cov0" title="0">{
        if len(jg.nodes) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // 从任意节点开始BFS
        <span class="cov0" title="0">start := ""
        for name := range jg.nodes </span><span class="cov0" title="0">{
                start = name
                break</span>
        }

        <span class="cov0" title="0">visited := make(map[string]bool)
        jg.bfs(start, visited)

        return len(visited) == len(jg.nodes)</span>
}

// getMaxDegree 获取最大度数
func (jg *JoinGraph) getMaxDegree() int <span class="cov0" title="0">{
        maxDegree := 0
        for _, node := range jg.nodes </span><span class="cov0" title="0">{
                if node.Degree &gt; maxDegree </span><span class="cov0" title="0">{
                        maxDegree = node.Degree
                }</span>
        }
        <span class="cov0" title="0">return maxDegree</span>
}

// getMinDegree 获取最小度数
func (jg *JoinGraph) getMinDegree() int <span class="cov0" title="0">{
        minDegree := int(^uint(0) &gt;&gt; 1)
        for _, node := range jg.nodes </span><span class="cov0" title="0">{
                if node.Degree &lt; minDegree </span><span class="cov0" title="0">{
                        minDegree = node.Degree
                }</span>
        }
        <span class="cov0" title="0">return minDegree</span>
}

// GraphStats 图统计信息
type GraphStats struct {
        NodeCount   int
        EdgeCount   int
        MaxDegree   int
        MinDegree   int
        AvgDegree   float64
        IsConnected bool
        IsStar      bool
}

// Explain 返回图的说明
func (jg *JoinGraph) Explain() string <span class="cov0" title="0">{
        stats := jg.GetStats()
        
        return fmt.Sprintf(
                "=== Join Graph ===\n"+
                "Nodes: %d\n"+
                "Edges: %d\n"+
                "Max Degree: %d\n"+
                "Min Degree: %d\n"+
                "Avg Degree: %.2f\n"+
                "Connected: %v\n"+
                "Star Graph: %v\n",
                stats.NodeCount,
                stats.EdgeCount,
                stats.MaxDegree,
                stats.MinDegree,
                stats.AvgDegree,
                stats.IsConnected,
                stats.IsStar,
        )
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package optimizer

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// JoinEliminationRule JOIN消除规则
// 消除冗余的JOIN操作，如1:1的外键主键JOIN
type JoinEliminationRule struct {
        cardinalityEstimator CardinalityEstimator
}

// Name 返回规则名称
func (r *JoinEliminationRule) Name() string <span class="cov8" title="59">{
        return "JoinElimination"
}</span>

// Match 检查规则是否匹配
func (r *JoinEliminationRule) Match(plan LogicalPlan) bool <span class="cov10" title="151">{
        // 检查是否包含JOIN节点
        return containsJoin(plan)
}</span>

// Apply 应用规则：消除冗余JOIN
func (r *JoinEliminationRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 尝试消除每个JOIN节点
        return r.eliminateJoins(plan), nil
}</span>

// eliminateJoins 递归消除JOIN节点
func (r *JoinEliminationRule) eliminateJoins(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if join, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                // 检查是否可以消除这个JOIN
                if r.canEliminate(join) </span><span class="cov0" title="0">{
                        // 消除JOIN：返回子节点
                        if len(join.Children()) &gt; 0 </span><span class="cov0" title="0">{
                                return join.Children()[0]
                        }</span>
                        <span class="cov0" title="0">return plan</span>
                }
        }

        // 递归处理子节点
        <span class="cov0" title="0">for i, child := range plan.Children() </span><span class="cov0" title="0">{
                newChild := r.eliminateJoins(child)
                if newChild != child </span><span class="cov0" title="0">{
                        children := plan.Children()
                        children[i] = newChild
                        plan.SetChildren(children...)
                        return plan
                }</span>
        }

        <span class="cov0" title="0">return plan</span>
}

// canEliminate 检查是否可以消除JOIN
func (r *JoinEliminationRule) canEliminate(join *LogicalJoin) bool <span class="cov0" title="0">{
        // 简化实现：检查以下情况
        // 1. 1:1的JOIN（外键主键关系）
        // 2. 连接条件包含等式
        // 3. 右表（或左表）可以被推导

        conditions := join.GetJoinConditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return false // 没有连接条件，不能消除
        }</span>

        // 检查连接条件是否为等值
        <span class="cov0" title="0">for i := range conditions </span><span class="cov0" title="0">{
                if !isEqualityCondition(conditions[i]) </span><span class="cov0" title="0">{
                        return false // 不是等值条件，不能消除
                }</span>
        }

        // 检查是否为1:1关系
        <span class="cov0" title="0">leftCardinality := r.cardinalityEstimator.EstimateFilter(getTableName(join.Children()[0]), []domain.Filter{})
        rightCardinality := r.cardinalityEstimator.EstimateFilter(getTableName(join.Children()[1]), []domain.Filter{})

        // 如果一边表很小（如1行），可以考虑消除
        if leftCardinality &lt;= 1 || rightCardinality &lt;= 1 </span><span class="cov0" title="0">{
                return true
        }</span>

        // 检查是否为外键-主键关系（简化版）
        // 实际应该从schema中提取外键信息
        <span class="cov0" title="0">if r.isForeignKeyPrimaryKeyJoin(join) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isEqualityCondition 检查条件是否为等值
func isEqualityCondition(cond *JoinCondition) bool <span class="cov0" title="0">{
        // 简化：检查连接条件的结构
        // 实际应该检查表达式类型
        return cond.Left != nil &amp;&amp; cond.Right != nil &amp;&amp; cond.Operator == "="
}</span>

// isForeignKeyPrimaryKeyJoin 检查是否为外键-主键JOIN（简化版）
func (r *JoinEliminationRule) isForeignKeyPrimaryKeyJoin(join *LogicalJoin) bool <span class="cov0" title="0">{
        // 简化实现：假设表名包含外键信息
        // 实际应该从schema中读取外键定义

        leftTables := extractTableNames(join.Children()[0])
        rightTables := extractTableNames(join.Children()[1])

        if len(leftTables) != 1 || len(rightTables) != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 简化判断：如果表名包含_id或以_id结尾，可能是主键
        <span class="cov0" title="0">leftTable := leftTables[0]
        rightTable := rightTables[0]

        // 检查连接条件
        conditions := join.GetJoinConditions()
        for _, cond := range conditions </span><span class="cov0" title="0">{
                // 如果连接条件是 id = other_id，可能是外键主键关系
                leftExpr := expressionToString(cond.Left)
                rightExpr := expressionToString(cond.Right)
                if (leftExpr == "id" || leftExpr == "id_"+leftTable) &amp;&amp;
                        (rightExpr == rightTable+"_id" || rightExpr == "id") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}


// extractTableNames 从计划中提取表名
func extractTableNames(plan LogicalPlan) []string <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                return []string{dataSource.TableName}
        }</span>

        <span class="cov0" title="0">tables := make(map[string]bool)
        for _, child := range plan.Children() </span><span class="cov0" title="0">{
                childTables := extractTableNames(child)
                for _, t := range childTables </span><span class="cov0" title="0">{
                        tables[t] = true
                }</span>
        }

        <span class="cov0" title="0">result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// NewJoinEliminationRule 创建JOIN消除规则
func NewJoinEliminationRule(estimator CardinalityEstimator) *JoinEliminationRule <span class="cov0" title="0">{
        return &amp;JoinEliminationRule{
                cardinalityEstimator: estimator,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// JoinReorderRule JOIN重排序规则
// 使用贪心算法选择最优的JOIN顺序
type JoinReorderRule struct {
        cardinalityEstimator CardinalityEstimator
        costModel            CostModel
}

// Name 返回规则名称
func (r *JoinReorderRule) Name() string <span class="cov6" title="59">{
        return "JoinReorder"
}</span>

// Match 检查规则是否匹配
func (r *JoinReorderRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        // 检查是否包含JOIN节点
        return containsJoin(plan)
}</span>

// containsJoin 递归检查是否包含JOIN节点
func containsJoin(plan LogicalPlan) bool <span class="cov10" title="504">{
        // 检查当前节点
        if _, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov10" title="504">if _, ok := plan.(*LogicalDataSource); ok </span><span class="cov9" title="302">{
                // DataSource节点，不需要递归检查
                return false
        }</span>

        // 递归检查子节点
        <span class="cov8" title="202">children := plan.Children()
        if children == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="202">for _, child := range children </span><span class="cov8" title="202">{
                if containsJoin(child) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="202">return false</span>
}

// Apply 应用规则：重排序JOIN顺序
func (r *JoinReorderRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] JoinReorderRule.Apply: 开始")
        // 收集所有JOIN节点
        joinNodes := collectJoins(plan)
        fmt.Println("  [DEBUG] JoinReorderRule.Apply: 收集到JOIN节点数:", len(joinNodes))

        if len(joinNodes) &lt; 2 </span><span class="cov0" title="0">{
                // 少于2个JOIN，不需要重排序
                return plan, nil
        }</span>

        // 提取涉及的表
        <span class="cov0" title="0">tables := extractTablesFromJoins(joinNodes)

        if len(tables) &lt; 2 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        // 使用贪心算法选择最优JOIN顺序
        <span class="cov0" title="0">optimalOrder, minCost := r.findOptimalJoinOrder(tables, joinNodes, optCtx)

        if minCost &gt;= math.MaxFloat64 </span><span class="cov0" title="0">{
                // 没找到有效的顺序，返回原计划
                return plan, nil
        }</span>

        // 重新构建JOIN树
        <span class="cov0" title="0">return r.rebuildJoinTree(joinNodes[0], optimalOrder, joinNodes)</span>
}

// findOptimalJoinOrder 使用贪心算法找到最优JOIN顺序
func (r *JoinReorderRule) findOptimalJoinOrder(
        tables []string,
        joinNodes []*LogicalJoin,
        optCtx *OptimizationContext,
) ([]string, float64) <span class="cov0" title="0">{

        if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil, math.MaxFloat64
        }</span>

        // 贪心算法：
        // 1. 选择基数最小的表作为起点
        // 2. 每次选择与已选表集JOIN成本最小的表
        // 3. 直到所有表都被选入

        <span class="cov0" title="0">remainingTables := make([]string, len(tables))
        copy(remainingTables, tables)

        selectedTables := []string{}
        minCost := 0.0

        // 第一轮：选择基数最小的表
        var firstTable string
        minCardinality := int64(math.MaxInt64)

        for _, table := range remainingTables </span><span class="cov0" title="0">{
                card := r.cardinalityEstimator.EstimateTableScan(table)
                if card &lt; minCardinality </span><span class="cov0" title="0">{
                        minCardinality = card
                        firstTable = table
                }</span>
        }

        <span class="cov0" title="0">selectedTables = append(selectedTables, firstTable)
        remainingTables = removeTable(remainingTables, firstTable)

        // 后续轮：贪心选择
        for len(remainingTables) &gt; 0 </span><span class="cov0" title="0">{
                bestTable := ""
                bestCost := math.MaxFloat64

                for _, table := range remainingTables </span><span class="cov0" title="0">{
                        // 估算将table加入已选表集的成本
                        cost := r.estimateJoinCost(selectedTables, table, joinNodes, optCtx)
                        if cost &lt; bestCost </span><span class="cov0" title="0">{
                                bestCost = cost
                                bestTable = table
                        }</span>
                }

                <span class="cov0" title="0">if bestTable == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">selectedTables = append(selectedTables, bestTable)
                minCost += bestCost
                remainingTables = removeTable(remainingTables, bestTable)</span>
        }

        <span class="cov0" title="0">return selectedTables, minCost</span>
}

// estimateJoinCost 估算JOIN成本
func (r *JoinReorderRule) estimateJoinCost(
        selectedTables []string,
        newTable string,
        joinNodes []*LogicalJoin,
        optCtx *OptimizationContext,
) float64 <span class="cov0" title="0">{

        // 估算newTable的基数
        newTableCard := r.cardinalityEstimator.EstimateTableScan(newTable)

        // 简化：假设均匀分布
        // 实际应该根据JOIN条件估算
        // 成本 = 表扫描成本 + 匹配成本
        scanCost := r.costModel.ScanCost(newTable, newTableCard)

        // 假设每个已选表行与新表有1/NDV的匹配
        avgDistinct := 100.0 // 默认NDV
        matchCost := float64(newTableCard) / avgDistinct

        return scanCost + matchCost
}</span>

// rebuildJoinTree 根据最优顺序重新构建JOIN树
func (r *JoinReorderRule) rebuildJoinTree(
        rootJoin *LogicalJoin,
        order []string,
        allJoins []*LogicalJoin,
) (LogicalPlan, error) <span class="cov0" title="0">{

        if len(order) == 0 </span><span class="cov0" title="0">{
                return rootJoin, nil
        }</span>

        // 简化实现：从左到右构建线性JOIN树
        // 实际应该考虑连接条件，构建最优树

        // 找到第一个表
        <span class="cov0" title="0">firstTable := order[0]

        // 查找对应的数据源节点
        firstDataSource := findDataSource(rootJoin, firstTable)
        if firstDataSource == nil </span><span class="cov0" title="0">{
                return rootJoin, nil
        }</span>

        // 逐步添加其他表
        <span class="cov0" title="0">currentPlan := LogicalPlan(firstDataSource)

        for i := 1; i &lt; len(order); i++ </span><span class="cov0" title="0">{
                nextTable := order[i]
                nextDataSource := findDataSource(rootJoin, nextTable)
                if nextDataSource == nil </span><span class="cov0" title="0">{
                        return rootJoin, nil
                }</span>

                // 创建新的JOIN节点
                <span class="cov0" title="0">newJoin := NewLogicalJoin(
                        rootJoin.GetJoinType(),
                        currentPlan,
                        nextDataSource,
                        []*JoinCondition{
                                {
                                        Left:    &amp;parser.Expression{Type: parser.ExprTypeColumn, Column: "id"},
                                        Right:   &amp;parser.Expression{Type: parser.ExprTypeColumn, Column: "id"},
                                        Operator: "=",
                                }, // 简化：假设id连接
                        },
                )

                currentPlan = newJoin</span>
        }

        <span class="cov0" title="0">return currentPlan, nil</span>
}

// collectJoins 收集所有JOIN节点
func collectJoins(plan LogicalPlan) []*LogicalJoin <span class="cov0" title="0">{
        joins := []*LogicalJoin{}

        if join, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                joins = append(joins, join)
                // 递归收集子节点的JOIN
                for _, child := range plan.Children() </span><span class="cov0" title="0">{
                        joins = append(joins, collectJoins(child)...)
                }</span>
                <span class="cov0" title="0">return joins</span>
        }

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                joins = append(joins, collectJoins(child)...)
        }</span>

        <span class="cov0" title="0">return joins</span>
}

// extractTablesFromJoins 从JOIN节点中提取表名
func extractTablesFromJoins(joins []*LogicalJoin) []string <span class="cov0" title="0">{
        tables := make(map[string]bool)

        for _, join := range joins </span><span class="cov0" title="0">{
                // 从子节点中提取表名
                extractTablesFromPlan(join, tables)
        }</span>

        <span class="cov0" title="0">result := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                result = append(result, table)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// extractTablesFromPlan 从计划中提取表名
func extractTablesFromPlan(plan LogicalPlan, tables map[string]bool) <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                tables[dataSource.TableName] = true
                return
        }</span>

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                extractTablesFromPlan(child, tables)
        }</span>
}

// findDataSource 在计划树中查找数据源节点
func findDataSource(plan LogicalPlan, tableName string) *LogicalDataSource <span class="cov0" title="0">{
        if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                if dataSource.TableName == tableName </span><span class="cov0" title="0">{
                        return dataSource
                }</span>
        }

        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                if found := findDataSource(child, tableName); found != nil </span><span class="cov0" title="0">{
                        return found
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// removeTable 从表列表中移除表
func removeTable(tables []string, table string) []string <span class="cov0" title="0">{
        result := []string{}
        for _, t := range tables </span><span class="cov0" title="0">{
                if t != table </span><span class="cov0" title="0">{
                        result = append(result, t)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// NewJoinReorderRule 创建JOIN重排序规则
func NewJoinReorderRule(estimator CardinalityEstimator, costModel CostModel) *JoinReorderRule <span class="cov0" title="0">{
        return &amp;JoinReorderRule{
                cardinalityEstimator: estimator,
                costModel:            costModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package optimizer

import (
        "fmt"
)

// LogicalAggregate 逻辑聚合
type LogicalAggregate struct {
        aggFuncs      []*AggregationItem
        groupByFields []string
        children       []LogicalPlan
}

// NewLogicalAggregate 创建逻辑聚合
func NewLogicalAggregate(aggFuncs []*AggregationItem, groupByCols []string, child LogicalPlan) *LogicalAggregate <span class="cov4" title="5">{
        return &amp;LogicalAggregate{
                aggFuncs:      aggFuncs,
                groupByFields: groupByCols,
                children:      []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalAggregate) Children() []LogicalPlan <span class="cov10" title="49">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalAggregate) SetChildren(children ...LogicalPlan) <span class="cov1" title="1">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalAggregate) Schema() []ColumnInfo <span class="cov3" title="3">{
        columns := []ColumnInfo{}

        // 添加 GROUP BY 列
        for _, col := range p.groupByFields </span><span class="cov3" title="3">{
                columns = append(columns, ColumnInfo{
                        Name:     col,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 添加聚合函数列
        <span class="cov3" title="3">for _, agg := range p.aggFuncs </span><span class="cov0" title="0">{
                name := agg.Alias
                if name == "" </span><span class="cov0" title="0">{
                        name = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov3" title="3">return columns</span>
}

// GetAggFuncs 返回聚合函数列表
func (p *LogicalAggregate) GetAggFuncs() []*AggregationItem <span class="cov6" title="10">{
        return p.aggFuncs
}</span>

// GetGroupByCols 返回分组列列表
func (p *LogicalAggregate) GetGroupByCols() []string <span class="cov6" title="10">{
        return p.groupByFields
}</span>

// Explain 返回计划说明
func (p *LogicalAggregate) Explain() string <span class="cov4" title="5">{
        aggStr := ""
        aggFuncs := p.GetAggFuncs()
        for i, agg := range aggFuncs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        aggStr += ", "
                }</span>
                <span class="cov0" title="0">aggStr += fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)</span>
        }
        <span class="cov4" title="5">groupStr := ""
        groupByCols := p.GetGroupByCols()
        if len(groupByCols) &gt; 0 </span><span class="cov4" title="5">{
                groupStr = " GROUP BY "
                for i, col := range groupByCols </span><span class="cov4" title="5">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                groupStr += ", "
                        }</span>
                        <span class="cov4" title="5">groupStr += col</span>
                }
        }
        <span class="cov4" title="5">return "Aggregate(" + aggStr + groupStr + ")"</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package optimizer

import (
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// LogicalDataSource 逻辑数据源（表扫描）
type LogicalDataSource struct {
        TableName            string
        Columns              []ColumnInfo
        TableInfo            *domain.TableInfo
        Statistics           *Statistics
        children             []LogicalPlan
        pushedDownPredicates []*parser.Expression // 下推的谓词条件
        pushedDownLimit      *LimitInfo           // 下推的Limit信息
}

// NewLogicalDataSource 创建逻辑数据源
func NewLogicalDataSource(tableName string, tableInfo *domain.TableInfo) *LogicalDataSource <span class="cov7" title="93">{
        columns := make([]ColumnInfo, 0, len(tableInfo.Columns))
        for _, col := range tableInfo.Columns </span><span class="cov8" title="250">{
                columns = append(columns, ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                })
        }</span>

        <span class="cov7" title="93">return &amp;LogicalDataSource{
                TableName: tableName,
                Columns:   columns,
                TableInfo: tableInfo,
                children:  []LogicalPlan{},
        }</span>
}

// Children 获取子节点
func (p *LogicalDataSource) Children() []LogicalPlan <span class="cov10" title="557">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalDataSource) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalDataSource) Schema() []ColumnInfo <span class="cov6" title="57">{
        return p.Columns
}</span>

// RowCount 返回预估行数
func (p *LogicalDataSource) RowCount() int64 <span class="cov0" title="0">{
        if p.Statistics != nil </span><span class="cov0" title="0">{
                return p.Statistics.RowCount
        }</span>
        <span class="cov0" title="0">return 1000</span> // 默认估计
}

// Table 返回表名
func (p *LogicalDataSource) Table() string <span class="cov0" title="0">{
        return p.TableName
}</span>

// Explain 返回计划说明
func (p *LogicalDataSource) Explain() string <span class="cov6" title="53">{
        return "DataSource(" + p.TableName + ")"
}</span>

// PushDownPredicates 添加下推的谓词条件
func (p *LogicalDataSource) PushDownPredicates(conditions []*parser.Expression) <span class="cov6" title="55">{
        p.pushedDownPredicates = append(p.pushedDownPredicates, conditions...)
}</span>

// GetPushedDownPredicates 获取下推的谓词条件
func (p *LogicalDataSource) GetPushedDownPredicates() []*parser.Expression <span class="cov7" title="103">{
        return p.pushedDownPredicates
}</span>

// PushDownLimit 添加下推的Limit
func (p *LogicalDataSource) PushDownLimit(limit, offset int64) <span class="cov3" title="6">{
        p.pushedDownLimit = &amp;LimitInfo{
                Limit:  limit,
                Offset: offset,
        }
}</span>

// GetPushedDownLimit 获取下推的Limit
func (p *LogicalDataSource) GetPushedDownLimit() *LimitInfo <span class="cov6" title="65">{
        return p.pushedDownLimit
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package optimizer

// LogicalJoin 逻辑连接
type LogicalJoin struct {
        joinType       JoinType
        LeftTable      string
        RightTable     string
        joinConditions []*JoinCondition
        children       []LogicalPlan
}

// NewLogicalJoin 创建逻辑连接
func NewLogicalJoin(joinType JoinType, left, right LogicalPlan, conditions []*JoinCondition) *LogicalJoin <span class="cov0" title="0">{
        leftTable := ""
        if left != nil </span><span class="cov0" title="0">{
                if ds, ok := left.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                        leftTable = ds.TableName
                }</span>
        }

        <span class="cov0" title="0">rightTable := ""
        if right != nil </span><span class="cov0" title="0">{
                if ds, ok := right.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                        rightTable = ds.TableName
                }</span>
        }

        <span class="cov0" title="0">return &amp;LogicalJoin{
                joinType:       joinType,
                LeftTable:      leftTable,
                RightTable:     rightTable,
                joinConditions: conditions,
                children:       []LogicalPlan{left, right},
        }</span>
}

// Children 获取子节点
func (p *LogicalJoin) Children() []LogicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalJoin) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// GetJoinType 返回连接类型
func (p *LogicalJoin) GetJoinType() JoinType <span class="cov0" title="0">{
        return p.joinType
}</span>

// GetJoinConditions 返回连接条件
func (p *LogicalJoin) GetJoinConditions() []*JoinCondition <span class="cov0" title="0">{
        return p.joinConditions
}</span>

// Explain 返回计划说明
func (p *LogicalJoin) Explain() string <span class="cov0" title="0">{
        return "Join(" + p.LeftTable + ", " + p.RightTable + ", type=" + p.GetJoinType().String() + ")"
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package optimizer

import (
        "strconv"
)

// LogicalLimit 逻辑限制
type LogicalLimit struct {
        limitVal  int64
        offsetVal int64
        children  []LogicalPlan
}

// NewLogicalLimit 创建逻辑限制
func NewLogicalLimit(limit, offset int64, child LogicalPlan) *LogicalLimit <span class="cov6" title="10">{
        return &amp;LogicalLimit{
                limitVal:  limit,
                offsetVal: offset,
                children:  []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalLimit) Children() []LogicalPlan <span class="cov10" title="49">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalLimit) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalLimit) Schema() []ColumnInfo <span class="cov4" title="4">{
        if len(p.children) &gt; 0 </span><span class="cov4" title="4">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// GetLimit 返回LIMIT值
func (p *LogicalLimit) GetLimit() int64 <span class="cov7" title="20">{
        return p.limitVal
}</span>

// GetOffset 返回OFFSET值
func (p *LogicalLimit) GetOffset() int64 <span class="cov7" title="20">{
        return p.offsetVal
}</span>

// Explain 返回计划说明
func (p *LogicalLimit) Explain() string <span class="cov6" title="10">{
        return "Limit(offset=" + strconv.FormatInt(p.GetOffset(), 10) + ", limit=" + strconv.FormatInt(p.GetLimit(), 10) + ")"
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package optimizer

import (
        "fmt"
        "strconv"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalProjection 逻辑投影
type LogicalProjection struct {
        Exprs        []*parser.Expression
        columnAliases []string
        Columns       []ColumnInfo
        children      []LogicalPlan
}

// NewLogicalProjection 创建逻辑投影
func NewLogicalProjection(exprs []*parser.Expression, aliases []string, child LogicalPlan) *LogicalProjection <span class="cov6" title="55">{
        columns := make([]ColumnInfo, len(exprs))
        for i, expr := range exprs </span><span class="cov7" title="80">{
                name := aliases[i]
                if name == "" </span><span class="cov0" title="0">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                                name = expr.Column
                        }</span> else<span class="cov0" title="0"> {
                                name = "expr_" + strconv.Itoa(i)
                        }</span>
                }
                <span class="cov7" title="80">columns[i] = ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                }</span>
        }

        <span class="cov6" title="55">return &amp;LogicalProjection{
                Exprs:        exprs,
                columnAliases:  aliases,
                Columns:       columns,
                children:      []LogicalPlan{child},
        }</span>
}

// Children 获取子节点
func (p *LogicalProjection) Children() []LogicalPlan <span class="cov10" title="414">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalProjection) SetChildren(children ...LogicalPlan) <span class="cov5" title="18">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalProjection) Schema() []ColumnInfo <span class="cov0" title="0">{
        return p.Columns
}</span>

// GetExprs 返回投影表达式
func (p *LogicalProjection) GetExprs() []*parser.Expression <span class="cov6" title="52">{
        return p.Exprs
}</span>

// GetAliases 返回别名列表
func (p *LogicalProjection) GetAliases() []string <span class="cov6" title="52">{
        return p.columnAliases
}</span>

// Explain 返回计划说明
func (p *LogicalProjection) Explain() string <span class="cov8" title="129">{
        exprs := ""
        for i, expr := range p.Exprs </span><span class="cov8" title="193">{
                if i &gt; 0 </span><span class="cov7" title="64">{
                        exprs += ", "
                }</span>
                <span class="cov8" title="193">if expr.Type == parser.ExprTypeColumn </span><span class="cov8" title="193">{
                        exprs += expr.Column
                }</span> else<span class="cov0" title="0"> {
                        exprs += fmt.Sprintf("%v", expr)
                }</span>
        }
        <span class="cov8" title="129">return "Projection(" + exprs + ")"</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package optimizer

// 为 LogicalSelection 和其他算子添加访问器方法
// 用于修复方法名冲突问题

import "github.com/kasuganosora/sqlexec/pkg/parser"

// SelectionConditions 过滤条件访问器
func SelectionConditions(conditions []*parser.Expression) []*parser.Expression <span class="cov0" title="0">{
        return conditions
}</span>

// SortOrderByItems 排序项访问器
func SortOrderByItems(orderBy []OrderByItem) []OrderByItem <span class="cov0" title="0">{
        result := make([]OrderByItem, 0, len(orderBy))
        for i := range orderBy </span><span class="cov0" title="0">{
                result[i] = OrderByItem{
                        Column:    orderBy[i].Column,
                        Direction: orderBy[i].Direction,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AggregateAggFuncs 聚合函数访问器
func AggregateAggFuncs(aggFuncs []*AggregationItem) []*AggregationItem <span class="cov0" title="0">{
        result := make([]*AggregationItem, 0, len(aggFuncs))
        for i := range aggFuncs </span><span class="cov0" title="0">{
                result[i] = &amp;AggregationItem{
                        Type:     aggFuncs[i].Type,
                        Expr:     aggFuncs[i].Expr,
                        Alias:    aggFuncs[i].Alias,
                        Distinct: aggFuncs[i].Distinct,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AggregateGroupByCols 分组列访问器
func AggregateGroupByCols(groupByCols []string) []string <span class="cov0" title="0">{
        result := make([]string, 0, len(groupByCols))
        copy(result, groupByCols)
        return result
}</span>

// UnionChildren Union子节点访问器
func UnionChildren(children []LogicalPlan) []LogicalPlan <span class="cov0" title="0">{
        return children
}</span>

// UnionUnionType Union类型访问器
func UnionUnionType(unionType string) string <span class="cov0" title="0">{
        return unionType
}</span>

// UnionAll Union all标志访问器
func UnionAll(all bool) bool <span class="cov0" title="0">{
        return all
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package optimizer

import (
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalSelection 逻辑过滤（选择）
type LogicalSelection struct {
        filterConditions []*parser.Expression
        children         []LogicalPlan
}

// NewLogicalSelection 创建逻辑过滤
func NewLogicalSelection(conditions []*parser.Expression, child LogicalPlan) *LogicalSelection <span class="cov6" title="28">{
        return &amp;LogicalSelection{
                filterConditions: conditions,
                children:       []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalSelection) Children() []LogicalPlan <span class="cov10" title="167">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalSelection) SetChildren(children ...LogicalPlan) <span class="cov2" title="2">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalSelection) Schema() []ColumnInfo <span class="cov6" title="19">{
        if len(p.children) &gt; 0 </span><span class="cov6" title="19">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Conditions 返回过滤条件
func (p *LogicalSelection) Conditions() []*parser.Expression <span class="cov9" title="121">{
        return p.filterConditions
}</span>

// GetConditions 返回过滤条件（用于避免与Conditions方法冲突）
func (p *LogicalSelection) GetConditions() []*parser.Expression <span class="cov7" title="36">{
        return p.filterConditions
}</span>

// Selectivity 返回选择率
func (p *LogicalSelection) Selectivity() float64 <span class="cov0" title="0">{
        // 简化实现：默认0.1（10%的选择率）
        return 0.1
}</span>

// Explain 返回计划说明
func (p *LogicalSelection) Explain() string <span class="cov6" title="24">{
        conditions := p.GetConditions()
        if len(conditions) &gt; 0 </span><span class="cov6" title="24">{
                return "Selection WHERE " + fmt.Sprintf("%v", conditions[0])
        }</span>
        <span class="cov0" title="0">return "Selection"</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package optimizer

// LogicalSort 逻辑排序
type LogicalSort struct {
        OrderBy  []OrderByItem
        children []LogicalPlan
}

// NewLogicalSort 创建逻辑排序
func NewLogicalSort(orderBy []OrderByItem, child LogicalPlan) *LogicalSort <span class="cov4" title="6">{
        return &amp;LogicalSort{
                OrderBy:  orderBy,
                children: []LogicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *LogicalSort) Children() []LogicalPlan <span class="cov10" title="73">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalSort) SetChildren(children ...LogicalPlan) <span class="cov2" title="2">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalSort) Schema() []ColumnInfo <span class="cov3" title="4">{
        if len(p.children) &gt; 0 </span><span class="cov3" title="4">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// GetOrderByItems 返回排序列表
func (p *LogicalSort) GetOrderByItems() []*OrderByItem <span class="cov4" title="6">{
        result := make([]*OrderByItem, 0, len(p.OrderBy))
        for i := range p.OrderBy </span><span class="cov4" title="6">{
                result = append(result, &amp;p.OrderBy[i])
        }</span>
        <span class="cov4" title="6">return result</span>
}

// Explain 返回计划说明
func (p *LogicalSort) Explain() string <span class="cov4" title="6">{
        items := ""
        orderByItems := p.GetOrderByItems()
        for i, item := range orderByItems </span><span class="cov4" title="6">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        items += ", "
                }</span>
                <span class="cov4" title="6">items += item.Column + " " + item.Direction</span>
        }
        <span class="cov4" title="6">return "Sort(" + items + ")"</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package optimizer

import (
        "fmt"
        "strings"
)

// LogicalUnion 逻辑UNION操作符
// 用于合并多个子查询的结果集
type LogicalUnion struct {
        children []LogicalPlan
        isAll    bool // 是否为UNION ALL（不去重）
}

// NewLogicalUnion 创建逻辑UNION
func NewLogicalUnion(children []LogicalPlan) *LogicalUnion <span class="cov0" title="0">{
        return &amp;LogicalUnion{
                children: children,
                isAll:    true, // 默认使用UNION ALL以提升性能
        }
}</span>

// Children 获取子节点
func (p *LogicalUnion) Children() []LogicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *LogicalUnion) SetChildren(children ...LogicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *LogicalUnion) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return []ColumnInfo{}
        }</span>
        // 返回第一个子节点的schema（假设所有子节点schema一致）
        <span class="cov0" title="0">return p.children[0].Schema()</span>
}

// IsAll 返回是否为UNION ALL
func (p *LogicalUnion) IsAll() bool <span class="cov0" title="0">{
        return p.isAll
}</span>

// SetAll 设置是否为UNION ALL
func (p *LogicalUnion) SetAll(isAll bool) <span class="cov0" title="0">{
        p.isAll = isAll
}</span>

// Explain 返回计划说明
func (p *LogicalUnion) Explain() string <span class="cov0" title="0">{
        unionType := "UNION"
        if p.isAll </span><span class="cov0" title="0">{
                unionType = "UNION ALL"
        }</span>

        <span class="cov0" title="0">childSchemas := make([]string, 0, len(p.children))
        for _, child := range p.children </span><span class="cov0" title="0">{
                childSchemas = append(childSchemas, child.Explain())
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", unionType, strings.Join(childSchemas, ", "))</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/utils"
)

// PhysicalMergeJoin 物理归并连接
// 基于两路归并排序的连接算法，适合有序数据
type PhysicalMergeJoin struct {
        JoinType   JoinType
        Conditions  []*JoinCondition
        cost        float64
        children    []PhysicalPlan
}

// NewPhysicalMergeJoin 创建物理归并连接
func NewPhysicalMergeJoin(joinType JoinType, left, right PhysicalPlan, conditions []*JoinCondition) *PhysicalMergeJoin <span class="cov0" title="0">{
        leftRows := int64(1000) // 假设
        rightRows := int64(1000) // 假设

        // Merge Join 成本 = 合并两个有序序列
        // 时间复杂度: O(n + m)
        leftCost := left.Cost()
        rightCost := right.Cost()
        mergeCost := float64(leftRows+rightRows) * 0.05
        cost := leftCost + rightCost + mergeCost

        return &amp;PhysicalMergeJoin{
                JoinType:  joinType,
                Conditions:  conditions,
                cost:       cost,
                children:    []PhysicalPlan{left, right},
        }
}</span>

// Children 获取子节点
func (p *PhysicalMergeJoin) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalMergeJoin) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalMergeJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalMergeJoin) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行归并连接
func (p *PhysicalMergeJoin) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MergeJoin requires exactly 2 children")
        }</span>

        // 1. 执行左表和右表
        <span class="cov0" title="0">leftResult, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left table execute error: %w", err)
        }</span>

        <span class="cov0" title="0">rightResult, err := p.children[1].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right table execute error: %w", err)
        }</span>

        // 2. 获取连接条件
        <span class="cov0" title="0">leftJoinCol, rightJoinCol := getJoinColumns(p.Conditions)
        if leftJoinCol == "" || rightJoinCol == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid join conditions")
        }</span>

        // 3. 对两边数据进行排序（如果是有序数据可以跳过这一步）
        <span class="cov0" title="0">leftRows := p.sortByColumn(leftResult.Rows, leftJoinCol)
        rightRows := p.sortByColumn(rightResult.Rows, rightJoinCol)

        // 4. 执行两路归并
        output := p.mergeRows(leftRows, rightRows, leftJoinCol, rightJoinCol, p.JoinType)

        // 5. 合并列信息
        columns := []domain.ColumnInfo{}
        columns = append(columns, leftResult.Columns...)
        for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                // 检查列名冲突
                conflict := false
                for _, leftCol := range leftResult.Columns </span><span class="cov0" title="0">{
                        if leftCol.Name == col.Name </span><span class="cov0" title="0">{
                                conflict = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if conflict </span><span class="cov0" title="0">{
                        columns = append(columns, domain.ColumnInfo{
                                Name:     "right_" + col.Name,
                                Type:     col.Type,
                                Nullable: col.Nullable,
                        })
                }</span> else<span class="cov0" title="0"> {
                        columns = append(columns, col)
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// sortByColumn 按指定列排序行数据
func (p *PhysicalMergeJoin) sortByColumn(rows []domain.Row, column string) []domain.Row <span class="cov0" title="0">{
        // 使用稳定的排序算法
        sorted := make([]domain.Row, len(rows))
        copy(sorted, rows)

        // 简单冒泡排序（实际应该用更高效的算法）
        for i := 0; i &lt; len(sorted); i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(sorted)-i-1; j++ </span><span class="cov0" title="0">{
                        leftVal := sorted[j][column]
                        rightVal := sorted[j+1][column]

                        if compareValuesForSort(leftVal, rightVal) &gt; 0 </span><span class="cov0" title="0">{
                                // 交换
                                sorted[j], sorted[j+1] = sorted[j+1], sorted[j]
                        }</span>
                }
        }

        <span class="cov0" title="0">return sorted</span>
}

// mergeRows 使用两路归并算法合并已排序的行
func (p *PhysicalMergeJoin) mergeRows(
        leftRows, rightRows []domain.Row,
        leftCol, rightCol string,
        joinType JoinType,
) []domain.Row <span class="cov0" title="0">{
        
        // 使用归并排序算法
        i, j := 0, 0
        leftCount := len(leftRows)
        rightCount := len(rightRows)

        output := make([]domain.Row, 0, leftCount+rightCount)

        switch joinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN: 只有两边都有的行
                for i &lt; leftCount &amp;&amp; j &lt; rightCount </span><span class="cov0" title="0">{
                        leftVal := leftRows[i][leftCol]
                        rightVal := rightRows[j][rightCol]

                        cmp := compareValuesForSort(leftVal, rightVal)
                        if cmp &lt; 0 </span><span class="cov0" title="0">{
                                // 左值小，取左行
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                i++
                        }</span> else<span class="cov0" title="0"> if cmp &gt; 0 </span><span class="cov0" title="0">{
                                // 右值小，取右行
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                j++
                        }</span> else<span class="cov0" title="0"> {
                                // 相等，合并行并推进两个指针
                                output = append(output, p.mergeRow(leftRows[i], rightRows[j]))
                                i++
                                j++
                        }</span>
                }

        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN: 左表所有行，右表匹配的行
                for i &lt; leftCount </span><span class="cov0" title="0">{
                        leftRow := leftRows[i]
                        leftVal := leftRow[leftCol]

                        // 在右表中查找匹配
                        matchFound := false
                        for j &lt; rightCount </span><span class="cov0" title="0">{
                                rightVal := rightRows[j][rightCol]

                                if compareValuesForSort(leftVal, rightVal) == 0 </span><span class="cov0" title="0">{
                                        output = append(output, p.mergeRow(leftRow, rightRows[j]))
                                        matchFound = true
                                        break</span>
                                } else<span class="cov0" title="0"> if compareValuesForSort(leftVal, rightVal) &lt; 0 </span><span class="cov0" title="0">{
                                        // 右表的值已经更大，不需要继续查找
                                        break</span>
                                }
                                <span class="cov0" title="0">j++</span>
                        }

                        <span class="cov0" title="0">if !matchFound </span><span class="cov0" title="0">{
                                // 没有匹配，左行 + 右NULL
                                output = append(output, p.mergeRowWithNull(leftRow, rightRows[0]))
                        }</span>

                        <span class="cov0" title="0">i++</span>
                }

        case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN: 右表所有行，左表匹配的行
                for j &lt; rightCount </span><span class="cov0" title="0">{
                        rightRow := rightRows[j]
                        rightVal := rightRow[rightCol]

                        // 在左表中查找匹配
                        matchFound := false
                        for i &lt; leftCount </span><span class="cov0" title="0">{
                                leftVal := leftRows[i][leftCol]

                                if compareValuesForSort(leftVal, rightVal) == 0 </span><span class="cov0" title="0">{
                                        output = append(output, p.mergeRow(leftRows[i], rightRow))
                                        matchFound = true
                                        break</span>
                                } else<span class="cov0" title="0"> if compareValuesForSort(leftVal, rightVal) &lt; 0 </span><span class="cov0" title="0">{
                                        // 左表的值已经更大，不需要继续查找
                                        break</span>
                                }
                                <span class="cov0" title="0">i++</span>
                        }

                        <span class="cov0" title="0">if !matchFound </span><span class="cov0" title="0">{
                                // 没有匹配，左NULL + 右行
                                output = append(output, p.mergeRowWithNull(leftRows[0], rightRow))
                        }</span>

                        <span class="cov0" title="0">j++</span>
                }

        default:<span class="cov0" title="0">
                // 其他JOIN类型：默认为INNER JOIN
                return p.mergeRows(leftRows, rightRows, leftCol, rightCol, InnerJoin)</span>
        }

        <span class="cov0" title="0">return output</span>
}

// mergeRow 合并两行数据
func (p *PhysicalMergeJoin) mergeRow(left, right domain.Row) domain.Row <span class="cov0" title="0">{
        merged := make(domain.Row)

        // 添加左行数据
        for k, v := range left </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>

        // 添加右行数据
        <span class="cov0" title="0">for k, v := range right </span><span class="cov0" title="0">{
                // 检查列名冲突
                if _, exists := merged[k]; exists </span><span class="cov0" title="0">{
                        merged["right_"+k] = v
                }</span> else<span class="cov0" title="0"> {
                        merged[k] = v
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// mergeRowWithNull 合并行数据，一边为NULL
func (p *PhysicalMergeJoin) mergeRowWithNull(notNull, nullRow domain.Row) domain.Row <span class="cov0" title="0">{
        merged := make(domain.Row)

        // 添加非NULL行的数据
        for k, v := range notNull </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>

        // 添加NULL行的数据（全部为NULL）
        <span class="cov0" title="0">for k := range nullRow </span><span class="cov0" title="0">{
                if _, exists := merged[k]; !exists </span><span class="cov0" title="0">{
                        merged[k] = nil
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// getJoinColumns 从连接条件中获取列名
func getJoinColumns(conditions []*JoinCondition) (string, string) <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return "", ""
        }</span>

        // 简化：取第一个条件的字符串表示
        <span class="cov0" title="0">if conditions[0].Left != nil </span><span class="cov0" title="0">{
                leftStr := fmt.Sprintf("%v", conditions[0].Left)
                if conditions[0].Right != nil </span><span class="cov0" title="0">{
                        rightStr := fmt.Sprintf("%v", conditions[0].Right)
                        return leftStr, rightStr
                }</span>
                <span class="cov0" title="0">return leftStr, ""</span>
        }
        <span class="cov0" title="0">return "", ""</span>
}

// compareValuesForSort 为归并排序比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func compareValuesForSort(a, b interface{}) int <span class="cov0" title="0">{
        return utils.CompareValuesForSort(a, b)
}</span>

// Explain 返回计划说明
func (p *PhysicalMergeJoin) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf("MergeJoin(type=%s, cost=%.2f)", p.JoinType, p.cost)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/builtin"
        "github.com/kasuganosora/sqlexec/pkg/information_schema"
        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/application"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/virtual"
)

// ProcessListProvider 进程列表提供者函数类型（用于避免循环依赖）
type ProcessListProvider func() []interface{}

var processListProvider ProcessListProvider

// RegisterProcessListProvider 注册进程列表提供者
func RegisterProcessListProvider(provider ProcessListProvider) <span class="cov0" title="0">{
        processListProvider = provider
}</span>

// OptimizedExecutor 优化的执行器
// 集成 Optimizer 和 QueryBuilder，提供优化后的查询执行
type OptimizedExecutor struct {
        dataSource    domain.DataSource
        dsManager     *application.DataSourceManager
        optimizer     *Optimizer
        useOptimizer  bool
        currentDB     string
        currentUser   string // 当前用户（用于权限检查）
        functionAPI   *builtin.FunctionAPI // 函数API
        exprEvaluator *ExpressionEvaluator // 表达式求值器
}

// contextKey 是context中的key类型
type contextKey int

const (
        aclManagerKey contextKey = iota
)

// NewOptimizedExecutor 创建优化的执行器
func NewOptimizedExecutor(dataSource domain.DataSource, useOptimizer bool) *OptimizedExecutor <span class="cov1" title="1">{
        functionAPI := builtin.NewFunctionAPI()
        // 使用包装器将旧的 FunctionRegistry 适配到新的 FunctionAPI
        registry := builtin.GetGlobalRegistry()
        // 注册所有旧的全局函数到新的API
        for _, info := range registry.List() </span><span class="cov10" title="96">{
                functionAPI.RegisterScalarFunction(
                        info.Name,
                        info.Name,
                        info.Description,
                        info.Handler,
                )
        }</span>

        <span class="cov1" title="1">return &amp;OptimizedExecutor{
                dataSource:    dataSource,
                optimizer:     NewOptimizer(dataSource),
                useOptimizer:  useOptimizer,
                currentDB:     "", // 默认为空字符串
                functionAPI:   functionAPI,
                exprEvaluator: NewExpressionEvaluator(functionAPI),
        }</span>
}

// NewOptimizedExecutorWithDSManager 创建带有数据源管理器的优化执行器
func NewOptimizedExecutorWithDSManager(dataSource domain.DataSource, dsManager *application.DataSourceManager, useOptimizer bool) *OptimizedExecutor <span class="cov0" title="0">{
        functionAPI := builtin.NewFunctionAPI()
        // 使用包装器将旧的 FunctionRegistry 适配到新的 FunctionAPI
        registry := builtin.GetGlobalRegistry()
        // 注册所有旧的全局函数到新的API
        for _, info := range registry.List() </span><span class="cov0" title="0">{
                functionAPI.RegisterScalarFunction(
                        info.Name,
                        info.Name,
                        info.Description,
                        info.Handler,
                )
        }</span>

        <span class="cov0" title="0">return &amp;OptimizedExecutor{
                dataSource:    dataSource,
                dsManager:     dsManager,
                optimizer:     NewOptimizer(dataSource),
                useOptimizer:  useOptimizer,
                currentDB:     "default", // 默认数据库
                functionAPI:   functionAPI,
                exprEvaluator: NewExpressionEvaluator(functionAPI),
        }</span>
}

// SetUseOptimizer 设置是否使用优化器
func (e *OptimizedExecutor) SetUseOptimizer(use bool) <span class="cov0" title="0">{
        e.useOptimizer = use
}</span>

// GetQueryBuilder 获取底层的 QueryBuilder（如果存在）
// 用于设置当前数据库上下文
func (e *OptimizedExecutor) GetQueryBuilder() interface{} <span class="cov0" title="0">{
        return nil
}</span>

// GetOptimizer 获取优化器
func (e *OptimizedExecutor) GetOptimizer() interface{} <span class="cov0" title="0">{
        return e.optimizer
}</span>

// SetCurrentDB 设置当前数据库
func (e *OptimizedExecutor) SetCurrentDB(dbName string) <span class="cov1" title="1">{
        e.currentDB = dbName
        fmt.Printf("  [DEBUG] OptimizedExecutor.SetCurrentDB: currentDB 设置为 %q\n", dbName)
}</span>

// GetCurrentDB 获取当前数据库
func (e *OptimizedExecutor) GetCurrentDB() string <span class="cov0" title="0">{
        return e.currentDB
}</span>

// SetCurrentUser 设置当前用户
func (e *OptimizedExecutor) SetCurrentUser(user string) <span class="cov0" title="0">{
        e.currentUser = user
        fmt.Printf("  [DEBUG] OptimizedExecutor.SetCurrentUser: 当前用户设置为 %q\n", user)
}</span>

// GetCurrentUser 获取当前用户
func (e *OptimizedExecutor) GetCurrentUser() string <span class="cov0" title="0">{
        return e.currentUser
}</span>

// ExecuteSelect 执行 SELECT 查询（支持优化）
func (e *OptimizedExecutor) ExecuteSelect(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 将用户信息传递到 context（用于权限检查）
        if e.currentUser != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, "user", e.currentUser)
        }</span>

        // Check if this is an information_schema query
        // information_schema queries should use QueryBuilder path to access virtual tables
        <span class="cov0" title="0">if e.isInformationSchemaQuery(stmt.From) </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] Detected information_schema query, using QueryBuilder path")
                return e.executeWithBuilder(ctx, stmt)
        }</span>

        // 如果启用了优化器，使用优化路径
        <span class="cov0" title="0">if e.useOptimizer </span><span class="cov0" title="0">{
                return e.executeWithOptimizer(ctx, stmt)
        }</span>

        // 否则使用传统的 QueryBuilder 路径
        <span class="cov0" title="0">return e.executeWithBuilder(ctx, stmt)</span>
}

// ExecuteShow 执行 SHOW 语句 - 转换为 information_schema 查询
func (e *OptimizedExecutor) ExecuteShow(ctx context.Context, showStmt *parser.ShowStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        fmt.Printf("  [DEBUG] Executing SHOW statement: Type=%s, Table=%s, Like=%s, Where=%s\n",
                showStmt.Type, showStmt.Table, showStmt.Like, showStmt.Where)

        // 将用户信息传递到 context（用于权限检查）
        if e.currentUser != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, "user", e.currentUser)
                fmt.Printf("  [DEBUG] ExecuteShow: 设置用户到context: %s\n", e.currentUser)
        }</span>

        // 根据 SHOW 类型转换为相应的 information_schema 查询
        <span class="cov0" title="0">switch showStmt.Type </span>{
        case "TABLES":<span class="cov0" title="0">
                // SHOW TABLES -&gt; SELECT table_name FROM information_schema.tables WHERE table_schema = ?
                var whereClause string
                if showStmt.Like != "" </span><span class="cov0" title="0">{
                        whereClause = fmt.Sprintf(" AND table_name LIKE '%s'", showStmt.Like)
                }</span>
                <span class="cov0" title="0">if showStmt.Where != "" </span><span class="cov0" title="0">{
                        whereClause = fmt.Sprintf(" AND (%s)", showStmt.Where)
                }</span>

                // 获取当前数据库（从 session 上下文）
                <span class="cov0" title="0">currentDB := e.currentDB
                if showStmt.Table != "" </span><span class="cov0" title="0">{
                        // 如果指定了数据库，使用指定的
                        currentDB = showStmt.Table
                }</span>

                // 构建 SQL 语句
                <span class="cov0" title="0">sql := fmt.Sprintf("SELECT table_name FROM information_schema.tables WHERE table_schema = '%s'%s",
                        currentDB, whereClause)
                fmt.Printf("  [DEBUG] SHOW TABLES converted to: %s, currentDB=%s\n", sql, currentDB)

                // 解析 SQL
                adapter := parser.NewSQLAdapter()
                parseResult, err := adapter.Parse(sql)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse SHOW TABLES query: %w", err)
                }</span>

                <span class="cov0" title="0">if parseResult.Statement.Select == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SHOW TABLES conversion failed: not a SELECT statement")
                }</span>

                <span class="cov0" title="0">return e.executeWithBuilder(ctx, parseResult.Statement.Select)</span>

        case "DATABASES":<span class="cov0" title="0">
                // SHOW DATABASES -&gt; SELECT schema_name FROM information_schema.schemata
                var whereClause string
                if showStmt.Like != "" </span><span class="cov0" title="0">{
                        whereClause = fmt.Sprintf(" WHERE schema_name LIKE '%s'", showStmt.Like)
                }</span>
                <span class="cov0" title="0">if showStmt.Where != "" </span><span class="cov0" title="0">{
                        if whereClause == "" </span><span class="cov0" title="0">{
                                whereClause = fmt.Sprintf(" WHERE (%s)", showStmt.Where)
                        }</span> else<span class="cov0" title="0"> {
                                whereClause = fmt.Sprintf("%s AND (%s)", whereClause, showStmt.Where)
                        }</span>
                }

                <span class="cov0" title="0">sql := fmt.Sprintf("SELECT schema_name FROM information_schema.schemata%s", whereClause)
                fmt.Printf("  [DEBUG] SHOW DATABASES converted to: %s\n", sql)

                // 解析 SQL
                adapter := parser.NewSQLAdapter()
                parseResult, err := adapter.Parse(sql)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse SHOW DATABASES query: %w", err)
                }</span>

                <span class="cov0" title="0">if parseResult.Statement.Select == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SHOW DATABASES conversion failed: not a SELECT statement")
                }</span>

                <span class="cov0" title="0">return e.executeWithBuilder(ctx, parseResult.Statement.Select)</span>

        case "COLUMNS":<span class="cov0" title="0">
                // SHOW COLUMNS FROM table -&gt; SELECT * FROM information_schema.columns WHERE table_name = ?
                if showStmt.Table == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SHOW COLUMNS requires a table name")
                }</span>

                <span class="cov0" title="0">var whereClause string
                if showStmt.Like != "" </span><span class="cov0" title="0">{
                        whereClause = fmt.Sprintf(" AND column_name LIKE '%s'", showStmt.Like)
                }</span>
                <span class="cov0" title="0">if showStmt.Where != "" </span><span class="cov0" title="0">{
                        whereClause = fmt.Sprintf(" AND (%s)", showStmt.Where)
                }</span>

                <span class="cov0" title="0">sql := fmt.Sprintf("SELECT * FROM information_schema.columns WHERE table_name = '%s'%s",
                        showStmt.Table, whereClause)
                fmt.Printf("  [DEBUG] SHOW COLUMNS converted to: %s\n", sql)

                // 解析 SQL
                adapter := parser.NewSQLAdapter()
                parseResult, err := adapter.Parse(sql)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse SHOW COLUMNS query: %w", err)
                }</span>

                <span class="cov0" title="0">if parseResult.Statement.Select == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SHOW COLUMNS conversion failed: not a SELECT statement")
                }</span>

                <span class="cov0" title="0">return e.executeWithBuilder(ctx, parseResult.Statement.Select)</span>

        case "PROCESSLIST":<span class="cov0" title="0">
                // SHOW PROCESSLIST - 从查询注册表获取所有查询
                return e.executeShowProcessList(ctx, showStmt.Full)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported SHOW type: %s", showStmt.Type)</span>
        }
}

// executeShowProcessList 执行 SHOW PROCESSLIST
func (e *OptimizedExecutor) executeShowProcessList(ctx context.Context, full bool) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 使用进程列表提供者获取查询列表
        var processList []interface{}
        if processListProvider != nil </span><span class="cov0" title="0">{
                processList = processListProvider()
        }</span>

        // 定义 PROCESSLIST 字段
        <span class="cov0" title="0">columns := []domain.ColumnInfo{
                {Name: "Id", Type: "BIGINT UNSIGNED"},
                {Name: "User", Type: "VARCHAR"},
                {Name: "Host", Type: "VARCHAR"},
                {Name: "db", Type: "VARCHAR"},
                {Name: "Command", Type: "VARCHAR"},
                {Name: "Time", Type: "BIGINT UNSIGNED"},
                {Name: "State", Type: "VARCHAR"},
                {Name: "Info", Type: "TEXT"},
        }

        // 构建结果行
        rows := make([]domain.Row, 0, len(processList))
        for _, item := range processList </span><span class="cov0" title="0">{
                // 使用类型断言和反射来访问字段
                // 由于避免循环依赖，我们假设 item 是一个结构体，包含 QueryID, ThreadID, SQL, StartTime, Duration, Status, User, Host, DB 字段
                itemMap, ok := item.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        // 如果不是 map，跳过
                        continue</span>
                }

                <span class="cov0" title="0">threadID, _ := itemMap["ThreadID"].(uint32)
                sql, _ := itemMap["SQL"].(string)
                duration, _ := itemMap["Duration"].(time.Duration)
                status, _ := itemMap["Status"].(string)
                user, _ := itemMap["User"].(string)
                host, _ := itemMap["Host"].(string)
                db, _ := itemMap["DB"].(string)

                timeSeconds := uint64(duration.Seconds())

                // 获取 Info 字段
                info := sql
                if !full &amp;&amp; len(info) &gt; 100 </span><span class="cov0" title="0">{
                        info = info[:100]
                }</span>

                // 构建 State
                <span class="cov0" title="0">state := "executing"
                if status == "canceled" </span><span class="cov0" title="0">{
                        state = "killed"
                }</span> else<span class="cov0" title="0"> if status == "timeout" </span><span class="cov0" title="0">{
                        state = "timeout"
                }</span>

                // User 和 Host 的默认值
                <span class="cov0" title="0">if user == "" </span><span class="cov0" title="0">{
                        user = "user"
                }</span>
                <span class="cov0" title="0">if host == "" </span><span class="cov0" title="0">{
                        host = "localhost:3306"
                }</span>

                <span class="cov0" title="0">row := domain.Row{
                        "Id":     int64(threadID),
                        "User":   user,
                        "Host":   host,
                        "db":     db,
                        "Command": "Query",
                        "Time":   timeSeconds,
                        "State":  state,
                        "Info":   info,
                }
                rows = append(rows, row)</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    rows,
                Total:   int64(len(rows)),
        }, nil</span>
}

// isInformationSchemaQuery 检查是否是 information_schema 查询
func (e *OptimizedExecutor) isInformationSchemaQuery(tableName string) bool <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 空表名不是 information_schema 查询（如 SELECT DATABASE()）
        <span class="cov0" title="0">if tableName == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for information_schema. prefix (case-insensitive)
        <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(tableName), "information_schema.") </span><span class="cov0" title="0">{
                return true
        }</span>

        // 检查当前数据库是否为 information_schema
        <span class="cov0" title="0">if strings.EqualFold(e.currentDB, "information_schema") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// handleNoFromQuery 处理没有 FROM 子句的查询（如 SELECT DATABASE(), SELECT NOW()）
func (e *OptimizedExecutor) handleNoFromQuery(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov5" title="9">{
        fmt.Println("  [DEBUG] handleNoFromQuery: 开始处理")
        fmt.Printf("  [DEBUG] handleNoFromQuery: e.currentDB = %q\n", e.currentDB)

        // 构建空 row（用于表达式求值）
        row := make(parser.Row)

        // 处理多个列
        columns := make([]domain.ColumnInfo, 0, len(stmt.Columns))
        rowData := make(domain.Row)
        colIdx := 0

        for _, col := range stmt.Columns </span><span class="cov5" title="11">{
                if col.Expr == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("column expression is nil")
                }</span>

                // 确定列名
                <span class="cov5" title="11">colName := col.Alias
                if colName == "" </span><span class="cov5" title="10">{
                        colName = col.Name
                }</span>
                <span class="cov5" title="11">if colName == "" </span><span class="cov5" title="8">{
                        // 如果没有别名和名称，根据表达式生成列名
                        colName = e.generateColumnName(col.Expr)
                }</span>

                // 特殊处理函数调用：如果有名称但没有括号，添加括号
                <span class="cov5" title="11">if col.Expr.Type == parser.ExprTypeFunction &amp;&amp; colName != "" &amp;&amp; !strings.HasSuffix(colName, "()") </span><span class="cov2" title="2">{
                        colName = colName + "()"
                }</span>

                // 特殊处理：如果生成的列名是 NULL，尝试从表达式中提取更多信息
                <span class="cov5" title="11">if colName == "NULL" </span><span class="cov1" title="1">{
                        // 对于无法确定列名的情况，使用默认名称
                        colName = fmt.Sprintf("expr_%d", colIdx)
                }</span>

                <span class="cov5" title="11">fmt.Printf("  [DEBUG] handleNoFromQuery: 处理列 %s, 表达式类型=%s\n", colName, col.Expr.Type)

                // 计算表达式值
                value, err := e.evaluateNoFromExpression(col.Expr, row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to evaluate expression for column %s: %w", colName, err)
                }</span>

                // 确定列类型
                <span class="cov5" title="11">colType := e.inferType(value)

                columns = append(columns, domain.ColumnInfo{Name: colName, Type: colType})
                rowData[colName] = value
                colIdx++</span>
        }

        <span class="cov5" title="9">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    []domain.Row{rowData},
                Total:   1,
        }, nil</span>
}

// generateColumnName 根据表达式生成列名
func (e *OptimizedExecutor) generateColumnName(expr *parser.Expression) string <span class="cov6" title="14">{
        // 特殊处理：如果是系统变量，使用 Column 字段
        if expr.Column != "" &amp;&amp; (strings.HasPrefix(expr.Column, "@@") || strings.HasPrefix(expr.Column, "@")) </span><span class="cov0" title="0">{
                return expr.Column
        }</span>

        <span class="cov6" title="14">switch expr.Type </span>{
        case parser.ExprTypeValue:<span class="cov5" title="11">
                // 常量值：使用值的字符串表示
                if expr.Value != nil </span><span class="cov5" title="10">{
                        return fmt.Sprintf("%v", expr.Value)
                }</span>
                // Value 为 nil 的情况，可能是系统变量或 NULL
                <span class="cov1" title="1">return "NULL"</span>

        case parser.ExprTypeFunction:<span class="cov0" title="0">
                // 函数调用：使用函数名()
                if expr.Function != "" </span><span class="cov0" title="0">{
                        return expr.Function + "()"
                }</span>
                <span class="cov0" title="0">return "function"</span>

        case parser.ExprTypeOperator:<span class="cov3" title="3">
                // 运算符表达式：递归生成操作数和运算符
                return e.generateOperatorColumnName(expr)</span>

        case parser.ExprTypeColumn:<span class="cov0" title="0">
                // 列引用：使用列名
                if expr.Column != "" </span><span class="cov0" title="0">{
                        return expr.Column
                }</span>
                <span class="cov0" title="0">return "column"</span>

        default:<span class="cov0" title="0">
                return "expr"</span>
        }
}

// generateOperatorColumnName 为运算符表达式生成列名
func (e *OptimizedExecutor) generateOperatorColumnName(expr *parser.Expression) string <span class="cov3" title="3">{
        if expr.Operator == "" </span><span class="cov0" title="0">{
                return "expr"
        }</span>

        // 将解析器的运算符名称转换为SQL符号
        <span class="cov3" title="3">opSymbol := e.operatorToSQL(expr.Operator)

        if expr.Left != nil </span><span class="cov3" title="3">{
                leftName := e.generateColumnName(expr.Left)
                if expr.Right != nil </span><span class="cov3" title="3">{
                        rightName := e.generateColumnName(expr.Right)
                        // 二元运算符
                        return leftName + opSymbol + rightName
                }</span>
                // 一元运算符
                <span class="cov0" title="0">return opSymbol + leftName</span>
        }

        <span class="cov0" title="0">if expr.Right != nil </span><span class="cov0" title="0">{
                rightName := e.generateColumnName(expr.Right)
                return opSymbol + rightName
        }</span>

        <span class="cov0" title="0">return "expr"</span>
}

// operatorToSQL 将解析器的运算符名称转换为SQL符号
func (e *OptimizedExecutor) operatorToSQL(op string) string <span class="cov3" title="3">{
        switch strings.ToLower(op) </span>{
        case "plus":<span class="cov1" title="1">
                return "+"</span>
        case "minus":<span class="cov0" title="0">
                return "-"</span>
        case "mul":<span class="cov1" title="1">
                return "*"</span>
        case "div":<span class="cov1" title="1">
                return "/"</span>
        case "eq":<span class="cov0" title="0">
                return "="</span>
        case "neq":<span class="cov0" title="0">
                return "!="</span>
        case "gt":<span class="cov0" title="0">
                return "&gt;"</span>
        case "gte":<span class="cov0" title="0">
                return "&gt;="</span>
        case "lt":<span class="cov0" title="0">
                return "&lt;"</span>
        case "lte":<span class="cov0" title="0">
                return "&lt;="</span>
        case "and":<span class="cov0" title="0">
                return " AND "</span>
        case "or":<span class="cov0" title="0">
                return " OR "</span>
        case "not":<span class="cov0" title="0">
                return "NOT "</span>
        case "like":<span class="cov0" title="0">
                return " LIKE "</span>
        default:<span class="cov0" title="0">
                return op</span>
        }
}

// evaluateNoFromExpression 评估无 FROM 子句的表达式
func (e *OptimizedExecutor) evaluateNoFromExpression(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov5" title="11">{
        // 特殊处理：如果 Column 字段包含系统变量（即使 Type 不是 COLUMN）
        if expr.Column != "" &amp;&amp; (strings.HasPrefix(expr.Column, "@@") || strings.HasPrefix(expr.Column, "@")) </span><span class="cov0" title="0">{
                return e.evaluateVariable(expr.Column)
        }</span>

        <span class="cov5" title="11">switch expr.Type </span>{
        case parser.ExprTypeValue:<span class="cov4" title="6">
                // 常量值
                fmt.Printf("  [DEBUG] evaluateNoFromExpression: 常量值=%v\n", expr.Value)
                // 特殊处理：如果 Value 为 nil，返回默认的系统变量值
                // 注意：这是启发式方法，因为解析器无法提供原始变量名
                if expr.Value == nil </span><span class="cov1" title="1">{
                        // 返回 @@version_comment 的默认值
                        return "sqlexec MySQL-compatible database", nil
                }</span>
                <span class="cov4" title="5">return expr.Value, nil</span>

        case parser.ExprTypeColumn:<span class="cov0" title="0">
                // 变量引用（系统变量、会话变量）
                if expr.Column != "" </span><span class="cov0" title="0">{
                        return e.evaluateVariable(expr.Column)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("column reference without column name")</span>

        case parser.ExprTypeFunction:<span class="cov2" title="2">
                // 函数调用
                return e.evaluateFunctionExpression(expr, row)</span>

        case parser.ExprTypeOperator:<span class="cov3" title="3">
                // 运算符表达式
                return e.exprEvaluator.Evaluate(expr, row)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported expression type: %s", expr.Type)</span>
        }
}

// evaluateVariable 评估变量（系统变量或会话变量）
func (e *OptimizedExecutor) evaluateVariable(colName string) (interface{}, error) <span class="cov0" title="0">{
        varName := strings.ToUpper(strings.TrimSpace(colName))

        fmt.Printf("  [DEBUG] evaluateVariable: 变量名=%s\n", varName)

        // 处理系统变量（@@variable）
        if strings.HasPrefix(varName, "@@") </span><span class="cov0" title="0">{
                return e.evaluateSystemVariable(varName)
        }</span>

        // 处理会话变量（@variable）
        <span class="cov0" title="0">if strings.HasPrefix(varName, "@") &amp;&amp; !strings.HasPrefix(varName, "@@") </span><span class="cov0" title="0">{
                return e.evaluateSessionVariable(varName)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported variable: %s", colName)</span>
}

// evaluateSystemVariable 评估系统变量
func (e *OptimizedExecutor) evaluateSystemVariable(varName string) (interface{}, error) <span class="cov0" title="0">{
        // 移除 @@ 前缀
        name := strings.TrimPrefix(varName, "@@")

        // 移除作用域前缀（@@global., @@session., @@local.）
        name = strings.TrimPrefix(name, "GLOBAL.")
        name = strings.TrimPrefix(name, "SESSION.")
        name = strings.TrimPrefix(name, "LOCAL.")

        fmt.Printf("  [DEBUG] evaluateSystemVariable: 系统变量=%s\n", name)

        // 处理已知的系统变量
        switch name </span>{
        case "VERSION_COMMENT", "@@VERSION_COMMENT":<span class="cov0" title="0">
                return "sqlexec MySQL-compatible database", nil</span>
        case "VERSION":<span class="cov0" title="0">
                return "8.0.0-sqlexec", nil</span>
        case "PORT":<span class="cov0" title="0">
                return 3307, nil</span>
        case "HOSTNAME":<span class="cov0" title="0">
                return "localhost", nil</span>
        case "DATADIR":<span class="cov0" title="0">
                return "/var/lib/mysql", nil</span>
        case "SERVER_ID":<span class="cov0" title="0">
                return 1, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown system variable: %s", name)</span>
        }
}

// evaluateSessionVariable 评估会话变量
func (e *OptimizedExecutor) evaluateSessionVariable(varName string) (interface{}, error) <span class="cov0" title="0">{
        // 移除 @ 前缀
        name := strings.TrimPrefix(varName, "@")

        fmt.Printf("  [DEBUG] evaluateSessionVariable: 会话变量=%s\n", name)

        // 当前实现中，我们无法访问 session 对象
        // 这是一个限制，需要在未来改进架构
        return nil, fmt.Errorf("session variables not yet supported in no-FROM queries: %s", name)
}</span>

// evaluateFunctionExpression 评估函数表达式
func (e *OptimizedExecutor) evaluateFunctionExpression(expr *parser.Expression, row parser.Row) (interface{}, error) <span class="cov2" title="2">{
        funcName := strings.ToUpper(expr.Function)

        fmt.Printf("  [DEBUG] evaluateFunctionExpression: 函数名=%s\n", funcName)

        // 特殊处理 DATABASE() 函数（因为它需要当前数据库上下文）
        if funcName == "DATABASE" </span><span class="cov1" title="1">{
                return e.currentDB, nil
        }</span>

        // 对于其他函数，使用 ExpressionEvaluator
        <span class="cov1" title="1">return e.exprEvaluator.Evaluate(expr, row)</span>
}

// inferType 推断值的类型
func (e *OptimizedExecutor) inferType(value interface{}) string <span class="cov5" title="11">{
        if value == nil </span><span class="cov0" title="0">{
                return "null"
        }</span>

        <span class="cov5" title="11">switch value.(type) </span>{
        case int, int8, int16, int32, uint, uint8, uint16, uint32, int64, uint64:<span class="cov4" title="5">
                return "int"</span>
        case float32, float64:<span class="cov3" title="3">
                return "float"</span>
        case bool:<span class="cov0" title="0">
                return "bool"</span>
        case string:<span class="cov2" title="2">
                return "string"</span>
        case time.Time:<span class="cov1" title="1">
                return "datetime"</span>
        default:<span class="cov0" title="0">
                return "string"</span>
        }
}

// executeWithOptimizer 使用优化器执行查询
func (e *OptimizedExecutor) executeWithOptimizer(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] 开始优化查询...")

        // 处理没有 FROM 子句的查询（如 SELECT DATABASE()）
        if stmt.From == "" </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] 检测到无 FROM 子句的查询")
                return e.handleNoFromQuery(ctx, stmt)
        }</span>

        // 再次检查是否是 information_schema 查询
        // 因为 optimizer 路径不支持 information_schema 虚拟表
        <span class="cov0" title="0">if e.isInformationSchemaQuery(stmt.From) </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] 在 optimizer 路径中检测到 information_schema 查询，切换到 builder 路径")
                return e.executeWithBuilder(ctx, stmt)
        }</span>

        // 1. 构建 SQLStatement
        <span class="cov0" title="0">sqlStmt := &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: stmt,
        }
        fmt.Println("  [DEBUG] SQLStatement构建完成")

        // 2. 优化查询计划
        fmt.Println("  [DEBUG] 调用 Optimize...")
        physicalPlan, err := e.optimizer.Optimize(ctx, sqlStmt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("optimizer failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("  [DEBUG] Optimize完成")

        // 3. 执行物理计划
        fmt.Println("  [DEBUG] 开始执行物理计划...")
        result, err := physicalPlan.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("execute physical plan failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("  [DEBUG] 物理计划执行完成")

        // 4. 设置列信息
        tableInfo, err := e.dataSource.GetTableInfo(ctx, stmt.From)
        if err == nil </span><span class="cov0" title="0">{
                // 根据选择的列过滤
                if !isWildcard(stmt.Columns) </span><span class="cov0" title="0">{
                        result.Columns = filterColumns(tableInfo.Columns, stmt.Columns)
                }</span> else<span class="cov0" title="0"> {
                        result.Columns = tableInfo.Columns
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// getVirtualDataSource 获取 information_schema 虚拟数据源
func (e *OptimizedExecutor) getVirtualDataSource() domain.DataSource <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 尝试获取全局ACL Manager adapter
        <span class="cov0" title="0">aclAdapter := information_schema.GetACLManagerAdapter()

        // 使用ACL Manager adapter创建provider，以便权限表可以正常工作
        if aclAdapter != nil </span><span class="cov0" title="0">{
                provider := information_schema.NewProviderWithACL(e.dsManager, aclAdapter)
                return virtual.NewVirtualDataSource(provider)
        }</span>

        // 如果没有ACL Manager，使用不带ACL的provider
        <span class="cov0" title="0">provider := information_schema.NewProvider(e.dsManager)
        return virtual.NewVirtualDataSource(provider)</span>
}

// executeWithBuilder 使用 QueryBuilder 执行查询（传统路径）
func (e *OptimizedExecutor) executeWithBuilder(ctx context.Context, stmt *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // If this is an information_schema query, use virtual data source
        if e.isInformationSchemaQuery(stmt.From) </span><span class="cov0" title="0">{
                vds := e.getVirtualDataSource()
                if vds != nil </span><span class="cov0" title="0">{
                        // Strip the "information_schema." prefix from the table name
                        tableName := stmt.From
                        if strings.HasPrefix(strings.ToLower(tableName), "information_schema.") </span><span class="cov0" title="0">{
                                tableName = strings.TrimPrefix(tableName, "information_schema.")
                                // Also handle case where prefix is "INFORMATION_SCHEMA."
                                tableName = strings.TrimPrefix(tableName, "INFORMATION_SCHEMA.")
                        }</span>

                        // Create a new SelectStatement with the stripped table name
                        <span class="cov0" title="0">newStmt := *stmt
                        newStmt.From = tableName

                        builder := parser.NewQueryBuilder(vds)
                        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                                Type:   parser.SQLTypeSelect,
                                Select: &amp;newStmt,
                        })</span>
                }
        }

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: stmt,
        })</span>
}

// ExecuteInsert 执行 INSERT
func (e *OptimizedExecutor) ExecuteInsert(ctx context.Context, stmt *parser.InsertStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to INSERT into information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: INSERT operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeInsert,
                Insert: stmt,
        })</span>
}

// ExecuteUpdate 执行 UPDATE
func (e *OptimizedExecutor) ExecuteUpdate(ctx context.Context, stmt *parser.UpdateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to UPDATE information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: UPDATE operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeUpdate,
                Update: stmt,
        })</span>
}

// ExecuteDelete 执行 DELETE
func (e *OptimizedExecutor) ExecuteDelete(ctx context.Context, stmt *parser.DeleteStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check if trying to DELETE from information_schema
        if e.isInformationSchemaTable(stmt.Table) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("information_schema is read-only: DELETE operation not supported")
        }</span>

        <span class="cov0" title="0">builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeDelete,
                Delete: stmt,
        })</span>
}

// ExecuteCreate 执行 CREATE
func (e *OptimizedExecutor) ExecuteCreate(ctx context.Context, stmt *parser.CreateStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeCreate,
                Create: stmt,
        })
}</span>

// ExecuteDrop 执行 DROP
func (e *OptimizedExecutor) ExecuteDrop(ctx context.Context, stmt *parser.DropStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:  parser.SQLTypeDrop,
                Drop:  stmt,
        })
}</span>

// ExecuteAlter 执行 ALTER
func (e *OptimizedExecutor) ExecuteAlter(ctx context.Context, stmt *parser.AlterStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:  parser.SQLTypeAlter,
                Alter: stmt,
        })
}</span>

// ExecuteCreateIndex 执行 CREATE INDEX
func (e *OptimizedExecutor) ExecuteCreateIndex(ctx context.Context, stmt *parser.CreateIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:       parser.SQLTypeCreate,
                CreateIndex: stmt,
        })
}</span>

// ExecuteDropIndex 执行 DROP INDEX
func (e *OptimizedExecutor) ExecuteDropIndex(ctx context.Context, stmt *parser.DropIndexStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        builder := parser.NewQueryBuilder(e.dataSource)
        return builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:     parser.SQLTypeDrop,
                DropIndex: stmt,
        })
}</span>

// filterColumns 过滤列信息
func filterColumns(columns []domain.ColumnInfo, selectCols []parser.SelectColumn) []domain.ColumnInfo <span class="cov0" title="0">{
        result := make([]domain.ColumnInfo, 0, len(selectCols))

        // 构建选择的列名映射
        selectMap := make(map[string]bool)
        for _, col := range selectCols </span><span class="cov0" title="0">{
                if !col.IsWildcard &amp;&amp; col.Name != "" </span><span class="cov0" title="0">{
                        selectMap[col.Name] = true
                }</span>
        }

        // 过滤列
        <span class="cov0" title="0">for _, col := range columns </span><span class="cov0" title="0">{
                if selectMap[col.Name] </span><span class="cov0" title="0">{
                        result = append(result, col)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// isInformationSchemaTable 检查表是否属于 information_schema
func (e *OptimizedExecutor) isInformationSchemaTable(tableName string) bool <span class="cov0" title="0">{
        if e.dsManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for information_schema. prefix (case-insensitive)
        <span class="cov0" title="0">if strings.Contains(tableName, ".") </span><span class="cov0" title="0">{
                parts := strings.SplitN(tableName, ".", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "information_schema" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

</pre>
		
		<pre class="file" id="file24" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Optimizer 优化器
type Optimizer struct {
        rules      RuleSet
        costModel  CostModel
        dataSource domain.DataSource
}

// NewOptimizer 创建优化器
func NewOptimizer(dataSource domain.DataSource) *Optimizer <span class="cov8" title="56">{
        return &amp;Optimizer{
                rules:     DefaultRuleSet(),
                costModel:  NewDefaultCostModel(),
                dataSource: dataSource,
        }
}</span>

// Optimize 优化查询计划
func (o *Optimizer) Optimize(ctx context.Context, stmt *parser.SQLStatement) (PhysicalPlan, error) <span class="cov7" title="38">{
        fmt.Println("  [DEBUG] Optimize: 步骤1 - 转换为逻辑计划")
        // 1. 转换为逻辑计划
        logicalPlan, err := o.convertToLogicalPlan(stmt)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("convert to logical plan failed: %w", err)
        }</span>
        <span class="cov7" title="36">fmt.Println("  [DEBUG] Optimize: 逻辑计划转换完成, 类型:", logicalPlan.Explain())

        // 2. 应用优化规则
        fmt.Println("  [DEBUG] Optimize: 步骤2 - 应用优化规则")
        optCtx := &amp;OptimizationContext{
                DataSource: o.dataSource,
                TableInfo: make(map[string]*domain.TableInfo),
                Stats:      make(map[string]*Statistics),
                CostModel:  o.costModel,
        }

        optimizedPlan, err := o.rules.Apply(ctx, logicalPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apply optimization rules failed: %w", err)
        }</span>
        <span class="cov7" title="36">fmt.Println("  [DEBUG] Optimize: 优化规则应用完成")

        // 3. 转换为物理计划
        fmt.Println("  [DEBUG] Optimize: 步骤3 - 转换为物理计划")
        physicalPlan, err := o.convertToPhysicalPlan(ctx, optimizedPlan, optCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("convert to physical plan failed: %w", err)
        }</span>
        <span class="cov7" title="36">fmt.Println("  [DEBUG] Optimize: 物理计划转换完成")

        return physicalPlan, nil</span>
}

// convertToLogicalPlan 将 SQL 语句转换为逻辑计划
func (o *Optimizer) convertToLogicalPlan(stmt *parser.SQLStatement) (LogicalPlan, error) <span class="cov8" title="58">{
        switch stmt.Type </span>{
        case parser.SQLTypeSelect:<span class="cov8" title="58">
                return o.convertSelect(stmt.Select)</span>
        case parser.SQLTypeInsert:<span class="cov0" title="0">
                return o.convertInsert(stmt.Insert)</span>
        case parser.SQLTypeUpdate:<span class="cov0" title="0">
                return o.convertUpdate(stmt.Update)</span>
        case parser.SQLTypeDelete:<span class="cov0" title="0">
                return o.convertDelete(stmt.Delete)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported SQL type: %s", stmt.Type)</span>
        }
}

// convertSelect 转换 SELECT 语句
func (o *Optimizer) convertSelect(stmt *parser.SelectStatement) (LogicalPlan, error) <span class="cov8" title="58">{
        fmt.Println("  [DEBUG] convertSelect: 开始转换, 表名:", stmt.From)

        // 处理没有 FROM 子句的查询（如 SELECT DATABASE()）
        if stmt.From == "" </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] convertSelect: 无 FROM 子句，使用常量数据源")
                // 创建一个虚拟表，只有一行一列
                virtualTableInfo := &amp;domain.TableInfo{
                        Name:    "dual",
                        Columns: []domain.ColumnInfo{},
                }

                var logicalPlan LogicalPlan = NewLogicalDataSource("dual", virtualTableInfo)

                // 应用 WHERE 条件（Selection）
                if stmt.Where != nil </span><span class="cov0" title="0">{
                        conditions := o.extractConditions(stmt.Where)
                        logicalPlan = NewLogicalSelection(conditions, logicalPlan)
                }</span>

                // 应用 GROUP BY（Aggregate）
                <span class="cov0" title="0">if len(stmt.GroupBy) &gt; 0 </span><span class="cov0" title="0">{
                        aggFuncs := o.extractAggFuncs(stmt.Columns)
                        logicalPlan = NewLogicalAggregate(aggFuncs, stmt.GroupBy, logicalPlan)
                }</span>

                // 应用 ORDER BY（Sort）
                <span class="cov0" title="0">if len(stmt.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                        orderItems := make([]OrderByItem, len(stmt.OrderBy))
                        for i, item := range stmt.OrderBy </span><span class="cov0" title="0">{
                                orderItems[i] = OrderByItem{
                                        Column:    item.Column,
                                        Direction: item.Direction,
                                }
                        }</span>
                        <span class="cov0" title="0">logicalPlan = NewLogicalSort(orderItems, logicalPlan)</span>
                }

                // 应用 LIMIT（Limit）
                <span class="cov0" title="0">if stmt.Limit != nil </span><span class="cov0" title="0">{
                        limit := *stmt.Limit
                        offset := int64(0)
                        if stmt.Offset != nil </span><span class="cov0" title="0">{
                                offset = *stmt.Offset
                        }</span>
                        <span class="cov0" title="0">logicalPlan = NewLogicalLimit(limit, offset, logicalPlan)</span>
                }

                <span class="cov0" title="0">return logicalPlan, nil</span>
        }

        // 1. 创建 DataSource
        <span class="cov8" title="58">tableInfo, err := o.dataSource.GetTableInfo(context.Background(), stmt.From)
        if err != nil </span><span class="cov3" title="3">{
                fmt.Println("  [DEBUG] convertSelect: GetTableInfo 失败:", err)
                return nil, fmt.Errorf("get table info failed: %w", err)
        }</span>
        <span class="cov8" title="55">fmt.Println("  [DEBUG] convertSelect: GetTableInfo 成功, 列数:", len(tableInfo.Columns))

        var logicalPlan LogicalPlan = NewLogicalDataSource(stmt.From, tableInfo)
        fmt.Println("  [DEBUG] convertSelect: LogicalDataSource 创建完成")

        // 2. 应用 WHERE 条件（Selection）
        if stmt.Where != nil </span><span class="cov7" title="26">{
                conditions := o.extractConditions(stmt.Where)
                logicalPlan = NewLogicalSelection(conditions, logicalPlan)
        }</span>

        // 3. 应用 GROUP BY（Aggregate）
        <span class="cov8" title="55">if len(stmt.GroupBy) &gt; 0 </span><span class="cov4" title="5">{
                aggFuncs := o.extractAggFuncs(stmt.Columns)
                logicalPlan = NewLogicalAggregate(aggFuncs, stmt.GroupBy, logicalPlan)
        }</span>

        // 4. 应用 ORDER BY（Sort）
        <span class="cov8" title="55">if len(stmt.OrderBy) &gt; 0 </span><span class="cov4" title="6">{
                orderItems := make([]OrderByItem, len(stmt.OrderBy))
                for i, item := range stmt.OrderBy </span><span class="cov4" title="6">{
                        orderItems[i] = OrderByItem{
                                Column:    item.Column,
                                Direction: item.Direction,
                        }
                }</span>
                <span class="cov4" title="6">logicalPlan = NewLogicalSort(orderItems, logicalPlan)</span>
        }

        // 5. 应用 LIMIT（Limit）
        <span class="cov8" title="55">if stmt.Limit != nil </span><span class="cov4" title="8">{
                limit := *stmt.Limit
                offset := int64(0)
                if stmt.Offset != nil </span><span class="cov0" title="0">{
                        offset = *stmt.Offset
                }</span>
                <span class="cov4" title="8">logicalPlan = NewLogicalLimit(limit, offset, logicalPlan)</span>
        }

        // 6. 应用 SELECT 列（Projection）
        <span class="cov8" title="55">fmt.Printf("  [DEBUG] convertSelect: SELECT列数量: %d, IsWildcard=%v\n", len(stmt.Columns), isWildcard(stmt.Columns))
        if len(stmt.Columns) &gt; 0 </span><span class="cov8" title="55">{
                fmt.Printf("  [DEBUG] convertSelect: cols[0].Name='%s'\n", stmt.Columns[0].Name)
        }</span>
        <span class="cov8" title="55">if len(stmt.Columns) &gt; 0 &amp;&amp; !isWildcard(stmt.Columns) </span><span class="cov8" title="55">{
                fmt.Println("  [DEBUG] convertSelect: 创建Projection")
                exprs := make([]*parser.Expression, len(stmt.Columns))
                aliases := make([]string, len(stmt.Columns))
                for i, col := range stmt.Columns </span><span class="cov9" title="80">{
                        fmt.Printf("  [DEBUG] convertSelect: 列%d: Name='%s', Alias='%s'\n", i, col.Name, col.Alias)
                        exprs[i] = &amp;parser.Expression{
                                Type:   parser.ExprTypeColumn,
                                Column: col.Name,
                        }
                        if col.Alias != "" </span><span class="cov4" title="8">{
                                aliases[i] = col.Alias
                        }</span> else<span class="cov9" title="72"> {
                                aliases[i] = col.Name
                        }</span>
                }
                <span class="cov8" title="55">logicalPlan = NewLogicalProjection(exprs, aliases, logicalPlan)</span>
        }

        <span class="cov8" title="55">return logicalPlan, nil</span>
}

// convertInsert 转换 INSERT 语句
func (o *Optimizer) convertInsert(stmt *parser.InsertStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("INSERT statement not supported in optimizer yet")
}</span>

// convertUpdate 转换 UPDATE 语句
func (o *Optimizer) convertUpdate(stmt *parser.UpdateStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("UPDATE statement not supported in optimizer yet")
}</span>

// convertDelete 转换 DELETE 语句
func (o *Optimizer) convertDelete(stmt *parser.DeleteStatement) (LogicalPlan, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("DELETE statement not supported in optimizer yet")
}</span>

// extractConditions 从表达式中提取条件列表
func (o *Optimizer) extractConditions(expr *parser.Expression) []*parser.Expression <span class="cov7" title="26">{
        conditions := []*parser.Expression{expr}
        // 简化实现，不处理复杂表达式
        return conditions
}</span>

// extractAggFuncs 提取聚合函数
// 从 SELECT 列中识别并提取聚合函数（如 COUNT, SUM, AVG, MAX, MIN）
func (o *Optimizer) extractAggFuncs(cols []parser.SelectColumn) []*AggregationItem <span class="cov4" title="5">{
        aggFuncs := []*AggregationItem{}

        for _, col := range cols </span><span class="cov5" title="11">{
                // 跳过通配符
                if col.IsWildcard </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 检查表达式类型
                <span class="cov5" title="11">if col.Expr == nil </span><span class="cov5" title="11">{
                        continue</span>
                }

                // 解析聚合函数
                <span class="cov0" title="0">if aggItem := o.parseAggregationFunction(col.Expr); aggItem != nil </span><span class="cov0" title="0">{
                        // 如果有别名，使用别名；否则使用聚合函数名称
                        if col.Alias != "" </span><span class="cov0" title="0">{
                                aggItem.Alias = col.Alias
                        }</span> else<span class="cov0" title="0"> {
                                // 生成默认别名（如 "COUNT_id", "SUM_amount"）
                                aggItem.Alias = fmt.Sprintf("%s_%s", aggItem.Type.String(),
                                        expressionToString(col.Expr))
                        }</span>
                        <span class="cov0" title="0">aggFuncs = append(aggFuncs, aggItem)</span>
                }
        }

        <span class="cov4" title="5">return aggFuncs</span>
}

// parseAggregationFunction 解析单个聚合函数
func (o *Optimizer) parseAggregationFunction(expr *parser.Expression) *AggregationItem <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 检查是否是函数调用（Type == ExprTypeFunction 或函数名）
        <span class="cov0" title="0">funcName := ""
        var funcExpr *parser.Expression

        // 尝试从表达式提取函数名和参数
        if expr.Type == parser.ExprTypeFunction </span><span class="cov0" title="0">{
                // 假设表达式中有 FunctionName 和 Args 字段
                if name, ok := expr.Value.(string); ok </span><span class="cov0" title="0">{
                        funcName = name
                }</span>
                <span class="cov0" title="0">funcExpr = expr</span>
        } else<span class="cov0" title="0"> if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                // 可能是列名，也可能包含函数调用
                colName := expr.Column
                // 解析函数名（如 "COUNT(id)" -&gt; "COUNT"）
                if idx := strings.Index(colName, "("); idx &gt; 0 </span><span class="cov0" title="0">{
                        funcName = strings.ToUpper(colName[:idx])
                }</span>
        }

        // 匹配聚合函数类型
        <span class="cov0" title="0">var aggType AggregationType
        isDistinct := false

        // 检查 DISTINCT 关键字
        if strings.Contains(strings.ToUpper(o.expressionToString(expr)), "DISTINCT") </span><span class="cov0" title="0">{
                isDistinct = true
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(funcName) </span>{
        case "COUNT":<span class="cov0" title="0">
                aggType = Count</span>
        case "SUM":<span class="cov0" title="0">
                aggType = Sum</span>
        case "AVG":<span class="cov0" title="0">
                aggType = Avg</span>
        case "MAX":<span class="cov0" title="0">
                aggType = Max</span>
        case "MIN":<span class="cov0" title="0">
                aggType = Min</span>
        default:<span class="cov0" title="0">
                // 不是聚合函数
                return nil</span>
        }

        // 构建聚合项
        <span class="cov0" title="0">return &amp;AggregationItem{
                Type:     aggType,
                Expr:     funcExpr,
                Alias:    "",
                Distinct: isDistinct,
        }</span>
}

// expressionToString 将表达式转换为字符串
func (o *Optimizer) expressionToString(expr *parser.Expression) string <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                return expr.Column
        }</span>

        <span class="cov0" title="0">if expr.Type == parser.ExprTypeValue </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", expr.Value)
        }</span>

        <span class="cov0" title="0">if expr.Type == parser.ExprTypeOperator </span><span class="cov0" title="0">{
                left := o.expressionToString(expr.Left)
                right := o.expressionToString(expr.Right)
                if left != "" &amp;&amp; right != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s %s %s", left, expr.Operator, right)
                }</span>
                <span class="cov0" title="0">if left != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s %s", expr.Operator, left)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", expr.Value)</span>
}

// isWildcard 检查是否是通配符
func isWildcard(cols []parser.SelectColumn) bool <span class="cov10" title="110">{
        if len(cols) == 1 &amp;&amp; cols[0].IsWildcard </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov10" title="110">return false</span>
}

// convertConditionsToFilters 将条件表达式转换为过滤器
func (o *Optimizer) convertConditionsToFilters(conditions []*parser.Expression) []domain.Filter <span class="cov7" title="36">{
        filters := []domain.Filter{}

        for _, cond := range conditions </span><span class="cov6" title="20">{
                if cond == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 提取 AND 条件中的所有独立条件
                <span class="cov6" title="20">conditionFilters := o.extractFiltersFromCondition(cond)
                filters = append(filters, conditionFilters...)</span>
        }

        <span class="cov7" title="36">fmt.Println("  [DEBUG] convertConditionsToFilters: 生成的过滤器数量:", len(filters))
        return filters</span>
}

// extractFiltersFromCondition 从条件中提取所有过滤器（处理 AND 表达式）
func (o *Optimizer) extractFiltersFromCondition(expr *parser.Expression) []domain.Filter <span class="cov7" title="30">{
        filters := []domain.Filter{}
        
        if expr == nil </span><span class="cov0" title="0">{
                return filters
        }</span>

        // 如果是 AND 操作符，递归处理两边
        <span class="cov7" title="30">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "and" </span><span class="cov4" title="5">{
                if expr.Left != nil </span><span class="cov4" title="5">{
                        filters = append(filters, o.extractFiltersFromCondition(expr.Left)...)
                }</span>
                <span class="cov4" title="5">if expr.Right != nil </span><span class="cov4" title="5">{
                        filters = append(filters, o.extractFiltersFromCondition(expr.Right)...)
                }</span>
                <span class="cov4" title="5">return filters</span>
        }

        // 否则，转换为单个过滤器
        <span class="cov7" title="25">filter := o.convertExpressionToFilter(expr)
        if filter != nil </span><span class="cov6" title="16">{
                filters = append(filters, *filter)
        }</span>

        <span class="cov7" title="25">return filters</span>
}

// convertExpressionToFilter 将表达式转换为过滤器
func (o *Optimizer) convertExpressionToFilter(expr *parser.Expression) *domain.Filter <span class="cov7" title="25">{
        if expr == nil || expr.Type != parser.ExprTypeOperator </span><span class="cov0" title="0">{
                return nil
        }</span>

                // 处理二元比较表达式 (e.g., age &gt; 30, name = 'Alice')
                <span class="cov7" title="25">if expr.Left != nil &amp;&amp; expr.Right != nil &amp;&amp; expr.Operator != "" </span><span class="cov7" title="25">{
                        // 左边是列名
                        if expr.Left.Type == parser.ExprTypeColumn &amp;&amp; expr.Left.Column != "" </span><span class="cov6" title="16">{
                                // 右边是常量值
                                if expr.Right.Type == parser.ExprTypeValue </span><span class="cov6" title="16">{
                                        // 映射操作符
                                        operator := o.mapOperator(expr.Operator)
                                        return &amp;domain.Filter{
                                                Field:    expr.Left.Column,
                                                Operator:  operator,
                                                Value:     expr.Right.Value,
                                        }
                                }</span>
                        }
                }

                // 处理 AND 逻辑表达式
                <span class="cov5" title="9">if expr.Operator == "and" &amp;&amp; expr.Left != nil &amp;&amp; expr.Right != nil </span><span class="cov0" title="0">{
                        leftFilter := o.convertExpressionToFilter(expr.Left)
                        rightFilter := o.convertExpressionToFilter(expr.Right)
                        if leftFilter != nil </span><span class="cov0" title="0">{
                                return leftFilter
                        }</span>
                        <span class="cov0" title="0">if rightFilter != nil </span><span class="cov0" title="0">{
                                return rightFilter
                        }</span>
                }

        <span class="cov5" title="9">return nil</span>
}

// mapOperator 映射parser操作符到domain.Filter操作符
func (o *Optimizer) mapOperator(parserOp string) string <span class="cov6" title="16">{
        // 转换parser操作符到domain.Filter操作符
        switch parserOp </span>{
        case "gt":<span class="cov6" title="14">
                return "&gt;"</span>
        case "gte":<span class="cov0" title="0">
                return "&gt;="</span>
        case "lt":<span class="cov1" title="1">
                return "&lt;"</span>
        case "lte":<span class="cov0" title="0">
                return "&lt;="</span>
        case "eq", "===":<span class="cov0" title="0">
                return "="</span>
        case "ne", "!=":<span class="cov0" title="0">
                return "!="</span>
        default:<span class="cov1" title="1">
                return parserOp</span>
        }
}

// convertToPhysicalPlan 将逻辑计划转换为物理计划
func (o *Optimizer) convertToPhysicalPlan(ctx context.Context, logicalPlan LogicalPlan, optCtx *OptimizationContext) (PhysicalPlan, error) <span class="cov9" title="77">{
        switch p := logicalPlan.(type) </span>{
        case *LogicalDataSource:<span class="cov7" title="36">
                // 获取下推的谓词条件
                pushedDownPredicates := p.GetPushedDownPredicates()
                filters := o.convertConditionsToFilters(pushedDownPredicates)
                // 获取下推的Limit
                limitInfo := p.GetPushedDownLimit()
                fmt.Printf("  [DEBUG] convertToPhysicalPlan: DataSource(%s), 下推谓词数量: %d, 下推Limit: %v\n", p.TableName, len(filters), limitInfo != nil)
                return NewPhysicalTableScan(p.TableName, p.TableInfo, o.dataSource, filters, limitInfo), nil</span>
        case *LogicalSelection:<span class="cov0" title="0">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // 转换条件为过滤器
                <span class="cov0" title="0">filters := o.convertConditionsToFilters(p.GetConditions())
                fmt.Println("  [DEBUG] convertToPhysicalPlan: Selection, 过滤器数量:", len(filters))
                return NewPhysicalSelection(p.GetConditions(), filters, child, o.dataSource), nil</span>
        case *LogicalProjection:<span class="cov7" title="33">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="33">exprs := p.GetExprs()
                aliases := p.GetAliases()
                fmt.Printf("  [DEBUG] convertToPhysicalPlan: Projection, 表达式数量: %d, 别名数量: %d\n", len(exprs), len(aliases))
                for i, expr := range exprs </span><span class="cov8" title="41">{
                        fmt.Printf("  [DEBUG] convertToPhysicalPlan: 表达式%d: Type=%v, Column='%s'\n", i, expr.Type, expr.Column)
                        if i &lt; len(aliases) </span><span class="cov8" title="41">{
                                fmt.Printf("  [DEBUG] convertToPhysicalPlan: 别名%d: '%s'\n", i, aliases[i])
                        }</span>
                }
                <span class="cov7" title="33">return NewPhysicalProjection(exprs, aliases, child), nil</span>
        case *LogicalLimit:<span class="cov1" title="1">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return NewPhysicalLimit(p.GetLimit(), p.GetOffset(), child), nil</span>
        case *LogicalSort:<span class="cov3" title="4">
                // 简化：暂时不实现排序
                return o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                left, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">right, err := o.convertToPhysicalPlan(ctx, p.Children()[1], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return NewPhysicalHashJoin(p.GetJoinType(), left, right, p.GetJoinConditions()), nil</span>
        case *LogicalAggregate:<span class="cov3" title="3">
                child, err := o.convertToPhysicalPlan(ctx, p.Children()[0], optCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">return NewPhysicalHashAggregate(p.GetAggFuncs(), p.GetGroupByCols(), child), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported logical plan type: %T", p)</span>
        }
}

// ExplainPlan 解释执行计划
func ExplainPlan(plan PhysicalPlan) string <span class="cov7" title="24">{
        return explainPlan(plan, 0)
}</span>

// explainPlan 递归解释计划
func explainPlan(plan PhysicalPlan, depth int) string <span class="cov8" title="61">{
        indent := ""
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="56">{
                indent += "  "
        }</span>

        <span class="cov8" title="61">result := indent + plan.Explain() + "\n"

        for _, child := range plan.Children() </span><span class="cov7" title="37">{
                result += explainPlan(child, depth+1)
        }</span>

        <span class="cov8" title="61">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// ORToUnionRule OR转UNION规则
// 将包含OR条件的Selection转换为UNION
type ORToUnionRule struct{}

// NewORToUnionRule 创建OR转UNION规则
func NewORToUnionRule() *ORToUnionRule <span class="cov7" title="19">{
        return &amp;ORToUnionRule{}
}</span>

// Name 返回规则名称
func (r *ORToUnionRule) Name() string <span class="cov0" title="0">{
        return "ORToUnion"
}</span>

// Match 检查规则是否匹配
func (r *ORToUnionRule) Match(plan LogicalPlan) bool <span class="cov9" title="52">{
        selection, ok := plan.(*LogicalSelection)
        if !ok </span><span class="cov9" title="46">{
                return false
        }</span>

        // 检查是否包含OR条件
        <span class="cov4" title="6">conditions := selection.Conditions()
        return r.hasORCondition(conditions)</span>
}

// Apply 应用规则
func (r *ORToUnionRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        selection, ok := plan.(*LogicalSelection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        // 转换OR为UNION
        <span class="cov0" title="0">unionPlan := r.convertORToUnion(selection)
        if unionPlan != nil </span><span class="cov0" title="0">{
                fmt.Println("  [OR2UNION] Converted OR to UNION")
                return unionPlan, nil
        }</span>

        <span class="cov0" title="0">return plan, nil</span>
}

// hasORCondition 检查条件列表中是否包含OR条件
func (r *ORToUnionRule) hasORCondition(conditions []*parser.Expression) bool <span class="cov4" title="6">{
        for _, cond := range conditions </span><span class="cov4" title="6">{
                if r.isORExpression(cond) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov4" title="6">return false</span>
}

// convertORToUnion 将Selection中的OR条件转换为UNION
func (r *ORToUnionRule) convertORToUnion(selection *LogicalSelection) LogicalPlan <span class="cov0" title="0">{
        conditions := selection.Conditions()
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">child := selection.Children()[0]
        if child == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 提取OR条件并分解为独立分支
        <span class="cov0" title="0">orBranches := r.extractORBranches(conditions)
        if len(orBranches) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 为每个OR分支创建独立的查询计划
        <span class="cov0" title="0">unionChildren := make([]LogicalPlan, 0, len(orBranches))
        for _, branch := range orBranches </span><span class="cov0" title="0">{
                // 为每个分支创建Selection
                branchSelection := NewLogicalSelection(branch, child)
                unionChildren = append(unionChildren, branchSelection)
        }</span>

        // 创建UNION节点
        <span class="cov0" title="0">return NewLogicalUnion(unionChildren)</span>
}

// extractORBranches 从条件中提取OR分支
// 将复杂的OR表达式分解为简单的独立条件
func (r *ORToUnionRule) extractORBranches(conditions []*parser.Expression) [][]*parser.Expression <span class="cov0" title="0">{
        branches := make([][]*parser.Expression, 0)

        for _, cond := range conditions </span><span class="cov0" title="0">{
                orExprs := r.extractORExpressions(cond)
                if len(orExprs) &gt; 0 </span><span class="cov0" title="0">{
                        // 为每个OR表达式创建独立分支
                        for _, orExpr := range orExprs </span><span class="cov0" title="0">{
                                branches = append(branches, []*parser.Expression{orExpr})
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 非OR条件，添加到所有现有分支
                        if len(branches) == 0 </span><span class="cov0" title="0">{
                                branches = append(branches, []*parser.Expression{cond})
                        }</span> else<span class="cov0" title="0"> {
                                for i := range branches </span><span class="cov0" title="0">{
                                        branches[i] = append(branches[i], cond)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return branches</span>
}

// extractORExpressions 从表达式中提取所有顶层OR表达式
func (r *ORToUnionRule) extractORExpressions(expr *parser.Expression) []*parser.Expression <span class="cov0" title="0">{
        var result []*parser.Expression

        // 如果表达式本身是OR
        if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "or" </span><span class="cov0" title="0">{
                // 提取左右子表达式
                leftExprs := r.extractORExpressions(expr.Left)
                rightExprs := r.extractORExpressions(expr.Right)

                // 合并结果
                result = append(result, leftExprs...)
                result = append(result, rightExprs...)
                return result
        }</span>

        // 不是OR表达式，直接返回
        <span class="cov0" title="0">return []*parser.Expression{expr}</span>
}

// isORExpression 判断是否是OR表达式
func (r *ORToUnionRule) isORExpression(expr *parser.Expression) bool <span class="cov10" title="58">{
        if expr == nil </span><span class="cov8" title="32">{
                return false
        }</span>

        // 检查顶层运算符是否是OR
        <span class="cov8" title="26">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "or" </span><span class="cov0" title="0">{
                return true
        }</span>

        // 递归检查子表达式
        <span class="cov8" title="26">if r.isORExpression(expr.Left) || r.isORExpression(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="26">return false</span>
}

// Explain 解释规则应用
func (r *ORToUnionRule) Explain(result LogicalPlan) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "ORToUnion: Applied, result type: %T",
                result,
        )
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package parallel

import (
        "context"
        "fmt"
        "hash/fnv"
        "sync"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ParallelHashJoinExecutor 并行哈希连接执行器
// 支持并行构建哈希表和探测
type ParallelHashJoinExecutor struct {
        joinType      parser.JoinType
        left          *domain.QueryResult
        right         *domain.QueryResult
        joinCondition *parser.Expression
        buildParallel int
        probeParallel int
        workerPool    *WorkerPool

        // State for parallel execution
        hashTable map[uint64][]domain.Row
        joinCols  JoinColumns
        hashTableReady chan struct{}
}

// NewParallelHashJoinExecutor 创建并行哈希连接执行器
func NewParallelHashJoinExecutor(
        joinType parser.JoinType,
        left, right *domain.QueryResult,
        condition *parser.Expression,
        buildParallel, probeParallel int,
        workerPool *WorkerPool,
) *ParallelHashJoinExecutor <span class="cov10" title="4">{
        return &amp;ParallelHashJoinExecutor{
                joinType:      joinType,
                left:          left,
                right:         right,
                joinCondition: condition,
                buildParallel: buildParallel,
                probeParallel: probeParallel,
                workerPool:    workerPool,
        }
}</span>

// Execute 执行并行哈希连接
func (phje *ParallelHashJoinExecutor) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov1" title="1">{
        fmt.Printf("  [PARALLEL JOIN] Starting parallel %s join, leftRows=%d, rightRows=%d, buildParallel=%d, probeParallel=%d\n",
                phje.joinType, len(phje.left.Rows), len(phje.right.Rows),
                phje.buildParallel, phje.probeParallel)

        // 并行构建和探测哈希表
        resultChan := make(chan *domain.QueryResult, 2)
        errChan := make(chan error, 2)

        // 并行构建哈希表
        go phje.buildHashTable(ctx, resultChan, errChan)
        // 并行探测哈希表
        go phje.probeHashTable(ctx, resultChan, errChan)

        // 等待结果
        var results [2]*domain.QueryResult
        for i := 0; i &lt; 2; i++ </span><span class="cov1" title="1">{
                select </span>{
                case result := &lt;-resultChan:<span class="cov0" title="0">
                        if result != nil </span><span class="cov0" title="0">{
                                results[i] = result
                        }</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        // 合并结果
        <span class="cov0" title="0">merged := phje.mergeJoinResults(results)

        fmt.Printf("  [PARALLEL JOIN] Completed: %d rows\n", len(merged.Rows))
        return merged, nil</span>
}

// buildHashTable 构建哈希表（可并行）
func (phje *ParallelHashJoinExecutor) buildHashTable(ctx context.Context, resultChan chan&lt;- *domain.QueryResult, errChan chan&lt;- error) <span class="cov1" title="1">{
        // 确定连接列
        phje.joinCols = phje.extractJoinColumns()
        if len(phje.joinCols.Left) == 0 || len(phje.joinCols.Right) == 0 </span><span class="cov0" title="0">{
                errChan &lt;- fmt.Errorf("no join columns specified")
                return
        }</span>

        // 构建哈希表
        <span class="cov1" title="1">phje.hashTable = make(map[uint64][]domain.Row)
        phje.hashTableReady = make(chan struct{})
        
        // 使用parallelism
        parallelism := phje.buildParallel
        if parallelism &lt;= 0 </span><span class="cov0" title="0">{
                parallelism = 1
        }</span>

        <span class="cov1" title="1">rowCount := len(phje.left.Rows)
        rowsPerWorker := rowCount / parallelism

        // 并行构建
        var wg sync.WaitGroup
        workerErrs := make(chan error, parallelism)

        for i := 0; i &lt; parallelism; i++ </span><span class="cov5" title="2">{
                wg.Add(1)
                
                start := i * rowsPerWorker
                end := start + rowsPerWorker
                if end &gt; rowCount </span><span class="cov0" title="0">{
                        end = rowCount
                }</span>

                <span class="cov5" title="2">go func(workerIdx int, start, end int) </span><span class="cov5" title="2">{
                        defer wg.Done()
                        
                        for rowIdx := start; rowIdx &lt; end; rowIdx++ </span><span class="cov5" title="2">{
                                row := phje.left.Rows[rowIdx]
                                
                                // 计算哈希键
                                key := phje.computeHashKey(row, phje.joinCols.Left)

                        phje.hashTable[key] = append(phje.hashTable[key], row)
                        }</span>
                }(i, start, end)
        }

        // 等待构建完成
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                wg.Wait()

                // 检查错误
                close(workerErrs)
                for err := range workerErrs </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>
                }

                // 构建完成，通知探测阶段可以开始
                <span class="cov1" title="1">close(phje.hashTableReady)</span>
        }()
}

// probeHashTable 探测哈希表（可并行）
func (phje *ParallelHashJoinExecutor) probeHashTable(ctx context.Context, resultChan chan&lt;- *domain.QueryResult, errChan chan&lt;- error) <span class="cov1" title="1">{
        // 等待哈希表构建完成
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                errChan &lt;- ctx.Err()
                return</span>
        case &lt;-phje.hashTableReady:<span class="cov0" title="0"></span>
                // 哈希表已构建完成，开始探测
        }

        // 探测阶段
        <span class="cov0" title="0">parallelism := phje.probeParallel
        if parallelism &lt;= 0 </span><span class="cov0" title="0">{
                parallelism = 1
        }</span>

        // 并行探测
        <span class="cov0" title="0">rowCount := len(phje.right.Rows)
        rowsPerWorker := rowCount / parallelism
        results := make([]domain.Row, 0, rowCount)
        mu := sync.Mutex{}

        var wg sync.WaitGroup
        workerErrs := make(chan error, parallelism)

        for i := 0; i &lt; parallelism; i++ </span><span class="cov0" title="0">{
                wg.Add(1)

                start := i * rowsPerWorker
                end := start + rowsPerWorker
                if end &gt; rowCount </span><span class="cov0" title="0">{
                        end = rowCount
                }</span>

                <span class="cov0" title="0">go func(workerIdx int, start, end int) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        for rowIdx := start; rowIdx &lt; end; rowIdx++ </span><span class="cov0" title="0">{
                                row := phje.right.Rows[rowIdx]

                                // 计算哈希键
                                key := phje.computeHashKey(row, phje.joinCols.Right)

                                // 查找匹配的行
                                if matchedRows, exists := phje.hashTable[key]; exists </span><span class="cov0" title="0">{
                                        for _, leftRow := range matchedRows </span><span class="cov0" title="0">{
                                                mu.Lock()
                                                merged := phje.mergeRows(leftRow, row, phje.left.Columns, phje.right.Columns)
                                                results = append(results, merged)
                                                mu.Unlock()
                                        }</span>
                                }
                        }
                }(i, start, end)
        }

        // 等待探测完成
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()

                // 检查错误
                close(workerErrs)
                for err := range workerErrs </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>
                }

                // 探测完成
                <span class="cov0" title="0">resultChan &lt;- &amp;domain.QueryResult{
                        Rows:    results,
                        Columns: phje.mergeColumns(phje.left.Columns, phje.right.Columns),
                        Total:   int64(len(results)),
                }</span>
        }()
}

// mergeJoinResults 合并JOIN结果（简化）
func (phje *ParallelHashJoinExecutor) mergeJoinResults(results [2]*domain.QueryResult) *domain.QueryResult <span class="cov0" title="0">{
        // 简化：只返回第一个非空结果
        for _, result := range results </span><span class="cov0" title="0">{
                if result != nil &amp;&amp; len(result.Rows) &gt; 0 </span><span class="cov0" title="0">{
                        return result
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Rows:    []domain.Row{},
                Columns: []domain.ColumnInfo{},
                Total:   0,
        }</span>
}

// mergeRows 合并行行（同步）
func (phje *ParallelHashJoinExecutor) mergeRows(leftRow, rightRow domain.Row, leftCols, rightCols []domain.ColumnInfo) domain.Row <span class="cov0" title="0">{
        merged := make(domain.Row)
        
        // 添加左表列
        for _, col := range leftCols </span><span class="cov0" title="0">{
                merged[col.Name] = leftRow[col.Name]
        }</span>
        
        // 添加右表列（处理冲突）
        <span class="cov0" title="0">for _, col := range rightCols </span><span class="cov0" title="0">{
                value := rightRow[col.Name]
                colName := col.Name
                
                // 检查列名冲突
                if _, exists := merged[colName]; exists </span><span class="cov0" title="0">{
                        colName = "right_" + colName
                }</span>
                <span class="cov0" title="0">merged[colName] = value</span>
        }
        
        <span class="cov0" title="0">return merged</span>
}

// mergeColumns 合并列信息
func (phje *ParallelHashJoinExecutor) mergeColumns(left, right []domain.ColumnInfo) []domain.ColumnInfo <span class="cov0" title="0">{
        merged := make([]domain.ColumnInfo, 0, len(left)+len(right))
        
        // 添加左表列
        for _, col := range left </span><span class="cov0" title="0">{
                merged = append(merged, col)
        }</span>
        
        // 添加右表列（处理冲突）
        <span class="cov0" title="0">for _, col := range right </span><span class="cov0" title="0">{
                colName := col.Name
                
                // 检查列名冲突
                conflict := false
                for _, leftCol := range left </span><span class="cov0" title="0">{
                        if leftCol.Name == colName </span><span class="cov0" title="0">{
                                conflict = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if conflict </span><span class="cov0" title="0">{
                        colName = "right_" + colName
                }</span>
                
                <span class="cov0" title="0">merged = append(merged, domain.ColumnInfo{
                        Name:     colName,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                })</span>
        }
        
        <span class="cov0" title="0">return merged</span>
}

// JoinColumns 连接列结果
type JoinColumns struct {
        Left  []string
        Right []string
}

// extractJoinColumns 提取连接列
func (phje *ParallelHashJoinExecutor) extractJoinColumns() JoinColumns <span class="cov1" title="1">{
        // 简化：从连接条件提取列名
        leftCols := []string{}
        rightCols := []string{}

        if phje.joinCondition != nil </span><span class="cov0" title="0">{
                phje.extractColumnsFromExpr(phje.joinCondition, &amp;leftCols, &amp;rightCols)
        }</span>

        // 如果没有连接条件，使用id列
        <span class="cov1" title="1">if len(leftCols) == 0 </span><span class="cov1" title="1">{
                leftCols = []string{"id"}
        }</span>
        <span class="cov1" title="1">if len(rightCols) == 0 </span><span class="cov1" title="1">{
                rightCols = []string{"id"}
        }</span>

        <span class="cov1" title="1">return JoinColumns{
                Left:  leftCols,
                Right: rightCols,
        }</span>
}

// extractColumnsFromExpr 从表达式提取列名
func (phje *ParallelHashJoinExecutor) extractColumnsFromExpr(expr *parser.Expression, leftCols, rightCols *[]string) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if expr.Left != nil </span><span class="cov0" title="0">{
                phje.extractColumnsFromExpr(expr.Left, leftCols, rightCols)
        }</span>

        <span class="cov0" title="0">if expr.Right != nil </span><span class="cov0" title="0">{
                phje.extractColumnsFromExpr(expr.Right, leftCols, rightCols)
        }</span>
}

// computeHashKey 计算行的哈希键
func (phje *ParallelHashJoinExecutor) computeHashKey(row domain.Row, cols []string) uint64 <span class="cov5" title="2">{
        if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 使用FNV-64a哈希算法
        <span class="cov5" title="2">h := fnv.New64a()
        for _, col := range cols </span><span class="cov5" title="2">{
                if val, exists := row[col]; exists </span><span class="cov5" title="2">{
                        h.Write([]byte(fmt.Sprintf("%v", val)))
                }</span>
        }

        <span class="cov5" title="2">return h.Sum64()</span>
}

// Explain 解释并行JOIN执行器
func (phje *ParallelHashJoinExecutor) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "ParallelHashJoin(type=%s, buildParallel=%d, probeParallel=%d)",
                phje.joinType, phje.buildParallel, phje.probeParallel,
        )
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package parallel

import (
        "context"
        "fmt"
        "runtime"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ParallelScanner 并行表扫描器
// 根据CPU核心数自动划分ScanRange，实现并行扫描
type ParallelScanner struct {
        dataSource   domain.DataSource
        parallelism int       // 并行度
        workerPool   *WorkerPool
}

// ScanRange 扫描范围
type ScanRange struct {
        TableName string
        Offset    int64
        Limit     int64
}

// NewParallelScanner 创建并行扫描器
func NewParallelScanner(dataSource domain.DataSource, parallelism int) *ParallelScanner <span class="cov0" title="0">{
        // 默认使用CPU核心数
        if parallelism &lt;= 0 </span><span class="cov0" title="0">{
                parallelism = runtime.NumCPU()
        }</span>
        
        <span class="cov0" title="0">return &amp;ParallelScanner{
                dataSource:   dataSource,
                parallelism: parallelism,
                workerPool:   NewWorkerPool(parallelism),
        }</span>
}

// Execute 并行执行扫描
func (ps *ParallelScanner) Execute(ctx context.Context, scanRange ScanRange, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 计算扫描参数
        limit := scanRange.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10000 // 默认
        }</span>
        
        <span class="cov0" title="0">offset := scanRange.Offset

        fmt.Printf("  [PARALLEL SCAN] Table: %s, Offset: %d, Limit: %d, Parallelism: %d\n",
                scanRange.TableName, offset, limit, ps.parallelism)

        // 计算每个worker的ScanRange
        ranges := ps.divideScanRange(scanRange.TableName, offset, limit, ps.parallelism)

        if len(ranges) == 0 </span><span class="cov0" title="0">{
                // 单个范围，直接扫描
                return ps.dataSource.Query(ctx, scanRange.TableName, options)
        }</span>

        // 并行执行扫描
        <span class="cov0" title="0">resultChan := make(chan *ScanResult, len(ranges))
        errChan := make(chan error, len(ranges))

        for i, r := range ranges </span><span class="cov0" title="0">{
                go func(idx int, r ScanRange) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        errChan &lt;- fmt.Errorf("worker %d panic: %v", idx, r)
                                }</span>
                        }()

                        // 执行扫描
                        <span class="cov0" title="0">result, err := ps.executeScanRange(ctx, r, options)
                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">resultChan &lt;- &amp;ScanResult{
                                WorkerIndex: idx,
                                Result:      result,
                        }</span>
                }(i, r)
        }

        // 收集结果
        <span class="cov0" title="0">results := make([]*ScanResult, 0, len(ranges))
        completed := 0

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case result := &lt;-resultChan:<span class="cov0" title="0">
                        if result != nil </span><span class="cov0" title="0">{
                                results[completed] = result
                                completed++
                        }</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">if completed == len(ranges) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // 合并结果
        <span class="cov0" title="0">mergedResult := ps.mergeScanResults(results, scanRange.TableName)
        fmt.Printf("  [PARALLEL SCAN] Completed: %d rows from %d workers\n", len(mergedResult.Rows), completed)

        return mergedResult, nil</span>
}

// divideScanRange 划分扫描范围
func (ps *ParallelScanner) divideScanRange(tableName string, offset, limit int64, parallelism int) []ScanRange <span class="cov0" title="0">{
        ranges := make([]ScanRange, 0, parallelism)

        // 每个worker的行数
        rowsPerWorker := int64(float64(limit) / float64(parallelism))

        for i := 0; i &lt; parallelism; i++ </span><span class="cov0" title="0">{
                r := ScanRange{
                        TableName: tableName,
                        Offset:    offset + int64(i)*rowsPerWorker,
                        Limit:     rowsPerWorker,
                }
                ranges[i] = r
        }</span>

        <span class="cov0" title="0">return ranges</span>
}

// executeScanRange 执行单个扫描范围
func (ps *ParallelScanner) executeScanRange(ctx context.Context, r ScanRange, options *domain.QueryOptions) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // 构建查询选项
        scanOptions := &amp;domain.QueryOptions{}
        if options != nil </span><span class="cov0" title="0">{
                scanOptions = options
        }</span>
        <span class="cov0" title="0">scanOptions.Offset = int(r.Offset)
        scanOptions.Limit = int(r.Limit)

        return ps.dataSource.Query(ctx, r.TableName, scanOptions)</span>
}

// mergeScanResults 合并扫描结果
func (ps *ParallelScanner) mergeScanResults(results []*ScanResult, tableName string) *domain.QueryResult <span class="cov0" title="0">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return &amp;domain.QueryResult{
                        Rows:  []domain.Row{},
                        Total: 0,
                }
        }</span>

        // 合并行行
        <span class="cov0" title="0">totalRows := int64(0)
        for _, result := range results </span><span class="cov0" title="0">{
                totalRows += result.Result.Total
        }</span>

        <span class="cov0" title="0">mergedRows := make([]domain.Row, 0, totalRows)
        for _, result := range results </span><span class="cov0" title="0">{
                mergedRows = append(mergedRows, result.Result.Rows...)
        }</span>

        // 获取列信息（从第一个结果）
        <span class="cov0" title="0">var columns []domain.ColumnInfo
        if len(results) &gt; 0 &amp;&amp; results[0] != nil </span><span class="cov0" title="0">{
                columns = results[0].Result.Columns
        }</span>

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Rows:    mergedRows,
                Columns: columns,
                Total:   totalRows,
        }</span>
}

// ScanResult 扫描结果
type ScanResult struct {
        WorkerIndex int
        Result      *domain.QueryResult
}

// GetParallelism 获取并行度
func (ps *ParallelScanner) GetParallelism() int <span class="cov0" title="0">{
        return ps.parallelism
}</span>

// SetParallelism 设置并行度
func (ps *ParallelScanner) SetParallelism(parallelism int) <span class="cov0" title="0">{
        if parallelism &gt; 0 &amp;&amp; parallelism &lt;= 64 </span><span class="cov0" title="0">{
                ps.parallelism = parallelism
                ps.workerPool = NewWorkerPool(parallelism)
        }</span>
}

// Explain 解释并行扫描器
func (ps *ParallelScanner) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "ParallelScanner(parallelism=%d, workerPool=%s)",
                ps.parallelism,
                ps.workerPool.Explain(),
        )
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package parallel

import (
        "fmt"
        "runtime"
        "sync"
        "time"
)

// WorkerPool 工作池
// 管理并发worker的生命周期，避免频繁创建和销毁goroutine
type WorkerPool struct {
        workers     []worker
        taskQueue   chan Task
        workerCount int
        wg          sync.WaitGroup
        shutdown    chan struct{}
        mu          sync.Mutex
}

// worker 工作包装器
type worker struct {
        id       int
        taskChan chan Task
        done     chan struct{}
}

// Task 任务接口
type Task interface {
        Execute() error
}

// NewWorkerPool 创建工作池
func NewWorkerPool(workerCount int) *WorkerPool <span class="cov6" title="18">{
        if workerCount &lt;= 0 </span><span class="cov0" title="0">{
                workerCount = runtime.NumCPU()
        }</span>

        <span class="cov6" title="18">wp := &amp;WorkerPool{
                workers:     make([]worker, workerCount),
                taskQueue:   make(chan Task, workerCount*2), // 缓冲队列
                workerCount: workerCount,
                shutdown:    make(chan struct{}),
        }

        // 初始化workers
        for i := 0; i &lt; workerCount; i++ </span><span class="cov10" title="157">{
                wp.workers[i] = worker{
                        id:       i,
                        taskChan: make(chan Task, 1),
                        done:     make(chan struct{}),
                }

                // 启动worker
                wp.wg.Add(1)
                go func(idx int) </span><span class="cov10" title="157">{
                        defer wp.wg.Done()
                        wp.workers[idx].run()
                }</span>(i)
        }

        <span class="cov6" title="18">return wp</span>
}

// Submit 提交任务到工作池
func (wp *WorkerPool) Submit(task Task) error <span class="cov0" title="0">{
        select </span>{
        case wp.taskQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        case &lt;-wp.shutdown:<span class="cov0" title="0">
                return fmt.Errorf("worker pool is shutdown")</span>
        }
}

// SubmitWithTimeout 提交任务（带超时）
func (wp *WorkerPool) SubmitWithTimeout(task Task, timeout time.Duration) error <span class="cov0" title="0">{
        timer := time.NewTimer(timeout)
        defer timer.Stop()

        select </span>{
        case wp.taskQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return fmt.Errorf("task timeout after %v", timeout)</span>
        case &lt;-wp.shutdown:<span class="cov0" title="0">
                return fmt.Errorf("worker pool is shutdown")</span>
        }
}

// SubmitAndWait 提交任务并等待完成
func (wp *WorkerPool) SubmitAndWait(task Task) error <span class="cov0" title="0">{
        wp.wg.Add(1)
        defer wp.wg.Done()

        if err := wp.Submit(task); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 等待任务完成
        <span class="cov0" title="0">return nil</span>
}

// SubmitAndWaitWithTimeout 提交任务并等待完成（带超时）
func (wp *WorkerPool) SubmitAndWaitWithTimeout(task Task, timeout time.Duration) error <span class="cov0" title="0">{
        if err := wp.SubmitWithTimeout(task, timeout); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wp.wg.Add(1)
        defer wp.wg.Done()

        // 等待任务完成（带超时）
        timeoutChan := time.After(timeout)
        done := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                if err := task.Execute(); err != nil </span><span class="cov0" title="0">{
                        done &lt;- err
                }</span> else<span class="cov0" title="0"> {
                        done &lt;- nil
                }</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                return err</span>
        case &lt;-timeoutChan:<span class="cov0" title="0">
                return fmt.Errorf("task wait timeout after %v", timeout)</span>
        }
}

// BatchSubmit 批量提交任务
func (wp *WorkerPool) BatchSubmit(tasks []Task) error <span class="cov0" title="0">{
        for _, task := range tasks </span><span class="cov0" title="0">{
                if err := wp.Submit(task); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// BatchSubmitAndWait 批量提交任务并等待全部完成
func (wp *WorkerPool) BatchSubmitAndWait(tasks []Task) error <span class="cov0" title="0">{
        for _, task := range tasks </span><span class="cov0" title="0">{
                if err := wp.Submit(task); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return wp.Wait()</span>
}

// GetStats 获取工作池统计信息
func (wp *WorkerPool) GetStats() WorkerPoolStats <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()

        return WorkerPoolStats{
                WorkerCount:  wp.workerCount,
                QueueSize:     len(wp.taskQueue),
                ActiveWorkers: wp.getActiveWorkerCount(),
        }
}</span>

// getActiveWorkerCount 获取活跃worker数量
func (wp *WorkerPool) getActiveWorkerCount() int <span class="cov0" title="0">{
        activeCount := 0
        for _, w := range wp.workers </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.taskChan:<span class="cov0" title="0">
                        activeCount++</span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov0" title="0">return activeCount</span>
}

// Resize 动态调整worker数量
func (wp *WorkerPool) Resize(newWorkerCount int) <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()

        if newWorkerCount &lt;= 0 || newWorkerCount == wp.workerCount </span><span class="cov0" title="0">{
                return
        }</span>

        // 关闭旧workers
        <span class="cov0" title="0">oldWorkers := wp.workers
        wp.workers = make([]worker, newWorkerCount)
        wp.workerCount = newWorkerCount

        // 创建新workers
        for i := 0; i &lt; newWorkerCount; i++ </span><span class="cov0" title="0">{
                wp.workers[i] = worker{
                        id:       i,
                        taskChan: make(chan Task, 1),
                        done:     make(chan struct{}),
                }

                // 启动新worker
                wp.wg.Add(1)
                go func(idx int) </span><span class="cov0" title="0">{
                        defer wp.wg.Done()
                        wp.workers[idx].run()
                }</span>(i)
        }

        // 停止旧workers
        <span class="cov0" title="0">for _, w := range oldWorkers </span><span class="cov0" title="0">{
                close(w.taskChan)
                close(w.done)
                &lt;-w.done
        }</span>
}

// Shutdown 优雅关闭工作池
func (wp *WorkerPool) Shutdown() <span class="cov0" title="0">{
        close(wp.shutdown)
        wp.wg.Wait()

        wp.mu.Lock()
        defer wp.mu.Unlock()

        // 停止所有workers
        for _, w := range wp.workers </span><span class="cov0" title="0">{
                close(w.taskChan)
                &lt;-w.done
        }</span>

        // 清空workers
        <span class="cov0" title="0">wp.workers = nil
        wp.workerCount = 0</span>
}

// Wait 等待所有任务完成
func (wp *WorkerPool) Wait() error <span class="cov0" title="0">{
        wp.wg.Wait()
        return nil
}</span>

// WaitWithTimeout 等待所有任务完成（带超时）
func (wp *WorkerPool) WaitWithTimeout(timeout time.Duration) error <span class="cov0" title="0">{
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wp.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return fmt.Errorf("wait timeout after %v", timeout)</span>
        }
}

// worker run worker主循环
func (w *worker) run() <span class="cov10" title="157">{
        for </span><span class="cov10" title="157">{
                select </span>{
                case &lt;-w.done:<span class="cov0" title="0">
                        return</span>
                case task := &lt;-w.taskChan:<span class="cov0" title="0">
                        // 执行任务（忽略错误，实际应该记录）
                        _ = task.Execute()</span>
                }
        }
}

// WorkerPoolStats 工作池统计信息
type WorkerPoolStats struct {
        WorkerCount  int // Worker总数
        QueueSize    int // 任务队列大小
        ActiveWorkers int // 活跃Worker数量
}

// Explain 返回工作池的说明
func (wp *WorkerPool) Explain() string <span class="cov0" title="0">{
        stats := wp.GetStats()
        return fmt.Sprintf(
                "WorkerPool(workers=%d, queueSize=%d, activeWorkers=%d)",
                stats.WorkerCount, stats.QueueSize, stats.ActiveWorkers,
        )
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package optimizer

import (
        "container/heap"
        "context"
        "fmt"
        "math"
        "sync"
        "time"
)

// Index 索引定义
type Index struct {
        Name       string
        TableName  string
        Columns    []string
        Unique     bool
        Primary    bool
        Cardinality int64 // 基数（唯一值数量）
}

// IndexManager 索引管理器
type IndexManager struct {
        mu      sync.RWMutex
        indices map[string][]*Index // table_name -&gt; indices
        stats   map[string]*IndexStats // index_name -&gt; stats
}

// IndexStats 索引统计信息
type IndexStats struct {
        Name         string
        HitCount     int64
        MissCount    int64
        AvgAccessTime time.Duration
        LastAccessed time.Time
}

// NewIndexManager 创建索引管理器
func NewIndexManager() *IndexManager <span class="cov0" title="0">{
        return &amp;IndexManager{
                indices: make(map[string][]*Index),
                stats:   make(map[string]*IndexStats),
        }
}</span>

// AddIndex 添加索引
func (im *IndexManager) AddIndex(index *Index) <span class="cov0" title="0">{
        im.mu.Lock()
        defer im.mu.Unlock()

        im.indices[index.TableName] = append(im.indices[index.TableName], index)
        im.stats[index.Name] = &amp;IndexStats{
                Name:         index.Name,
                LastAccessed: time.Now(),
        }
}</span>

// GetIndices 获取表的所有索引
func (im *IndexManager) GetIndices(tableName string) []*Index <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        if indices, ok := im.indices[tableName]; ok </span><span class="cov0" title="0">{
                result := make([]*Index, len(indices))
                copy(result, indices)
                return result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindBestIndex 查找最佳索引
func (im *IndexManager) FindBestIndex(tableName string, columns []string) *Index <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        indices, ok := im.indices[tableName]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 寻找列数匹配且基数最高的索引
        <span class="cov0" title="0">var bestIndex *Index
        maxCardinality := int64(0)

        for _, index := range indices </span><span class="cov0" title="0">{
                if len(index.Columns) &gt;= len(columns) </span><span class="cov0" title="0">{
                        // 检查前几列是否匹配
                        match := true
                        for i, col := range columns </span><span class="cov0" title="0">{
                                if i &gt;= len(index.Columns) || index.Columns[i] != col </span><span class="cov0" title="0">{
                                        match = false
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if match &amp;&amp; index.Cardinality &gt; maxCardinality </span><span class="cov0" title="0">{
                                bestIndex = index
                                maxCardinality = index.Cardinality
                        }</span>
                }
        }

        <span class="cov0" title="0">return bestIndex</span>
}

// RecordIndexAccess 记录索引访问
func (im *IndexManager) RecordIndexAccess(indexName string, duration time.Duration) <span class="cov0" title="0">{
        im.mu.Lock()
        defer im.mu.Unlock()

        if stats, ok := im.stats[indexName]; ok </span><span class="cov0" title="0">{
                stats.HitCount++
                stats.LastAccessed = time.Now()

                // 更新平均访问时间
                if stats.AvgAccessTime == 0 </span><span class="cov0" title="0">{
                        stats.AvgAccessTime = duration
                }</span> else<span class="cov0" title="0"> {
                        stats.AvgAccessTime = (stats.AvgAccessTime*time.Duration(stats.HitCount) + duration) / time.Duration(stats.HitCount+1)
                }</span>
        }
}

// GetIndexStats 获取索引统计
func (im *IndexManager) GetIndexStats(indexName string) *IndexStats <span class="cov0" title="0">{
        im.mu.RLock()
        defer im.mu.RUnlock()

        if stats, ok := im.stats[indexName]; ok </span><span class="cov0" title="0">{
                // 返回副本
                return &amp;IndexStats{
                        Name:         stats.Name,
                        HitCount:     stats.HitCount,
                        MissCount:    stats.MissCount,
                        AvgAccessTime: stats.AvgAccessTime,
                        LastAccessed: stats.LastAccessed,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BatchExecutor 批量执行器
type BatchExecutor struct {
        batchSize     int
        flushInterval time.Duration
        batch         []interface{}
        timer         *time.Timer
        mu            sync.Mutex
        flushFunc      func([]interface{}) error
}

// NewBatchExecutor 创建批量执行器
func NewBatchExecutor(batchSize int, flushInterval time.Duration, flushFunc func([]interface{}) error) *BatchExecutor <span class="cov0" title="0">{
        be := &amp;BatchExecutor{
                batchSize:     batchSize,
                flushInterval: flushInterval,
                flushFunc:     flushFunc,
        }
        be.timer = time.AfterFunc(flushInterval, func() </span><span class="cov0" title="0">{ be.flush() }</span>)
        <span class="cov0" title="0">return be</span>
}

// Add 添加到批次
func (be *BatchExecutor) Add(item interface{}) error <span class="cov0" title="0">{
        be.mu.Lock()
        defer be.mu.Unlock()

        be.batch = append(be.batch, item)

        if len(be.batch) &gt;= be.batchSize </span><span class="cov0" title="0">{
                return be.flush()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// flush 刷新批次
func (be *BatchExecutor) flush() error <span class="cov0" title="0">{
        be.mu.Lock()
        defer be.mu.Unlock()

        if len(be.batch) == 0 </span><span class="cov0" title="0">{
                be.timer.Reset(be.flushInterval)
                return nil
        }</span>

        <span class="cov0" title="0">items := be.batch
        be.batch = make([]interface{}, 0, be.batchSize)

        err := be.flushFunc(items)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">be.timer.Reset(be.flushInterval)
        return nil</span>
}

// Flush 手动刷新
func (be *BatchExecutor) Flush() error <span class="cov0" title="0">{
        return be.flush()
}</span>

// Close 关闭批量执行器
func (be *BatchExecutor) Close() error <span class="cov0" title="0">{
        be.timer.Stop()
        return be.Flush()
}</span>

// PriorityQueue 优先队列（用于JOIN重排序等优化）
type PriorityQueue []*PlanNode

// PlanPlan 计划节点
type PlanNode struct {
        Plan     LogicalPlan
        Cost     float64
        Priority int
        Index    int
}

// Len 实现 heap.Interface
func (pq PriorityQueue) Len() int <span class="cov0" title="0">{ return len(pq) }</span>

// Less 实现 heap.Interface
func (pq PriorityQueue) Less(i, j int) bool <span class="cov0" title="0">{
        // 优先级高的在前（成本低的优先）
        if pq[i].Priority == pq[j].Priority </span><span class="cov0" title="0">{
                return pq[i].Cost &lt; pq[j].Cost
        }</span>
        <span class="cov0" title="0">return pq[i].Priority &gt; pq[j].Priority</span>
}

// Swap 实现 heap.Interface
func (pq PriorityQueue) Swap(i, j int) <span class="cov0" title="0">{
        pq[i], pq[j] = pq[j], pq[i]
        pq[i].Index = i
        pq[j].Index = j
}</span>

// Push 实现 heap.Interface
func (pq *PriorityQueue) Push(x interface{}) <span class="cov0" title="0">{
        n := len(*pq)
        node := x.(*PlanNode)
        node.Index = n
        *pq = append(*pq, node)
}</span>

// Pop 实现 heap.Interface
func (pq *PriorityQueue) Pop() interface{} <span class="cov0" title="0">{
        old := *pq
        n := len(old)
        node := old[n-1]
        old[n-1] = nil
        node.Index = -1
        *pq = old[0 : n-1]
        return node
}</span>

// NewPriorityQueue 创建优先队列
func NewPriorityQueue() *PriorityQueue <span class="cov0" title="0">{
        pq := make(PriorityQueue, 0)
        heap.Init(&amp;pq)
        return &amp;pq
}</span>

// PerformanceOptimizer 性能优化器
type PerformanceOptimizer struct {
        indexManager  *IndexManager
        batchExecutor *BatchExecutor
}

// NewPerformanceOptimizer 创建性能优化器
func NewPerformanceOptimizer() *PerformanceOptimizer <span class="cov0" title="0">{
        return &amp;PerformanceOptimizer{
                indexManager: NewIndexManager(),
        }
}</span>

// OptimizeQuery 优化查询
func (po *PerformanceOptimizer) OptimizeQuery(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 1. 索引选择优化
        plan = po.optimizeIndexSelection(plan, optCtx)

        // 2. JOIN 重排序优化
        plan = po.optimizeJoinOrder(plan, optCtx)

        // 3. 谓词下推优化
        plan = po.optimizePredicatePushdown(plan, optCtx)

        return plan, nil
}</span>

// optimizeIndexSelection 优化索引选择
// 遍历逻辑计划，为每个数据源选择最优的索引，减少全表扫描
func (po *PerformanceOptimizer) optimizeIndexSelection(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        switch p := plan.(type) </span>{
        case *LogicalDataSource:<span class="cov0" title="0">
                return po.optimizeDataSourceIndexSelection(p, optCtx)</span>
        case *LogicalSelection:<span class="cov0" title="0">
                // 递归处理子节点
                child := po.optimizeIndexSelection(p.Children()[0], optCtx)
                if child != p.Children()[0] </span><span class="cov0" title="0">{
                        p.SetChildren(child)
                }</span>
                <span class="cov0" title="0">return p</span>
        case *LogicalJoin:<span class="cov0" title="0">
                // 递归处理左右子节点
                left := po.optimizeIndexSelection(p.Children()[0], optCtx)
                right := po.optimizeIndexSelection(p.Children()[1], optCtx)
                if left != p.Children()[0] || right != p.Children()[1] </span><span class="cov0" title="0">{
                        p.SetChildren(left, right)
                }</span>
                <span class="cov0" title="0">return p</span>
        default:<span class="cov0" title="0">
                // 其他类型，递归处理子节点
                for i, child := range plan.Children() </span><span class="cov0" title="0">{
                        newChild := po.optimizeIndexSelection(child, optCtx)
                        if newChild != child </span><span class="cov0" title="0">{
                                children := plan.Children()
                                children[i] = newChild
                                plan.SetChildren(children...)
                        }</span>
                }
                <span class="cov0" title="0">return plan</span>
        }
}

// optimizeDataSourceIndexSelection 优化数据源的索引选择
func (po *PerformanceOptimizer) optimizeDataSourceIndexSelection(dataSource *LogicalDataSource, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // 1. 收集所有过滤条件中的列名
        filterColumns := po.extractFilterColumns(dataSource)

        if len(filterColumns) == 0 </span><span class="cov0" title="0">{
                // 没有过滤条件，无法使用索引
                return dataSource
        }</span>

        // 2. 查找匹配的索引
        <span class="cov0" title="0">bestIndex := po.findBestIndex(dataSource.TableName, filterColumns)

        if bestIndex != nil </span><span class="cov0" title="0">{
                fmt.Printf("  [INDEX SELECT] 选择索引 %s 用于表 %s\n", bestIndex.Name, dataSource.TableName)
                // 标记使用索引（在 LogicalDataSource 中添加索引信息）
                // 注意：这里简化实现，实际应该修改 LogicalDataSource 结构
                // dataSource.SelectedIndex = bestIndex
        }</span>

        <span class="cov0" title="0">return dataSource</span>
}

// extractFilterColumns 从数据源中提取过滤条件涉及的列
func (po *PerformanceOptimizer) extractFilterColumns(dataSource *LogicalDataSource) []string <span class="cov0" title="0">{
        // 从下推的谓词条件中提取列
        predicates := dataSource.GetPushedDownPredicates()
        if predicates == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">columns := make([]string, 0)
        seen := make(map[string]bool)

        for _, pred := range predicates </span><span class="cov0" title="0">{
                if pred == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 提取列名 - 遍历表达式树
                <span class="cov0" title="0">po.extractColumnsFromExpression(pred, &amp;columns, seen)</span>
        }

        <span class="cov0" title="0">return columns</span>
}

// extractColumnsFromExpression 递归提取表达式中的列名
func (po *PerformanceOptimizer) extractColumnsFromExpression(expr interface{}, columns *[]string, seen map[string]bool) {<span class="cov0" title="0">
        // 这里简化实现，因为 parser.Expression 类型在另一个包中
        // 在实际使用中，应该通过反射或者接口方法来访问
        // 当前返回空列表，避免类型依赖
}</span>

// findBestIndex 查找最佳索引
func (po *PerformanceOptimizer) findBestIndex(tableName string, columns []string) *Index <span class="cov0" title="0">{
        indices := po.indexManager.GetIndices(tableName)
        if len(indices) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 评估每个索引
        <span class="cov0" title="0">var bestIndex *Index
        bestScore := 0.0

        for _, index := range indices </span><span class="cov0" title="0">{
                score := po.calculateIndexScore(index, columns)
                if score &gt; bestScore </span><span class="cov0" title="0">{
                        bestScore = score
                        bestIndex = index
                }</span>
        }

        <span class="cov0" title="0">return bestIndex</span>
}

// calculateIndexScore 计算索引评分
func (po *PerformanceOptimizer) calculateIndexScore(index *Index, columns []string) float64 <span class="cov0" title="0">{
        score := 0.0

        // 1. 前缀匹配评分（越靠前的列匹配分数越高）
        for i, col := range columns </span><span class="cov0" title="0">{
                if i &lt; len(index.Columns) &amp;&amp; index.Columns[i] == col </span><span class="cov0" title="0">{
                        // 第一个匹配列得分最高
                        score += float64(len(columns)-i) * 2.0
                }</span>
        }

        // 2. 基数评分（基数越高，区分度越好）
        <span class="cov0" title="0">score += float64(index.Cardinality) / 10000.0

        // 3. 主键索引加分
        if index.Primary </span><span class="cov0" title="0">{
                score += 100.0
        }</span>

        // 4. 唯一索引加分
        <span class="cov0" title="0">if index.Unique </span><span class="cov0" title="0">{
                score += 50.0
        }</span>

        <span class="cov0" title="0">return score</span>
}

// optimizeJoinOrder 优化JOIN顺序
// 使用贪心算法或动态规划算法重新排序JOIN节点，减少中间结果大小
func (po *PerformanceOptimizer) optimizeJoinOrder(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // 1. 识别JOIN树并收集涉及的表
        _, tables := po.collectJoinNodes(plan)

        if len(tables) &lt; 2 </span><span class="cov0" title="0">{
                // 单表或无JOIN，无需重排序
                return plan
        }</span>

        <span class="cov0" title="0">fmt.Printf("  [JOIN REORDER] 检测到 %d 个表需要JOIN\n", len(tables))

        // 2. 选择优化策略
        if len(tables) &lt;= 5 </span><span class="cov0" title="0">{
                // 小表数量：使用贪心算法
                return po.greedyJoinReorder(plan, tables, optCtx)
        }</span> else<span class="cov0" title="0"> {
                // 大表数量：使用简化的贪心算法
                return po.simpleJoinReorder(plan, tables, optCtx)
        }</span>
}

// collectJoinNodes 收集所有JOIN节点和表名
func (po *PerformanceOptimizer) collectJoinNodes(plan LogicalPlan) ([]LogicalPlan, []string) <span class="cov0" title="0">{
        joinNodes := []LogicalPlan{}
        tables := map[string]bool{}

        po.collectJoinsRecursive(plan, &amp;joinNodes, tables)

        tableList := make([]string, 0, len(tables))
        for table := range tables </span><span class="cov0" title="0">{
                tableList = append(tableList, table)
        }</span>

        <span class="cov0" title="0">return joinNodes, tableList</span>
}

// collectJoinsRecursive 递归收集JOIN节点
func (po *PerformanceOptimizer) collectJoinsRecursive(plan LogicalPlan, joinNodes *[]LogicalPlan, tables map[string]bool) <span class="cov0" title="0">{
        if plan == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 检查是否是JOIN节点
        <span class="cov0" title="0">if join, ok := plan.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                *joinNodes = append(*joinNodes, join)
                // 递归处理子节点
                po.collectJoinsRecursive(join.Children()[0], joinNodes, tables)
                po.collectJoinsRecursive(join.Children()[1], joinNodes, tables)
                return
        }</span>

        // 检查是否是数据源节点
        <span class="cov0" title="0">if dataSource, ok := plan.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                tables[dataSource.TableName] = true
                return
        }</span>

        // 其他节点，递归处理子节点
        <span class="cov0" title="0">for _, child := range plan.Children() </span><span class="cov0" title="0">{
                po.collectJoinsRecursive(child, joinNodes, tables)
        }</span>
}

// greedyJoinReorder 贪心算法JOIN重排序
func (po *PerformanceOptimizer) greedyJoinReorder(plan LogicalPlan, tables []string, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // 贪心策略：始终选择使当前结果最小的表
        remainingTables := make([]string, len(tables))
        copy(remainingTables, tables)

        order := []string{}

        for len(remainingTables) &gt; 0 </span><span class="cov0" title="0">{
                // 找到最优的下一个表
                bestTable := ""
                bestCost := float64(math.MaxFloat64)

                for _, table := range remainingTables </span><span class="cov0" title="0">{
                        // 计算将table加入当前顺序的成本
                        cost := po.calculateJoinCost(order, table, optCtx)
                        if cost &lt; bestCost </span><span class="cov0" title="0">{
                                bestCost = cost
                                bestTable = table
                        }</span>
                }

                <span class="cov0" title="0">if bestTable == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">order = append(order, bestTable)

                // 从剩余表中移除
                for i, t := range remainingTables </span><span class="cov0" title="0">{
                        if t == bestTable </span><span class="cov0" title="0">{
                                remainingTables = append(remainingTables[:i], remainingTables[i+1:]...)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">fmt.Printf("  [JOIN REORDER] 贪心顺序: %v\n", order)

        // 根据新顺序构建JOIN计划
        return po.rebuildJoinPlan(order, plan)</span>
}

// simpleJoinReorder 简化JOIN重排序（用于大表场景）
func (po *PerformanceOptimizer) simpleJoinReorder(plan LogicalPlan, tables []string, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // 简化策略：按表大小排序，从小到大JOIN
        sortedTables := po.sortTablesBySize(tables, optCtx)

        fmt.Printf("  [JOIN REORDER] 大小顺序: %v\n", sortedTables)

        return po.rebuildJoinPlan(sortedTables, plan)
}</span>

// calculateJoinCost 计算JOIN成本
func (po *PerformanceOptimizer) calculateJoinCost(currentOrder []string, newTable string, optCtx *OptimizationContext) float64 <span class="cov0" title="0">{
        if len(currentOrder) == 0 </span><span class="cov0" title="0">{
                // 第一个表，只有扫描成本
                return po.estimateScanCost(newTable, optCtx)
        }</span>

        // 计算与最后一个表的JOIN成本
        <span class="cov0" title="0">lastTable := currentOrder[len(currentOrder)-1]

        // 估算基数
        leftCard := po.estimateCardinality(lastTable, optCtx)
        rightCard := po.estimateCardinality(newTable, optCtx)

        // JOIN成本 = build + probe
        joinCost := leftCard + rightCard*0.1 // 假设10%的选择性

        return joinCost</span>
}

// estimateScanCost 估算扫描成本
func (po *PerformanceOptimizer) estimateScanCost(table string, optCtx *OptimizationContext) float64 <span class="cov0" title="0">{
        if optCtx == nil </span><span class="cov0" title="0">{
                return 1000.0 // 默认成本
        }</span>

        <span class="cov0" title="0">if stats, ok := optCtx.Stats[table]; ok </span><span class="cov0" title="0">{
                return float64(stats.RowCount)
        }</span>

        <span class="cov0" title="0">return 1000.0</span> // 默认估计
}

// estimateCardinality 估算表的基数
func (po *PerformanceOptimizer) estimateCardinality(table string, optCtx *OptimizationContext) float64 <span class="cov0" title="0">{
        if optCtx == nil </span><span class="cov0" title="0">{
                return 1000.0
        }</span>

        <span class="cov0" title="0">if stats, ok := optCtx.Stats[table]; ok </span><span class="cov0" title="0">{
                return float64(stats.RowCount)
        }</span>

        <span class="cov0" title="0">return 1000.0</span>
}

// sortTablesBySize 按表大小排序
func (po *PerformanceOptimizer) sortTablesBySize(tables []string, optCtx *OptimizationContext) []string <span class="cov0" title="0">{
        type tableCost struct {
                name string
                cost float64
        }

        tableCosts := make([]tableCost, len(tables))
        for i, table := range tables </span><span class="cov0" title="0">{
                tableCosts[i] = tableCost{
                        name: table,
                        cost: po.estimateCardinality(table, optCtx),
                }
        }</span>

        // 简单冒泡排序
        <span class="cov0" title="0">for i := 0; i &lt; len(tableCosts); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(tableCosts); j++ </span><span class="cov0" title="0">{
                        if tableCosts[i].cost &gt; tableCosts[j].cost </span><span class="cov0" title="0">{
                                tableCosts[i], tableCosts[j] = tableCosts[j], tableCosts[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">result := make([]string, len(tables))
        for i, tc := range tableCosts </span><span class="cov0" title="0">{
                result[i] = tc.name
        }</span>

        <span class="cov0" title="0">return result</span>
}

// rebuildJoinPlan 重新构建JOIN计划
// 注意：这是一个框架实现，实际需要根据具体的JOIN节点类型构建
func (po *PerformanceOptimizer) rebuildJoinPlan(order []string, originalPlan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        // 简化实现：返回原计划
        // 完整实现需要：
        // 1. 为每个表创建数据源节点
        // 2. 按顺序构建JOIN节点
        // 3. 复制JOIN条件和连接类型
        fmt.Println("  [JOIN REORDER] 框架实现：返回原计划")
        return originalPlan
}</span>

// optimizePredicatePushdown 优化谓词下推
// 将过滤条件尽可能下推到数据源，减少中间结果大小
func (po *PerformanceOptimizer) optimizePredicatePushdown(plan LogicalPlan, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        switch p := plan.(type) </span>{
        case *LogicalSelection:<span class="cov0" title="0">
                return po.pushDownSelection(p, optCtx)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                // 谓词下推到JOIN的两边
                return po.pushDownJoinPredicates(p, optCtx)</span>
        case *LogicalProjection:<span class="cov0" title="0">
                // 先处理子节点，再处理投影
                child := po.optimizePredicatePushdown(p.Children()[0], optCtx)
                if child != p.Children()[0] </span><span class="cov0" title="0">{
                        p.SetChildren(child)
                }</span>
                <span class="cov0" title="0">return p</span>
        case *LogicalAggregate:<span class="cov0" title="0">
                // 聚合前可以下推HAVING之外的过滤条件
                child := po.optimizePredicatePushdown(p.Children()[0], optCtx)
                if child != p.Children()[0] </span><span class="cov0" title="0">{
                        p.SetChildren(child)
                }</span>
                <span class="cov0" title="0">return p</span>
        default:<span class="cov0" title="0">
                // 其他节点，递归处理子节点
                for i, child := range plan.Children() </span><span class="cov0" title="0">{
                        newChild := po.optimizePredicatePushdown(child, optCtx)
                        if newChild != child </span><span class="cov0" title="0">{
                                children := plan.Children()
                                children[i] = newChild
                                plan.SetChildren(children...)
                        }</span>
                }
                <span class="cov0" title="0">return plan</span>
        }
}

// pushDownSelection 推下Selection节点的过滤条件
func (po *PerformanceOptimizer) pushDownSelection(selection *LogicalSelection, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        conditions := selection.GetConditions()
        child := selection.Children()[0]

        // 递归处理子节点
        child = po.optimizePredicatePushdown(child, optCtx)

        // 检查是否可以推到数据源
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov0" title="0">{
                // 推下到数据源
                dataSource.PushDownPredicates(conditions)
                fmt.Printf("  [PREDICATE PUSH] 将 %d 个条件下推到数据源 %s\n", len(conditions), dataSource.TableName)
                return dataSource
        }</span>

        // 检查是否可以推到JOIN
        <span class="cov0" title="0">if join, ok := child.(*LogicalJoin); ok </span><span class="cov0" title="0">{
                // 尝试将条件推到JOIN的左右两边
                // 注意：这里简化处理，实际需要分割条件
                fmt.Printf("  [PREDICATE PUSH] 检查JOIN谓词下推机会\n")

                join.SetChildren(join.Children()[0], join.Children()[1])
                selection.SetChildren(join)
                return selection
        }</span>

        // 无法进一步下推，保留当前Selection
        <span class="cov0" title="0">selection.SetChildren(child)
        return selection</span>
}

// pushDownJoinPredicates 下推JOIN上的谓词
func (po *PerformanceOptimizer) pushDownJoinPredicates(join *LogicalJoin, optCtx *OptimizationContext) LogicalPlan <span class="cov0" title="0">{
        // 递归处理左右子节点
        leftChild := po.optimizePredicatePushdown(join.Children()[0], optCtx)
        rightChild := po.optimizePredicatePushdown(join.Children()[1], optCtx)

        join.SetChildren(leftChild, rightChild)
        return join
}</span>

// EstimateSelectivity 估计过滤条件的选择性
// 基于统计信息计算过滤条件的选择性，提高优化决策的准确性
func (po *PerformanceOptimizer) EstimateSelectivity(filter Filter, stats *Statistics) float64 <span class="cov0" title="0">{
        if stats == nil </span><span class="cov0" title="0">{
                // 没有统计信息，使用默认选择性
                return po.getDefaultSelectivity(filter)
        }</span>

        // 根据不同的操作符类型计算选择性
        <span class="cov0" title="0">switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return po.estimateEqualitySelectivity(filter, stats)</span>
        case "&gt;", "&gt;=":<span class="cov0" title="0">
                return po.estimateRangeSelectivity(filter, stats, 0.5)</span>
        case "&lt;", "&lt;=":<span class="cov0" title="0">
                return po.estimateRangeSelectivity(filter, stats, 0.5)</span>
        case "!=", "&lt;&gt;":<span class="cov0" title="0">
                // 不等于：1 - 选择性
                return 1.0 - po.estimateEqualitySelectivity(filter, stats)</span>
        case "LIKE":<span class="cov0" title="0">
                // LIKE 操作符，通常选择性较低
                return po.estimateLikeSelectivity(filter)</span>
        case "IN":<span class="cov0" title="0">
                // IN 操作符，选择性取决于值的数量
                return po.estimateInSelectivity(filter)</span>
        default:<span class="cov0" title="0">
                // 未知操作符，使用默认值
                return po.getDefaultSelectivity(filter)</span>
        }
}

// estimateEqualitySelectivity 估算等值条件的选择性
func (po *PerformanceOptimizer) estimateEqualitySelectivity(filter Filter, stats *Statistics) float64 <span class="cov0" title="0">{
        // 选择性 = 1 / 唯一值数量
        if stats.UniqueKeys &gt; 0 </span><span class="cov0" title="0">{
                return 1.0 / float64(stats.UniqueKeys)
        }</span>

        // 没有唯一值统计，假设10%的选择性
        <span class="cov0" title="0">return 0.1</span>
}

// estimateRangeSelectivity 估算范围条件的选择性
func (po *PerformanceOptimizer) estimateRangeSelectivity(filter Filter, stats *Statistics, defaultFraction float64) float64 <span class="cov0" title="0">{
        if stats == nil || stats.RowCount == 0 </span><span class="cov0" title="0">{
                return defaultFraction
        }</span>

        // 基于值的分布估算范围选择性
        // 这里简化：对于 &gt;, &gt;=, &lt;, &lt;= 等操作符，假设50%的选择性
        // 完整实现需要直方图统计信息

        // 检查是否有NULL值
        <span class="cov0" title="0">nullFraction := 0.0
        if stats.RowCount &gt; 0 </span><span class="cov0" title="0">{
                nullFraction = float64(stats.NullCount) / float64(stats.RowCount)
        }</span>

        // 排除NULL值后的选择性
        <span class="cov0" title="0">return defaultFraction * (1.0 - nullFraction)</span>
}

// estimateLikeSelectivity 估算LIKE条件的选择性
func (po *PerformanceOptimizer) estimateLikeSelectivity(filter Filter) float64 <span class="cov0" title="0">{
        if filter.Value == nil </span><span class="cov0" title="0">{
                return 0.1
        }</span>

        <span class="cov0" title="0">valueStr := fmt.Sprintf("%v", filter.Value)

        // 前缀匹配（如 'abc%'）选择性较高
        if len(valueStr) &gt; 0 &amp;&amp; valueStr[len(valueStr)-1] == '%' </span><span class="cov0" title="0">{
                return 0.3
        }</span>

        // 后缀匹配（如 '%abc'）选择性较低
        <span class="cov0" title="0">if len(valueStr) &gt; 0 &amp;&amp; valueStr[0] == '%' </span><span class="cov0" title="0">{
                return 0.05
        }</span>

        // 包含匹配（如 '%abc%'）选择性中等
        <span class="cov0" title="0">if len(valueStr) &gt; 2 &amp;&amp; valueStr[0] == '%' &amp;&amp; valueStr[len(valueStr)-1] == '%' </span><span class="cov0" title="0">{
                return 0.1
        }</span>

        // 无通配符，等价于等值条件
        <span class="cov0" title="0">return 0.1</span>
}

// estimateInSelectivity 估算IN条件的选择性
func (po *PerformanceOptimizer) estimateInSelectivity(filter Filter) float64 <span class="cov0" title="0">{
        // IN (a, b, c) 的选择性 = 不同值的数量 / 表总行数
        // 简化：根据值的数量估算

        // 尝试从值中提取数量
        if values, ok := filter.Value.([]interface{}); ok </span><span class="cov0" title="0">{
                numValues := len(values)
                if numValues &gt; 0 </span><span class="cov0" title="0">{
                        // 每个值的平均选择性，但不超过1
                        selectivity := float64(numValues) * 0.1
                        if selectivity &gt; 1.0 </span><span class="cov0" title="0">{
                                return 1.0
                        }</span>
                        <span class="cov0" title="0">return selectivity</span>
                }
        }

        // 默认假设IN中有3个值
        <span class="cov0" title="0">return 0.3</span>
}

// getDefaultSelectivity 获取默认选择性
func (po *PerformanceOptimizer) getDefaultSelectivity(filter Filter) float64 <span class="cov0" title="0">{
        // 根据操作符类型返回默认选择性
        switch filter.Operator </span>{
        case "=":<span class="cov0" title="0">
                return 0.1</span> // 等值条件
        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov0" title="0">
                return 0.3</span> // 范围条件
        case "!=", "&lt;&gt;":<span class="cov0" title="0">
                return 0.9</span> // 不等于
        case "LIKE":<span class="cov0" title="0">
                return 0.1</span> // LIKE
        default:<span class="cov0" title="0">
                return 0.5</span> // 未知操作符
        }
}

// EstimateJoinSelectivity 估算JOIN的选择性
func (po *PerformanceOptimizer) EstimateJoinSelectivity(leftTable, rightTable string, optCtx *OptimizationContext) float64 <span class="cov0" title="0">{
        // 估算两个表JOIN后的行数
        leftRows := po.getTableRows(leftTable, optCtx)
        rightRows := po.getTableRows(rightTable, optCtx)

        // 笛卡尔积大小
        cartesianSize := float64(leftRows * rightRows)

        // 假设等值连接的选择性为10%
        selectivity := 0.1

        // 计算预期结果行数
        estimatedRows := cartesianSize * selectivity

        // 计算选择性（结果行数 / 笛卡尔积）
        if cartesianSize &gt; 0 </span><span class="cov0" title="0">{
                return estimatedRows / cartesianSize
        }</span>

        <span class="cov0" title="0">return 0.1</span>
}

// getTableRows 获取表的行数
func (po *PerformanceOptimizer) getTableRows(table string, optCtx *OptimizationContext) int64 <span class="cov0" title="0">{
        if optCtx == nil || optCtx.Stats == nil </span><span class="cov0" title="0">{
                return 1000 // 默认估计
        }</span>

        <span class="cov0" title="0">if stats, ok := optCtx.Stats[table]; ok </span><span class="cov0" title="0">{
                return stats.RowCount
        }</span>

        <span class="cov0" title="0">return 1000</span> // 默认估计
}

// Filter 过滤条件（简化版）
type Filter struct {
        Column   string
        Operator string
        Value    interface{}
}

// OptimizeScan 优化扫描操作
func (po *PerformanceOptimizer) OptimizeScan(tableName string, filters []Filter, optCtx *OptimizationContext) *ScanOptimization <span class="cov0" title="0">{
        optimization := &amp;ScanOptimization{
                UseIndex:      false,
                IndexName:     "",
                PushDown:      true,
                EstimatedRows: 10000,
        }

        // 检查是否有可用的索引
        for _, filter := range filters </span><span class="cov0" title="0">{
                if index := po.indexManager.FindBestIndex(tableName, []string{filter.Column}); index != nil </span><span class="cov0" title="0">{
                        optimization.UseIndex = true
                        optimization.IndexName = index.Name
                        optimization.EstimatedRows = index.Cardinality / 10 // 假设索引选择性为10%
                        break</span>
                }
        }

        <span class="cov0" title="0">return optimization</span>
}

// ScanOptimization 扫描优化建议
type ScanOptimization struct {
        UseIndex      bool
        IndexName     string
        PushDown      bool
        EstimatedRows int64
}

// Explain 解释优化建议
func (so *ScanOptimization) Explain() string <span class="cov0" title="0">{
        if so.UseIndex </span><span class="cov0" title="0">{
                return fmt.Sprintf("建议使用索引 %s，预计扫描 %d 行", so.IndexName, so.EstimatedRows)
        }</span>
        <span class="cov0" title="0">if so.PushDown </span><span class="cov0" title="0">{
                return fmt.Sprintf("建议将过滤条件下推，预计扫描 %d 行", so.EstimatedRows)
        }</span>
        <span class="cov0" title="0">return "全表扫描"</span>
}

// MemoryPool 内存池（用于重用对象减少GC压力）
type MemoryPool struct {
        pools map[string]interface{}
        mu    sync.RWMutex
}

// NewMemoryPool 创建内存池
func NewMemoryPool() *MemoryPool <span class="cov0" title="0">{
        return &amp;MemoryPool{
                pools: make(map[string]interface{}),
        }
}</span>

// GetPool 获取指定类型的池
func (mp *MemoryPool) GetPool(key string) interface{} <span class="cov0" title="0">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()
        return mp.pools[key]
}</span>

// SetPool 设置指定类型的池
func (mp *MemoryPool) SetPool(key string, pool interface{}) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()
        mp.pools[key] = pool
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/utils"
)

// PhysicalTableScan 物理表扫描
type PhysicalTableScan struct {
        TableName  string
        Columns    []ColumnInfo
        TableInfo  *domain.TableInfo
        cost       float64
        children   []PhysicalPlan
        dataSource domain.DataSource
        filters    []domain.Filter // 下推的过滤条件
        limitInfo  *LimitInfo      // 下推的Limit信息
}

// NewPhysicalTableScan 创建物理表扫描
func NewPhysicalTableScan(tableName string, tableInfo *domain.TableInfo, dataSource domain.DataSource, filters []domain.Filter, limitInfo *LimitInfo) *PhysicalTableScan <span class="cov7" title="68">{
        columns := make([]ColumnInfo, 0, len(tableInfo.Columns))
        for _, col := range tableInfo.Columns </span><span class="cov9" title="197">{
                columns = append(columns, ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                })
        }</span>

        // 假设表有1000行
        <span class="cov7" title="68">rowCount := int64(1000)
        
        // 如果有Limit，调整成本估计
        if limitInfo != nil &amp;&amp; limitInfo.Limit &gt; 0 </span><span class="cov3" title="5">{
                rowCount = limitInfo.Limit
        }</span>

        <span class="cov7" title="68">return &amp;PhysicalTableScan{
                TableName: tableName,
                Columns:   columns,
                TableInfo: tableInfo,
                cost:      float64(rowCount),
                children:  []PhysicalPlan{},
                dataSource: dataSource,
                filters:   filters,
                limitInfo: limitInfo,
        }</span>
}

// Children 获取子节点
func (p *PhysicalTableScan) Children() []PhysicalPlan <span class="cov6" title="24">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalTableScan) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalTableScan) Schema() []ColumnInfo <span class="cov1" title="1">{
        return p.Columns
}</span>

// Cost 返回执行成本
func (p *PhysicalTableScan) Cost() float64 <span class="cov7" title="58">{
        return p.cost
}</span>

// Execute 执行扫描
func (p *PhysicalTableScan) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov6" title="22">{
        fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 开始查询表 %s, 过滤器数: %d, Limit: %v\n", p.TableName, len(p.filters), p.limitInfo)

        // 检查数据源是否支持 FilterableDataSource
        filterableDS, isFilterable := p.dataSource.(domain.FilterableDataSource)

        // 计算偏移量和限制量
        offset := int64(0)
        limit := int64(0)
        if p.limitInfo != nil </span><span class="cov5" title="16">{
                offset = p.limitInfo.Offset
                limit = p.limitInfo.Limit
        }</span>

        <span class="cov6" title="22">var result *domain.QueryResult
        var err error

        if isFilterable &amp;&amp; len(p.filters) &gt; 0 </span><span class="cov4" title="10">{
                // 数据源支持过滤，调用 Filter 方法
                fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 数据源支持过滤，调用 Filter 方法\n")
                for i, filter := range p.filters </span><span class="cov5" title="12">{
                        fmt.Printf("  [DEBUG]   过滤器%d: Field=%s, Operator=%s, Value=%v\n", i, filter.Field, filter.Operator, filter.Value)
                }</span>

                // 构建过滤条件
                <span class="cov4" title="10">var filter domain.Filter
                if len(p.filters) == 1 </span><span class="cov4" title="8">{
                        // 单个条件，直接使用
                        filter = p.filters[0]
                }</span> else<span class="cov2" title="2"> {
                        // 多个条件，使用 AND 逻辑组合
                        filter = domain.Filter{
                                Logic: "AND",
                                Value: p.filters,
                        }
                }</span>

                // 调用 Filter 方法
                <span class="cov4" title="10">rows, total, filterErr := filterableDS.Filter(ctx, p.TableName, filter, int(offset), int(limit))
                if filterErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: Filter 方法失败 %v\n", filterErr)
                        return nil, filterErr
                }</span>

                // 构建结果
                <span class="cov4" title="10">result = &amp;domain.QueryResult{
                        Rows:  rows,
                        Total: total,
                }
                fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: Filter 完成，返回 %d 行（total=%d）\n", len(rows), total)</span>
        } else<span class="cov5" title="12"> {
                // 数据源不支持过滤或无过滤条件，使用 Query 方法
                fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 数据源不支持过滤或无过滤条件，使用 Query 方法\n")
                
                // 使用 QueryOptions 传递过滤和分页
                options := &amp;domain.QueryOptions{}
                if len(p.filters) &gt; 0 </span><span class="cov0" title="0">{
                        options.Filters = p.filters
                        fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 应用过滤条件到 QueryOptions\n")
                        for i, filter := range p.filters </span><span class="cov0" title="0">{
                                fmt.Printf("  [DEBUG]   过滤器%d: Field=%s, Operator=%s, Value=%v\n", i, filter.Field, filter.Operator, filter.Value)
                        }</span>
                }
                <span class="cov5" title="12">if limit &gt; 0 </span><span class="cov0" title="0">{
                        options.Limit = int(limit)
                }</span>
                <span class="cov5" title="12">if offset &gt; 0 </span><span class="cov0" title="0">{
                        options.Offset = int(offset)
                }</span>
                <span class="cov5" title="12">fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: 应用分页参数: limit=%d, offset=%d\n", options.Limit, options.Offset)

                // 调用 Query 方法
                result, err = p.dataSource.Query(ctx, p.TableName, options)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: Query 方法失败 %v\n", err)
                        return nil, err
                }</span>
                <span class="cov5" title="12">fmt.Printf("  [DEBUG] PhysicalTableScan.Execute: Query 完成，返回 %d 行\n", len(result.Rows))</span>
        }

        <span class="cov6" title="22">return result, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalTableScan) Explain() string <span class="cov6" title="27">{
        return fmt.Sprintf("TableScan(%s, cost=%.2f)", p.TableName, p.cost)
}</span>

// PhysicalSelection 物理过滤
type PhysicalSelection struct {
        Conditions []*parser.Expression
        Filters    []domain.Filter
        cost       float64
        children   []PhysicalPlan
        dataSource domain.DataSource
}

// NewPhysicalSelection 创建物理过滤
func NewPhysicalSelection(conditions []*parser.Expression, filters []domain.Filter, child PhysicalPlan, dataSource domain.DataSource) *PhysicalSelection <span class="cov3" title="6">{
        inputCost := child.Cost()
        cost := inputCost*1.2 + 10 // 过滤成本

        return &amp;PhysicalSelection{
                Conditions: conditions,
                Filters:    filters,
                cost:       cost,
                children:   []PhysicalPlan{child},
                dataSource: dataSource,
        }
}</span>

// Children 获取子节点
func (p *PhysicalSelection) Children() []PhysicalPlan <span class="cov4" title="9">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalSelection) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalSelection) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalSelection) Cost() float64 <span class="cov4" title="7">{
        return p.cost
}</span>

// Execute 执行过滤
func (p *PhysicalSelection) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov3" title="4">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalSelection has no child")
        }</span>

        // 先执行子节点
        <span class="cov3" title="4">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 手动应用过滤（简化实现）
        <span class="cov3" title="4">filtered := []domain.Row{}
        for _, row := range input.Rows </span><span class="cov0" title="0">{
                match := true
                for _, filter := range p.Filters </span><span class="cov0" title="0">{
                        if !matchesFilter(row, filter) </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                        filtered = append(filtered, row)
                }</span>
        }

        <span class="cov3" title="4">return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    filtered,
                Total:    int64(len(filtered)),
        }, nil</span>
}

// matchesFilter 检查行是否匹配过滤器（简化实现）
func matchesFilter(row domain.Row, filter domain.Filter) bool <span class="cov0" title="0">{
        match, _ := utils.MatchesFilter(row, filter)
        return match
}</span>

// Explain 返回计划说明
func (p *PhysicalSelection) Explain() string <span class="cov4" title="9">{
        return fmt.Sprintf("Selection(cost=%.2f)", p.cost)
}</span>

// PhysicalProjection 物理投影
type PhysicalProjection struct {
        Exprs   []*parser.Expression
        Aliases  []string
        Columns  []ColumnInfo
        cost     float64
        children []PhysicalPlan
}

// NewPhysicalProjection 创建物理投影
func NewPhysicalProjection(exprs []*parser.Expression, aliases []string, child PhysicalPlan) *PhysicalProjection <span class="cov7" title="52">{
        inputCost := child.Cost()
        cost := inputCost*1.1 + float64(len(exprs))*5 // 投影成本

        columns := make([]ColumnInfo, len(exprs))
        for i, expr := range exprs </span><span class="cov7" title="74">{
                name := aliases[i]
                if name == "" </span><span class="cov0" title="0">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov0" title="0">{
                                name = expr.Column
                        }</span> else<span class="cov0" title="0"> {
                                name = fmt.Sprintf("expr_%d", i)
                        }</span>
                }
                <span class="cov7" title="74">columns[i] = ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                }</span>
        }

        <span class="cov7" title="52">return &amp;PhysicalProjection{
                Exprs:    exprs,
                Aliases:   aliases,
                Columns:   columns,
                cost:      cost,
                children:  []PhysicalPlan{child},
        }</span>
}

// Children 获取子节点
func (p *PhysicalProjection) Children() []PhysicalPlan <span class="cov6" title="23">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalProjection) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalProjection) Schema() []ColumnInfo <span class="cov0" title="0">{
        return p.Columns
}</span>

// Cost 返回执行成本
func (p *PhysicalProjection) Cost() float64 <span class="cov3" title="6">{
        return p.cost
}</span>

// Execute 执行投影
func (p *PhysicalProjection) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov5" title="15">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalProjection has no child")
        }</span>

        // 先执行子节点
        <span class="cov5" title="15">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="15">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 输入行数: %d, 输入列数: %d\n", len(input.Rows), len(input.Columns))

        // 应用投影（简化实现，只支持列选择）
        output := []domain.Row{}
        for rowIdx, row := range input.Rows </span><span class="cov7" title="49">{
                newRow := make(domain.Row)
                fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 处理行 %d, 原始keys: %v\n", rowIdx, getMapKeys(row))
                for i, expr := range p.Exprs </span><span class="cov7" title="68">{
                        if expr.Type == parser.ExprTypeColumn </span><span class="cov7" title="68">{
                                fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 尝试提取列 %s (别名: %s)\n", expr.Column, p.Aliases[i])
                                if val, exists := row[expr.Column]; exists </span><span class="cov6" title="24">{
                                        newRow[p.Aliases[i]] = val
                                        fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 提取成功, 值: %v\n", val)
                                }</span> else<span class="cov7" title="44"> {
                                        fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 列 %s 不存在于行中\n", expr.Column)
                                        // 简化：不支持表达式计算
                                        newRow[p.Aliases[i]] = nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 简化：不支持表达式计算
                                newRow[p.Aliases[i]] = nil
                        }</span>
                }
                <span class="cov7" title="49">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 新行keys: %v\n", getMapKeys(newRow))
                output = append(output, newRow)</span>
        }

        // 更新列信息
        <span class="cov5" title="15">columns := make([]domain.ColumnInfo, len(p.Columns))
        for i, col := range p.Columns </span><span class="cov6" title="28">{
                columns[i] = domain.ColumnInfo{
                        Name:     col.Name,
                        Type:     col.Type,
                        Nullable: col.Nullable,
                }
        }</span>

        <span class="cov5" title="15">fmt.Printf("  [DEBUG] PhysicalProjection.Execute: 输出行数: %d, 输出列: %v\n", len(output), p.Aliases)
        return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// getMapKeys 获取map的所有key
func getMapKeys(m domain.Row) []string <span class="cov8" title="98">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov10" title="260">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="98">return keys</span>
}

// Explain 返回计划说明
func (p *PhysicalProjection) Explain() string <span class="cov6" title="29">{
        return fmt.Sprintf("Projection(cost=%.2f)", p.cost)
}</span>

// PhysicalLimit 物理限制
type PhysicalLimit struct {
        Limit    int64
        Offset   int64
        cost     float64
        children []PhysicalPlan
}

// NewPhysicalLimit 创建物理限制
func NewPhysicalLimit(limit, offset int64, child PhysicalPlan) *PhysicalLimit <span class="cov3" title="6">{
        inputCost := child.Cost()
        cost := inputCost + float64(limit)*0.01 // 限制操作成本很低

        return &amp;PhysicalLimit{
                Limit:    limit,
                Offset:   offset,
                cost:     cost,
                children: []PhysicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *PhysicalLimit) Children() []PhysicalPlan <span class="cov4" title="7">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalLimit) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalLimit) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalLimit) Cost() float64 <span class="cov3" title="6">{
        return p.cost
}</span>

// Execute 执行限制
func (p *PhysicalLimit) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov2" title="3">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalLimit has no child")
        }</span>

        // 先执行子节点
        <span class="cov2" title="3">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 应用 OFFSET 和 LIMIT
        <span class="cov2" title="3">start := p.Offset
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov2" title="3">if start &gt;= int64(len(input.Rows)) </span><span class="cov2" title="2">{
                return &amp;domain.QueryResult{
                        Columns: input.Columns,
                        Rows:    []domain.Row{},
                        Total:    0,
                }, nil
        }</span>

        <span class="cov1" title="1">end := start + p.Limit
        if end &gt; int64(len(input.Rows)) </span><span class="cov0" title="0">{
                end = int64(len(input.Rows))
        }</span>

        <span class="cov1" title="1">output := input.Rows[start:end]

        return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    output,
                Total:    int64(len(output)),
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalLimit) Explain() string <span class="cov4" title="7">{
        return fmt.Sprintf("Limit(offset=%d, limit=%d, cost=%.2f)", p.Offset, p.Limit, p.cost)
}</span>

// PhysicalHashJoin 物理哈希连接
type PhysicalHashJoin struct {
        JoinType   JoinType
        Conditions []*JoinCondition
        cost       float64
        children   []PhysicalPlan
}

// NewPhysicalHashJoin 创建物理哈希连接
func NewPhysicalHashJoin(joinType JoinType, left, right PhysicalPlan, conditions []*JoinCondition) *PhysicalHashJoin <span class="cov0" title="0">{
        leftRows := int64(1000) // 假设
        rightRows := int64(1000) // 假设

        // Hash Join 成本 = 构建哈希表 + 探测
        buildCost := float64(leftRows) * 0.1
        probeCost := float64(rightRows) * 0.1
        cost := left.Cost() + right.Cost() + buildCost + probeCost

        return &amp;PhysicalHashJoin{
                JoinType:   joinType,
                Conditions: conditions,
                cost:       cost,
                children:   []PhysicalPlan{left, right},
        }
}</span>

// Children 获取子节点
func (p *PhysicalHashJoin) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalHashJoin) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalHashJoin) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[0].Schema()...)
        }</span>
        <span class="cov0" title="0">if len(p.children) &gt; 1 </span><span class="cov0" title="0">{
                columns = append(columns, p.children[1].Schema()...)
        }</span>
        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalHashJoin) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行哈希连接
func (p *PhysicalHashJoin) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HashJoin requires exactly 2 children")
        }</span>

        // 获取连接条件（简化：只支持单列等值连接）
        <span class="cov0" title="0">leftJoinCol := ""
        rightJoinCol := ""
        if len(p.Conditions) &gt; 0 &amp;&amp; p.Conditions[0].Left != nil </span><span class="cov0" title="0">{
                leftJoinCol = fmt.Sprintf("%v", p.Conditions[0].Left)
        }</span>
        <span class="cov0" title="0">if len(p.Conditions) &gt; 0 &amp;&amp; p.Conditions[0].Right != nil </span><span class="cov0" title="0">{
                rightJoinCol = fmt.Sprintf("%v", p.Conditions[0].Right)
        }</span>

        // 1. 执行左表（构建端）
        <span class="cov0" title="0">leftResult, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("left table execute error: %w", err)
        }</span>

        // 2. 执行右表（探测端）
        <span class="cov0" title="0">rightResult, err := p.children[1].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("right table execute error: %w", err)
        }</span>

        // 3. 构建哈希表（从左表）
        <span class="cov0" title="0">hashTable := make(map[interface{}][]domain.Row)
        for _, row := range leftResult.Rows </span><span class="cov0" title="0">{
                key := row[leftJoinCol]
                hashTable[key] = append(hashTable[key], row)
        }</span>

        // 4. 探测右表并产生结果
        <span class="cov0" title="0">output := []domain.Row{}

        // 根据连接类型处理
        switch p.JoinType </span>{
        case InnerJoin:<span class="cov0" title="0">
                // INNER JOIN：两边都有匹配
                for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := hashTable[key]; exists </span><span class="cov0" title="0">{
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        // 合并左右行
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                // 如果列名冲突，添加前缀
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        }
                }
        case LeftOuterJoin:<span class="cov0" title="0">
                // LEFT JOIN：左边所有行，右边没有匹配的用NULL填充
                // 跟踪右边已匹配的行
                rightMatched := make(map[int]bool)
                for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := hashTable[key]; exists </span><span class="cov0" title="0">{
                                // 有匹配：连接
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        // 标记右边已匹配的行 - 简化：不比较行内容
                        // 由于 map 不能直接比较，使用索引方式
                        <span class="cov0" title="0">rightMatched[len(rightResult.Rows)-1] = true</span>
                        }
                }
                // 添加左边没有匹配的行
                <span class="cov0" title="0">for _, leftRow := range leftResult.Rows </span><span class="cov0" title="0">{
                        leftKey := leftRow[leftJoinCol]
                        matched := false
                        for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                                if rightRow[rightJoinCol] == leftKey </span><span class="cov0" title="0">{
                                        matched = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                                merged := make(domain.Row)
                                for k, v := range leftRow </span><span class="cov0" title="0">{
                                        merged[k] = v
                                }</span>
                                <span class="cov0" title="0">for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                                        newKey := col.Name
                                        if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                newKey = "right_" + col.Name
                                        }</span>
                                        <span class="cov0" title="0">merged[newKey] = nil</span>
                                }
                                <span class="cov0" title="0">output = append(output, merged)</span>
                        }
                }
case RightOuterJoin:<span class="cov0" title="0">
                // RIGHT JOIN：右边所有行，左边没有匹配的用NULL填充
                // 重新构建左表的哈希表用于RIGHT JOIN
                leftHashTable := make(map[interface{}][]domain.Row)
                for _, row := range leftResult.Rows </span><span class="cov0" title="0">{
                        key := row[leftJoinCol]
                        leftHashTable[key] = append(leftHashTable[key], row)
                }</span>

                <span class="cov0" title="0">for _, rightRow := range rightResult.Rows </span><span class="cov0" title="0">{
                        key := rightRow[rightJoinCol]
                        if leftRows, exists := leftHashTable[key]; exists </span><span class="cov0" title="0">{
                                // 有匹配：连接
                                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                                        merged := make(domain.Row)
                                        for k, v := range leftRow </span><span class="cov0" title="0">{
                                                merged[k] = v
                                        }</span>
                                        <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                                newKey := k
                                                if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                        newKey = "right_" + k
                                                }</span>
                                                <span class="cov0" title="0">merged[newKey] = v</span>
                                        }
                                        <span class="cov0" title="0">output = append(output, merged)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // 无匹配：左边NULL + 右边行
                                merged := make(domain.Row)
                                for _, col := range leftResult.Columns </span><span class="cov0" title="0">{
                                        merged[col.Name] = nil
                                }</span>
                                <span class="cov0" title="0">for k, v := range rightRow </span><span class="cov0" title="0">{
                                        newKey := k
                                        if _, exists := merged[newKey]; exists </span><span class="cov0" title="0">{
                                                newKey = "right_" + k
                                        }</span>
                                        <span class="cov0" title="0">merged[newKey] = v</span>
                                }
                                <span class="cov0" title="0">output = append(output, merged)</span>
                        }
                }

default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported join type: %s", p.JoinType)</span>
        }

        // 合并列信息
        <span class="cov0" title="0">columns := []domain.ColumnInfo{}
        columns = append(columns, leftResult.Columns...)
        for _, col := range rightResult.Columns </span><span class="cov0" title="0">{
                // 检查列名是否冲突
                conflict := false
                for _, leftCol := range leftResult.Columns </span><span class="cov0" title="0">{
                        if leftCol.Name == col.Name </span><span class="cov0" title="0">{
                                conflict = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if conflict </span><span class="cov0" title="0">{
                        columns = append(columns, domain.ColumnInfo{
                                Name:     "right_" + col.Name,
                                Type:     col.Type,
                                Nullable: true,
                        })
                }</span> else<span class="cov0" title="0"> {
                        columns = append(columns, col)
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:   int64(len(output)),
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalHashJoin) Explain() string <span class="cov0" title="0">{
        return fmt.Sprintf("HashJoin(type=%s, cost=%.2f)", p.JoinType, p.cost)
}</span>

// PhysicalHashAggregate 物理哈希聚合
type PhysicalHashAggregate struct {
        AggFuncs   []*AggregationItem
        GroupByCols []string
        cost        float64
        children    []PhysicalPlan
}

// NewPhysicalHashAggregate 创建物理哈希聚合
func NewPhysicalHashAggregate(aggFuncs []*AggregationItem, groupByCols []string, child PhysicalPlan) *PhysicalHashAggregate <span class="cov3" title="5">{
        inputRows := int64(1000) // 假设

        // Hash Agg 成本 = 分组 + 聚合
        groupCost := float64(inputRows) * float64(len(groupByCols)) * 0.05
        aggCost := float64(inputRows) * float64(len(aggFuncs)) * 0.05
        cost := child.Cost() + groupCost + aggCost

        return &amp;PhysicalHashAggregate{
                AggFuncs:   aggFuncs,
                GroupByCols: groupByCols,
                cost:        cost,
                children:    []PhysicalPlan{child},
        }
}</span>

// Children 获取子节点
func (p *PhysicalHashAggregate) Children() []PhysicalPlan <span class="cov2" title="2">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalHashAggregate) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalHashAggregate) Schema() []ColumnInfo <span class="cov0" title="0">{
        columns := []ColumnInfo{}

        // 添加 GROUP BY 列
        for _, col := range p.GroupByCols </span><span class="cov0" title="0">{
                columns = append(columns, ColumnInfo{
                        Name:     col,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 添加聚合函数列
        <span class="cov0" title="0">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                name := agg.Alias
                if name == "" </span><span class="cov0" title="0">{
                        name = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, ColumnInfo{
                        Name:     name,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov0" title="0">return columns</span>
}

// Cost 返回执行成本
func (p *PhysicalHashAggregate) Cost() float64 <span class="cov3" title="5">{
        return p.cost
}</span>

// Execute 执行哈希聚合
func (p *PhysicalHashAggregate) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov1" title="1">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HashAggregate has no child")
        }</span>

        // 执行子节点
        <span class="cov1" title="1">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(p.AggFuncs) == 0 &amp;&amp; len(p.GroupByCols) == 0 </span><span class="cov0" title="0">{
                // 没有聚合函数也没有分组，直接返回
                return input, nil
        }</span>

        // 用于存储分组结果的哈希表
        <span class="cov1" title="1">type groupKey struct {
                values []interface{}
        }
        groups := make(map[interface{}]*aggregateGroup)

        // 遍历所有行，进行分组和聚合
        for _, row := range input.Rows </span><span class="cov3" title="5">{
                // 构建分组键
                key := make([]interface{}, len(p.GroupByCols))
                for i, colName := range p.GroupByCols </span><span class="cov3" title="5">{
                        key[i] = row[colName]
                }</span>

                // 将key转换为字符串作为map的key
                <span class="cov3" title="5">keyStr := fmt.Sprintf("%v", key)

                // 获取或创建分组
                group, exists := groups[keyStr]
                if !exists </span><span class="cov2" title="3">{
                        group = &amp;aggregateGroup{
                                key:    key,
                                rows:   []domain.Row{},
                                values: make(map[string]interface{}),
                        }
                        groups[keyStr] = group
                }</span>

                <span class="cov3" title="5">group.rows = append(group.rows, row)</span>
        }

        // 为每个分组计算聚合函数
        <span class="cov1" title="1">output := []domain.Row{}
        for _, group := range groups </span><span class="cov2" title="3">{
                row := make(domain.Row)

                // 添加 GROUP BY 列
                for i, colName := range p.GroupByCols </span><span class="cov2" title="3">{
                        if i &lt; len(group.key) </span><span class="cov2" title="3">{
                                row[colName] = group.key[i]
                        }</span>
                }

                // 计算聚合函数
                <span class="cov2" title="3">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                        result := p.calculateAggregation(agg, group.rows)
                        colName := agg.Alias
                        if colName == "" </span><span class="cov0" title="0">{
                                colName = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                        }</span>
                        <span class="cov0" title="0">row[colName] = result</span>
                }

                <span class="cov2" title="3">output = append(output, row)</span>
        }

        // 构建列信息
        <span class="cov1" title="1">columns := []domain.ColumnInfo{}

        // GROUP BY 列
        for _, colName := range p.GroupByCols </span><span class="cov1" title="1">{
                columns = append(columns, domain.ColumnInfo{
                        Name:     colName,
                        Type:     "unknown",
                        Nullable: true,
                })
        }</span>

        // 聚合函数列
        <span class="cov1" title="1">for _, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                colName := agg.Alias
                if colName == "" </span><span class="cov0" title="0">{
                        colName = fmt.Sprintf("%s(%v)", agg.Type, agg.Expr)
                }</span>
                <span class="cov0" title="0">columns = append(columns, domain.ColumnInfo{
                        Name:     colName,
                        Type:     "unknown",
                        Nullable: true,
                })</span>
        }

        <span class="cov1" title="1">return &amp;domain.QueryResult{
                Columns: columns,
                Rows:    output,
                Total:   int64(len(output)),
        }, nil</span>
}

// aggregateGroup 表示一个分组
type aggregateGroup struct {
        key    []interface{}
        rows   []domain.Row
        values map[string]interface{}
}

// calculateAggregation 计算聚合函数
func (p *PhysicalHashAggregate) calculateAggregation(agg *AggregationItem, rows []domain.Row) interface{} <span class="cov0" title="0">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                switch agg.Type </span>{
                case Count:<span class="cov0" title="0">
                        return int64(0)</span>
                case Sum, Avg, Max, Min:<span class="cov0" title="0">
                        return nil</span>
                }
        }

        // 获取聚合列名
        <span class="cov0" title="0">colName := agg.Expr.Column
        if colName == "" &amp;&amp; agg.Expr.Function != "" </span><span class="cov0" title="0">{
                colName = fmt.Sprintf("%s(%v)", agg.Expr.Function, agg.Expr.Args)
        }</span>

        <span class="cov0" title="0">switch agg.Type </span>{
        case Count:<span class="cov0" title="0">
                return int64(len(rows))</span>
        case Sum:<span class="cov0" title="0">
                sum := 0.0
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil </span><span class="cov0" title="0">{
                                fval, _ := utils.ToFloat64(val)
                                sum += fval
                        }</span>
                }
                <span class="cov0" title="0">return sum</span>
        case Avg:<span class="cov0" title="0">
                if len(rows) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">sum := 0.0
                count := 0
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil </span><span class="cov0" title="0">{
                                fval, _ := utils.ToFloat64(val)
                                sum += fval
                                count++
                        }</span>
                }
                <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                        return sum / float64(count)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case Max:<span class="cov0" title="0">
                var max interface{}
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil &amp;&amp; max == nil </span><span class="cov0" title="0">{
                                max = val
                        }</span> else<span class="cov0" title="0"> if val != nil &amp;&amp; max != nil </span><span class="cov0" title="0">{
                                cmp := compareValues(val, max)
                                if cmp &gt; 0 </span><span class="cov0" title="0">{
                                        max = val
                                }</span>
                        }
                }
                <span class="cov0" title="0">return max</span>
        case Min:<span class="cov0" title="0">
                var min interface{}
                for _, row := range rows </span><span class="cov0" title="0">{
                        val := row[colName]
                        if val != nil &amp;&amp; min == nil </span><span class="cov0" title="0">{
                                min = val
                        }</span> else<span class="cov0" title="0"> if val != nil &amp;&amp; min != nil </span><span class="cov0" title="0">{
                                cmp := compareValues(val, min)
                                if cmp &lt; 0 </span><span class="cov0" title="0">{
                                        min = val
                                }</span>
                        }
                }
                <span class="cov0" title="0">return min</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Explain 返回计划说明
func (p *PhysicalHashAggregate) Explain() string <span class="cov2" title="2">{
        aggFuncs := ""
        for i, agg := range p.AggFuncs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        aggFuncs += ", "
                }</span>
                <span class="cov0" title="0">aggFuncs += agg.Type.String()</span>
        }
        
        <span class="cov2" title="2">groupBy := ""
        if len(p.GroupByCols) &gt; 0 </span><span class="cov2" title="2">{
                groupBy = fmt.Sprintf(", GROUP BY(%s)", fmt.Sprintf("%v", p.GroupByCols))
        }</span>
        
        <span class="cov2" title="2">return fmt.Sprintf("HashAggregate(funcs=[%s]%s, cost=%.2f)", aggFuncs, groupBy, p.cost)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "math"
        "sort"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// PhysicalSort 物理排序
type PhysicalSort struct {
        OrderByItems []*OrderByItem
        cost         float64
        children     []PhysicalPlan
}

// NewPhysicalSort 创建物理排序
func NewPhysicalSort(orderByItems []*OrderByItem, child PhysicalPlan) *PhysicalSort <span class="cov0" title="0">{
        inputCost := child.Cost()
        // 排序成本估算：n * log(n)，n是输入行数
        // 假设1000行
        inputRows := int64(1000)
        sortCost := float64(inputRows) * float64(log2(float64(inputRows))) * 0.01
        cost := inputCost + sortCost

        return &amp;PhysicalSort{
                OrderByItems: orderByItems,
                cost:         cost,
                children:     []PhysicalPlan{child},
        }
}</span>

// log2 计算以2为底的对数
func log2(x float64) float64 <span class="cov0" title="0">{
        if x &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return math.Log2(x)</span>
}

// Children 获取子节点
func (p *PhysicalSort) Children() []PhysicalPlan <span class="cov0" title="0">{
        return p.children
}</span>

// SetChildren 设置子节点
func (p *PhysicalSort) SetChildren(children ...PhysicalPlan) <span class="cov0" title="0">{
        p.children = children
}</span>

// Schema 返回输出列
func (p *PhysicalSort) Schema() []ColumnInfo <span class="cov0" title="0">{
        if len(p.children) &gt; 0 </span><span class="cov0" title="0">{
                return p.children[0].Schema()
        }</span>
        <span class="cov0" title="0">return []ColumnInfo{}</span>
}

// Cost 返回执行成本
func (p *PhysicalSort) Cost() float64 <span class="cov0" title="0">{
        return p.cost
}</span>

// Execute 执行排序
func (p *PhysicalSort) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        if len(p.children) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PhysicalSort has no child")
        }</span>

        // 执行子节点
        <span class="cov0" title="0">input, err := p.children[0].Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(p.OrderByItems) == 0 </span><span class="cov0" title="0">{
                // 没有排序条件，直接返回
                return input, nil
        }</span>

        // 复制行以避免修改原始数据
        <span class="cov0" title="0">rows := make([]domain.Row, len(input.Rows))
        copy(rows, input.Rows)

        // 排序
        sort.Slice(rows, func(i, j int) bool </span><span class="cov0" title="0">{
                for _, item := range p.OrderByItems </span><span class="cov0" title="0">{
                        leftVal := rows[i][item.Column]
                        rightVal := rows[j][item.Column]

                        // 比较两个值
                        cmp := compareValues(leftVal, rightVal)
                        if cmp != 0 </span><span class="cov0" title="0">{
                                // DESC 需要反转比较结果
                                if item.Direction == "DESC" </span><span class="cov0" title="0">{
                                        return cmp &gt; 0
                                }</span>
                                <span class="cov0" title="0">return cmp &lt; 0</span>
                        }
                }
                // 所有排序列都相等，保持原顺序
                <span class="cov0" title="0">return i &lt; j</span>
        })

        <span class="cov0" title="0">return &amp;domain.QueryResult{
                Columns: input.Columns,
                Rows:    rows,
                Total:   input.Total,
        }, nil</span>
}

// Explain 返回计划说明
func (p *PhysicalSort) Explain() string <span class="cov0" title="0">{
        items := ""
        for i, item := range p.OrderByItems </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        items += ", "
                }</span>
                <span class="cov0" title="0">direction := "ASC"
                if item.Direction == "DESC" </span><span class="cov0" title="0">{
                        direction = "DESC"
                }</span>
                <span class="cov0" title="0">items += fmt.Sprintf("%s %s", item.Column, direction)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Sort(%s, cost=%.2f)", items, p.cost)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// ProcedureExecutor 存储过程执行器
type ProcedureExecutor struct {
        // 变量作用域栈
        scopeStack []*Scope
        
        // 存储过程缓存
        procedures map[string]*parser.ProcedureInfo
        
        // 函数缓存
        functions map[string]*parser.FunctionInfo
        
        // 执行上下文
        ctx context.Context
}

// Scope 变量作用域
type Scope struct {
        Variables map[string]interface{}
        Parent    *Scope
}

// NewScope 创建新作用域
func NewScope(parent *Scope) *Scope <span class="cov0" title="0">{
        return &amp;Scope{
                Variables: make(map[string]interface{}),
                Parent:    parent,
        }
}</span>

// GetVariable 获取变量值
func (s *Scope) GetVariable(name string) (interface{}, bool) <span class="cov0" title="0">{
        if val, exists := s.Variables[name]; exists </span><span class="cov0" title="0">{
                return val, true
        }</span>
        
        // 查找父作用域
        <span class="cov0" title="0">if s.Parent != nil </span><span class="cov0" title="0">{
                return s.Parent.GetVariable(name)
        }</span>
        
        <span class="cov0" title="0">return nil, false</span>
}

// SetVariable 设置变量值
func (s *Scope) SetVariable(name string, value interface{}) <span class="cov0" title="0">{
        s.Variables[name] = value
}</span>

// NewProcedureExecutor 创建存储过程执行器
func NewProcedureExecutor() *ProcedureExecutor <span class="cov0" title="0">{
        return &amp;ProcedureExecutor{
                scopeStack: make([]*Scope, 0),
                procedures: make(map[string]*parser.ProcedureInfo),
                functions:   make(map[string]*parser.FunctionInfo),
        }
}</span>

// RegisterProcedure 注册存储过程
func (pe *ProcedureExecutor) RegisterProcedure(proc *parser.ProcedureInfo) error <span class="cov0" title="0">{
        if err := parser.ValidateProcedure(&amp;parser.ProcedureStmt{
                Name:   proc.Name,
                Params: proc.Params,
                Body:   proc.Body,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("procedure validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">pe.procedures[proc.Name] = proc
        return nil</span>
}

// RegisterFunction 注册函数
func (pe *ProcedureExecutor) RegisterFunction(fn *parser.FunctionInfo) error <span class="cov0" title="0">{
        if err := parser.ValidateFunction(&amp;parser.FunctionStmt{
                Name:       fn.Name,
                ReturnType:  fn.ReturnType,
                Params:     fn.Params,
                Body:       fn.Body,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("function validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">pe.functions[fn.Name] = fn
        return nil</span>
}

// ExecuteProcedure 执行存储过程
func (pe *ProcedureExecutor) ExecuteProcedure(ctx context.Context, name string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        pe.ctx = ctx
        
        // 查找存储过程
        proc, exists := pe.procedures[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("procedure not found: %s", name)
        }</span>
        
        // 创建新作用域
        <span class="cov0" title="0">newScope := NewScope(pe.currentScope())
        pe.pushScope(newScope)
        defer pe.popScope()
        
        // 绑定参数
        if len(args) != len(proc.Params) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter count mismatch: expected %d, got %d", len(proc.Params), len(args))
        }</span>
        
        <span class="cov0" title="0">for i, param := range proc.Params </span><span class="cov0" title="0">{
                newScope.SetVariable(param.Name, args[i])
        }</span>
        
        // 执行存储过程体
        <span class="cov0" title="0">return pe.executeBlock(proc.Body)</span>
}

// ExecuteFunction 执行函数
func (pe *ProcedureExecutor) ExecuteFunction(ctx context.Context, name string, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        pe.ctx = ctx
        
        // 查找函数
        fn, exists := pe.functions[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function not found: %s", name)
        }</span>
        
        // 创建新作用域
        <span class="cov0" title="0">newScope := NewScope(pe.currentScope())
        pe.pushScope(newScope)
        defer pe.popScope()
        
        // 绑定参数
        if len(args) != len(fn.Params) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter count mismatch: expected %d, got %d", len(fn.Params), len(args))
        }</span>
        
        <span class="cov0" title="0">for i, param := range fn.Params </span><span class="cov0" title="0">{
                newScope.SetVariable(param.Name, args[i])
        }</span>
        
        // 执行函数体
        <span class="cov0" title="0">result, err := pe.executeBlockWithReturn(fn.Body)
        return result, err</span>
}

// executeBlock 执行语句块
func (pe *ProcedureExecutor) executeBlock(block *parser.BlockStmt) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // 执行声明
        <span class="cov0" title="0">for _, decl := range block.Declarations </span><span class="cov0" title="0">{
                if err := pe.executeDeclaration(decl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        // 执行语句
        <span class="cov0" title="0">for _, stmt := range block.Statements </span><span class="cov0" title="0">{
                switch s := stmt.(type) </span>{
                case *parser.IfStmt:<span class="cov0" title="0">
                        if err := pe.executeIf(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.WhileStmt:<span class="cov0" title="0">
                        if err := pe.executeWhile(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.SetStmt:<span class="cov0" title="0">
                        if err := pe.executeSet(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.CaseStmt:<span class="cov0" title="0">
                        if err := pe.executeCase(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.ReturnStmt:<span class="cov0" title="0">
                        // RETURN语句在函数中处理
                        return nil, fmt.Errorf("RETURN statement not allowed in procedure")</span>
                }
        }
        
        // 返回空结果集
        <span class="cov0" title="0">return []map[string]interface{}{}, nil</span>
}

// executeBlockWithReturn 执行语句块(支持RETURN)
func (pe *ProcedureExecutor) executeBlockWithReturn(block *parser.BlockStmt) (interface{}, error) <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // 执行声明
        <span class="cov0" title="0">for _, decl := range block.Declarations </span><span class="cov0" title="0">{
                if err := pe.executeDeclaration(decl); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        // 执行语句
        <span class="cov0" title="0">for _, stmt := range block.Statements </span><span class="cov0" title="0">{
                switch s := stmt.(type) </span>{
                case *parser.IfStmt:<span class="cov0" title="0">
                        if err := pe.executeIf(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.WhileStmt:<span class="cov0" title="0">
                        if err := pe.executeWhile(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.SetStmt:<span class="cov0" title="0">
                        if err := pe.executeSet(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case *parser.CaseStmt:<span class="cov0" title="0">
                        if err := pe.executeCase(s); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
        case *parser.ReturnStmt:<span class="cov0" title="0">
                // RETURN语句,返回值
                result, err := pe.evaluateExpression(&amp;s.Expression)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }
        }
        
        <span class="cov0" title="0">return nil, nil</span>
}

// executeDeclaration 执行变量声明
func (pe *ProcedureExecutor) executeDeclaration(decl parser.Declaration) error <span class="cov0" title="0">{
        scope := pe.currentScope()
        
        // 设置初始值
        value := interface{}(nil)
        if decl.Initial != nil </span><span class="cov0" title="0">{
                // 初始值直接使用，无需表达式求值
                value = decl.Initial
        }</span>
        
        <span class="cov0" title="0">scope.SetVariable(decl.Name, value)
        return nil</span>
}

// executeIf 执行IF语句
func (pe *ProcedureExecutor) executeIf(ifStmt *parser.IfStmt) error <span class="cov0" title="0">{
        // 计算条件
        cond, err := pe.evaluateExpression(&amp;ifStmt.Condition)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 判断条件
        <span class="cov0" title="0">if isTrue(cond) </span><span class="cov0" title="0">{
                // 执行THEN块
                _, err := pe.executeBlock(ifStmt.Then)
                return err
        }</span>
        
        // 执行ELSE IF块
        <span class="cov0" title="0">for _, elif := range ifStmt.ElseIfs </span><span class="cov0" title="0">{
                cond, err := pe.evaluateExpression(&amp;elif.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if isTrue(cond) </span><span class="cov0" title="0">{
                        _, err := pe.executeBlock(elif.Then)
                        return err
                }</span>
        }
        
        // 执行ELSE块
        <span class="cov0" title="0">if ifStmt.Else != nil </span><span class="cov0" title="0">{
                _, err := pe.executeBlock(ifStmt.Else)
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// executeWhile 执行WHILE语句
func (pe *ProcedureExecutor) executeWhile(whileStmt *parser.WhileStmt) error <span class="cov0" title="0">{
        // 循环执行
        for </span><span class="cov0" title="0">{
                // 计算条件
                cond, err := pe.evaluateExpression(&amp;whileStmt.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // 如果条件为假,退出循环
                <span class="cov0" title="0">if !isTrue(cond) </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // 执行循环体
                <span class="cov0" title="0">_, err = pe.executeBlock(whileStmt.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// executeSet 执行SET语句
func (pe *ProcedureExecutor) executeSet(setStmt *parser.SetStmt) error <span class="cov0" title="0">{
        // 计算值
        value, err := pe.evaluateExpression(&amp;setStmt.Value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 设置变量
        <span class="cov0" title="0">scope := pe.currentScope()
        scope.SetVariable(setStmt.Variable, value)
        
        return nil</span>
}

// executeCase 执行CASE语句
func (pe *ProcedureExecutor) executeCase(caseStmt *parser.CaseStmt) error <span class="cov0" title="0">{
        // 如果有表达式,先计算
        var caseExpr interface{}
        if caseStmt.Expression.Type != "" </span><span class="cov0" title="0">{
                val, err := pe.evaluateExpression(&amp;caseStmt.Expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">caseExpr = val</span>
        }
        
        // 检查每个WHEN
        <span class="cov0" title="0">for _, when := range caseStmt.Cases </span><span class="cov0" title="0">{
                cond, err := pe.evaluateExpression(&amp;when.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // 如果没有表达式,直接判断WHEN条件
                <span class="cov0" title="0">if caseStmt.Expression.Type == "" </span><span class="cov0" title="0">{
                        if isTrue(cond) </span><span class="cov0" title="0">{
                                _, err := pe.executeBlock(when.Then)
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 有表达式,比较值
                        if compareValuesEqual(cond, caseExpr) </span><span class="cov0" title="0">{
                                _, err := pe.executeBlock(when.Then)
                                return err
                        }</span>
                }
        }
        
        // 执行ELSE块
        <span class="cov0" title="0">if caseStmt.Else != nil </span><span class="cov0" title="0">{
                _, err := pe.executeBlock(caseStmt.Else)
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// evaluateExpression 计算表达式
func (pe *ProcedureExecutor) evaluateExpression(expr *parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        // 简化实现:只支持简单的常量和变量
        if expr.Value != nil </span><span class="cov0" title="0">{
                return expr.Value, nil
        }</span>
        
        <span class="cov0" title="0">if expr.Column != "" </span><span class="cov0" title="0">{
                scope := pe.currentScope()
                val, exists := scope.GetVariable(expr.Column)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("variable not found: %s", expr.Column)
                }</span>
                <span class="cov0" title="0">return val, nil</span>
        }
        
        <span class="cov0" title="0">if expr.Function != "" </span><span class="cov0" title="0">{
                // 简化实现:不支持复杂函数
                return nil, fmt.Errorf("function evaluation not yet implemented: %s", expr.Function)
        }</span>
        
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported expression")</span>
}

// 作用域管理

// pushScope 推入新作用域
func (pe *ProcedureExecutor) pushScope(scope *Scope) <span class="cov0" title="0">{
        pe.scopeStack = append(pe.scopeStack, scope)
}</span>

// popScope 弹出作用域
func (pe *ProcedureExecutor) popScope() <span class="cov0" title="0">{
        if len(pe.scopeStack) &gt; 0 </span><span class="cov0" title="0">{
                pe.scopeStack = pe.scopeStack[:len(pe.scopeStack)-1]
        }</span>
}

// currentScope 获取当前作用域
func (pe *ProcedureExecutor) currentScope() *Scope <span class="cov0" title="0">{
        if len(pe.scopeStack) == 0 </span><span class="cov0" title="0">{
                return NewScope(nil)
        }</span>
        <span class="cov0" title="0">return pe.scopeStack[len(pe.scopeStack)-1]</span>
}

// 辅助函数

// isTrue 判断值是否为真
func isTrue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return v != 0</span>
        case float32, float64:<span class="cov0" title="0">
                return v != 0.0</span>
        case string:<span class="cov0" title="0">
                return v != "" &amp;&amp; v != "0"</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// compareValuesEqual 比较两个值是否相等


</pre>
		
		<pre class="file" id="file33" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// PredicatePushDownRule 谓词下推规则
// 将 Selection 节点尽可能下推到 DataSource
type PredicatePushDownRule struct{}

// Name 返回规则名称
func (r *PredicatePushDownRule) Name() string <span class="cov7" title="99">{
        return "PredicatePushDown"
}</span>

// Match 检查规则是否匹配
func (r *PredicatePushDownRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        _, ok := plan.(*LogicalSelection)
        return ok
}</span>

// Apply 应用规则
func (r *PredicatePushDownRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov5" title="20">{
        selection, ok := plan.(*LogicalSelection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov5" title="20">if len(selection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov5" title="20">child := selection.children[0]

        // 如果子节点是 DataSource，将谓词标记到DataSource上（下推成功）
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov5" title="20">{
                // 将Selection的条件标记到DataSource，表示可以在扫描时过滤
                dataSource.PushDownPredicates(selection.Conditions())
                // 返回child，消除Selection节点（条件已下推到DataSource）
                return child, nil
        }</span>

        // 如果子节点是 Selection，合并条件
        <span class="cov0" title="0">if childSelection, ok := child.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                // 合并条件列表
                mergedConditions := append(selection.Conditions(), childSelection.Conditions()...)
                return NewLogicalSelection(mergedConditions, childSelection.Children()[0]), nil
        }</span>

        // 尝试下推到其他节点
        // 简化实现：不下推
        <span class="cov0" title="0">return plan, nil</span>
}

// ColumnPruningRule 列裁剪规则
// 移除不需要的列
type ColumnPruningRule struct{}

// Name 返回规则名称
func (r *ColumnPruningRule) Name() string <span class="cov7" title="113">{
        return "ColumnPruning"
}</span>

// Match 检查规则是否匹配
func (r *ColumnPruningRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        _, ok := plan.(*LogicalProjection)
        return ok
}</span>

// Apply 应用规则
func (r *ColumnPruningRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov6" title="54">{
        projection, ok := plan.(*LogicalProjection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov6" title="54">if len(projection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov6" title="54">child := projection.children[0]

        // 收集子节点需要的列
        requiredCols := make(map[string]bool)
        for _, expr := range projection.Exprs </span><span class="cov7" title="67">{
                collectRequiredColumns(expr, requiredCols)
        }</span>
        
        // 打印需要的列
        <span class="cov6" title="54">keys := make([]string, 0, len(requiredCols))
        for k := range requiredCols </span><span class="cov7" title="67">{
                keys = append(keys, k)
        }</span>
        <span class="cov6" title="54">fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 需要的列: %v\n", keys)

        // 如果子节点是 DataSource，调整输出列
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov5" title="29">{
                // 筛选出需要的列
                newColumns := []ColumnInfo{}
                for _, col := range dataSource.Columns </span><span class="cov7" title="72">{
                        if requiredCols[col.Name] </span><span class="cov3" title="6">{
                                newColumns = append(newColumns, col)
                        }</span>
                }
                // 如果有变化，创建新的 DataSource
                <span class="cov5" title="29">if len(newColumns) &lt; len(dataSource.Columns) </span><span class="cov5" title="29">{
                        fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 原列数: %d, 裁剪后: %d\n", len(dataSource.Columns), len(newColumns))
                        // 保存下推的谓词和Limit信息
                        predicates := dataSource.GetPushedDownPredicates()
                        limitInfo := dataSource.GetPushedDownLimit()
                        
                        newDataSource := NewLogicalDataSource(dataSource.TableName, dataSource.TableInfo)
                        newDataSource.Columns = newColumns
                        newDataSource.PushDownPredicates(predicates)
                        if limitInfo != nil </span><span class="cov2" title="3">{
                                newDataSource.PushDownLimit(limitInfo.Limit, limitInfo.Offset)
                        }</span>
                        <span class="cov5" title="29">projection.children[0] = newDataSource
                        fmt.Printf("  [DEBUG] ColumnPruningRule.Apply: 列裁剪完成\n")</span>
                }
        }

        <span class="cov6" title="54">return plan, nil</span>
}

// collectRequiredColumns 收集表达式需要的列
func collectRequiredColumns(expr *parser.Expression, cols map[string]bool) <span class="cov8" title="201">{
        if expr == nil </span><span class="cov8" title="134">{
                return
        }</span>

        <span class="cov7" title="67">if expr.Type == parser.ExprTypeColumn &amp;&amp; expr.Column != "" </span><span class="cov7" title="67">{
                cols[expr.Column] = true
        }</span>

        // 递归处理子表达式
        <span class="cov7" title="67">collectRequiredColumns(expr.Left, cols)
        collectRequiredColumns(expr.Right, cols)</span>
}

// ProjectionEliminationRule 投影消除规则
// 移除不必要的投影节点
type ProjectionEliminationRule struct{}

// Name 返回规则名称
func (r *ProjectionEliminationRule) Name() string <span class="cov7" title="116">{
        return "ProjectionElimination"
}</span>

// Match 检查规则是否匹配
func (r *ProjectionEliminationRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        _, ok := plan.(*LogicalProjection)
        return ok
}</span>

// Apply 应用规则
func (r *ProjectionEliminationRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov6" title="54">{
        projection, ok := plan.(*LogicalProjection)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov6" title="54">if len(projection.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov6" title="54">child := projection.children[0]

        // 如果投影只是简单地传递所有列，可以消除
        childSchema := child.Schema()
        if len(projection.Exprs) == len(childSchema) </span><span class="cov2" title="3">{
                allPassThrough := true
                for i, expr := range projection.Exprs </span><span class="cov3" title="6">{
                        if expr.Type != parser.ExprTypeColumn || expr.Column != childSchema[i].Name </span><span class="cov0" title="0">{
                                allPassThrough = false
                                break</span>
                        }
                }
                <span class="cov2" title="3">if allPassThrough </span><span class="cov2" title="3">{
                        return child, nil
                }</span>
        }

        <span class="cov6" title="51">return plan, nil</span>
}

// LimitPushDownRule Limit 下推规则
// 将 Limit 尽可能下推
type LimitPushDownRule struct{}

// Name 返回规则名称
func (r *LimitPushDownRule) Name() string <span class="cov7" title="70">{
        return "LimitPushDown"
}</span>

// Match 检查规则是否匹配
func (r *LimitPushDownRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        _, ok := plan.(*LogicalLimit)
        return ok
}</span>

// Apply 应用规则
func (r *LimitPushDownRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov3" title="6">{
        limit, ok := plan.(*LogicalLimit)
        if !ok </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov3" title="6">if len(limit.children) == 0 </span><span class="cov0" title="0">{
                return plan, nil
        }</span>

        <span class="cov3" title="6">child := limit.children[0]

        // 如果子节点是 DataSource，下推到DataSource
        if dataSource, ok := child.(*LogicalDataSource); ok </span><span class="cov2" title="3">{
                // 标记Limit到DataSource
                dataSource.PushDownLimit(limit.GetLimit(), limit.GetOffset())
                // 返回child，消除Limit节点（已下推）
                return child, nil
        }</span>

        // 如果子节点是 Selection，可以下推到Selection的子节点
        <span class="cov2" title="3">if selection, ok := child.(*LogicalSelection); ok </span><span class="cov2" title="2">{
                // 创建新的 Selection，其子节点是新的 Limit
                newLimit := NewLogicalLimit(limit.GetLimit(), limit.GetOffset(), selection.Children()[0])
                return NewLogicalSelection(selection.Conditions(), newLimit), nil
        }</span>

        <span class="cov1" title="1">return plan, nil</span>
}

// ConstantFoldingRule 常量折叠规则
// 计算常量表达式
type ConstantFoldingRule struct{}

// Name 返回规则名称
func (r *ConstantFoldingRule) Name() string <span class="cov8" title="209">{
        return "ConstantFolding"
}</span>

// Match 检查规则是否匹配
func (r *ConstantFoldingRule) Match(plan LogicalPlan) bool <span class="cov8" title="151">{
        // 简化实现：总是匹配
        return true
}</span>

// Apply 应用规则
func (r *ConstantFoldingRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov8" title="150">{
        evaluator := NewExpressionEvaluatorWithoutAPI()
        return r.foldConstants(plan, evaluator)
}</span>

// foldConstants 递归折叠常量表达式
func (r *ConstantFoldingRule) foldConstants(plan LogicalPlan, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov9" title="251">{
        // 先处理子节点
        children := plan.Children()
        for i, child := range children </span><span class="cov7" title="101">{
                newChild, err := r.foldConstants(child, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="101">if newChild != child </span><span class="cov0" title="0">{
                        plan.SetChildren(children...)
                        children[i] = newChild
                }</span>
        }

        // 根据不同的算子类型进行常量折叠
        <span class="cov9" title="251">switch p := plan.(type) </span>{
        case *LogicalSelection:<span class="cov5" title="25">
                return r.foldSelectionConstants(p, evaluator)</span>
        case *LogicalProjection:<span class="cov6" title="51">
                return r.foldProjectionConstants(p, evaluator)</span>
        case *LogicalJoin:<span class="cov0" title="0">
                return r.foldJoinConstants(p, evaluator)</span>
        }

        <span class="cov8" title="175">return plan, nil</span>
}

// foldSelectionConstants 折叠 Selection 中的常量
func (r *ConstantFoldingRule) foldSelectionConstants(selection *LogicalSelection, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov5" title="25">{
        newConditions := []*parser.Expression{}
        changed := false

        for _, cond := range selection.Conditions() </span><span class="cov5" title="25">{
                folded, isConst, err := r.tryFoldExpression(cond, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov5" title="25">if isConst </span><span class="cov0" title="0">{
                        // 常量表达式
                        if folded == nil </span><span class="cov0" title="0">{
                                // 条件永远为假，可以丢弃整个 Selection
                                return selection, nil
                        }</span>
                        // 检查是否为 false 布尔值
                        <span class="cov0" title="0">if folded.Value != nil </span><span class="cov0" title="0">{
                                if boolVal, ok := folded.Value.(bool); ok &amp;&amp; !boolVal </span><span class="cov0" title="0">{
                                        // 条件永远为假，可以丢弃整个 Selection
                                        return selection, nil
                                }</span>
                        }
                        // 条件永远为真，可以移除这个条件
                        <span class="cov0" title="0">changed = true</span>
                } else<span class="cov5" title="25"> {
                        newConditions = append(newConditions, folded)
                }</span>
        }

        <span class="cov5" title="25">if changed </span><span class="cov0" title="0">{
                if len(newConditions) == 0 </span><span class="cov0" title="0">{
                        // 所有条件都被移除，返回子节点
                        if len(selection.children) &gt; 0 </span><span class="cov0" title="0">{
                                return selection.children[0], nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0]), nil
                }</span>
        }

        <span class="cov5" title="25">return selection, nil</span>
}

// foldProjectionConstants 折叠 Projection 中的常量
func (r *ConstantFoldingRule) foldProjectionConstants(projection *LogicalProjection, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov6" title="51">{
        newExprs := []*parser.Expression{}
        changed := false

        for _, expr := range projection.Exprs </span><span class="cov7" title="61">{
                folded, isConst, err := r.tryFoldExpression(expr, evaluator)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="61">if isConst </span><span class="cov0" title="0">{
                        newExprs = append(newExprs, folded)
                        changed = true
                }</span> else<span class="cov7" title="61"> {
                        newExprs = append(newExprs, expr)
                }</span>
        }

        <span class="cov6" title="51">if changed </span><span class="cov0" title="0">{
                projection.Exprs = newExprs
        }</span>

        <span class="cov6" title="51">return projection, nil</span>
}

// foldJoinConstants 折叠 Join 中的常量
func (r *ConstantFoldingRule) foldJoinConstants(join *LogicalJoin, evaluator *ExpressionEvaluator) (LogicalPlan, error) <span class="cov0" title="0">{
        // 简化：不处理
        return join, nil
}</span>

// tryFoldExpression 尝试折叠表达式
// 返回: (新表达式, 是否是常量, 错误)
func (r *ConstantFoldingRule) tryFoldExpression(expr *parser.Expression, evaluator *ExpressionEvaluator) (*parser.Expression, bool, error) <span class="cov8" title="208">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>

        // 如果是字面量，已经是常量
        <span class="cov8" title="208">if expr.Type == parser.ExprTypeValue </span><span class="cov6" title="43">{
                return expr, true, nil
        }</span>

        // 如果是列引用，不能折叠
        <span class="cov8" title="165">if expr.Type == parser.ExprTypeColumn </span><span class="cov7" title="104">{
                return expr, false, nil
        }</span>

        // 如果是运算符，尝试计算
        <span class="cov7" title="61">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator != "" </span><span class="cov7" title="61">{
                // 一元运算符
                if expr.Right == nil &amp;&amp; expr.Left != nil </span><span class="cov0" title="0">{
                        leftFolded, leftIsConst, err := r.tryFoldExpression(expr.Left, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                        <span class="cov0" title="0">if leftIsConst </span><span class="cov0" title="0">{
                                // 尝试计算
                                result, err := evaluator.Evaluate(&amp;parser.Expression{
                                        Type:     parser.ExprTypeOperator,
                                        Operator: expr.Operator,
                                        Left:     &amp;parser.Expression{Type: parser.ExprTypeValue, Value: leftFolded},
                                }, parser.Row{})
                                if err == nil </span><span class="cov0" title="0">{
                                        return &amp;parser.Expression{
                                                Type:  parser.ExprTypeValue,
                                                Value: result,
                                        }, true, nil
                                }</span>
                        }
                        <span class="cov0" title="0">expr.Left = leftFolded
                        return expr, false, nil</span>
                }

                // 二元运算符
                <span class="cov7" title="61">if expr.Left != nil &amp;&amp; expr.Right != nil </span><span class="cov7" title="61">{
                        leftFolded, leftIsConst, err := r.tryFoldExpression(expr.Left, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                        <span class="cov7" title="61">rightFolded, rightIsConst, err := r.tryFoldExpression(expr.Right, evaluator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>

                        <span class="cov7" title="61">if leftIsConst &amp;&amp; rightIsConst </span><span class="cov0" title="0">{
                                // 两个操作数都是常量，可以计算
                                result, err := evaluator.Evaluate(&amp;parser.Expression{
                                        Type:     parser.ExprTypeOperator,
                                        Operator: expr.Operator,
                                        Left:     &amp;parser.Expression{Type: parser.ExprTypeValue, Value: leftFolded},
                                        Right:    &amp;parser.Expression{Type: parser.ExprTypeValue, Value: rightFolded},
                                }, parser.Row{})
                                if err == nil </span><span class="cov0" title="0">{
                                        return &amp;parser.Expression{
                                                Type:  parser.ExprTypeValue,
                                                Value: result,
                                        }, true, nil
                                }</span>
                        }

                        <span class="cov7" title="61">expr.Left = leftFolded
                        expr.Right = rightFolded
                        if leftFolded != expr.Left || rightFolded != expr.Right </span><span class="cov0" title="0">{
                                return expr, false, nil
                        }</span>
                }
        }

        <span class="cov7" title="61">return expr, false, nil</span>
}

// DefaultRuleSet 返回默认规则集
func DefaultRuleSet() RuleSet <span class="cov6" title="58">{
        rules := RuleSet{
                &amp;PredicatePushDownRule{},
                &amp;ColumnPruningRule{},
                &amp;ProjectionEliminationRule{},
                &amp;LimitPushDownRule{},
                &amp;ConstantFoldingRule{},
                &amp;JoinReorderRule{},
                &amp;JoinEliminationRule{},
                &amp;SemiJoinRewriteRule{},
        }
        fmt.Println("  [DEBUG] DefaultRuleSet: 创建规则集, 数量:", len(rules))
        for i, r := range rules </span><span class="cov10" title="464">{
                fmt.Printf("  [DEBUG]   规则%d: %s\n", i, r.Name())
        }</span>
        <span class="cov6" title="58">return rules</span>
}

// EnhancedRuleSet 返回增强规则集（包含新规则）
func EnhancedRuleSet(estimator CardinalityEstimator) RuleSet <span class="cov0" title="0">{
        rules := RuleSet{
                &amp;PredicatePushDownRule{}, // 基础谓词下推
                // 增强的谓词下推规则（需要放在基础规则之后）
                NewEnhancedPredicatePushdownRule(estimator),
                &amp;ColumnPruningRule{},
                &amp;ProjectionEliminationRule{},
                &amp;LimitPushDownRule{},
                &amp;ConstantFoldingRule{},
                &amp;JoinReorderRule{},
                &amp;JoinEliminationRule{},
                &amp;SemiJoinRewriteRule{},
                NewORToUnionRule(), // OR转UNION规则
        }
        fmt.Println("  [DEBUG] EnhancedRuleSet: 创建增强规则集, 数量:", len(rules))
        for i, r := range rules </span><span class="cov0" title="0">{
                fmt.Printf("  [DEBUG]   规则%d: %s\n", i, r.Name())
        }</span>
        <span class="cov0" title="0">return rules</span>
}

// RuleExecutor 规则执行器
type RuleExecutor struct {
        rules RuleSet
}

// NewRuleExecutor 创建规则执行器
func NewRuleExecutor(rules RuleSet) *RuleExecutor <span class="cov0" title="0">{
        return &amp;RuleExecutor{
                rules: rules,
        }
}</span>

// Execute 执行所有规则
func (re *RuleExecutor) Execute(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        fmt.Println("  [DEBUG] RuleExecutor: 开始执行规则, 规则数量:", len(re.rules))
        current := plan
        maxIterations := 10 // 防止无限循环
        iterations := 0

        for iterations &lt; maxIterations </span><span class="cov0" title="0">{
                fmt.Println("  [DEBUG] RuleExecutor: 迭代", iterations+1)
                changed := false

                for _, rule := range re.rules </span><span class="cov0" title="0">{
                        if rule.Match(current) </span><span class="cov0" title="0">{
                                fmt.Println("  [DEBUG] RuleExecutor: 规则", rule.Name(), "匹配")
                                newPlan, err := rule.Apply(ctx, current, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("rule %s failed: %w", rule.Name(), err)
                                }</span>
                                <span class="cov0" title="0">if newPlan != current </span><span class="cov0" title="0">{
                                        current = newPlan
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleExecutor: 规则", rule.Name(), "已应用")
                                }</span>
                        }

                        // 递归应用到子节点
                        <span class="cov0" title="0">children := current.Children()
                        fmt.Println("  [DEBUG] RuleExecutor: 处理子节点, 子节点数:", len(children))
                        for i, child := range children </span><span class="cov0" title="0">{
                                fmt.Println("  [DEBUG] RuleExecutor: 递归处理子节点", i, "类型:", child.Explain())
                                newChild, err := re.Execute(ctx, child, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if newChild != child </span><span class="cov0" title="0">{
                                        children = current.Children()
                                        children[i] = newChild
                                        current.SetChildren(children...)
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleExecutor: 子节点", i, "已更新")
                                }</span>
                        }
                }

                <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                        fmt.Println("  [DEBUG] RuleExecutor: 没有变化，退出")
                        break</span>
                }

                <span class="cov0" title="0">iterations++</span>
        }

        <span class="cov0" title="0">fmt.Println("  [DEBUG] RuleExecutor: 执行完成, 总迭代次数:", iterations)
        return current, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package optimizer

import (
        "context"

        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// SemiJoinRewriteRule 半连接重写规则
// 将EXISTS和IN子查询重写为更高效的连接形式
type SemiJoinRewriteRule struct {
        cardinalityEstimator CardinalityEstimator
}

// Name 返回规则名称
func (r *SemiJoinRewriteRule) Name() string <span class="cov6" title="59">{
        return "SemiJoinRewrite"
}</span>

// Match 检查规则是否匹配
func (r *SemiJoinRewriteRule) Match(plan LogicalPlan) bool <span class="cov7" title="151">{
        // 检查是否包含EXISTS或IN子查询
        return containsSubquery(plan, "EXISTS") || containsSubquery(plan, "IN")
}</span>

// containsSubquery 检查是否包含指定类型的子查询
func containsSubquery(plan LogicalPlan, queryType string) bool <span class="cov9" title="504">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov6" title="50">{
                for _, cond := range selection.Conditions() </span><span class="cov6" title="50">{
                        if isSubquery(cond, queryType) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov9" title="504">for _, child := range plan.Children() </span><span class="cov8" title="202">{
                if containsSubquery(child, queryType) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov9" title="504">return false</span>
}

// isSubquery 检查表达式是否为子查询
func isSubquery(expr *parser.Expression, queryType string) bool <span class="cov10" title="638">{
        if expr == nil </span><span class="cov9" title="344">{
                return false
        }</span>

        // 检查是否为子查询节点
        // 简化实现：检查函数名
        <span class="cov8" title="294">if expr.Type == parser.ExprTypeFunction </span><span class="cov0" title="0">{
                if expr.Function == queryType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // 递归检查子表达式
        <span class="cov8" title="294">if isSubquery(expr.Left, queryType) || isSubquery(expr.Right, queryType) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="294">return false</span>
}

// Apply 应用规则：重写半连接
func (r *SemiJoinRewriteRule) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov0" title="0">{
        // 1. 查找EXISTS子查询并重写为JOIN
        plan = r.rewriteExistsToJoin(plan)

        // 2. 查找IN子查询并重写为JOIN
        plan = r.rewriteInToJoin(plan)

        return plan, nil
}</span>

// rewriteExistsToJoin 将EXISTS子查询重写为JOIN + DISTINCT
func (r *SemiJoinRewriteRule) rewriteExistsToJoin(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                rewritten := false

                // 遍历条件，查找EXISTS子查询
                newConditions := make([]*parser.Expression, 0, len(selection.Conditions()))

                for _, cond := range selection.Conditions() </span><span class="cov0" title="0">{
                        if r.isExistsSubquery(cond) </span><span class="cov0" title="0">{
                                // EXISTS (SELECT ...) -&gt; INNER JOIN
                                // 重写为: EXISTS (SELECT ...) = TRUE
                                // 注意：实际应该提取子查询表名，创建JOIN
                                // 这里简化为保留条件，标记为已重写
                                newConditions = append(newConditions, cond)
                                rewritten = true
                        }</span> else<span class="cov0" title="0"> {
                                newConditions = append(newConditions, cond)
                        }</span>
                }

                <span class="cov0" title="0">if rewritten </span><span class="cov0" title="0">{
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0])
                }</span>

                <span class="cov0" title="0">return selection</span>
        }

        // 递归处理子节点
        <span class="cov0" title="0">children := plan.Children()
        for i, child := range children </span><span class="cov0" title="0">{
                newChild := r.rewriteExistsToJoin(child)
                if newChild != child </span><span class="cov0" title="0">{
                        newChildren := make([]LogicalPlan, len(children))
                        copy(newChildren, children)
                        newChildren[i] = newChild
                        plan.SetChildren(newChildren...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return plan</span>
}

// rewriteInToJoin 将IN子查询重写为JOIN
func (r *SemiJoinRewriteRule) rewriteInToJoin(plan LogicalPlan) LogicalPlan <span class="cov0" title="0">{
        if selection, ok := plan.(*LogicalSelection); ok </span><span class="cov0" title="0">{
                rewritten := false

                // 遍历条件，查找IN子查询
                newConditions := make([]*parser.Expression, 0, len(selection.Conditions()))

                for _, cond := range selection.Conditions() </span><span class="cov0" title="0">{
                        if r.isInSubquery(cond) </span><span class="cov0" title="0">{
                                // column IN (SELECT ...) -&gt; JOIN
                                // 重写为: column IN (SELECT ...) = TRUE
                                // 注意：实际应该提取子查询表名，创建JOIN
                                // 这里简化为保留条件，标记为已重写
                                newConditions = append(newConditions, cond)
                                rewritten = true
                        }</span> else<span class="cov0" title="0"> {
                                newConditions = append(newConditions, cond)
                        }</span>
                }

                <span class="cov0" title="0">if rewritten </span><span class="cov0" title="0">{
                        // 创建新的 Selection 更新条件
                        return NewLogicalSelection(newConditions, selection.children[0])
                }</span>

                <span class="cov0" title="0">return selection</span>
        }

        // 递归处理子节点
        <span class="cov0" title="0">children := plan.Children()
        for i, child := range children </span><span class="cov0" title="0">{
                newChild := r.rewriteInToJoin(child)
                if newChild != child </span><span class="cov0" title="0">{
                        newChildren := make([]LogicalPlan, len(children))
                        copy(newChildren, children)
                        newChildren[i] = newChild
                        plan.SetChildren(newChildren...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return plan</span>
}

// isExistsSubquery 检查是否为EXISTS子查询
func (r *SemiJoinRewriteRule) isExistsSubquery(expr *parser.Expression) bool <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if expr.Type == parser.ExprTypeFunction &amp;&amp; expr.Function == "EXISTS" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if r.isExistsSubquery(expr.Left) || r.isExistsSubquery(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isInSubquery 检查是否为IN子查询
func (r *SemiJoinRewriteRule) isInSubquery(expr *parser.Expression) bool <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // IN操作符
        <span class="cov0" title="0">if expr.Type == parser.ExprTypeOperator &amp;&amp; expr.Operator == "IN" </span><span class="cov0" title="0">{
                // 检查右侧是否为子查询
                if expr.Right != nil &amp;&amp; expr.Right.Type == parser.ExprTypeFunction </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if r.isInSubquery(expr.Left) || r.isInSubquery(expr.Right) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// NewSemiJoinRewriteRule 创建半连接重写规则
func NewSemiJoinRewriteRule(estimator CardinalityEstimator) *SemiJoinRewriteRule <span class="cov0" title="0">{
        return &amp;SemiJoinRewriteRule{
                cardinalityEstimator: estimator,
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package statistics

import (
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// StatisticsCache 统计信息缓存
// 避免频繁收集统计信息，提升性能
type StatisticsCache struct {
        mu       sync.RWMutex
        cache     map[string]*CachedStatistics
        ttl       time.Duration // 缓存过期时间
        hits      int64       // 缓存命中次数
        misses    int64       // 缓存未命中次数
}

// CachedStatistics 缓存的统计信息
type CachedStatistics struct {
        Statistics    *TableStatistics
        CollectTime  time.Time
        LastAccessed time.Time
        HitCount     int64
}

// NewStatisticsCache 创建统计信息缓存
func NewStatisticsCache(ttl time.Duration) *StatisticsCache <span class="cov7" title="47">{
        return &amp;StatisticsCache{
                cache: make(map[string]*CachedStatistics),
                ttl:   ttl,
        }
}</span>

// Get 获取缓存的统计信息
func (sc *StatisticsCache) Get(tableName string) (*TableStatistics, bool) <span class="cov10" title="157">{
        sc.mu.RLock()

        cached, exists := sc.cache[tableName]
        if !exists </span><span class="cov6" title="27">{
                sc.mu.RUnlock()
                sc.misses++
                return nil, false
        }</span>

        // 检查是否过期
        <span class="cov9" title="130">if time.Since(cached.CollectTime) &gt; sc.ttl </span><span class="cov1" title="1">{
                sc.mu.RUnlock()
                sc.mu.Lock()
                delete(sc.cache, tableName)
                sc.mu.Unlock()
                sc.misses++
                return nil, false
        }</span>

        <span class="cov9" title="129">cached.LastAccessed = time.Now()
        cached.HitCount++
        sc.hits++

        sc.mu.RUnlock()
        return cached.Statistics, true</span>
}

// Set 设置缓存的统计信息
func (sc *StatisticsCache) Set(tableName string, stats *TableStatistics) <span class="cov7" title="40">{
        sc.mu.Lock()
        defer sc.mu.Unlock()

        sc.cache[tableName] = &amp;CachedStatistics{
                Statistics:    stats,
                CollectTime:  time.Now(),
                LastAccessed: time.Now(),
                HitCount:     0,
        }
}</span>

// Invalidate 使指定表的缓存失效
func (sc *StatisticsCache) Invalidate(tableName string) <span class="cov2" title="3">{
        sc.mu.Lock()
        defer sc.mu.Unlock()

        delete(sc.cache, tableName)
}</span>

// InvalidateAll 使所有缓存失效
func (sc *StatisticsCache) InvalidateAll() <span class="cov2" title="2">{
        sc.mu.Lock()
        defer sc.mu.Unlock()

        sc.cache = make(map[string]*CachedStatistics)
        sc.hits = 0
        sc.misses = 0
}</span>

// Stats 返回缓存统计信息
func (sc *StatisticsCache) Stats() CacheStats <span class="cov4" title="7">{
        sc.mu.RLock()
        defer sc.mu.RUnlock()

        totalRequests := sc.hits + sc.misses
        hitRate := 0.0
        if totalRequests &gt; 0 </span><span class="cov3" title="4">{
                hitRate = float64(sc.hits) / float64(totalRequests)
        }</span>

        <span class="cov4" title="7">return CacheStats{
                Size:      len(sc.cache),
                Hits:      sc.hits,
                Misses:    sc.misses,
                HitRate:   hitRate,
                TTL:        sc.ttl,
        }</span>
}

// CacheStats 缓存统计信息
type CacheStats struct {
        Size     int         // 缓存中的表数量
        Hits     int64       // 命中次数
        Misses   int64       // 未命中次数
        HitRate  float64     // 命中率
        TTL      time.Duration // 过期时间
}

// TableStatistics 增强的表统计信息
type TableStatistics struct {
        Name             string
        RowCount         int64
        SampleCount      int64      // 采样行数
        SampleRatio      float64    // 采样比例
        ColumnStats      map[string]*ColumnStatistics
        Histograms       map[string]*Histogram // 列直方图
        CollectTimestamp  time.Time  // 收集时间
        EstimatedRowCount int64      // 估计的行数（可能不同于实际RowCount）
}

// ColumnStatistics 增强的列统计信息
type ColumnStatistics struct {
        Name          string
        DataType      string
        DistinctCount int64  // NDV (Number of Distinct Values)
        NullCount     int64
        MinValue      interface{}
        MaxValue      interface{}
        NullFraction  float64
        AvgWidth     float64 // 平均字符串长度
        MedianValue   interface{} // 中位数（可选）
        StdDev       float64    // 标准差（可选）
}

// AutoRefreshStatisticsCache 自动刷新的统计信息缓存
type AutoRefreshStatisticsCache struct {
        cache       *StatisticsCache
        collector  *SamplingCollector
        dataSource domain.DataSource
        refreshOn  map[string]time.Time // 下次刷新时间
        mu         sync.RWMutex
}

// NewAutoRefreshStatisticsCache 创建自动刷新缓存
func NewAutoRefreshStatisticsCache(
        collector *SamplingCollector,
        dataSource domain.DataSource,
        ttl time.Duration,
) *AutoRefreshStatisticsCache <span class="cov3" title="5">{
        return &amp;AutoRefreshStatisticsCache{
                cache:      NewStatisticsCache(ttl),
                collector:   collector,
                dataSource:  dataSource,
                refreshOn:  make(map[string]time.Time),
        }
}</span>

// Get 获取统计信息（自动刷新过期数据）
func (arc *AutoRefreshStatisticsCache) Get(tableName string) (*TableStatistics, error) <span class="cov0" title="0">{
        arc.mu.RLock()
        nextRefresh, exists := arc.refreshOn[tableName]
        arc.mu.RUnlock()

        // 检查是否需要刷新
        needRefresh := !exists || time.Now().After(nextRefresh)
        
        if needRefresh </span><span class="cov0" title="0">{
                return arc.refresh(tableName)
        }</span>

        // 从缓存获取
        <span class="cov0" title="0">stats, ok := arc.cache.Get(tableName)
        if !ok </span><span class="cov0" title="0">{
                return arc.refresh(tableName)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// refresh 刷新表的统计信息
func (arc *AutoRefreshStatisticsCache) refresh(tableName string) (*TableStatistics, error) <span class="cov2" title="2">{
        // 收集新的统计信息
        stats, err := arc.collector.CollectStatistics(nil, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新缓存
        <span class="cov2" title="2">arc.cache.Set(tableName, stats)

        // 更新下次刷新时间
        arc.mu.Lock()
        arc.refreshOn[tableName] = time.Now().Add(arc.cache.ttl)
        arc.mu.Unlock()

        return stats, nil</span>
}

// Invalidate 使缓存失效并清除刷新计划
func (arc *AutoRefreshStatisticsCache) Invalidate(tableName string) <span class="cov1" title="1">{
        arc.cache.Invalidate(tableName)

        arc.mu.Lock()
        delete(arc.refreshOn, tableName)
        arc.mu.Unlock()
}</span>

// InvalidateAll 使所有缓存失效
func (arc *AutoRefreshStatisticsCache) InvalidateAll() <span class="cov1" title="1">{
        arc.cache.InvalidateAll()

        arc.mu.Lock()
        arc.refreshOn = make(map[string]time.Time)
        arc.mu.Unlock()
}</span>

// Stats 返回缓存统计信息
func (arc *AutoRefreshStatisticsCache) Stats() CacheStats <span class="cov1" title="1">{
        return arc.cache.Stats()
}</span>

// Preload 预加载多个表的统计信息
func (arc *AutoRefreshStatisticsCache) Preload(tableNames []string) error <span class="cov1" title="1">{
        var wg sync.WaitGroup
        errChan := make(chan error, len(tableNames))

        for _, tableName := range tableNames </span><span class="cov2" title="2">{
                wg.Add(1)
                go func(name string) </span><span class="cov2" title="2">{
                        defer wg.Done()
                        _, err := arc.refresh(name)
                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                        }</span>
                }(tableName)
        }

        <span class="cov1" title="1">wg.Wait()
        close(errChan)

        // 检查是否有错误
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package statistics

import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "time"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// SamplingCollector 采样统计收集器
// 使用Reservoir Sampling算法进行高效采样，避免全表扫描
type SamplingCollector struct {
        dataSource domain.DataSource
        sampleRate float64 // 采样率 (0.01-0.05 = 1%-5%)
        maxRows    int64   // 最大采样行数
        rand        *rand.Rand
}

// NewSamplingCollector 创建采样收集器
func NewSamplingCollector(dataSource domain.DataSource, sampleRate float64) *SamplingCollector <span class="cov4" title="13">{
        return &amp;SamplingCollector{
                dataSource: dataSource,
                sampleRate: sampleRate,
                maxRows:    10000, // 默认最多采样10000行
                rand:        rand.New(rand.NewSource(time.Now().UnixNano())),
        }
}</span>

// SetMaxRows 设置最大采样行数
func (sc *SamplingCollector) SetMaxRows(maxRows int64) <span class="cov2" title="4">{
        sc.maxRows = maxRows
}</span>

// CollectStatistics 采样收集统计信息
func (sc *SamplingCollector) CollectStatistics(ctx context.Context, tableName string) (*TableStatistics, error) <span class="cov3" title="5">{
        // 第一步：获取表信息和总行数（用于计算采样大小）
        _, err := sc.dataSource.GetTableInfo(ctx, tableName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get table info failed: %w", err)
        }</span>

        // 第二步：计算采样参数
        // TableInfo 没有 RowCount 字段，使用默认值
        <span class="cov2" title="4">totalRows := int64(100000) // 默认假设10万行
        sampleSize := sc.calculateSampleSize(totalRows)
        if sampleSize &lt;= 0 </span><span class="cov0" title="0">{
                sampleSize = 100 // 最小采样100行
        }</span>

        <span class="cov2" title="4">fmt.Printf("  [STATISTICS] Sampling table %s: total=%d, sampleRate=%.2f%%, sampleSize=%d\n",
                tableName, totalRows, sc.sampleRate*100, sampleSize)

        // 第三步：执行采样查询
        sampleRows, err := sc.sampleRows(ctx, tableName, int(sampleSize))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sample rows failed: %w", err)
        }</span>

        // 第四步：从样本计算统计信息
        <span class="cov2" title="4">stats := sc.calculateStatisticsFromSample(tableName, sampleRows, totalRows)

        // 估算总行数（基于采样比例）
        stats.EstimatedRowCount = totalRows

        fmt.Printf("  [STATISTICS] Collected statistics for %s: rows=%d, columns=%d\n",
                tableName, stats.RowCount, len(stats.ColumnStats))

        return stats, nil</span>
}

// calculateSampleSize 计算采样大小
func (sc *SamplingCollector) calculateSampleSize(totalRows int64) int64 <span class="cov3" title="8">{
        // 如果行数很少，返回所有数据
        if totalRows &lt;= 100 </span><span class="cov1" title="1">{
                return totalRows
        }</span>

        <span class="cov3" title="7">sampleSize := int64(float64(totalRows) * sc.sampleRate)

        // 限制最大采样行数
        if sampleSize &gt; sc.maxRows </span><span class="cov2" title="3">{
                sampleSize = sc.maxRows
        }</span>

        // 确保至少采样一定比例
        <span class="cov3" title="7">if sampleSize &lt; 100 </span><span class="cov1" title="1">{
                sampleSize = 100
        }</span>

        <span class="cov3" title="7">return sampleSize</span>
}

// sampleRows 采样行数据（使用系统采样 Systematic Sampling）
func (sc *SamplingCollector) sampleRows(ctx context.Context, tableName string, sampleSize int) ([]domain.Row, error) <span class="cov3" title="7">{
        // 获取所有数据（简化实现，实际应该使用游标跳过采样）
        result, err := sc.dataSource.Query(ctx, tableName, &amp;domain.QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="7">totalRows := len(result.Rows)
        if totalRows == 0 </span><span class="cov1" title="2">{
                return result.Rows, nil
        }</span>

        // 系统采样：计算步长
        <span class="cov3" title="5">step := float64(totalRows) / float64(sampleSize)
        if step &lt; 1 </span><span class="cov1" title="2">{
                step = 1
        }</span>

        // 按步长采样
        <span class="cov3" title="5">sampleRows := make([]domain.Row, 0, sampleSize)
        for i := 0; i &lt; totalRows; i += int(step) </span><span class="cov8" title="246">{
                if len(sampleRows) &gt;= sampleSize </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov8" title="245">sampleRows = append(sampleRows, result.Rows[i])</span>
        }

        <span class="cov3" title="5">return sampleRows, nil</span>
}

// calculateStatisticsFromSample 从样本计算统计信息
func (sc *SamplingCollector) calculateStatisticsFromSample(tableName string, sampleRows []domain.Row, totalRowCount int64) *TableStatistics <span class="cov2" title="4">{
        sampleCount := int64(len(sampleRows))
        
        // 计算采样比例
        sampleRatio := 1.0
        if totalRowCount &gt; 0 </span><span class="cov2" title="4">{
                sampleRatio = float64(sampleCount) / float64(totalRowCount)
        }</span>

        <span class="cov2" title="4">stats := &amp;TableStatistics{
                Name:              tableName,
                RowCount:          totalRowCount,
                SampleCount:       sampleCount,
                SampleRatio:       sampleRatio,
                ColumnStats:       make(map[string]*ColumnStatistics),
                Histograms:        make(map[string]*Histogram),
                CollectTimestamp:  time.Now(),
                EstimatedRowCount: totalRowCount,
        }

        // 收集列统计信息
        if len(sampleRows) &gt; 0 </span><span class="cov1" title="2">{
                // 获取列名
                colNames := make([]string, 0, len(sampleRows[0]))
                for colName := range sampleRows[0] </span><span class="cov3" title="6">{
                        colNames = append(colNames, colName)
                }</span>

                // 为每列构建统计信息和直方图
                <span class="cov1" title="2">var wg sync.WaitGroup
                var mu sync.Mutex
                
                for _, colName := range colNames </span><span class="cov3" title="6">{
                        wg.Add(1)
                        go func(name string) </span><span class="cov3" title="6">{
                                defer wg.Done()
                                
                                colStats, histogram := sc.collectColumnStats(sampleRows, name)
                                
                                mu.Lock()
                                stats.ColumnStats[name] = colStats
                                stats.Histograms[name] = histogram
                                mu.Unlock()
                        }</span>(colName)
                }
                
                <span class="cov1" title="2">wg.Wait()</span>
        }

        <span class="cov2" title="4">return stats</span>
}

// collectColumnStats 收集单个列的统计信息
func (sc *SamplingCollector) collectColumnStats(rows []domain.Row, colName string) (*ColumnStatistics, *Histogram) <span class="cov3" title="6">{
        colStats := &amp;ColumnStatistics{
                Name:    colName,
                DataType: inferDataType(rows, colName),
        }

        values := make([]interface{}, 0, len(rows))
        distinctValues := make(map[interface{}]bool)
        nullCount := int64(0)
        totalWidth := 0.0

        // 收集值
        for _, row := range rows </span><span class="cov9" title="315">{
                val := row[colName]
                if val == nil </span><span class="cov1" title="1">{
                        nullCount++
                        continue</span>
                }

                <span class="cov9" title="314">values = append(values, val)
                distinctValues[val] = true

                // 字符串宽度
                if s, ok := val.(string); ok </span><span class="cov7" title="105">{
                        totalWidth += float64(len(s))
                }</span>
        }

        // 计算基本统计
        <span class="cov3" title="6">colStats.NullCount = nullCount
        colStats.NullFraction = float64(nullCount) / float64(len(rows))
        colStats.DistinctCount = int64(len(distinctValues))

        if len(values) &gt; 0 </span><span class="cov3" title="6">{
                // 计算Min/Max
                colStats.MinValue = values[0]
                colStats.MaxValue = values[0]
                for _, val := range values </span><span class="cov9" title="314">{
                        if compareValues(val, colStats.MinValue) &lt; 0 </span><span class="cov1" title="1">{
                                colStats.MinValue = val
                        }</span>
                        <span class="cov9" title="314">if compareValues(val, colStats.MaxValue) &gt; 0 </span><span class="cov8" title="157">{
                                colStats.MaxValue = val
                        }</span>
                }
                
                // 计算平均宽度
                <span class="cov3" title="6">if len(values)-int(nullCount) &gt; 0 </span><span class="cov3" title="6">{
                        colStats.AvgWidth = totalWidth / float64(len(values)-int(nullCount))
                }</span>

                // 构建直方图（等宽直方图）
                <span class="cov3" title="6">histogram := BuildEquiWidthHistogram(values, 10)
                return colStats, histogram</span>
        }

        <span class="cov0" title="0">return colStats, nil</span>
}

// inferDataType 推断列的数据类型
func inferDataType(rows []domain.Row, colName string) string <span class="cov4" title="14">{
        for _, row := range rows </span><span class="cov4" title="14">{
                val := row[colName]
                if val == nil </span><span class="cov1" title="2">{
                        continue</span>
                }
                
                <span class="cov4" title="12">switch val.(type) </span>{
                case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov3" title="6">
                        return "integer"</span>
                case float32, float64:<span class="cov1" title="1">
                        return "numeric"</span>
                case string:<span class="cov2" title="3">
                        return "varchar"</span>
                case bool:<span class="cov1" title="1">
                        return "boolean"</span>
                case time.Time:<span class="cov1" title="1">
                        return "datetime"</span>
                default:<span class="cov0" title="0">
                        return "unknown"</span>
                }
        }
        <span class="cov1" title="2">return "unknown"</span>
}

// compareValues 比较两个值
func compareValues(a, b interface{}) int <span class="cov10" title="637">{
        if a == nil &amp;&amp; b == nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov9" title="636">if a == nil </span><span class="cov1" title="1">{
                return -1
        }</span>
        <span class="cov9" title="635">if b == nil </span><span class="cov1" title="1">{
                return 1
        }</span>

        // 数值比较
        <span class="cov9" title="634">if aNum, aOk := toFloat64(a); aOk </span><span class="cov9" title="422">{
                if bNum, bOk := toFloat64(b); bOk </span><span class="cov9" title="422">{
                        if aNum &lt; bNum </span><span class="cov6" title="54">{
                                return -1
                        }</span> else<span class="cov9" title="368"> if aNum &gt; bNum </span><span class="cov9" title="356">{
                                return 1
                        }</span>
                        <span class="cov4" title="12">return 0</span>
                }
        }

        // 字符串比较
        <span class="cov8" title="212">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov1" title="1">{
                return -1
        }</span> else<span class="cov8" title="211"> if aStr &gt; bStr </span><span class="cov4" title="9">{
                return 1
        }</span>
        <span class="cov8" title="202">return 0</span>
}

</pre>
		
		<pre class="file" id="file37" style="display: none">package statistics

import (
        "fmt"
        "math"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// CardinalityEstimator 基数估算器接口
type CardinalityEstimator interface {
        EstimateTableScan(tableName string) int64
        EstimateFilter(tableName string, filters []domain.Filter) int64
        GetStatistics(tableName string) (*TableStatistics, error)
}

// EnhancedCardinalityEstimator 增强的基数估算器
// 使用直方图提供更准确的估算
type EnhancedCardinalityEstimator struct {
        statsCache *StatisticsCache
        stats      map[string]*TableStatistics
}

// NewEnhancedCardinalityEstimator 创建增强的基数估算器
func NewEnhancedCardinalityEstimator(cache *StatisticsCache) *EnhancedCardinalityEstimator <span class="cov9" title="26">{
        return &amp;EnhancedCardinalityEstimator{
                statsCache: cache,
                stats:      make(map[string]*TableStatistics),
        }
}</span>

// UpdateStatistics 更新统计信息
func (e *EnhancedCardinalityEstimator) UpdateStatistics(tableName string, stats *TableStatistics) <span class="cov6" title="10">{
        e.stats[tableName] = stats
        e.statsCache.Set(tableName, stats)
}</span>

// GetStatistics 获取统计信息（优先从缓存）
func (e *EnhancedCardinalityEstimator) GetStatistics(tableName string) (*TableStatistics, error) <span class="cov10" title="35">{
        // 先从内存获取
        if stats, exists := e.stats[tableName]; exists </span><span class="cov8" title="19">{
                return stats, nil
        }</span>

        // 从缓存获取
        <span class="cov8" title="16">cachedStats, ok := e.statsCache.Get(tableName)
        if ok </span><span class="cov1" title="1">{
                e.stats[tableName] = cachedStats
                return cachedStats, nil
        }</span>

        <span class="cov7" title="15">return nil, fmt.Errorf("statistics not found for table: %s", tableName)</span>
}

// EstimateTableScan 估算表扫描基数
func (e *EnhancedCardinalityEstimator) EstimateTableScan(tableName string) int64 <span class="cov6" title="10">{
        stats, err := e.GetStatistics(tableName)
        if err != nil </span><span class="cov3" title="3">{
                // 没有统计信息，使用保守估计
                return 10000 // 更大的默认值
        }</span>

        // 使用估计的行数（可能基于采样）
        <span class="cov5" title="7">if stats.EstimatedRowCount &gt; 0 </span><span class="cov2" title="2">{
                return stats.EstimatedRowCount
        }</span>
        <span class="cov5" title="5">return stats.RowCount</span>
}

// EstimateFilter 估算过滤后的基数
func (e *EnhancedCardinalityEstimator) EstimateFilter(table string, filters []domain.Filter) int64 <span class="cov5" title="6">{
        baseRowCount := e.EstimateTableScan(table)
        if len(filters) == 0 </span><span class="cov1" title="1">{
                return baseRowCount
        }</span>

        // 计算每个过滤器的选择率
        <span class="cov5" title="5">totalSelectivity := 1.0
        for _, filter := range filters </span><span class="cov5" title="6">{
                sel := e.estimateFilterSelectivity(table, filter)
                if filter.LogicOp == "AND" </span><span class="cov1" title="1">{
                        // AND: 选择率相乘
                        totalSelectivity *= sel
                }</span> else<span class="cov5" title="5"> if filter.LogicOp == "OR" </span><span class="cov1" title="1">{
                        // OR: 处理OR子过滤器
                        orSelectivity := e.estimateOrSelectivity(table, filter)
                        totalSelectivity *= orSelectivity
                }</span> else<span class="cov4" title="4"> {
                        // 单个条件
                        totalSelectivity *= sel
                }</span>
        }

        <span class="cov5" title="5">result := float64(baseRowCount) * totalSelectivity
        // 确保至少返回1行
        if result &lt; 1 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov5" title="5">return int64(result)</span>
}

// estimateFilterSelectivity 估算单个过滤器的选择率
func (e *EnhancedCardinalityEstimator) estimateFilterSelectivity(table string, filter domain.Filter) float64 <span class="cov8" title="17">{
        // 处理逻辑组合
        if filter.LogicOp == "AND" || filter.LogicOp == "OR" </span><span class="cov2" title="2">{
                return e.estimateLogicSelectivity(table, filter)
        }</span>

        <span class="cov7" title="15">stats, err := e.GetStatistics(table)
        if err != nil </span><span class="cov6" title="9">{
                // 没有统计信息时使用默认选择率
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        <span class="cov5" title="6">colStats, colExists := stats.ColumnStats[filter.Field]
        if !colExists </span><span class="cov3" title="3">{
                return e.getDefaultSelectivity(filter.Operator)
        }</span>

        // 优先使用直方图估算
        <span class="cov3" title="3">if histogram, histExists := stats.Histograms[filter.Field]; histExists </span><span class="cov0" title="0">{
                return histogram.EstimateSelectivity(filter)
        }</span>

        // 回退到基础统计信息
        <span class="cov3" title="3">return e.estimateSelectivityUsingStats(filter, colStats)</span>
}

// estimateOrSelectivity 估算OR条件的选择率
func (e *EnhancedCardinalityEstimator) estimateOrSelectivity(table string, filter domain.Filter) float64 <span class="cov3" title="3">{
        if len(filter.SubFilters) == 0 </span><span class="cov1" title="1">{
                return 1.0
        }</span>

        // OR选择率 = 1 - (1-s1)*(1-s2)*...*(1-sn)
        // 简化：使用包含-排斥原则
        <span class="cov2" title="2">inclusionSum := 0.0
        for _, subFilter := range filter.SubFilters </span><span class="cov3" title="3">{
                sel := e.estimateFilterSelectivity(table, subFilter)
                inclusionSum += sel
        }</span>

        // 避免超过1.0
        <span class="cov2" title="2">if inclusionSum &gt; 0.95 </span><span class="cov0" title="0">{
                return 0.95
        }</span>
        <span class="cov2" title="2">return inclusionSum</span>
}

// estimateLogicSelectivity 估算逻辑组合的选择率
func (e *EnhancedCardinalityEstimator) estimateLogicSelectivity(table string, filter domain.Filter) float64 <span class="cov5" title="7">{
        if len(filter.SubFilters) == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov5" title="7">switch filter.LogicOp </span>{
        case "AND":<span class="cov3" title="3">
                // AND: 选择率相乘
                sel := 1.0
                for _, subFilter := range filter.SubFilters </span><span class="cov3" title="3">{
                        sel *= e.estimateFilterSelectivity(table, subFilter)
                }</span>
                <span class="cov3" title="3">return sel</span>
        case "OR":<span class="cov3" title="3">
                // OR: 选择率 = 1 - (1-s1)*(1-s2)*...*(1-sn)
                // 简化：使用包含关系
                sel := 0.0
                for _, subFilter := range filter.SubFilters </span><span class="cov5" title="5">{
                        subSel := e.estimateFilterSelectivity(table, subFilter)
                        sel += subSel
                }</span>
                // 避免超过1.0
                <span class="cov3" title="3">if sel &gt; 0.95 </span><span class="cov0" title="0">{
                        sel = 0.95
                }</span>
                <span class="cov3" title="3">return sel</span>
        default:<span class="cov1" title="1">
                return 1.0</span>
        }
}

// estimateSelectivityUsingStats 使用基础统计信息估算选择率
func (e *EnhancedCardinalityEstimator) estimateSelectivityUsingStats(filter domain.Filter, colStats *ColumnStatistics) float64 <span class="cov6" title="8">{
        switch filter.Operator </span>{
        case "=", "!=":<span class="cov0" title="0">
                // 等值查询：选择率 = 1/NDV
                if colStats.DistinctCount &gt; 0 </span><span class="cov0" title="0">{
                        return 1.0 / float64(colStats.DistinctCount)
                }</span>
                <span class="cov0" title="0">return 0.1</span>

        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov3" title="3">
                // 范围查询
                return e.estimateRangeSelectivityUsingStats(filter.Operator, filter.Value, colStats)</span>

        case "IN":<span class="cov2" title="2">
                // IN操作
                if valList, ok := filter.Value.([]interface{}); ok &amp;&amp; len(valList) &gt; 0 </span><span class="cov1" title="1">{
                        return math.Min(1.0, float64(len(valList))/float64(colStats.DistinctCount))
                }</span>
                <span class="cov1" title="1">return 0.2</span>

        case "BETWEEN":<span class="cov1" title="1">
                // BETWEEN操作
                if vals, ok := filter.Value.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov1" title="1">{
                        sel1 := e.estimateRangeSelectivityUsingStats("&gt;=", vals[0], colStats)
                        sel2 := e.estimateRangeSelectivityUsingStats("&lt;=", vals[1], colStats)
                        return sel1 * sel2
                }</span>
                <span class="cov0" title="0">return 0.3</span>

        case "LIKE":<span class="cov2" title="2">
                // LIKE操作：考虑前缀匹配
                if pattern, ok := filter.Value.(string); ok </span><span class="cov2" title="2">{
                        // 前缀匹配选择性更高
                        if len(pattern) &gt; 0 &amp;&amp; pattern[len(pattern)-1] == '%' </span><span class="cov1" title="1">{
                                // 'abc%' 模式
                                prefixLen := len(pattern) - 1
                                // 估计：前缀越 长，选择性越高
                                return math.Min(0.8, 1.0-math.Pow(0.9, float64(prefixLen)))
                        }</span>
                }
                <span class="cov1" title="1">return 0.25</span>

        default:<span class="cov0" title="0">
                return e.getDefaultSelectivity(filter.Operator)</span>
        }
}

// estimateRangeSelectivityUsingStats 使用统计信息估算范围查询选择率
func (e *EnhancedCardinalityEstimator) estimateRangeSelectivityUsingStats(operator string, value interface{}, colStats *ColumnStatistics) float64 <span class="cov7" title="13">{
        minVal := colStats.MinValue
        maxVal := colStats.MaxValue

        if minVal == nil || maxVal == nil </span><span class="cov2" title="2">{
                return 0.1
        }</span>

        <span class="cov7" title="11">minFloat, ok := toFloat64(minVal)
        if !ok </span><span class="cov0" title="0">{
                return 0.1
        }</span>
        <span class="cov7" title="11">maxFloat, ok := toFloat64(maxVal)
        if !ok </span><span class="cov0" title="0">{
                return 0.1
        }</span>
        <span class="cov7" title="11">valFloat, ok := toFloat64(value)
        if !ok </span><span class="cov2" title="2">{
                return 0.1
        }</span>

        <span class="cov6" title="9">if minFloat == maxFloat </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov6" title="9">rangeSize := maxFloat - minFloat
        if rangeSize == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov6" title="9">switch operator </span>{
        case "&gt;":<span class="cov4" title="4">
                // value &gt; min: (max - value) / (max - min)
                if valFloat &lt;= minFloat </span><span class="cov1" title="1">{
                        return 0.0
                }</span>
                <span class="cov3" title="3">return (maxFloat - valFloat) / rangeSize</span>
        case "&gt;=":<span class="cov1" title="1">
                // value &gt;= min: (max - value + epsilon) / (max - min)
                if valFloat &lt; minFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov1" title="1">return (maxFloat - valFloat + 0.0001) / rangeSize</span>
        case "&lt;":<span class="cov3" title="3">
                // value &lt; max: (value - min) / (max - min)
                if valFloat &gt;= maxFloat </span><span class="cov1" title="1">{
                        return 0.0
                }</span>
                <span class="cov2" title="2">return (valFloat - minFloat) / rangeSize</span>
        case "&lt;=":<span class="cov1" title="1">
                // value &lt;= max: (value - min + epsilon) / (max - min)
                if valFloat &gt; maxFloat </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov1" title="1">return (valFloat - minFloat + 0.0001) / rangeSize</span>
        default:<span class="cov0" title="0">
                return 0.5</span>
        }
}

// EstimateJoin 估算JOIN的基数（增强版）
func (e *EnhancedCardinalityEstimator) EstimateJoin(left, right interface{}, joinType string) int64 <span class="cov5" title="5">{
        leftCount := int64(10000)
        rightCount := int64(10000)

        if leftCount == 0 || rightCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 简化实现：基于JOIN类型估算基数
        <span class="cov5" title="5">switch joinType </span>{
        case "INNER":<span class="cov1" title="1">
                // INNER JOIN: left * right * selectivity
                selectivity := 0.1
                return int64(float64(leftCount*rightCount) * selectivity)</span>
        case "LEFT":<span class="cov1" title="1">
                // LEFT JOIN: left
                return leftCount</span>
        case "RIGHT":<span class="cov1" title="1">
                // RIGHT JOIN: right
                return rightCount</span>
        case "FULL":<span class="cov1" title="1">
                // FULL JOIN: left + right
                return leftCount + rightCount</span>
        default:<span class="cov1" title="1">
                return leftCount * rightCount</span>
        }
}

// estimateJoinSelectivity 估算JOIN的选择性
func (e *EnhancedCardinalityEstimator) estimateJoinSelectivity(conditions []*parser.Expression, left, right interface{}) float64 <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // 分析连接条件中的列
        <span class="cov0" title="0">leftTableName := getTableName(left)
        rightTableName := getTableName(right)

        totalSelectivity := 1.0
        for range conditions </span><span class="cov0" title="0">{
                // 简化：假设等值连接
                // 实际应该解析表达式获取列名
                selectivity := e.estimateEquijoinSelectivity(leftTableName, rightTableName)
                totalSelectivity *= selectivity
        }</span>

        <span class="cov0" title="0">return totalSelectivity</span>
}

// estimateEquijoinSelectivity 估算等值连接的选择性
func (e *EnhancedCardinalityEstimator) estimateEquijoinSelectivity(leftTable, rightTable string) float64 <span class="cov2" title="2">{
        // 获取两个表的NDV
        leftStats, err := e.GetStatistics(leftTable)
        if err != nil </span><span class="cov1" title="1">{
                return 0.1
        }</span>

        <span class="cov1" title="1">rightStats, err := e.GetStatistics(rightTable)
        if err != nil </span><span class="cov0" title="0">{
                return 0.1
        }</span>

        // 假设连接列的NDV相似
        // 选择性 = 1 / NDV
        <span class="cov1" title="1">avgNDV := float64(leftStats.RowCount + rightStats.RowCount) / 2.0
        if avgNDV &gt; 0 </span><span class="cov1" title="1">{
                return 1.0 / math.Min(100.0, avgNDV)
        }</span>

        <span class="cov0" title="0">return 0.1</span>
}

// EstimateDistinct 估算DISTINCT后的行数
func (e *EnhancedCardinalityEstimator) EstimateDistinct(table string, columns []string) int64 <span class="cov4" title="4">{
        stats, err := e.GetStatistics(table)
        if err != nil </span><span class="cov1" title="1">{
                return e.EstimateTableScan(table) / 2
        }</span>

        <span class="cov3" title="3">if len(columns) == 0 </span><span class="cov1" title="1">{
                return stats.RowCount
        }</span>

        // 使用直方图或NDV估算
        <span class="cov2" title="2">minNDV := int64(math.MaxInt64)
        for _, col := range columns </span><span class="cov3" title="3">{
                if histogram, exists := stats.Histograms[col]; exists </span><span class="cov0" title="0">{
                        // 使用直方图的NDV
                        if histogram.NDV &lt; minNDV </span><span class="cov0" title="0">{
                                minNDV = histogram.NDV
                        }</span>
                } else<span class="cov3" title="3"> if colStats, exists := stats.ColumnStats[col]; exists &amp;&amp; colStats.DistinctCount &gt; 0 </span><span class="cov3" title="3">{
                        if colStats.DistinctCount &lt; minNDV </span><span class="cov3" title="3">{
                                minNDV = colStats.DistinctCount
                        }</span>
                }
        }

        <span class="cov2" title="2">if minNDV == math.MaxInt64 </span><span class="cov0" title="0">{
                return stats.RowCount / 2
        }</span>

        // 考虑采样比例
        <span class="cov2" title="2">return minNDV</span>
}

// estimateRowCount 估算逻辑计划的行数
func (e *EnhancedCardinalityEstimator) estimateRowCount(plan interface{}) int64 <span class="cov1" title="1">{
        // 简化实现：返回默认值
        // 完整实现需要处理不同的 LogicalPlan 类型
        _ = plan // 避免未使用警告
        return 10000
}</span>

// getDefaultSelectivity 获取默认选择率
func (e *EnhancedCardinalityEstimator) getDefaultSelectivity(operator string) float64 <span class="cov8" title="22">{
        switch operator </span>{
        case "=", "!=":<span class="cov5" title="5">
                return 0.1</span> // 等值查询：10%
        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov7" title="13">
                return 0.3</span> // 范围查询：30%
        case "IN":<span class="cov1" title="1">
                return 0.2</span> // IN查询：20%
        case "BETWEEN":<span class="cov1" title="1">
                return 0.3</span> // BETWEEN查询：30%
        case "LIKE":<span class="cov1" title="1">
                return 0.25</span> // LIKE查询：25%
        default:<span class="cov1" title="1">
                return 0.5</span> // 默认：50%
        }
}

// expressionToString 将表达式转换为字符串（简化）
func expressionToString(expr *parser.Expression) string <span class="cov2" title="2">{
        if expr == nil </span><span class="cov2" title="2">{
                return ""
        }</span>
        <span class="cov0" title="0">if expr.Column != "" </span><span class="cov0" title="0">{
                return expr.Column
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v", expr)</span>
}

// getTableName 获取逻辑计划的表名
func getTableName(plan interface{}) string <span class="cov0" title="0">{
        // 简化实现：需要处理具体的 LogicalPlan 类型
        _ = plan
        return ""
}</span>



</pre>
		
		<pre class="file" id="file38" style="display: none">package statistics

import (
        "fmt"
        "math"
        "sort"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// Histogram 直方图类型
type HistogramType int

const (
        EquiWidthHistogram HistogramType = iota // 等宽直方图
        EquiDepthHistogram                     // 等深直方图
        FrequencyHistogram                    // 频率直方图
)

// HistogramBucket 直方图桶
type HistogramBucket struct {
        LowerBound   interface{}
        UpperBound   interface{}
        Count        int64
        Distinct     int64
        NDV          int64 // 唯一值数
}

// Histogram 直方图
type Histogram struct {
        Type        HistogramType
        Buckets     []*HistogramBucket
        MinValue    interface{}
        MaxValue    interface{}
        BucketCount  int
        NDV          int64 // 总唯一值数
        NullCount    int64
}

// BuildEquiWidthHistogram 构建等宽直方图
func BuildEquiWidthHistogram(values []interface{}, bucketCount int) *Histogram <span class="cov4" title="13">{
        if len(values) == 0 </span><span class="cov1" title="1">{
                return &amp;Histogram{
                        Type:       EquiWidthHistogram,
                        Buckets:     []*HistogramBucket{},
                        BucketCount: bucketCount,
                }
        }</span>

        // 过滤非空值
        <span class="cov4" title="12">nonNullValues := make([]interface{}, 0, len(values))
        for _, val := range values </span><span class="cov8" title="435">{
                if val != nil </span><span class="cov8" title="432">{
                        nonNullValues = append(nonNullValues, val)
                }</span>
        }

        <span class="cov4" title="12">if len(nonNullValues) == 0 </span><span class="cov1" title="1">{
                return &amp;Histogram{
                        Type:       EquiWidthHistogram,
                        Buckets:     []*HistogramBucket{},
                        BucketCount: bucketCount,
                        NullCount:   int64(len(values)),
                }
        }</span>

        // 排序
        <span class="cov4" title="11">sortedValues := make([]interface{}, len(nonNullValues))
        copy(sortedValues, nonNullValues)
        sort.Slice(sortedValues, func(i, j int) bool </span><span class="cov9" title="949">{
                return compareHistogramValues(sortedValues[i], sortedValues[j]) &lt; 0
        }</span>)

        // 计算Min/Max
        <span class="cov4" title="11">hist := &amp;Histogram{
                Type:       EquiWidthHistogram,
                MinValue:   sortedValues[0],
                MaxValue:   sortedValues[len(sortedValues)-1],
                BucketCount: bucketCount,
                NullCount:   int64(len(values) - len(nonNullValues)),
        }

        // 计算总唯一值数
        uniqueSet := make(map[interface{}]bool)
        for _, val := range sortedValues </span><span class="cov8" title="432">{
                uniqueSet[val] = true
        }</span>
        <span class="cov4" title="11">hist.NDV = int64(len(uniqueSet))

        // 构建桶
        if bucketCount &lt;= 0 </span><span class="cov1" title="1">{
                bucketCount = 10
        }</span>
        <span class="cov4" title="11">if bucketCount &gt; len(nonNullValues) </span><span class="cov3" title="5">{
                bucketCount = len(nonNullValues)
        }</span>

        // 计算每个桶的值数
        <span class="cov4" title="11">valuesPerBucket := float64(len(nonNullValues)) / float64(bucketCount)
        hist.Buckets = make([]*HistogramBucket, 0, bucketCount)

        for i := 0; i &lt; bucketCount; i++ </span><span class="cov6" title="72">{
                start := int(float64(i) * valuesPerBucket)
                end := int(float64(i+1) * valuesPerBucket)
                if end &gt; len(nonNullValues) </span><span class="cov0" title="0">{
                        end = len(nonNullValues)
                }</span>

                <span class="cov6" title="72">bucketValues := sortedValues[start:end]
                if len(bucketValues) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="72">bucket := &amp;HistogramBucket{
                        LowerBound: bucketValues[0],
                        UpperBound: bucketValues[len(bucketValues)-1],
                        Count:      int64(len(bucketValues)),
                }

                // 计算桶内唯一值数
                bucketUnique := make(map[interface{}]bool)
                for _, val := range bucketValues </span><span class="cov8" title="432">{
                        bucketUnique[val] = true
                }</span>
                <span class="cov6" title="72">bucket.Distinct = int64(len(bucketUnique))
                bucket.NDV = bucket.Distinct

                hist.Buckets = append(hist.Buckets, bucket)</span>
        }

        <span class="cov4" title="11">return hist</span>
}

// BuildFrequencyHistogram 构建频率直方图
func BuildFrequencyHistogram(values []interface{}, bucketCount int) *Histogram <span class="cov2" title="3">{
        if len(values) == 0 </span><span class="cov1" title="1">{
                return &amp;Histogram{
                        Type:       FrequencyHistogram,
                        Buckets:     []*HistogramBucket{},
                        BucketCount: bucketCount,
                }
        }</span>

        // 计算值频率
        <span class="cov1" title="2">freq := make(map[interface{}]int64)
        nonNullCount := int64(0)
        for _, val := range values </span><span class="cov4" title="14">{
                if val != nil </span><span class="cov4" title="14">{
                        freq[val]++
                        nonNullCount++
                }</span>
        }

        <span class="cov1" title="2">hist := &amp;Histogram{
                Type:       FrequencyHistogram,
                BucketCount: bucketCount,
                NullCount:   int64(len(values)) - nonNullCount,
                NDV:          int64(len(freq)),
        }

        if len(freq) == 0 </span><span class="cov0" title="0">{
                return hist
        }</span>

        // 按频率排序
        <span class="cov1" title="2">type valueFreq struct {
                value interface{}
                freq  int64
        }

        sortedFreq := make([]valueFreq, 0, len(freq))
        for val, f := range freq </span><span class="cov3" title="8">{
                sortedFreq = append(sortedFreq, valueFreq{value: val, freq: f})
        }</span>

        <span class="cov1" title="2">sort.Slice(sortedFreq, func(i, j int) bool </span><span class="cov3" title="6">{
                return sortedFreq[i].freq &gt; sortedFreq[j].freq
        }</span>)

        // 确定Min/Max
        <span class="cov1" title="2">hist.MinValue = sortedFreq[0].value
        hist.MaxValue = sortedFreq[len(sortedFreq)-1].value

        // 将高频率值分组到桶
        if bucketCount &gt; len(sortedFreq) </span><span class="cov0" title="0">{
                bucketCount = len(sortedFreq)
        }</span>

        <span class="cov1" title="2">hist.Buckets = make([]*HistogramBucket, 0, bucketCount)
        totalFreq := int64(0)

        for i := 0; i &lt; bucketCount; i++ </span><span class="cov3" title="8">{
                start := i * len(sortedFreq) / bucketCount
                end := (i + 1) * len(sortedFreq) / bucketCount
                if end &gt; len(sortedFreq) </span><span class="cov0" title="0">{
                        end = len(sortedFreq)
                }</span>

                <span class="cov3" title="8">bucket := &amp;HistogramBucket{}
                for j := start; j &lt; end; j++ </span><span class="cov3" title="8">{
                        bucket.Count += sortedFreq[j].freq
                        totalFreq += sortedFreq[j].freq
                }</span>

                <span class="cov3" title="8">bucket.LowerBound = sortedFreq[start].value
                bucket.UpperBound = sortedFreq[end-1].value
                bucket.NDV = int64(end - start)

                hist.Buckets = append(hist.Buckets, bucket)</span>
        }

        <span class="cov1" title="2">return hist</span>
}

// EstimateSelectivity 估算过滤器的选择性（基于直方图）
func (h *Histogram) EstimateSelectivity(filter domain.Filter) float64 <span class="cov3" title="8">{
        if h == nil || len(h.Buckets) == 0 </span><span class="cov1" title="2">{
                return 0.1 // 默认选择率
        }</span>

        <span class="cov3" title="6">switch filter.Operator </span>{
        case "=", "!=":<span class="cov1" title="1">
                return h.EstimateEqualitySelectivity(filter.Value)</span>
        case "&gt;", "&gt;=", "&lt;", "&lt;=":<span class="cov1" title="1">
                return h.estimateRangeSelectivity(filter.Operator, filter.Value)</span>
        case "IN":<span class="cov1" title="1">
                if valList, ok := filter.Value.([]interface{}); ok </span><span class="cov1" title="1">{
                        return h.estimateInSelectivity(valList)
                }</span>
                <span class="cov0" title="0">return 0.2</span>
        case "BETWEEN":<span class="cov1" title="1">
                if vals, ok := filter.Value.([]interface{}); ok &amp;&amp; len(vals) == 2 </span><span class="cov1" title="1">{
                        sel1 := h.estimateRangeSelectivity("&gt;=", vals[0])
                        sel2 := h.estimateRangeSelectivity("&lt;=", vals[1])
                        return sel1 * sel2
                }</span>
                <span class="cov0" title="0">return 0.3</span>
        case "LIKE":<span class="cov1" title="1">
                return 0.25</span> // LIKE默认选择率
        default:<span class="cov1" title="1">
                return 0.5</span> // 默认50%
        }
}

// estimateEqualitySelectivity 估算等值查询的选择率
func (h *Histogram) EstimateEqualitySelectivity(value interface{}) float64 <span class="cov2" title="4">{
        // 查找值所在的桶
        for _, bucket := range h.Buckets </span><span class="cov2" title="4">{
                if h.isValueInRange(value, bucket.LowerBound, bucket.UpperBound) </span><span class="cov1" title="2">{
                        // 选择率 ≈ 桶内NDV / 总NDV
                        if bucket.NDV &gt; 0 &amp;&amp; h.NDV &gt; 0 </span><span class="cov1" title="2">{
                                sel := float64(bucket.NDV) / float64(h.NDV)
                                // 考虑频率
                                return math.Min(sel, float64(bucket.Count)/float64(h.totalCount()))
                        }</span>
                }
        }

        // 值不在任何桶中，选择率为0
        <span class="cov1" title="2">return 0.0</span>
}

// estimateRangeSelectivity 估算范围查询的选择率
func (h *Histogram) estimateRangeSelectivity(operator string, value interface{}) float64 <span class="cov3" title="8">{
        valueNum, ok := toFloat64(value)
        if !ok </span><span class="cov1" title="1">{
                return 0.3
        }</span>

        <span class="cov3" title="7">minNum, minOk := toFloat64(h.MinValue)
        maxNum, maxOk := toFloat64(h.MaxValue)

        if !minOk || !maxOk </span><span class="cov0" title="0">{
                return 0.3
        }</span>

        // 计算范围内的桶数
        <span class="cov3" title="7">inRangeBuckets := 0
        totalRange := maxNum - minNum

                for _, bucket := range h.Buckets </span><span class="cov4" title="16">{
                lowerNum, lowerOk := toFloat64(bucket.LowerBound)
                upperNum, upperOk := toFloat64(bucket.UpperBound)

                if !lowerOk || !upperOk </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="16">bucketInRange := false

                switch operator </span>{
                case "&gt;":<span class="cov3" title="8">
                        bucketInRange = upperNum &gt; valueNum</span>
                case "&gt;=":<span class="cov1" title="1">
                        bucketInRange = upperNum &gt;= valueNum</span>
                case "&lt;":<span class="cov3" title="6">
                        bucketInRange = lowerNum &lt; valueNum</span>
                case "&lt;=":<span class="cov1" title="1">
                        bucketInRange = lowerNum &lt;= valueNum</span>
                }

                <span class="cov4" title="16">if bucketInRange </span><span class="cov3" title="7">{
                        inRangeBuckets++
                }</span>
        }

        // 选择率 = 范围内桶数 / 总桶数
        <span class="cov3" title="7">if len(h.Buckets) &gt; 0 </span><span class="cov3" title="7">{
                return float64(inRangeBuckets) / float64(len(h.Buckets))
        }</span>

        // 如果是等宽直方图且能确定数值范围
        <span class="cov0" title="0">if h.Type == EquiWidthHistogram &amp;&amp; totalRange &gt; 0 </span><span class="cov0" title="0">{
                var fraction float64
                switch operator </span>{
                case "&gt;":<span class="cov0" title="0">
                        fraction = (maxNum - valueNum) / totalRange</span>
                case "&gt;=":<span class="cov0" title="0">
                        fraction = (maxNum - valueNum + 0.0001) / totalRange</span>
                case "&lt;":<span class="cov0" title="0">
                        fraction = (valueNum - minNum) / totalRange</span>
                case "&lt;=":<span class="cov0" title="0">
                        fraction = (valueNum - minNum + 0.0001) / totalRange</span>
                }
                <span class="cov0" title="0">return math.Max(0.0, math.Min(1.0, fraction))</span>
        }

        <span class="cov0" title="0">return 0.3</span>
}

// estimateInSelectivity 估算IN查询的选择率
func (h *Histogram) estimateInSelectivity(values []interface{}) float64 <span class="cov2" title="4">{
        if len(h.Buckets) == 0 </span><span class="cov0" title="0">{
                return 0.2
        }</span>

        // 计算IN列表中不同值的数量
        <span class="cov2" title="4">distinctInValues := make(map[interface{}]bool)
        for _, val := range values </span><span class="cov4" title="10">{
                if val != nil </span><span class="cov3" title="9">{
                        distinctInValues[val] = true
                }</span>
        }

        // 估算覆盖的桶数
        <span class="cov2" title="4">coveredBuckets := 0
        for _, val := range values </span><span class="cov4" title="10">{
                for _, bucket := range h.Buckets </span><span class="cov4" title="14">{
                        if h.isValueInRange(val, bucket.LowerBound, bucket.UpperBound) </span><span class="cov3" title="8">{
                                coveredBuckets++
                                break</span>
                        }
                }
        }

        // 选择率 = 覆盖桶数 * (IN值数/总NDV) + 未覆盖桶的默认选择率
        <span class="cov2" title="4">bucketCoverage := float64(coveredBuckets) / float64(len(h.Buckets))
        valueCoverage := float64(len(distinctInValues)) / float64(h.NDV)

        return bucketCoverage * valueCoverage</span>
}

// isValueInRange 检查值是否在桶范围内
func (h *Histogram) isValueInRange(value, lower, upper interface{}) bool <span class="cov5" title="24">{
        if value == nil </span><span class="cov2" title="4">{
                return false
        }</span>

        <span class="cov4" title="20">cmpLower := compareHistogramValues(value, lower)
        cmpUpper := compareHistogramValues(value, upper)

        // 等宽直方图：值可能在桶边界
        if h.Type == EquiWidthHistogram </span><span class="cov4" title="20">{
                return cmpLower &gt;= 0 &amp;&amp; cmpUpper &lt;= 0
        }</span>

        // 频率直方图：值应该在桶的Lower和Upper之间
        <span class="cov0" title="0">return cmpLower &gt;= 0 &amp;&amp; cmpUpper &lt;= 0</span>
}

// totalCount 计算总行数（不包括NULL）
func (h *Histogram) totalCount() int64 <span class="cov3" title="6">{
        total := h.NullCount
        for _, bucket := range h.Buckets </span><span class="cov3" title="5">{
                total += bucket.Count
        }</span>
        <span class="cov3" title="6">return total</span>
}

// Explain 返回直方图的描述
func (h *Histogram) Explain() string <span class="cov2" title="4">{
        if h == nil </span><span class="cov1" title="1">{
                return "Empty Histogram"
        }</span>

        <span class="cov2" title="3">typeStr := ""
        switch h.Type </span>{
        case EquiWidthHistogram:<span class="cov1" title="1">
                typeStr = "Equi-Width"</span>
        case FrequencyHistogram:<span class="cov1" title="1">
                typeStr = "Frequency"</span>
        default:<span class="cov1" title="1">
                typeStr = "Unknown"</span>
        }

        <span class="cov2" title="3">bucketCount := h.BucketCount
        if bucketCount == 0 &amp;&amp; len(h.Buckets) &gt; 0 </span><span class="cov0" title="0">{
                bucketCount = len(h.Buckets)
        }</span>

        <span class="cov2" title="3">return fmt.Sprintf("Histogram(type=%s, buckets=%d, ndv=%d, min=%v, max=%v)",
                typeStr, bucketCount, h.NDV, h.MinValue, h.MaxValue)</span>
}

// compareHistogramValues 比较两个值
func compareHistogramValues(a, b interface{}) int <span class="cov10" title="999">{
        if a == nil &amp;&amp; b == nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov9" title="998">if a == nil </span><span class="cov1" title="1">{
                return -1
        }</span>
        <span class="cov9" title="997">if b == nil </span><span class="cov1" title="1">{
                return 1
        }</span>

        // 数值比较
        <span class="cov9" title="996">if aNum, aOk := toFloat64(a); aOk </span><span class="cov9" title="873">{
                if bNum, bOk := toFloat64(b); bOk </span><span class="cov9" title="873">{
                        if aNum &lt; bNum </span><span class="cov8" title="342">{
                                return -1
                        }</span> else<span class="cov9" title="531"> if aNum &gt; bNum </span><span class="cov9" title="471">{
                                return 1
                        }</span>
                        <span class="cov6" title="60">return 0</span>
                }
        }

        // 字符串比较
        <span class="cov7" title="123">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov1" title="2">{
                return -1
        }</span> else<span class="cov7" title="121"> if aStr &gt; bStr </span><span class="cov4" title="10">{
                return 1
        }</span>
        <span class="cov7" title="111">return 0</span>
}

</pre>
		
		<pre class="file" id="file39" style="display: none">package statistics

// toFloat64 转换值为float64
func toFloat64(val interface{}) (float64, bool) <span class="cov10" title="3012">{
        switch v := val.(type) </span>{
        case int:<span class="cov4" title="21">
                return float64(v), true</span>
        case int8:<span class="cov0" title="0">
                return float64(v), true</span>
        case int16:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov9" title="2648">
                return float64(v), true</span>
        case uint:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint8:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint16:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint32:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint64:<span class="cov0" title="0">
                return float64(v), true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case float64:<span class="cov2" title="5">
                return v, true</span>
        default:<span class="cov7" title="338">
                return 0, false</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package optimizer

import (
        "context"
        "fmt"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// LogicalPlan 逻辑计划接口
type LogicalPlan interface {
        // Children 获取子节点
        Children() []LogicalPlan

        // SetChildren 设置子节点
        SetChildren(children ...LogicalPlan)

        // Schema 返回输出列
        Schema() []ColumnInfo

        // Explain 返回计划说明
        Explain() string
}

// PhysicalPlan 物理计划接口
type PhysicalPlan interface {
        // Children 获取子节点
        Children() []PhysicalPlan

        // SetChildren 设置子节点
        SetChildren(children ...PhysicalPlan)

        // Schema 返回输出列
        Schema() []ColumnInfo

        // Cost 返回执行成本
        Cost() float64

        // Execute 执行计划
        Execute(ctx context.Context) (*domain.QueryResult, error)

        // Explain 返回计划说明
        Explain() string
}

// ColumnInfo 列信息
type ColumnInfo struct {
        Name     string
        Type     string
        Nullable bool
        // 可以扩展更多字段
}

// JoinType 连接类型
type JoinType int

const (
        InnerJoin JoinType = iota
        LeftOuterJoin
        RightOuterJoin
        FullOuterJoin
)

// String 返回 JoinType 的字符串表示
func (jt JoinType) String() string <span class="cov3" title="10">{
        switch jt </span>{
        case InnerJoin:<span class="cov1" title="2">
                return "INNER JOIN"</span>
        case LeftOuterJoin:<span class="cov1" title="2">
                return "LEFT OUTER JOIN"</span>
        case RightOuterJoin:<span class="cov1" title="2">
                return "RIGHT OUTER JOIN"</span>
        case FullOuterJoin:<span class="cov1" title="2">
                return "FULL OUTER JOIN"</span>
        default:<span class="cov1" title="2">
                return "UNKNOWN"</span>
        }
}

// AggregationType 聚合函数类型
type AggregationType int

const (
        Count AggregationType = iota
        Sum
        Avg
        Max
        Min
)

// String 返回 AggregationType 的字符串表示
func (at AggregationType) String() string <span class="cov4" title="12">{
        switch at </span>{
        case Count:<span class="cov1" title="2">
                return "COUNT"</span>
        case Sum:<span class="cov1" title="2">
                return "SUM"</span>
        case Avg:<span class="cov1" title="2">
                return "AVG"</span>
        case Max:<span class="cov1" title="2">
                return "MAX"</span>
        case Min:<span class="cov1" title="2">
                return "MIN"</span>
        default:<span class="cov1" title="2">
                return "UNKNOWN"</span>
        }
}

// AggregationItem 聚合项
type AggregationItem struct {
        Type     AggregationType
        Expr     *parser.Expression
        Alias    string
        Distinct bool
}

// JoinCondition 连接条件
type JoinCondition struct {
        Left     *parser.Expression
        Right    *parser.Expression
        Operator string
}

// LimitInfo Limit信息
type LimitInfo struct {
        Limit  int64
        Offset int64
}

// OrderByItem 排序项
type OrderByItem struct {
        Column    string
        Direction string // "ASC" or "DESC"
}

// Statistics 统计信息（简化版）
type Statistics struct {
        RowCount   int64
        UniqueKeys int64
        NullCount  int64
}

// OptimizationContext 优化上下文
type OptimizationContext struct {
        DataSource domain.DataSource
        TableInfo  map[string]*domain.TableInfo
        Stats      map[string]*Statistics
        CostModel  CostModel
}

// CostModel 成本模型
type CostModel interface {
        // ScanCost 计算扫描成本
        ScanCost(tableName string, rowCount int64) float64

        // FilterCost 计算过滤成本
        FilterCost(inputRows int64, selectivity float64) float64

        // JoinCost 计算连接成本
        JoinCost(leftRows, rightRows int64, joinType JoinType) float64

        // AggregateCost 计算聚合成本
        AggregateCost(inputRows int64, groupByCols int) float64

        // ProjectCost 计算投影成本
        ProjectCost(inputRows int64, projCols int) float64
}

// DefaultCostModel 默认成本模型
type DefaultCostModel struct {
        CPUFactor    float64
        IoFactor     float64
        MemoryFactor float64
}

// NewDefaultCostModel 创建默认成本模型
func NewDefaultCostModel() *DefaultCostModel <span class="cov6" title="90">{
        return &amp;DefaultCostModel{
                CPUFactor:    0.01,
                IoFactor:     0.1,
                MemoryFactor: 0.001,
        }
}</span>

// ScanCost 计算扫描成本
func (cm *DefaultCostModel) ScanCost(tableName string, rowCount int64) float64 <span class="cov3" title="8">{
        // 成本 = IO 读取 + CPU 处理
        return float64(rowCount)*cm.IoFactor + float64(rowCount)*cm.CPUFactor
}</span>

// FilterCost 计算过滤成本
func (cm *DefaultCostModel) FilterCost(inputRows int64, selectivity float64) float64 <span class="cov4" title="16">{
        // 成本 = 读取所有行 + 比较成本
        outputRows := float64(inputRows) * selectivity
        return float64(inputRows)*cm.CPUFactor + outputRows
}</span>

// JoinCost 计算连接成本
func (cm *DefaultCostModel) JoinCost(leftRows, rightRows int64, joinType JoinType) float64 <span class="cov3" title="7">{
        // 假设使用 hash join
        // 成本 = 构建 hash + 探测 hash
        buildCost := float64(leftRows) * cm.CPUFactor
        probeCost := float64(rightRows) * cm.CPUFactor
        memoryCost := float64(leftRows) * cm.MemoryFactor
        return buildCost + probeCost + memoryCost
}</span>

// AggregateCost 计算聚合成本
func (cm *DefaultCostModel) AggregateCost(inputRows int64, groupByCols int) float64 <span class="cov3" title="6">{
        // 成本 = 分组 + 聚合
        groupCost := float64(inputRows) * cm.CPUFactor * float64(groupByCols)
        aggCost := float64(inputRows) * cm.CPUFactor
        return groupCost + aggCost
}</span>

// ProjectCost 计算投影成本
func (cm *DefaultCostModel) ProjectCost(inputRows int64, projCols int) float64 <span class="cov5" title="26">{
        // 成本 = 计算每个表达式
        return float64(inputRows) * float64(projCols) * cm.CPUFactor
}</span>

// OptimizationRule 优化规则接口
type OptimizationRule interface {
        // Name 规则名称
        Name() string

        // Match 检查规则是否匹配
        Match(plan LogicalPlan) bool

        // Apply 应用规则，返回优化后的计划
        Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error)
}

// RuleSet 规则集合
type RuleSet []OptimizationRule

// Apply 应用所有规则
func (rs RuleSet) Apply(ctx context.Context, plan LogicalPlan, optCtx *OptimizationContext) (LogicalPlan, error) <span class="cov7" title="153">{
        fmt.Println("  [DEBUG] RuleSet.Apply: 开始, 当前计划:", plan.Explain())
        current := plan
        changed := true
        maxIterations := 10 // 防止无限循环
        iterations := 0

        // 迭代应用规则，直到不再变化
        for changed &amp;&amp; iterations &lt; maxIterations </span><span class="cov7" title="202">{
                changed = false
                iterations++
                fmt.Println("  [DEBUG] RuleSet.Apply: 迭代", iterations)

                for _, rule := range rs </span><span class="cov10" title="1460">{
                        if rule.Match(current) </span><span class="cov8" title="309">{
                                fmt.Println("  [DEBUG] RuleSet.Apply: 匹配规则", rule.Name())
                                newPlan, err := rule.Apply(ctx, current, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("rule %s failed: %w", rule.Name(), err)
                                }</span>
                                <span class="cov8" title="309">if newPlan != nil &amp;&amp; newPlan != current </span><span class="cov5" title="28">{
                                        current = newPlan
                                        changed = true
                                        fmt.Println("  [DEBUG] RuleSet.Apply: 规则", rule.Name(), "应用成功")
                                }</span>
                        }
                }

                // 递归应用到子节点
                <span class="cov7" title="202">children := current.Children()
                if len(children) &gt; 0 </span><span class="cov6" title="97">{
                        fmt.Println("  [DEBUG] RuleSet.Apply: 递归处理子节点, 数量:", len(children))
                        for i, child := range children </span><span class="cov6" title="97">{
                                newChild, err := rs.Apply(ctx, child, optCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov6" title="97">if newChild != child </span><span class="cov4" title="23">{
                                        fmt.Println("  [DEBUG] RuleSet.Apply: 子节点", i, "已更新")
                                        allChildren := current.Children()
                                        allChildren[i] = newChild
                                        current.SetChildren(allChildren...)
                                        changed = true
                                }</span>
                        }
                }
        }

        <span class="cov7" title="153">fmt.Println("  [DEBUG] RuleSet.Apply: 完成, 总迭代次数:", iterations)
        return current, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package optimizer

import (
        "github.com/kasuganosora/sqlexec/pkg/utils"
)

// toFloat64 转换值为float64（兼容包装）
// 这个函数用于数值类型转换
func toFloat64(val interface{}) (float64, bool) <span class="cov10" title="6">{
        f, err := utils.ToFloat64(val)
        return f, err == nil
}</span>

// toNumber 转换值为数值（兼容包装）
// 这个函数用于比较和排序
func toNumber(val interface{}) (float64, bool) <span class="cov0" title="0">{
        return toFloat64(val)
}</span>

// compareValues 比较两个值
// 返回 -1: a &lt; b, 0: a == b, 1: a &gt; b
func compareValues(a, b interface{}) int <span class="cov0" title="0">{
        // 使用 utils 包的 CompareValuesForSort 函数
        return utils.CompareValuesForSort(a, b)
}</span>

// compareValuesEqual 比较两个值是否相等
func compareValuesEqual(v1, v2 interface{}) bool <span class="cov0" title="0">{
        return utils.CompareValuesForSort(v1, v2) == 0
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "sort"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ViewExecutor handles view execution (TEMPTABLE algorithm)
type ViewExecutor struct {
        dataSource domain.DataSource
}

// NewViewExecutor creates a new view executor
func NewViewExecutor(dataSource domain.DataSource) *ViewExecutor <span class="cov0" title="0">{
        return &amp;ViewExecutor{
                dataSource: dataSource,
        }
}</span>

// ExecuteAsTempTable executes a view query and stores result in a temporary table
func (ve *ViewExecutor) ExecuteAsTempTable(ctx context.Context, viewInfo *domain.ViewInfo, outerQuery *parser.SelectStatement) (*domain.QueryResult, error) <span class="cov0" title="0">{
        // Check view algorithm
        if viewInfo.Algorithm != "" &amp;&amp; viewInfo.Algorithm != domain.ViewAlgorithmUndefined &amp;&amp; viewInfo.Algorithm != domain.ViewAlgorithmTempTable </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view does not use TEMPTABLE algorithm: %s", viewInfo.Algorithm)
        }</span>

        // Parse view's SELECT statement
        <span class="cov0" title="0">adapter := parser.NewSQLAdapter()
        parseResult, err := adapter.Parse(viewInfo.SelectStmt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse view SELECT: %w", err)
        }</span>

        <span class="cov0" title="0">if !parseResult.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view SELECT parse failed: %s", parseResult.Error)
        }</span>

        <span class="cov0" title="0">if parseResult.Statement.Select == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view definition is not a SELECT statement")
        }</span>

        <span class="cov0" title="0">viewSelect := parseResult.Statement.Select

        // Execute view's SELECT to get data
        builder := parser.NewQueryBuilder(ve.dataSource)
        result, err := builder.ExecuteStatement(ctx, &amp;parser.SQLStatement{
                Type:   parser.SQLTypeSelect,
                Select: viewSelect,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute view query: %w", err)
        }</span>

        <span class="cov0" title="0">if result == nil || result.Rows == nil </span><span class="cov0" title="0">{
                // Empty result - return empty result with correct columns
                return &amp;domain.QueryResult{
                        Columns: result.Columns,
                        Rows:    []domain.Row{},
                        Total:   0,
                }, nil
        }</span>

        // Apply outer query filters/limits to result
        <span class="cov0" title="0">filteredResult := ve.applyOuterQuery(result, outerQuery, viewInfo)

        return filteredResult, nil</span>
}

// applyOuterQuery applies outer query filters, limits, etc. to view result
func (ve *ViewExecutor) applyOuterQuery(viewResult *domain.QueryResult, outerQuery *parser.SelectStatement, viewInfo *domain.ViewInfo) *domain.QueryResult <span class="cov0" title="0">{
        filtered := &amp;domain.QueryResult{
                Columns: viewResult.Columns,
                Rows:    make([]domain.Row, 0, len(viewResult.Rows)),
                Total:   viewResult.Total,
        }

        // Apply WHERE from outer query
        if outerQuery.Where != nil </span><span class="cov0" title="0">{
                for _, row := range viewResult.Rows </span><span class="cov0" title="0">{
                        matches, err := ve.evaluateWhere(row, outerQuery.Where)
                        if err == nil &amp;&amp; matches </span><span class="cov0" title="0">{
                                filtered.Rows = append(filtered.Rows, row)
                        }</span>
                }
                <span class="cov0" title="0">filtered.Total = int64(len(filtered.Rows))</span>
        } else<span class="cov0" title="0"> {
                filtered.Rows = viewResult.Rows
        }</span>

        // Apply ORDER BY
        <span class="cov0" title="0">if len(outerQuery.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                ve.sortRows(filtered.Rows, outerQuery.OrderBy)
        }</span>

        // Apply LIMIT/OFFSET
        <span class="cov0" title="0">if outerQuery.Limit != nil </span><span class="cov0" title="0">{
                start := 0
                if outerQuery.Offset != nil </span><span class="cov0" title="0">{
                        start = int(*outerQuery.Offset)
                }</span>
                <span class="cov0" title="0">if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>

                <span class="cov0" title="0">end := start + int(*outerQuery.Limit)
                if end &gt; len(filtered.Rows) </span><span class="cov0" title="0">{
                        end = len(filtered.Rows)
                }</span>

                <span class="cov0" title="0">if start &lt; len(filtered.Rows) </span><span class="cov0" title="0">{
                        filtered.Rows = filtered.Rows[start:end]
                }</span> else<span class="cov0" title="0"> {
                        filtered.Rows = []domain.Row{}
                }</span>
                <span class="cov0" title="0">filtered.Total = int64(len(filtered.Rows))</span>
        }

        // Apply column selection
        <span class="cov0" title="0">if len(outerQuery.Columns) &gt; 0 &amp;&amp; !ve.isSelectAll(outerQuery.Columns) </span><span class="cov0" title="0">{
                filtered = ve.selectColumns(filtered, outerQuery.Columns, viewInfo)
        }</span>

        <span class="cov0" title="0">return filtered</span>
}

// evaluateWhere evaluates a WHERE expression against a row
func (ve *ViewExecutor) evaluateWhere(row domain.Row, expr *parser.Expression) (bool, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Evaluate expression based on type
        <span class="cov0" title="0">switch expr.Type </span>{
        case parser.ExprTypeColumn:<span class="cov0" title="0">
                // Check if column exists and has a truthy value
                val, exists := row[expr.Column]
                if !exists </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return ve.isTruthy(val), nil</span>

        case parser.ExprTypeValue:<span class="cov0" title="0">
                // Constant value
                return ve.isTruthy(expr.Value), nil</span>

        case parser.ExprTypeOperator:<span class="cov0" title="0">
                // Binary operation
                return ve.evaluateOperator(row, expr)</span>

        case parser.ExprTypeFunction:<span class="cov0" title="0">
                // Function call - not fully implemented
                return true, nil</span>

        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// evaluateOperator evaluates a binary operator expression
func (ve *ViewExecutor) evaluateOperator(row domain.Row, expr *parser.Expression) (bool, error) <span class="cov0" title="0">{
        if expr.Operator == "" </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Handle logical operators
        <span class="cov0" title="0">op := strings.ToUpper(expr.Operator)
        switch op </span>{
        case "AND":<span class="cov0" title="0">
                left, _ := ve.evaluateWhere(row, expr.Left)
                right, _ := ve.evaluateWhere(row, expr.Right)
                return left &amp;&amp; right, nil</span>

        case "OR":<span class="cov0" title="0">
                left, _ := ve.evaluateWhere(row, expr.Left)
                right, _ := ve.evaluateWhere(row, expr.Right)
                return left || right, nil</span>
        }

        // For comparison operators, extract column and value values
        <span class="cov0" title="0">if expr.Left == nil || expr.Right == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">leftValue, err := ve.extractValue(row, expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">rightValue, err := ve.extractValue(row, expr.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Perform comparison
        <span class="cov0" title="0">return ve.compareValues(leftValue, rightValue, op)</span>
}

// extractValue extracts a value from an expression
func (ve *ViewExecutor) extractValue(row domain.Row, expr *parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">switch expr.Type </span>{
        case parser.ExprTypeValue:<span class="cov0" title="0">
                return expr.Value, nil</span>

        case parser.ExprTypeColumn:<span class="cov0" title="0">
                val, exists := row[expr.Column]
                if !exists </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return val, nil</span>

        case parser.ExprTypeFunction:<span class="cov0" title="0">
                // Not implemented
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, nil</span>
        }
}

// compareValues compares two values
func (ve *ViewExecutor) compareValues(left, right interface{}, operator string) (bool, error) <span class="cov0" title="0">{
        // Handle nil values
        if left == nil || right == nil </span><span class="cov0" title="0">{
                // NULL comparisons always return false (except IS NULL)
                if operator == "!=" </span><span class="cov0" title="0">{
                        return left != right, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        // Try to convert to float64 for numeric comparison
        <span class="cov0" title="0">leftFloat, leftOk := ve.toFloat64(left)
        rightFloat, rightOk := ve.toFloat64(right)

        if leftOk &amp;&amp; rightOk </span><span class="cov0" title="0">{
                // Numeric comparison
                switch operator </span>{
                case "=":<span class="cov0" title="0">
                        return leftFloat == rightFloat, nil</span>
                case "!=":<span class="cov0" title="0">
                        return leftFloat != rightFloat, nil</span>
                case "&gt;":<span class="cov0" title="0">
                        return leftFloat &gt; rightFloat, nil</span>
                case "&lt;":<span class="cov0" title="0">
                        return leftFloat &lt; rightFloat, nil</span>
                case "&gt;=":<span class="cov0" title="0">
                        return leftFloat &gt;= rightFloat, nil</span>
                case "&lt;=":<span class="cov0" title="0">
                        return leftFloat &lt;= rightFloat, nil</span>
                }
        }

        // String comparison
        <span class="cov0" title="0">leftStr, leftOk := left.(string)
        rightStr, rightOk := right.(string)

        if leftOk &amp;&amp; rightOk </span><span class="cov0" title="0">{
                switch operator </span>{
                case "=":<span class="cov0" title="0">
                        return leftStr == rightStr, nil</span>
                case "!=":<span class="cov0" title="0">
                        return leftStr != rightStr, nil</span>
                case "&gt;":<span class="cov0" title="0">
                        return leftStr &gt; rightStr, nil</span>
                case "&lt;":<span class="cov0" title="0">
                        return leftStr &lt; rightStr, nil</span>
                case "&gt;=":<span class="cov0" title="0">
                        return leftStr &gt;= rightStr, nil</span>
                case "&lt;=":<span class="cov0" title="0">
                        return leftStr &lt;= rightStr, nil</span>
                case "LIKE":<span class="cov0" title="0">
                        // Simple LIKE implementation (case-insensitive)
                        pattern := strings.ToLower(rightStr)
                        text := strings.ToLower(leftStr)
                        return strings.Contains(text, pattern), nil</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}

// toFloat64 converts a value to float64 if possible
func (ve *ViewExecutor) toFloat64(val interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := val.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int8:<span class="cov0" title="0">
                return float64(v), true</span>
        case int16:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint8:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint16:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint32:<span class="cov0" title="0">
                return float64(v), true</span>
        case uint64:<span class="cov0" title="0">
                return float64(v), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// isTruthy checks if a value is truthy
func (ve *ViewExecutor) isTruthy(val interface{}) bool <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch v := val.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case string:<span class="cov0" title="0">
                return v != ""</span>
        case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return true</span>
        case float32, float64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// sortRows sorts rows by ORDER BY clause
func (ve *ViewExecutor) sortRows(rows []domain.Row, orderBy []parser.OrderByItem) <span class="cov0" title="0">{
        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Use first ORDER BY item (simplified)
        <span class="cov0" title="0">orderByItem := orderBy[0]

        sort.SliceStable(rows, func(i, j int) bool </span><span class="cov0" title="0">{
                val1, exists1 := rows[i][orderByItem.Column]
                val2, exists2 := rows[j][orderByItem.Column]

                if !exists1 &amp;&amp; !exists2 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !exists1 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !exists2 </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Compare values
                <span class="cov0" title="0">cmp := ve.compareForSort(val1, val2)
                if orderByItem.Direction == "DESC" </span><span class="cov0" title="0">{
                        return cmp &gt; 0
                }</span>
                <span class="cov0" title="0">return cmp &lt; 0</span>
        })
}

// compareForSort compares two values for sorting
func (ve *ViewExecutor) compareForSort(val1, val2 interface{}) int <span class="cov0" title="0">{
        // Handle nil values
        if val1 == nil &amp;&amp; val2 == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if val1 == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if val2 == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Try numeric comparison
        <span class="cov0" title="0">if num1, ok1 := ve.toFloat64(val1); ok1 </span><span class="cov0" title="0">{
                if num2, ok2 := ve.toFloat64(val2); ok2 </span><span class="cov0" title="0">{
                        if num1 &lt; num2 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                        <span class="cov0" title="0">if num1 &gt; num2 </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        }

        // String comparison
        <span class="cov0" title="0">if str1, ok1 := val1.(string); ok1 </span><span class="cov0" title="0">{
                if str2, ok2 := val2.(string); ok2 </span><span class="cov0" title="0">{
                        if str1 &lt; str2 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                        <span class="cov0" title="0">if str1 &gt; str2 </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        }

        <span class="cov0" title="0">return 0</span>
}

// isSelectAll checks if column list is SELECT *
func (ve *ViewExecutor) isSelectAll(cols []parser.SelectColumn) bool <span class="cov0" title="0">{
        for _, col := range cols </span><span class="cov0" title="0">{
                if col.IsWildcard </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// selectColumns selects specific columns from result
func (ve *ViewExecutor) selectColumns(result *domain.QueryResult, columns []parser.SelectColumn, viewInfo *domain.ViewInfo) *domain.QueryResult <span class="cov0" title="0">{
        // Build column name mapping
        colMap := make(map[string]bool)
        for _, col := range columns </span><span class="cov0" title="0">{
                if col.Name != "" </span><span class="cov0" title="0">{
                        colMap[col.Name] = true
                }</span>
                <span class="cov0" title="0">if col.Alias != "" </span><span class="cov0" title="0">{
                        colMap[col.Alias] = true
                }</span>
        }

        // If no specific columns selected, return all
        <span class="cov0" title="0">if len(colMap) == 0 </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">selected := &amp;domain.QueryResult{
                Columns: make([]domain.ColumnInfo, 0),
                Rows:    make([]domain.Row, 0, len(result.Rows)),
                Total:   result.Total,
        }

        // Build selected columns
        for _, colInfo := range result.Columns </span><span class="cov0" title="0">{
                if colMap[colInfo.Name] </span><span class="cov0" title="0">{
                        selected.Columns = append(selected.Columns, colInfo)
                }</span>
        }

        // If no columns selected, add requested columns with default info
        <span class="cov0" title="0">if len(selected.Columns) == 0 </span><span class="cov0" title="0">{
                for colName := range colMap </span><span class="cov0" title="0">{
                        selected.Columns = append(selected.Columns, domain.ColumnInfo{
                                Name:     colName,
                                Type:     "text",
                                Nullable: true,
                        })
                }</span>
        }

        // Build selected rows
        <span class="cov0" title="0">for _, row := range result.Rows </span><span class="cov0" title="0">{
                selectedRow := make(domain.Row)
                for colName := range colMap </span><span class="cov0" title="0">{
                        if val, exists := row[colName]; exists </span><span class="cov0" title="0">{
                                selectedRow[colName] = val
                        }</span>
                }
                <span class="cov0" title="0">selected.Rows = append(selected.Rows, selectedRow)</span>
        }

        <span class="cov0" title="0">return selected</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package optimizer

import (
        "fmt"
        "strings"

        "github.com/kasuganosora/sqlexec/pkg/parser"
        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
)

// ViewRewriter handles view query rewriting using the MERGE algorithm
type ViewRewriter struct {
        viewDepth int
        maxDepth  int
}

// NewViewRewriter creates a new view rewriter
func NewViewRewriter() *ViewRewriter <span class="cov0" title="0">{
        return &amp;ViewRewriter{
                viewDepth: 0,
                maxDepth:  domain.MaxViewDepth,
        }
}</span>

// Rewrite merges outer query with view definition using MERGE algorithm
func (vr *ViewRewriter) Rewrite(outerQuery *parser.SelectStatement, viewInfo *domain.ViewInfo) (*parser.SelectStatement, error) <span class="cov0" title="0">{
        // Check view algorithm
        if viewInfo.Algorithm != "" &amp;&amp; viewInfo.Algorithm != domain.ViewAlgorithmUndefined &amp;&amp; viewInfo.Algorithm != domain.ViewAlgorithmMerge </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view does not use MERGE algorithm: %s", viewInfo.Algorithm)
        }</span>

        // Parse view's SELECT statement
        <span class="cov0" title="0">adapter := parser.NewSQLAdapter()
        parseResult, err := adapter.Parse(viewInfo.SelectStmt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse view SELECT: %w", err)
        }</span>

        <span class="cov0" title="0">if !parseResult.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view SELECT parse failed: %s", parseResult.Error)
        }</span>

        <span class="cov0" title="0">if parseResult.Statement.Select == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view definition is not a SELECT statement")
        }</span>

        <span class="cov0" title="0">viewSelect := parseResult.Statement.Select

        // Check view depth to prevent infinite recursion
        vr.viewDepth++
        if vr.viewDepth &gt; vr.maxDepth </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("maximum view nesting depth exceeded: %d", vr.maxDepth)
        }</span>

        // Create merged SELECT statement
        <span class="cov0" title="0">merged := vr.mergeSelectStatements(outerQuery, viewSelect, viewInfo)

        return merged, nil</span>
}

// mergeSelectStatements merges outer query with view SELECT
func (vr *ViewRewriter) mergeSelectStatements(outer, view *parser.SelectStatement, viewInfo *domain.ViewInfo) *parser.SelectStatement <span class="cov0" title="0">{
        merged := &amp;parser.SelectStatement{
                Distinct: view.Distinct, // Keep view's DISTINCT
        }

        // Merge SELECT list
        if len(outer.Columns) &gt; 0 &amp;&amp; !vr.isSelectAll(outer.Columns) </span><span class="cov0" title="0">{
                // Outer query specifies columns - use those with proper column mapping
                merged.Columns = vr.mergeSelectColumns(outer.Columns, view.Columns, viewInfo)
        }</span> else<span class="cov0" title="0"> {
                // Outer query uses SELECT * - use view's columns
                merged.Columns = view.Columns
        }</span>

        // Merge FROM clause - use view's FROM
        <span class="cov0" title="0">merged.From = view.From
        if view.From == "" </span><span class="cov0" title="0">{
                // If view doesn't have FROM (e.g., SELECT 1+1), create a merged FROM
                merged.From = vr.buildMergedFrom(view, outer)
        }</span>

        // Merge JOINs
        <span class="cov0" title="0">if len(view.Joins) &gt; 0 </span><span class="cov0" title="0">{
                merged.Joins = view.Joins
        }</span>
        <span class="cov0" title="0">if len(outer.Joins) &gt; 0 </span><span class="cov0" title="0">{
                merged.Joins = append(merged.Joins, outer.Joins...)
        }</span>

        // Merge WHERE clauses
        <span class="cov0" title="0">merged.Where = vr.mergeWhereClauses(outer.Where, view.Where)

        // Merge GROUP BY
        if len(outer.GroupBy) &gt; 0 </span><span class="cov0" title="0">{
                // Outer query has GROUP BY - use it
                merged.GroupBy = outer.GroupBy
        }</span> else<span class="cov0" title="0"> {
                // Use view's GROUP BY
                merged.GroupBy = view.GroupBy
        }</span>

        // Merge HAVING
        <span class="cov0" title="0">merged.Having = vr.mergeHavingClauses(outer.Having, view.Having)

        // Merge ORDER BY - outer query takes precedence
        if len(outer.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                merged.OrderBy = outer.OrderBy
        }</span> else<span class="cov0" title="0"> {
                merged.OrderBy = view.OrderBy
        }</span>

        // Merge LIMIT/OFFSET
        <span class="cov0" title="0">if outer.Limit != nil </span><span class="cov0" title="0">{
                merged.Limit = outer.Limit
        }</span> else<span class="cov0" title="0"> {
                merged.Limit = view.Limit
        }</span>

        <span class="cov0" title="0">if outer.Offset != nil </span><span class="cov0" title="0">{
                merged.Offset = outer.Offset
        }</span> else<span class="cov0" title="0"> {
                merged.Offset = view.Offset
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// mergeSelectColumns merges outer and view SELECT columns
func (vr *ViewRewriter) mergeSelectColumns(outerCols, viewCols []parser.SelectColumn, viewInfo *domain.ViewInfo) []parser.SelectColumn <span class="cov0" title="0">{
        // If view has explicit column list, map outer columns to view columns
        if len(viewInfo.Cols) &gt; 0 </span><span class="cov0" title="0">{
                return vr.mapColumnsByViewDefinition(outerCols, viewInfo.Cols)
        }</span>

        // Otherwise, directly use outer columns mapped to view columns
        <span class="cov0" title="0">merged := make([]parser.SelectColumn, 0, len(outerCols))

        for _, outerCol := range outerCols </span><span class="cov0" title="0">{
                // Find corresponding column in view
                var viewCol *parser.SelectColumn
                for _, vc := range viewCols </span><span class="cov0" title="0">{
                        if vc.Name == outerCol.Name || vc.Alias == outerCol.Name </span><span class="cov0" title="0">{
                                viewCol = &amp;vc
                                break</span>
                        }
                }

                <span class="cov0" title="0">if viewCol != nil </span><span class="cov0" title="0">{
                        // Use view column definition but with outer alias
                        newCol := *viewCol
                        if outerCol.Alias != "" </span><span class="cov0" title="0">{
                                newCol.Alias = outerCol.Alias
                        }</span>
                        <span class="cov0" title="0">merged = append(merged, newCol)</span>
                } else<span class="cov0" title="0"> if outerCol.Expr != nil </span><span class="cov0" title="0">{
                        // Expression or column not in view - use as-is
                        merged = append(merged, outerCol)
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// mapColumnsByViewDefinition maps outer columns to view's column list
func (vr *ViewRewriter) mapColumnsByViewDefinition(outerCols []parser.SelectColumn, viewCols []string) []parser.SelectColumn <span class="cov0" title="0">{
        merged := make([]parser.SelectColumn, 0, len(outerCols))

        for _, outerCol := range outerCols </span><span class="cov0" title="0">{
                // Check if outer column name is in view's column list
                found := false
                for i, viewColName := range viewCols </span><span class="cov0" title="0">{
                        if outerCol.Name == viewColName || outerCol.Alias == viewColName </span><span class="cov0" title="0">{
                                // Map to the corresponding view column
                                merged = append(merged, parser.SelectColumn{
                                        Name:  viewColName,
                                        Alias: outerCol.Alias,
                                        Table: outerCol.Table,
                                        Expr:  &amp;parser.Expression{
                                                Type:   parser.ExprTypeColumn,
                                                Column: viewColName,
                                        },
                                })
                                found = true
                                break</span>
                        } else<span class="cov0" title="0"> if i &lt; len(viewCols) &amp;&amp; outerCol.Name == fmt.Sprintf("col%d", i+1) </span><span class="cov0" title="0">{
                                // Position-based mapping (SELECT col1, col2...)
                                merged = append(merged, parser.SelectColumn{
                                        Name:  viewColName,
                                        Alias: outerCol.Alias,
                                })
                                found = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // Column not found in view - use as-is
                        merged = append(merged, outerCol)
                }</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// buildMergedFrom builds FROM clause when view doesn't have one
func (vr *ViewRewriter) buildMergedFrom(view, outer *parser.SelectStatement) string <span class="cov0" title="0">{
        if view.From != "" </span><span class="cov0" title="0">{
                return view.From
        }</span>
        <span class="cov0" title="0">if outer.From != "" </span><span class="cov0" title="0">{
                return outer.From
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// mergeWhereClauses merges WHERE clauses from outer and view
func (vr *ViewRewriter) mergeWhereClauses(outerWhere, viewWhere *parser.Expression) *parser.Expression <span class="cov0" title="0">{
        if outerWhere == nil &amp;&amp; viewWhere == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if outerWhere == nil </span><span class="cov0" title="0">{
                return viewWhere
        }</span>

        <span class="cov0" title="0">if viewWhere == nil </span><span class="cov0" title="0">{
                return outerWhere
        }</span>

        // Combine with AND
        <span class="cov0" title="0">return &amp;parser.Expression{
                Type:     parser.ExprTypeOperator,
                Operator: "AND",
                Left:     viewWhere,
                Right:    outerWhere,
        }</span>
}

// mergeHavingClauses merges HAVING clauses
func (vr *ViewRewriter) mergeHavingClauses(outerHaving, viewHaving *parser.Expression) *parser.Expression <span class="cov0" title="0">{
        if outerHaving == nil &amp;&amp; viewHaving == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if outerHaving == nil </span><span class="cov0" title="0">{
                return viewHaving
        }</span>

        <span class="cov0" title="0">if viewHaving == nil </span><span class="cov0" title="0">{
                return outerHaving
        }</span>

        // Combine with AND
        <span class="cov0" title="0">return &amp;parser.Expression{
                Type:     parser.ExprTypeOperator,
                Operator: "AND",
                Left:     viewHaving,
                Right:    outerHaving,
        }</span>
}

// isSelectAll checks if the column list is SELECT *
func (vr *ViewRewriter) isSelectAll(cols []parser.SelectColumn) bool <span class="cov0" title="0">{
        if len(cols) == 1 &amp;&amp; cols[0].IsWildcard </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, col := range cols </span><span class="cov0" title="0">{
                if col.IsWildcard </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsUpdatable checks if a view is updatable based on its definition
func IsUpdatable(viewInfo *domain.ViewInfo) bool <span class="cov0" title="0">{
        // Simplified implementation - check for non-updatable patterns
        if viewInfo == nil </span><span class="cov0" title="0">{
                return true // Default to updatable
        }</span>

        // Check for aggregates in SELECT statement
        <span class="cov0" title="0">aggregates := []string{"count(", "sum(", "avg(", "min(", "max(", "group_concat(", "std(", "stddev("}
        selectStmt := viewInfo.SelectStmt
        if selectStmt == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">lowerStmt := strings.ToLower(selectStmt)
        for _, agg := range aggregates </span><span class="cov0" title="0">{
                if strings.Contains(lowerStmt, strings.ToLower(agg)) </span><span class="cov0" title="0">{
                        return false // Contains aggregate function
                }</span>
        }

        // Check for DISTINCT
        <span class="cov0" title="0">if strings.Contains(lowerStmt, "distinct ") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for GROUP BY
        <span class="cov0" title="0">if strings.Contains(lowerStmt, "group by ") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for HAVING
        <span class="cov0" title="0">if strings.Contains(lowerStmt, "having ") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for UNION
        <span class="cov0" title="0">if strings.Contains(lowerStmt, "union ") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for subqueries (simplified)
        <span class="cov0" title="0">if strings.Contains(lowerStmt, "select ") &amp;&amp; strings.Contains(lowerStmt, " from ") &amp;&amp; strings.Contains(lowerStmt, " where ") </span><span class="cov0" title="0">{
                // This is a heuristic check
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

</pre>
		
		<pre class="file" id="file44" style="display: none">package optimizer

import (
        "context"
        "fmt"
        "sort"

        "github.com/kasuganosora/sqlexec/pkg/resource/domain"
        "github.com/kasuganosora/sqlexec/pkg/parser"
)

// WindowOperator 窗口函数执行算子
type WindowOperator struct {
        // 子算子
        child PhysicalPlan

        // 窗口函数定义
        windowFuncs []*WindowFunctionDef

        // 执行上下文
        ctx context.Context

        // 表达式求值器
        evaluator *ExpressionEvaluator
}

// WindowFunctionDef 窗口函数定义
type WindowFunctionDef struct {
        Expr      *parser.WindowExpression
        ResultCol string // 结果列名
}

// NewWindowOperator 创建窗口函数算子
func NewWindowOperator(child PhysicalPlan, windowFuncs []*parser.WindowExpression) *WindowOperator <span class="cov0" title="0">{
        funcDefs := make([]*WindowFunctionDef, len(windowFuncs))
        for i, wf := range windowFuncs </span><span class="cov0" title="0">{
                funcDefs[i] = &amp;WindowFunctionDef{
                        Expr:      wf,
                        ResultCol: fmt.Sprintf("window_%d", i),
                }
        }</span>

        <span class="cov0" title="0">return &amp;WindowOperator{
                child:       child,
                windowFuncs: funcDefs,
                evaluator:   NewExpressionEvaluatorWithoutAPI(),
        }</span>
}

// Execute 执行窗口函数
func (op *WindowOperator) Execute(ctx context.Context) (*domain.QueryResult, error) <span class="cov0" title="0">{
        op.ctx = ctx

        // 1. 从子算子获取数据
        result, err := op.child.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute child: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Rows) == 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // 2. 处理每个窗口函数
        <span class="cov0" title="0">for _, wfDef := range op.windowFuncs </span><span class="cov0" title="0">{
                result.Rows, err = op.executeWindowFunction(result.Rows, wfDef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute window function %s: %w", wfDef.Expr.FuncName, err)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeWindowFunction 执行单个窗口函数
func (op *WindowOperator) executeWindowFunction(rows []domain.Row, wfDef *WindowFunctionDef) ([]domain.Row, error) <span class="cov0" title="0">{
        wf := wfDef.Expr

        // 3. 分区
        partitions := op.partitionRows(rows, wf.Spec.PartitionBy)

        // 4. 在每个分区内执行窗口函数
        result := make([]domain.Row, 0, len(rows))
        for _, partition := range partitions </span><span class="cov0" title="0">{
                // 5. 排序
                sortedPartition := op.sortRows(partition, wf.Spec.OrderBy)

                // 6. 计算窗口函数值
                for i, row := range sortedPartition </span><span class="cov0" title="0">{
                        // 克隆行
                        newRow := make(domain.Row)
                        for k, v := range row </span><span class="cov0" title="0">{
                                newRow[k] = v
                        }</span>

                        // 计算窗口函数
                        <span class="cov0" title="0">value, err := op.computeWindowValue(sortedPartition, i, wf)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">newRow[wfDef.ResultCol] = value
                        result = append(result, newRow)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// partitionRows 根据分区表达式分割行
func (op *WindowOperator) partitionRows(rows []domain.Row, partitionBy []parser.Expression) [][]domain.Row <span class="cov0" title="0">{
        if len(partitionBy) == 0 </span><span class="cov0" title="0">{
                // 无分区,所有行为一个分区
                return [][]domain.Row{rows}
        }</span>

        // 使用map分组
        <span class="cov0" title="0">partitions := make(map[string][]domain.Row)

        for _, row := range rows </span><span class="cov0" title="0">{
                // 计算分区键
                key := op.computePartitionKey(row, partitionBy)

                // 添加到对应分区
                partitions[key] = append(partitions[key], row)
        }</span>

        // 转换为slice
        <span class="cov0" title="0">result := make([][]domain.Row, 0, len(partitions))
        for _, partition := range partitions </span><span class="cov0" title="0">{
                result = append(result, partition)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// computePartitionKey 计算分区键
func (op *WindowOperator) computePartitionKey(row domain.Row, partitionBy []parser.Expression) string <span class="cov0" title="0">{
        keyParts := make([]interface{}, len(partitionBy))

        for i, expr := range partitionBy </span><span class="cov0" title="0">{
                value, err := op.evaluator.Evaluate(&amp;expr, parser.Row(row))
                if err != nil </span><span class="cov0" title="0">{
                        keyParts[i] = fmt.Sprintf("ERROR:%v", err)
                }</span> else<span class="cov0" title="0"> {
                        keyParts[i] = value
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", keyParts)</span>
}

// sortRows 根据排序表达式排序行
func (op *WindowOperator) sortRows(rows []domain.Row, orderBy []parser.OrderItem) []domain.Row <span class="cov0" title="0">{
        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                return rows
        }</span>

        // 克隆行,避免修改原始数据
        <span class="cov0" title="0">sorted := make([]domain.Row, len(rows))
        copy(sorted, rows)

        // 排序
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov0" title="0">{
                return op.compareRows(sorted[i], sorted[j], orderBy)
        }</span>)

        <span class="cov0" title="0">return sorted</span>
}

// compareRows 比较两行
func (op *WindowOperator) compareRows(row1, row2 domain.Row, orderBy []parser.OrderItem) bool <span class="cov0" title="0">{
        for _, orderItem := range orderBy </span><span class="cov0" title="0">{
                val1, err1 := op.evaluator.Evaluate(&amp;orderItem.Expr, parser.Row(row1))
                val2, err2 := op.evaluator.Evaluate(&amp;orderItem.Expr, parser.Row(row2))

                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cmp := compareValues(val1, val2)

                if cmp != 0 </span><span class="cov0" title="0">{
                        if orderItem.Direction == parser.SortDesc </span><span class="cov0" title="0">{
                                return cmp &gt; 0
                        }</span>
                        <span class="cov0" title="0">return cmp &lt; 0</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// computeWindowValue 计算窗口函数值
func (op *WindowOperator) computeWindowValue(rows []domain.Row, rowIndex int, wf *parser.WindowExpression) (interface{}, error) <span class="cov0" title="0">{
        switch wf.FuncName </span>{
        case "ROW_NUMBER":<span class="cov0" title="0">
                return op.computeRowNumber(rowIndex), nil</span>

        case "RANK":<span class="cov0" title="0">
                return op.computeRank(rows, rowIndex), nil</span>

        case "DENSE_RANK":<span class="cov0" title="0">
                return op.computeDenseRank(rows, rowIndex), nil</span>

        case "LAG":<span class="cov0" title="0">
                return op.computeLag(rows, rowIndex, wf.Args)</span>

        case "LEAD":<span class="cov0" title="0">
                return op.computeLead(rows, rowIndex, wf.Args)</span>

        case "COUNT", "SUM", "AVG", "MIN", "MAX":<span class="cov0" title="0">
                return op.computeAggregateWindow(rows, rowIndex, wf)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported window function: %s", wf.FuncName)</span>
        }
}

// ROW_NUMBER实现
func (op *WindowOperator) computeRowNumber(rowIndex int) int64 <span class="cov0" title="0">{
        return int64(rowIndex + 1)
}</span>

// RANK实现
func (op *WindowOperator) computeRank(rows []domain.Row, rowIndex int) int64 <span class="cov0" title="0">{
        if rowIndex == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">currentRow := rows[rowIndex]
        prevRow := rows[rowIndex-1]

        // 如果当前行与前一行相同,则排名相同
        if op.isEqual(currentRow, prevRow) </span><span class="cov0" title="0">{
                return op.computeRank(rows, rowIndex-1)
        }</span>

        // 否则排名为当前行号
        <span class="cov0" title="0">return int64(rowIndex + 1)</span>
}

// DENSE_RANK实现
func (op *WindowOperator) computeDenseRank(rows []domain.Row, rowIndex int) int64 <span class="cov0" title="0">{
        if rowIndex == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">currentRow := rows[rowIndex]
        prevRow := rows[rowIndex-1]

        // 如果当前行与前一行相同,则密集排名相同
        if op.isEqual(currentRow, prevRow) </span><span class="cov0" title="0">{
                return op.computeDenseRank(rows, rowIndex-1)
        }</span>

        // 否则寻找不同的行数
        <span class="cov0" title="0">rank := int64(1)
        for i := 1; i &lt;= rowIndex; i++ </span><span class="cov0" title="0">{
                if !op.isEqual(rows[i], rows[i-1]) </span><span class="cov0" title="0">{
                        rank++
                }</span>
        }

        <span class="cov0" title="0">return rank</span>
}

// LAG实现
func (op *WindowOperator) computeLag(rows []domain.Row, rowIndex int, args []parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LAG() requires 1 argument")
        }</span>

        // 获取偏移量(默认为1)
        <span class="cov0" title="0">offset := 1
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;args[0], nil)
                if err == nil </span><span class="cov0" title="0">{
                        if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                offset = int(offsetInt)
                        }</span>
                }
        }

        // 计算目标行索引
        <span class="cov0" title="0">targetIndex := rowIndex - offset

        if targetIndex &lt; 0 </span><span class="cov0" title="0">{
                // 超出范围,返回NULL
                return nil, nil
        }</span>

        // 返回目标行的值
        <span class="cov0" title="0">return op.getRowValue(rows[targetIndex], args[0])</span>
}

// LEAD实现
func (op *WindowOperator) computeLead(rows []domain.Row, rowIndex int, args []parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LEAD() requires 1 argument")
        }</span>

        // 获取偏移量(默认为1)
        <span class="cov0" title="0">offset := 1
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;args[0], nil)
                if err == nil </span><span class="cov0" title="0">{
                        if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                                offset = int(offsetInt)
                        }</span>
                }
        }

        // 计算目标行索引
        <span class="cov0" title="0">targetIndex := rowIndex + offset

        if targetIndex &gt;= len(rows) </span><span class="cov0" title="0">{
                // 超出范围,返回NULL
                return nil, nil
        }</span>

        // 返回目标行的值
        <span class="cov0" title="0">return op.getRowValue(rows[targetIndex], args[0])</span>
}

// 聚合窗口函数实现
func (op *WindowOperator) computeAggregateWindow(rows []domain.Row, rowIndex int, wf *parser.WindowExpression) (interface{}, error) <span class="cov0" title="0">{
        // 确定窗口范围
        start, end := op.getWindowBounds(rows, rowIndex, wf.Spec.Frame)

        // 计算聚合值
        switch wf.FuncName </span>{
        case "COUNT":<span class="cov0" title="0">
                return op.computeCount(rows, start, end), nil</span>
        case "SUM":<span class="cov0" title="0">
                return op.computeSum(rows, start, end, wf.Args[0])</span>
        case "AVG":<span class="cov0" title="0">
                return op.computeAvg(rows, start, end, wf.Args[0])</span>
        case "MIN":<span class="cov0" title="0">
                return op.computeMin(rows, start, end, wf.Args[0])</span>
        case "MAX":<span class="cov0" title="0">
                return op.computeMax(rows, start, end, wf.Args[0])</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported aggregate window function: %s", wf.FuncName)</span>
        }
}

// getWindowBounds 获取窗口边界
func (op *WindowOperator) getWindowBounds(rows []domain.Row, rowIndex int, frame *parser.WindowFrame) (int, int) <span class="cov0" title="0">{
        if frame == nil </span><span class="cov0" title="0">{
                // 无帧定义,默认从第一行到当前行
                return 0, rowIndex + 1
        }</span>

        <span class="cov0" title="0">start := rowIndex
        end := rowIndex + 1

        // 处理起始边界
        switch frame.Start.Type </span>{
        case parser.BoundUnboundedPreceding:<span class="cov0" title="0">
                start = 0</span>
        case parser.BoundPreceding:<span class="cov0" title="0">
                if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.Start.Value); ok </span><span class="cov0" title="0">{
                        start = rowIndex - offsetVal
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                }
        case parser.BoundCurrentRow:<span class="cov0" title="0">
                start = rowIndex</span>
        case parser.BoundFollowing:<span class="cov0" title="0">
                if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.Start.Value); ok </span><span class="cov0" title="0">{
                        start = rowIndex + offsetVal
                        if start &gt;= len(rows) </span><span class="cov0" title="0">{
                                start = len(rows) - 1
                        }</span>
                }
        }

        // 处理结束边界
        <span class="cov0" title="0">if frame.End != nil </span><span class="cov0" title="0">{
                switch frame.End.Type </span>{
                case parser.BoundCurrentRow:<span class="cov0" title="0">
                        end = rowIndex + 1</span>
                case parser.BoundFollowing:<span class="cov0" title="0">
                        if offsetVal, ok := op.getFrameOffset(rows[rowIndex], frame.End.Value); ok </span><span class="cov0" title="0">{
                                end = rowIndex + offsetVal + 1
                                if end &gt; len(rows) </span><span class="cov0" title="0">{
                                        end = len(rows)
                                }</span>
                        }
                case parser.BoundUnboundedFollowing:<span class="cov0" title="0">
                        end = len(rows)</span>
                }
        }

        <span class="cov0" title="0">return start, end</span>
}

// getFrameOffset 获取帧偏移
func (op *WindowOperator) getFrameOffset(row domain.Row, expr parser.Expression) (int, bool) <span class="cov0" title="0">{
        val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(row))
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">if offsetInt, ok := val.(int64); ok </span><span class="cov0" title="0">{
                return int(offsetInt), true
        }</span>

        <span class="cov0" title="0">return 0, false</span>
}

// 辅助函数

// isEqual 比较两行是否相等(根据ORDER BY列)
func (op *WindowOperator) isEqual(row1, row2 domain.Row) bool <span class="cov0" title="0">{
        // 简化实现:比较所有列
        // 实际应该只比较ORDER BY的列
        for k, v1 := range row1 </span><span class="cov0" title="0">{
                v2, ok := row2[k]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !compareValuesEqual(v1, v2) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return len(row1) == len(row2)</span>
}

// getRowValue 获取行的指定列值
func (op *WindowOperator) getRowValue(row domain.Row, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        return op.evaluator.Evaluate(&amp;expr, parser.Row(row))
}</span>

// 聚合函数

// computeCount 计数
func (op *WindowOperator) computeCount(rows []domain.Row, start, end int) int64 <span class="cov0" title="0">{
        count := int64(0)
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                if rows[i] != nil </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// computeSum 求和
func (op *WindowOperator) computeSum(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        var sum float64
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fval, ok := toFloat64(val)
                if ok </span><span class="cov0" title="0">{
                        sum += fval
                }</span>
        }
        <span class="cov0" title="0">return sum, nil</span>
}

// computeAvg 平均值
func (op *WindowOperator) computeAvg(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        sum, count := 0.0, 0

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fval, ok := toFloat64(val)
                if ok </span><span class="cov0" title="0">{
                        sum += fval
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return sum / float64(count), nil</span>
}

// computeMin 最小值
func (op *WindowOperator) computeMin(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        minVal := interface{}(nil)

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if minVal == nil || compareValues(val, minVal) &lt; 0 </span><span class="cov0" title="0">{
                        minVal = val
                }</span>
        }

        <span class="cov0" title="0">return minVal, nil</span>
}

// computeMax 最大值
func (op *WindowOperator) computeMax(rows []domain.Row, start, end int, expr parser.Expression) (interface{}, error) <span class="cov0" title="0">{
        maxVal := interface{}(nil)

        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                val, err := op.evaluator.Evaluate(&amp;expr, parser.Row(rows[i]))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if maxVal == nil || compareValues(val, maxVal) &gt; 0 </span><span class="cov0" title="0">{
                        maxVal = val
                }</span>
        }

        <span class="cov0" title="0">return maxVal, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
